{"component":"module.exports =\nwebpackJsonp([4],{\n\n/***/ 14:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _getPrototypeOf = __webpack_require__(4);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(5);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(6);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(8);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(7);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _style = __webpack_require__(11);\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _react = __webpack_require__(2);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _classnames = __webpack_require__(56);\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _class = function (_React$Component) {\n    (0, _inherits3.default)(_class, _React$Component);\n\n    function _class(props) {\n        (0, _classCallCheck3.default)(this, _class);\n\n        return (0, _possibleConstructorReturn3.default)(this, (_class.__proto__ || (0, _getPrototypeOf2.default)(_class)).call(this, props));\n    }\n\n    (0, _createClass3.default)(_class, [{\n        key: 'render',\n        value: function render() {\n            var containerClass = (0, _classnames2.default)({\n                'container': true,\n                'flex': this.props.flex,\n                'small': this.props.small\n            });\n            return _react2.default.createElement('div', { className: containerClass, 'data-jsx': 4159862121\n            }, this.props.children, _react2.default.createElement(_style2.default, {\n                styleId: 4159862121,\n                css: '.container.small[data-jsx=\"4159862121\"] {width: 1050px;}.container[data-jsx=\"4159862121\"] {height: 100%;margin: 0 auto;}.container.flex[data-jsx=\"4159862121\"] {display:-webkit-flex; display:flex;justify-content: space-between;}@media screen and (min-height: 630px) and (min-width: 1294px) {.container[data-jsx=\"4159862121\"] {width: 1066px;}}@media screen and (min-height: 870px) and (min-width: 1320px) {.container[data-jsx=\"4159862121\"] {width: 1280px;}}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHNcXGNvbnRhaW5lci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFrQjRCLEFBQ1UseUNBQ0EsY0FDakIsQ0FDVyxtQ0FDSyxhQUNFLGVBQ2xCLENBQ2dCLHdDQUNDLG1DQUNpQiwrQkFDbEMsQ0FDOEQsK0RBQy9DLG1DQUNNLGNBQ2pCLENBQ0osQ0FDOEQsK0RBQy9DLG1DQUNNLGNBQ2pCLENBQ0oiLCJmaWxlIjoiY29tcG9uZW50c1xcY29udGFpbmVyLmpzIiwic291cmNlUm9vdCI6IkM6L1VzZXJzL0FiYWlqdW4vRG9jdW1lbnRzL0dpdEh1Yi9sb2xpIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lckNsYXNzID0gY2xhc3NOYW1lcyh7XHJcbiAgICAgICAgICAgICdjb250YWluZXInOiB0cnVlLFxyXG4gICAgICAgICAgICAnZmxleCc6IHRoaXMucHJvcHMuZmxleCxcclxuICAgICAgICAgICAgJ3NtYWxsJzogdGhpcy5wcm9wcy5zbWFsbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjb250YWluZXJDbGFzc30+XHJcbiAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDxzdHlsZSBqc3g+e2BcclxuICAgICAgICAgICAgICAgICAgICAuY29udGFpbmVyLnNtYWxsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwNTBweDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbnRhaW5lciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC5jb250YWluZXIuZmxleCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi1oZWlnaHQ6IDYzMHB4KSBhbmQgKG1pbi13aWR0aDogMTI5NHB4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb250YWluZXIge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwNjZweDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLWhlaWdodDogODcwcHgpIGFuZCAobWluLXdpZHRoOiAxMzIwcHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRhaW5lciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTI4MHB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYH08L3N0eWxlPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn0iXX0= */\\n/*@ sourceURL=components\\\\container.js */'\n            }));\n        }\n    }]);\n\n    return _class;\n}(_react2.default.Component);\n\nexports.default = _class;\n\n ;(function register() { /* react-hot-loader/webpack */ if (process.env.NODE_ENV !== 'production') { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\components\\\\container.js\"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\components\\\\container.js\"); } } })();\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n\n/***/ 171:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _regenerator = __webpack_require__(23);\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = __webpack_require__(22);\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\n__webpack_require__(38);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar verify = function () {\n    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {\n        var userid, res, json, token;\n        return _regenerator2.default.wrap(function _callee$(_context) {\n            while (1) {\n                switch (_context.prev = _context.next) {\n                    case 0:\n                        userid = randomUserid();\n\n                        localStorage.setItem(\"userid\", userid);\n\n                        _context.next = 4;\n                        return fetch(\"http://loli.vc/login/\" + userid);\n\n                    case 4:\n                        res = _context.sent;\n                        _context.next = 7;\n                        return res.json();\n\n                    case 7:\n                        json = _context.sent;\n                        token = json.Message.Token;\n\n                        localStorage.setItem(\"token\", token);\n\n                    case 10:\n                    case \"end\":\n                        return _context.stop();\n                }\n            }\n        }, _callee, this);\n    }));\n\n    return function verify() {\n        return _ref.apply(this, arguments);\n    };\n}();\n\nfunction randomUserid() {\n    var str = \"\";\n    var str2 = \"\";\n    var pos = '';\n    var arr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\n    for (var i = 0; i < 32; i++) {\n        pos = Math.round(Math.random() * (arr.length - 1));\n        str += arr[pos];\n    }\n\n    str2 = str.substring(0, 8) + '-' + str.substring(8, 12) + '-' + str.substring(12, 16) + '-' + str.substring(16, 20) + '-' + str.substring(20, 32);\n    return str2;\n}\n\nexports.default = verify;\n\n ;(function register() { /* react-hot-loader/webpack */ if (process.env.NODE_ENV !== 'production') { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\lib\\\\tool.js\"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\lib\\\\tool.js\"); } } })();\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n\n/***/ 264:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process, __resourceQuery) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _getPrototypeOf = __webpack_require__(4);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _regenerator = __webpack_require__(23);\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = __webpack_require__(22);\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _classCallCheck2 = __webpack_require__(5);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(8);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _createClass2 = __webpack_require__(6);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _inherits2 = __webpack_require__(7);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _style = __webpack_require__(11);\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _react = __webpack_require__(2);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _link = __webpack_require__(27);\n\nvar _link2 = _interopRequireDefault(_link);\n\n__webpack_require__(38);\n\nvar _hls = __webpack_require__(358);\n\nvar _hls2 = _interopRequireDefault(_hls);\n\nvar _head = __webpack_require__(68);\n\nvar _head2 = _interopRequireDefault(_head);\n\nvar _header = __webpack_require__(74);\n\nvar _header2 = _interopRequireDefault(_header);\n\nvar _container = __webpack_require__(14);\n\nvar _container2 = _interopRequireDefault(_container);\n\nvar _tool = __webpack_require__(171);\n\nvar _tool2 = _interopRequireDefault(_tool);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _class = function (_React$Component) {\n    (0, _inherits3.default)(_class, _React$Component);\n\n    (0, _createClass3.default)(_class, [{\n        key: 'componentWillMount',\n        value: function () {\n            var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {\n                var uid, token, res, data, video, hls;\n                return _regenerator2.default.wrap(function _callee$(_context) {\n                    while (1) {\n                        switch (_context.prev = _context.next) {\n                            case 0:\n                                uid = localStorage.getItem(\"userid\");\n                                token = localStorage.getItem(\"token\");\n\n                                // 直接从 url 进入组件\n\n                                if (uid == null || token == null) {\n                                    (0, _tool2.default)();\n                                    uid = localStorage.getItem(\"userid\");\n                                    token = localStorage.getItem(\"token\");\n                                }\n\n                                _context.next = 5;\n                                return fetch('http://loli.vc/play/' + this.props.id + '?uid=' + uid + '&token=' + token);\n\n                            case 5:\n                                res = _context.sent;\n                                _context.next = 8;\n                                return res.json();\n\n                            case 8:\n                                data = _context.sent;\n\n                                if (!(data.Result == 0)) {\n                                    _context.next = 19;\n                                    break;\n                                }\n\n                                // 认证已过期, 需要重新认证\n                                (0, _tool2.default)();\n                                uid = localStorage.getItem(\"userid\");\n                                token = localStorage.getItem(\"token\");\n\n                                // 重新认证后发请求\n                                _context.next = 15;\n                                return fetch('http://loli.vc/play/' + this.props.id + '?uid=' + uid + '&token=' + token);\n\n                            case 15:\n                                res = _context.sent;\n                                _context.next = 18;\n                                return res.json();\n\n                            case 18:\n                                data = _context.sent;\n\n                            case 19:\n\n                                this.setState({ url: data.Message });\n\n                                if (_hls2.default.isSupported()) {\n                                    video = document.querySelector('.test');\n                                    hls = new _hls2.default();\n\n                                    hls.loadSource(this.state.url);\n                                    hls.attachMedia(video);\n                                    hls.on(_hls2.default.Events.MANIFEST_PARSED, function () {\n                                        video.play();\n                                    });\n                                }\n\n                            case 21:\n                            case 'end':\n                                return _context.stop();\n                        }\n                    }\n                }, _callee, this);\n            }));\n\n            function componentWillMount() {\n                return _ref.apply(this, arguments);\n            }\n\n            return componentWillMount;\n        }()\n    }], [{\n        key: 'getInitialProps',\n        value: function () {\n            var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(_ref3) {\n                var id = _ref3.query.id;\n                return _regenerator2.default.wrap(function _callee2$(_context2) {\n                    while (1) {\n                        switch (_context2.prev = _context2.next) {\n                            case 0:\n                                return _context2.abrupt('return', { id: id });\n\n                            case 1:\n                            case 'end':\n                                return _context2.stop();\n                        }\n                    }\n                }, _callee2, this);\n            }));\n\n            function getInitialProps(_x) {\n                return _ref2.apply(this, arguments);\n            }\n\n            return getInitialProps;\n        }()\n    }]);\n\n    function _class(props) {\n        (0, _classCallCheck3.default)(this, _class);\n\n        var _this = (0, _possibleConstructorReturn3.default)(this, (_class.__proto__ || (0, _getPrototypeOf2.default)(_class)).call(this, props));\n\n        _this.state = { url: \"\" };\n        return _this;\n    }\n\n    (0, _createClass3.default)(_class, [{\n        key: 'render',\n        value: function render() {\n            return _react2.default.createElement('div', { className: 'movie', 'data-jsx': 3448864484\n            }, _react2.default.createElement(_head2.default, null, _react2.default.createElement('title', {\n                'data-jsx': 3448864484\n            }, 'loli 3.0'), _react2.default.createElement('meta', { charSet: 'utf-8', 'data-jsx': 3448864484\n            }), _react2.default.createElement('link', { rel: 'stylesheet', href: '/static/global.css', 'data-jsx': 3448864484\n            })), _react2.default.createElement(_header2.default, null), _react2.default.createElement('div', { className: 'mask', 'data-jsx': 3448864484\n            }, _react2.default.createElement(_container2.default, { flex: true }, _react2.default.createElement('video', { className: 'test', 'data-jsx': 3448864484\n            }))), _react2.default.createElement(_style2.default, {\n                styleId: 3448864484,\n                css: '.test[data-jsx=\"3448864484\"] {display: block;height: 100%;margin: 0 auto;}.mask[data-jsx=\"3448864484\"] {background: #000;}@media screen and (min-height: 630px) and (min-width: 1294px) {.mask[data-jsx=\"3448864484\"] {height: 480px;}}@media screen and (min-height: 870px) and (min-width: 1320px) {.mask[data-jsx=\"3448864484\"] {height: 720px;}}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzXFxtb3ZpZS5qcz9lbnRyeSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF5RTRCLEFBQ0QsOEJBQ1ksZUFDRixhQUNFLGVBQ2xCLENBQ00sOEJBQ2MsaUJBQ3BCLENBQzhELCtEQUNwRCw4QkFDVyxjQUNqQixDQUNKLENBQzhELCtEQUNwRCw4QkFDVyxjQUNqQixDQUNKIiwiZmlsZSI6InBhZ2VzXFxtb3ZpZS5qcz9lbnRyeSIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9BYmFpanVuL0RvY3VtZW50cy9HaXRIdWIvbG9saSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcclxuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJ1xyXG5pbXBvcnQgJ2lzb21vcnBoaWMtZmV0Y2gnXHJcbmltcG9ydCBIbHMgZnJvbSAnaGxzLmpzJ1xyXG5pbXBvcnQgSGVhZCBmcm9tICduZXh0L2hlYWQnXHJcbmltcG9ydCBIZWFkZXIgZnJvbSAnLi4vY29tcG9uZW50cy9oZWFkZXInXHJcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vY29tcG9uZW50cy9jb250YWluZXInXHJcbmltcG9ydCB2ZXJpZnkgZnJvbSAnLi4vbGliL3Rvb2wnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBzdGF0aWMgYXN5bmMgZ2V0SW5pdGlhbFByb3BzICh7IHF1ZXJ5OiB7IGlkIH0gfSkge1xyXG4gICAgICAgIHJldHVybiB7aWQ6IGlkfVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcclxuICAgICAgICBsZXQgdWlkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ1c2VyaWRcIik7XHJcbiAgICAgICAgbGV0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlblwiKTtcclxuXHJcbiAgICAgICAgLy8g55u05o6l5LuOIHVybCDov5vlhaXnu4Tku7ZcclxuICAgICAgICBpZiAodWlkID09IG51bGwgfHwgdG9rZW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2ZXJpZnkoKTtcclxuICAgICAgICAgICAgdWlkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ1c2VyaWRcIik7XHJcbiAgICAgICAgICAgIHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlblwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByZXMgPSBhd2FpdCBmZXRjaChgaHR0cDovL2xvbGkudmMvcGxheS8ke3RoaXMucHJvcHMuaWR9P3VpZD0ke3VpZH0mdG9rZW49JHt0b2tlbn1gKTtcclxuICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XHJcblxyXG4gICAgICAgIGlmIChkYXRhLlJlc3VsdCA9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIOiupOivgeW3sui/h+acnywg6ZyA6KaB6YeN5paw6K6k6K+BXHJcbiAgICAgICAgICAgIHZlcmlmeSgpO1xyXG4gICAgICAgICAgICB1aWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInVzZXJpZFwiKTtcclxuICAgICAgICAgICAgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VuXCIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8g6YeN5paw6K6k6K+B5ZCO5Y+R6K+35rGCXHJcbiAgICAgICAgICAgIHJlcyA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9saS52Yy9wbGF5LyR7dGhpcy5wcm9wcy5pZH0/dWlkPSR7dWlkfSZ0b2tlbj0ke3Rva2VufWApO1xyXG4gICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe3VybDogZGF0YS5NZXNzYWdlfSk7XHJcblxyXG4gICAgICAgIGlmKEhscy5pc1N1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWRlbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50ZXN0Jyk7XHJcbiAgICAgICAgICAgIHZhciBobHMgPSBuZXcgSGxzKCk7XHJcbiAgICAgICAgICAgIGhscy5sb2FkU291cmNlKHRoaXMuc3RhdGUudXJsKTtcclxuICAgICAgICAgICAgaGxzLmF0dGFjaE1lZGlhKHZpZGVvKTtcclxuICAgICAgICAgICAgaGxzLm9uKEhscy5FdmVudHMuTUFOSUZFU1RfUEFSU0VELGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIHZpZGVvLnBsYXkoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yIChwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0ge3VybDogXCJcIn07XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW92aWVcIj5cclxuICAgICAgICAgICAgICAgIDxIZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0aXRsZT5sb2xpIDMuMDwvdGl0bGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPG1ldGEgY2hhclNldD0ndXRmLTgnIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIGhyZWY9XCIvc3RhdGljL2dsb2JhbC5jc3NcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9IZWFkPlxyXG5cclxuICAgICAgICAgICAgICAgIDxIZWFkZXIvPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXNrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPENvbnRhaW5lciBmbGV4PXt0cnVlfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHZpZGVvIGNsYXNzTmFtZT1cInRlc3RcIj48L3ZpZGVvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvQ29udGFpbmVyPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIDxzdHlsZSBqc3g+e2BcclxuICAgICAgICAgICAgICAgICAgICAudGVzdCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMCBhdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAubWFzayB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICMwMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4taGVpZ2h0OiA2MzBweCkgYW5kIChtaW4td2lkdGg6IDEyOTRweCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFzayB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDQ4MHB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4taGVpZ2h0OiA4NzBweCkgYW5kIChtaW4td2lkdGg6IDEzMjBweCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFzayB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDcyMHB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYH08L3N0eWxlPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn0iXX0= */\\n/*@ sourceURL=pages\\\\movie.js?entry */'\n            }));\n        }\n    }]);\n\n    return _class;\n}(_react2.default.Component);\n\nexports.default = _class;\n\n ;(function register() { /* react-hot-loader/webpack */ if (process.env.NODE_ENV !== 'production') { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\pages\\\\movie.js\"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\pages\\\\movie.js\"); } } })();\n    (function (Component, route) {\n      if (false) return\n      if (false) return\n\n      var qs = __webpack_require__(39)\n      var params = qs.parse(__resourceQuery.slice(1))\n      if (params.entry == null) return\n\n      module.hot.accept()\n      Component.__route = route\n\n      if (module.hot.status() === 'idle') return\n\n      var components = next.router.components\n      for (var r in components) {\n        if (!components.hasOwnProperty(r)) continue\n\n        if (components[r].Component.__route === route) {\n          next.router.update(r, Component)\n        }\n      }\n    })(module.exports.default || module.exports, \"/movie\")\n  \n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), \"?entry\"))\n\n/***/ }),\n\n/***/ 358:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar require;var require;(function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Hls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],2:[function(_dereq_,module,exports){\n/* jshint ignore:start */\r\n(function(root) { \r\n/* jshint ignore:end */\r\n\r\n  var HASH_SPLIT = /^([^#]*)(.*)$/;\r\n  var QUERY_SPLIT = /^([^\\?]*)(.*)$/;\r\n  var DOMAIN_SPLIT = /^(([a-z]+:\\/\\/)?[^:\\/]+(?::[0-9]+)?)?(\\/?.*)$/i;\r\n\r\n  var URLToolkit = {\r\n    // build an absolute URL from a relative one using the provided baseURL\r\n    // if relativeURL is an absolute URL it will be returned as is.\r\n    buildAbsoluteURL: function(baseURL, relativeURL) {\r\n      // remove any remaining space and CRLF\r\n      relativeURL = relativeURL.trim();\r\n      if (/^[a-z]+:/i.test(relativeURL)) {\r\n        // complete url, not relative\r\n        return relativeURL;\r\n      }\r\n\r\n      var relativeURLQuery = null;\r\n      var relativeURLHash = null;\r\n\r\n      var relativeURLHashSplit = HASH_SPLIT.exec(relativeURL);\r\n      if (relativeURLHashSplit) {\r\n        relativeURLHash = relativeURLHashSplit[2];\r\n        relativeURL = relativeURLHashSplit[1];\r\n      }\r\n      var relativeURLQuerySplit = QUERY_SPLIT.exec(relativeURL);\r\n      if (relativeURLQuerySplit) {\r\n        relativeURLQuery = relativeURLQuerySplit[2];\r\n        relativeURL = relativeURLQuerySplit[1];\r\n      }\r\n\r\n      var baseURLHashSplit = HASH_SPLIT.exec(baseURL);\r\n      if (baseURLHashSplit) {\r\n        baseURL = baseURLHashSplit[1];\r\n      }\r\n      var baseURLQuerySplit = QUERY_SPLIT.exec(baseURL);\r\n      if (baseURLQuerySplit) {\r\n        baseURL = baseURLQuerySplit[1];\r\n      }\r\n\r\n      var baseURLDomainSplit = DOMAIN_SPLIT.exec(baseURL);\r\n      if (!baseURLDomainSplit) {\r\n        throw new Error('Error trying to parse base URL.');\r\n      }\r\n      \r\n      // e.g. 'http://', 'https://', ''\r\n      var baseURLProtocol = baseURLDomainSplit[2] || '';\r\n      // e.g. 'http://example.com', '//example.com', 'example.com', ''\r\n      var baseURLProtocolDomain = baseURLDomainSplit[1] || '';\r\n      // e.g. '/a/b/c/playlist.m3u8', 'a/b/c/playlist.m3u8'\r\n      var baseURLPath = baseURLDomainSplit[3];\r\n      if (baseURLPath.indexOf('/') !== 0 && baseURLProtocolDomain !== '') {\r\n        // this handles a base url of http://example.com (missing last slash)\r\n        baseURLPath = '/'+baseURLPath;\r\n      }\r\n\r\n      var builtURL = null;\r\n      if (/^\\/\\//.test(relativeURL)) {\r\n        // relative url starts wth '//' so copy protocol (which may be '' if baseUrl didn't provide one)\r\n        builtURL = baseURLProtocol+URLToolkit.buildAbsolutePath('', relativeURL.substring(2));\r\n      }\r\n      else if (/^\\//.test(relativeURL)) {\r\n        // relative url starts with '/' so start from root of domain\r\n        builtURL = baseURLProtocolDomain+'/'+URLToolkit.buildAbsolutePath('', relativeURL.substring(1));\r\n      }\r\n      else {\r\n        builtURL = URLToolkit.buildAbsolutePath(baseURLProtocolDomain+baseURLPath, relativeURL);\r\n      }\r\n\r\n      // put the query and hash parts back\r\n      if (relativeURLQuery) {\r\n        builtURL += relativeURLQuery;\r\n      }\r\n      if (relativeURLHash) {\r\n        builtURL += relativeURLHash;\r\n      }\r\n      return builtURL;\r\n    },\r\n\r\n    // build an absolute path using the provided basePath\r\n    // adapted from https://developer.mozilla.org/en-US/docs/Web/API/document/cookie#Using_relative_URLs_in_the_path_parameter\r\n    // this does not handle the case where relativePath is \"/\" or \"//\". These cases should be handled outside this.\r\n    buildAbsolutePath: function(basePath, relativePath) {\r\n      var sRelPath = relativePath;\r\n      var nUpLn, sDir = '', sPath = basePath.replace(/[^\\/]*$/, sRelPath.replace(/(\\/|^)(?:\\.?\\/+)+/g, '$1'));\r\n      for (var nEnd, nStart = 0; nEnd = sPath.indexOf('/../', nStart), nEnd > -1; nStart = nEnd + nUpLn) {\r\n        nUpLn = /^\\/(?:\\.\\.\\/)*/.exec(sPath.slice(nEnd))[0].length;\r\n        sDir = (sDir + sPath.substring(nStart, nEnd)).replace(new RegExp('(?:\\\\\\/+[^\\\\\\/]*){0,' + ((nUpLn - 1) / 3) + '}$'), '/');\r\n      }\r\n      return sDir + sPath.substr(nStart);\r\n    }\r\n  };\r\n\r\n/* jshint ignore:start */\r\n  if(typeof exports === 'object' && typeof module === 'object')\r\n    module.exports = URLToolkit;\r\n  else if(typeof define === 'function' && define.amd)\r\n    define([], function() { return URLToolkit; });\r\n  else if(typeof exports === 'object')\r\n    exports[\"URLToolkit\"] = URLToolkit;\r\n  else\r\n    root[\"URLToolkit\"] = URLToolkit;\r\n})(this);\r\n/* jshint ignore:end */\r\n\n},{}],3:[function(_dereq_,module,exports){\nvar bundleFn = arguments[3];\nvar sources = arguments[4];\nvar cache = arguments[5];\n\nvar stringify = JSON.stringify;\n\nmodule.exports = function (fn, options) {\n    var wkey;\n    var cacheKeys = Object.keys(cache);\n\n    for (var i = 0, l = cacheKeys.length; i < l; i++) {\n        var key = cacheKeys[i];\n        var exp = cache[key].exports;\n        // Using babel as a transpiler to use esmodule, the export will always\n        // be an object with the default export as a property of it. To ensure\n        // the existing api and babel esmodule exports are both supported we\n        // check for both\n        if (exp === fn || exp && exp.default === fn) {\n            wkey = key;\n            break;\n        }\n    }\n\n    if (!wkey) {\n        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n        var wcache = {};\n        for (var i = 0, l = cacheKeys.length; i < l; i++) {\n            var key = cacheKeys[i];\n            wcache[key] = key;\n        }\n        sources[wkey] = [\n            Function(['require','module','exports'], '(' + fn + ')(self)'),\n            wcache\n        ];\n    }\n    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n\n    var scache = {}; scache[wkey] = wkey;\n    sources[skey] = [\n        Function(['require'], (\n            // try to call default if defined to also support babel esmodule\n            // exports\n            'var f = require(' + stringify(wkey) + ');' +\n            '(f.default ? f.default : f)(self);'\n        )),\n        scache\n    ];\n\n    var workerSources = {};\n    resolveSources(skey);\n\n    function resolveSources(key) {\n        workerSources[key] = true;\n\n        for (var depPath in sources[key][1]) {\n            var depKey = sources[key][1][depPath];\n            if (!workerSources[depKey]) {\n                resolveSources(depKey);\n            }\n        }\n    }\n\n    var src = '(' + bundleFn + ')({'\n        + Object.keys(workerSources).map(function (key) {\n            return stringify(key) + ':['\n                + sources[key][0]\n                + ',' + stringify(sources[key][1]) + ']'\n            ;\n        }).join(',')\n        + '},{},[' + stringify(skey) + '])'\n    ;\n\n    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n    var blob = new Blob([src], { type: 'text/javascript' });\n    if (options && options.bare) { return blob; }\n    var workerUrl = URL.createObjectURL(blob);\n    var worker = new Worker(workerUrl);\n    worker.objectURL = workerUrl;\n    return worker;\n};\n\n},{}],4:[function(_dereq_,module,exports){\n/**\n * HLS config\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n      value: true\n});\nexports.hlsDefaultConfig = undefined;\n\nvar _abrController = _dereq_(5);\n\nvar _abrController2 = _interopRequireDefault(_abrController);\n\nvar _bufferController = _dereq_(8);\n\nvar _bufferController2 = _interopRequireDefault(_bufferController);\n\nvar _capLevelController = _dereq_(9);\n\nvar _capLevelController2 = _interopRequireDefault(_capLevelController);\n\nvar _fpsController = _dereq_(11);\n\nvar _fpsController2 = _interopRequireDefault(_fpsController);\n\nvar _xhrLoader = _dereq_(55);\n\nvar _xhrLoader2 = _interopRequireDefault(_xhrLoader);\n\nvar _audioTrackController = _dereq_(7);\n\nvar _audioTrackController2 = _interopRequireDefault(_audioTrackController);\n\nvar _audioStreamController = _dereq_(6);\n\nvar _audioStreamController2 = _interopRequireDefault(_audioStreamController);\n\nvar _cues = _dereq_(48);\n\nvar _cues2 = _interopRequireDefault(_cues);\n\nvar _timelineController = _dereq_(16);\n\nvar _timelineController2 = _interopRequireDefault(_timelineController);\n\nvar _subtitleTrackController = _dereq_(15);\n\nvar _subtitleTrackController2 = _interopRequireDefault(_subtitleTrackController);\n\nvar _subtitleStreamController = _dereq_(14);\n\nvar _subtitleStreamController2 = _interopRequireDefault(_subtitleStreamController);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//#endif\n\n//#endif\n\n//#if subtitle\n\n//import FetchLoader from './utils/fetch-loader';\n//#if altaudio\nvar hlsDefaultConfig = exports.hlsDefaultConfig = {\n      autoStartLoad: true, // used by stream-controller\n      startPosition: -1, // used by stream-controller\n      defaultAudioCodec: undefined, // used by stream-controller\n      debug: false, // used by logger\n      capLevelOnFPSDrop: false, // used by fps-controller\n      capLevelToPlayerSize: false, // used by cap-level-controller\n      initialLiveManifestSize: 1, // used by stream-controller\n      maxBufferLength: 30, // used by stream-controller\n      maxBufferSize: 60 * 1000 * 1000, // used by stream-controller\n      maxBufferHole: 0.5, // used by stream-controller\n      maxSeekHole: 2, // used by stream-controller\n      lowBufferWatchdogPeriod: 0.5, // used by stream-controller\n      highBufferWatchdogPeriod: 3, // used by stream-controller\n      nudgeOffset: 0.1, // used by stream-controller\n      nudgeMaxRetry: 3, // used by stream-controller\n      maxFragLookUpTolerance: 0.2, // used by stream-controller\n      liveSyncDurationCount: 3, // used by stream-controller\n      liveMaxLatencyDurationCount: Infinity, // used by stream-controller\n      liveSyncDuration: undefined, // used by stream-controller\n      liveMaxLatencyDuration: undefined, // used by stream-controller\n      maxMaxBufferLength: 600, // used by stream-controller\n      enableWorker: true, // used by demuxer\n      enableSoftwareAES: true, // used by decrypter\n      manifestLoadingTimeOut: 10000, // used by playlist-loader\n      manifestLoadingMaxRetry: 1, // used by playlist-loader\n      manifestLoadingRetryDelay: 1000, // used by playlist-loader\n      manifestLoadingMaxRetryTimeout: 64000, // used by playlist-loader\n      startLevel: undefined, // used by level-controller\n      levelLoadingTimeOut: 10000, // used by playlist-loader\n      levelLoadingMaxRetry: 4, // used by playlist-loader\n      levelLoadingRetryDelay: 1000, // used by playlist-loader\n      levelLoadingMaxRetryTimeout: 64000, // used by playlist-loader\n      fragLoadingTimeOut: 20000, // used by fragment-loader\n      fragLoadingMaxRetry: 6, // used by fragment-loader\n      fragLoadingRetryDelay: 1000, // used by fragment-loader\n      fragLoadingMaxRetryTimeout: 64000, // used by fragment-loader\n      fragLoadingLoopThreshold: 3, // used by stream-controller\n      startFragPrefetch: false, // used by stream-controller\n      fpsDroppedMonitoringPeriod: 5000, // used by fps-controller\n      fpsDroppedMonitoringThreshold: 0.2, // used by fps-controller\n      appendErrorMaxRetry: 3, // used by buffer-controller\n      loader: _xhrLoader2.default,\n      //loader: FetchLoader,\n      fLoader: undefined,\n      pLoader: undefined,\n      xhrSetup: undefined,\n      fetchSetup: undefined,\n      abrController: _abrController2.default,\n      bufferController: _bufferController2.default,\n      capLevelController: _capLevelController2.default,\n      fpsController: _fpsController2.default,\n      //#if altaudio\n      audioStreamController: _audioStreamController2.default,\n      audioTrackController: _audioTrackController2.default,\n      //#endif\n      //#if subtitle\n      subtitleStreamController: _subtitleStreamController2.default,\n      subtitleTrackController: _subtitleTrackController2.default,\n      timelineController: _timelineController2.default,\n      cueHandler: _cues2.default,\n      enableCEA708Captions: true, // used by timeline-controller\n      enableWebVTT: true, // used by timeline-controller\n      //#endif\n      stretchShortVideoTrack: false, // used by mp4-remuxer\n      forceKeyFrameOnDiscontinuity: true, // used by ts-demuxer\n      abrEwmaFastLive: 3, // used by abr-controller\n      abrEwmaSlowLive: 9, // used by abr-controller\n      abrEwmaFastVoD: 3, // used by abr-controller\n      abrEwmaSlowVoD: 9, // used by abr-controller\n      abrEwmaDefaultEstimate: 5e5, // 500 kbps  // used by abr-controller\n      abrBandWidthFactor: 0.95, // used by abr-controller\n      abrBandWidthUpFactor: 0.7, // used by abr-controller\n      abrMaxWithRealBitrate: false, // used by abr-controller\n      maxStarvationDelay: 4, // used by abr-controller\n      maxLoadingDelay: 4, // used by abr-controller\n      minAutoBitrate: 0 // used by hls\n};\n\n},{\"11\":11,\"14\":14,\"15\":15,\"16\":16,\"48\":48,\"5\":5,\"55\":55,\"6\":6,\"7\":7,\"8\":8,\"9\":9}],5:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _bufferHelper = _dereq_(35);\n\nvar _bufferHelper2 = _interopRequireDefault(_bufferHelper);\n\nvar _errors = _dereq_(31);\n\nvar _logger = _dereq_(50);\n\nvar _ewmaBandwidthEstimator = _dereq_(10);\n\nvar _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar AbrController = function (_EventHandler) {\n  _inherits(AbrController, _EventHandler);\n\n  function AbrController(hls) {\n    _classCallCheck(this, AbrController);\n\n    var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.FRAG_BUFFERED, _events2.default.ERROR));\n\n    _this.lastLoadedFragLevel = 0;\n    _this._nextAutoLevel = -1;\n    _this.hls = hls;\n    _this.onCheck = _this._abandonRulesCheck.bind(_this);\n    return _this;\n  }\n\n  _createClass(AbrController, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.clearTimer();\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n  }, {\n    key: 'onFragLoading',\n    value: function onFragLoading(data) {\n      var frag = data.frag;\n      if (frag.type === 'main') {\n        if (!this.timer) {\n          this.timer = setInterval(this.onCheck, 100);\n        }\n        // lazy init of bw Estimator, rationale is that we use different params for Live/VoD\n        // so we need to wait for stream manifest / playlist type to instantiate it.\n        if (!this._bwEstimator) {\n          var hls = this.hls,\n              level = data.frag.level,\n              isLive = hls.levels[level].details.live,\n              config = hls.config,\n              ewmaFast = void 0,\n              ewmaSlow = void 0;\n\n          if (isLive) {\n            ewmaFast = config.abrEwmaFastLive;\n            ewmaSlow = config.abrEwmaSlowLive;\n          } else {\n            ewmaFast = config.abrEwmaFastVoD;\n            ewmaSlow = config.abrEwmaSlowVoD;\n          }\n          this._bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);\n        }\n        this.fragCurrent = frag;\n      }\n    }\n  }, {\n    key: '_abandonRulesCheck',\n    value: function _abandonRulesCheck() {\n      /*\n        monitor fragment retrieval time...\n        we compute expected time of arrival of the complete fragment.\n        we compare it to expected time of buffer starvation\n      */\n      var hls = this.hls,\n          v = hls.media,\n          frag = this.fragCurrent,\n          loader = frag.loader,\n          minAutoLevel = hls.minAutoLevel;\n\n      // if loader has been destroyed or loading has been aborted, stop timer and return\n      if (!loader || loader.stats && loader.stats.aborted) {\n        _logger.logger.warn('frag loader destroy or aborted, disarm abandonRules');\n        this.clearTimer();\n        return;\n      }\n      var stats = loader.stats;\n      /* only monitor frag retrieval time if\n      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */\n      if (v && (!v.paused && v.playbackRate !== 0 || !v.readyState) && frag.autoLevel && frag.level) {\n        var requestDelay = performance.now() - stats.trequest,\n            playbackRate = Math.abs(v.playbackRate);\n        // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate\n        if (requestDelay > 500 * frag.duration / playbackRate) {\n          var levels = hls.levels,\n              loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),\n              // byte/s; at least 1 byte/s to avoid division by zero\n          // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size\n          level = levels[frag.level],\n              levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate,\n              expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)),\n              pos = v.currentTime,\n              fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,\n              bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos) / playbackRate;\n          // consider emergency switch down only if we have less than 2 frag buffered AND\n          // time to finish loading current fragment is bigger than buffer starvation delay\n          // ie if we risk buffer starvation if bw does not increase quickly\n          if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {\n            var fragLevelNextLoadedDelay = void 0,\n                nextLoadLevel = void 0;\n            // lets iterate through lower level and try to find the biggest one that could avoid rebuffering\n            // we start from current level - 1 and we step down , until we find a matching level\n            for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n              // compute time to load next fragment at lower level\n              // 0.8 : consider only 80% of current bw to be conservative\n              // 8 = bits per byte (bps/Bps)\n              var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;\n              fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);\n              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {\n                // we found a lower level that be rebuffering free with current estimated bw !\n                break;\n              }\n            }\n            // only emergency switch down if it takes less time to load new fragment at lowest level instead\n            // of finishing loading current one ...\n            if (fragLevelNextLoadedDelay < fragLoadedDelay) {\n              _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']<fragLoadedDelay[' + (frag.level - 1) + '];bufferStarvationDelay:' + fragLevelNextLoadedDelay.toFixed(1) + '<' + fragLoadedDelay.toFixed(1) + ':' + bufferStarvationDelay.toFixed(1));\n              // force next load level in auto mode\n              hls.nextLoadLevel = nextLoadLevel;\n              // update bw estimate for this fragment before cancelling load (this will help reducing the bw)\n              this._bwEstimator.sample(requestDelay, stats.loaded);\n              //abort fragment loading\n              loader.abort();\n              // stop abandon rules timer\n              this.clearTimer();\n              hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: 'onFragLoaded',\n    value: function onFragLoaded(data) {\n      var frag = data.frag;\n      if (frag.type === 'main' && !isNaN(frag.sn)) {\n        // stop monitoring bw once frag loaded\n        this.clearTimer();\n        // store level id after successful fragment load\n        this.lastLoadedFragLevel = frag.level;\n        // reset forced auto level value so that next level will be selected\n        this._nextAutoLevel = -1;\n\n        // compute level average bitrate\n        if (this.hls.config.abrMaxWithRealBitrate) {\n          var level = this.hls.levels[frag.level];\n          var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;\n          var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;\n          level.loaded = { bytes: loadedBytes, duration: loadedDuration };\n          level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n        }\n        // if fragment has been loaded to perform a bitrate test,\n        if (data.frag.bitrateTest) {\n          var stats = data.stats;\n          stats.tparsed = stats.tbuffered = stats.tload;\n          this.onFragBuffered(data);\n        }\n      }\n    }\n  }, {\n    key: 'onFragBuffered',\n    value: function onFragBuffered(data) {\n      var stats = data.stats,\n          frag = data.frag;\n      // only update stats on first frag buffering\n      // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly\n      // and leading to wrong bw estimation\n      // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)\n      if (stats.aborted !== true && frag.loadCounter === 1 && frag.type === 'main' && !isNaN(frag.sn) && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {\n        // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached\n        // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached\n        // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation\n        var fragLoadingProcessingMs = stats.tparsed - stats.trequest;\n        _logger.logger.log('latency/loading/parsing/append/kbps:' + Math.round(stats.tfirst - stats.trequest) + '/' + Math.round(stats.tload - stats.tfirst) + '/' + Math.round(stats.tparsed - stats.tload) + '/' + Math.round(stats.tbuffered - stats.tparsed) + '/' + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));\n        this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);\n        // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration\n        if (frag.bitrateTest) {\n          this.bitrateTestDelay = fragLoadingProcessingMs / 1000;\n        } else {\n          this.bitrateTestDelay = 0;\n        }\n      }\n    }\n  }, {\n    key: 'onError',\n    value: function onError(data) {\n      // stop timer in case of frag loading error\n      switch (data.details) {\n        case _errors.ErrorDetails.FRAG_LOAD_ERROR:\n        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:\n          this.clearTimer();\n          break;\n        default:\n          break;\n      }\n    }\n  }, {\n    key: 'clearTimer',\n    value: function clearTimer() {\n      if (this.timer) {\n        clearInterval(this.timer);\n        this.timer = null;\n      }\n    }\n\n    // return next auto level\n\n  }, {\n    key: '_findBestLevel',\n    value: function _findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {\n      for (var i = maxAutoLevel; i >= minAutoLevel; i--) {\n        var levelInfo = levels[i],\n            levelDetails = levelInfo.details,\n            avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,\n            live = levelDetails ? levelDetails.live : false,\n            adjustedbw = void 0;\n        // follow algorithm captured from stagefright :\n        // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n        // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n        // consider only 80% of the available bandwidth, but if we are switching up,\n        // be even more conservative (70%) to avoid overestimating and immediately\n        // switching back.\n        if (i <= currentLevel) {\n          adjustedbw = bwFactor * currentBw;\n        } else {\n          adjustedbw = bwUpFactor * currentBw;\n        }\n        var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate,\n            fetchDuration = bitrate * avgDuration / adjustedbw;\n\n        _logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);\n        // if adjusted bw is greater than level bitrate AND\n        if (adjustedbw > bitrate && (\n        // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n        !fetchDuration || live || fetchDuration < maxFetchDuration)) {\n          // as we are looping from highest to lowest, this will return the best achievable quality level\n\n          return i;\n        }\n      }\n      // not enough time budget even with quality level 0 ... rebuffering might happen\n      return -1;\n    }\n  }, {\n    key: 'nextAutoLevel',\n    get: function get() {\n      var forcedAutoLevel = this._nextAutoLevel;\n      var bwEstimator = this._bwEstimator;\n      // in case next auto level has been forced, and bw not available or not reliable, return forced value\n      if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {\n        return forcedAutoLevel;\n      }\n      // compute next level using ABR logic\n      var nextABRAutoLevel = this._nextABRAutoLevel;\n      // if forced auto level has been defined, use it to cap ABR computed quality level\n      if (forcedAutoLevel !== -1) {\n        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);\n      }\n      return nextABRAutoLevel;\n    },\n    set: function set(nextLevel) {\n      this._nextAutoLevel = nextLevel;\n    }\n  }, {\n    key: '_nextABRAutoLevel',\n    get: function get() {\n      var hls = this.hls,\n          maxAutoLevel = hls.maxAutoLevel,\n          levels = hls.levels,\n          config = hls.config,\n          minAutoLevel = hls.minAutoLevel;\n      var v = hls.media,\n          currentLevel = this.lastLoadedFragLevel,\n          currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,\n          pos = v ? v.currentTime : 0,\n\n      // playbackRate is the absolute value of the playback rate; if v.playbackRate is 0, we use 1 to load as\n      // if we're playing back at the normal rate.\n      playbackRate = v && v.playbackRate !== 0 ? Math.abs(v.playbackRate) : 1.0,\n          avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,\n\n      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n      bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, config.maxBufferHole).end - pos) / playbackRate;\n\n      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n      var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);\n      if (bestLevel >= 0) {\n        return bestLevel;\n      } else {\n        _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');\n        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering\n        // if no matching level found, logic will return 0\n        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay,\n            bwFactor = config.abrBandWidthFactor,\n            bwUpFactor = config.abrBandWidthUpFactor;\n        if (bufferStarvationDelay === 0) {\n          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n          var bitrateTestDelay = this.bitrateTestDelay;\n          if (bitrateTestDelay) {\n            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n            // max video loading delay used in  automatic start level selection :\n            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n            // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n            var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n            maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n            _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');\n            // don't use conservative factor on bitrate test\n            bwFactor = bwUpFactor = 1;\n          }\n        }\n        bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);\n        return Math.max(bestLevel, 0);\n      }\n    }\n  }]);\n\n  return AbrController;\n}(_eventHandler2.default);\n\nexports.default = AbrController;\n\n},{\"10\":10,\"31\":31,\"32\":32,\"33\":33,\"35\":35,\"50\":50}],6:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _binarySearch = _dereq_(46);\n\nvar _binarySearch2 = _interopRequireDefault(_binarySearch);\n\nvar _bufferHelper = _dereq_(35);\n\nvar _bufferHelper2 = _interopRequireDefault(_bufferHelper);\n\nvar _demuxer = _dereq_(25);\n\nvar _demuxer2 = _interopRequireDefault(_demuxer);\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _levelHelper = _dereq_(36);\n\nvar _levelHelper2 = _interopRequireDefault(_levelHelper);\n\nvar _timeRanges = _dereq_(51);\n\nvar _timeRanges2 = _interopRequireDefault(_timeRanges);\n\nvar _errors = _dereq_(31);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar State = {\n  STOPPED: 'STOPPED',\n  STARTING: 'STARTING',\n  IDLE: 'IDLE',\n  PAUSED: 'PAUSED',\n  KEY_LOADING: 'KEY_LOADING',\n  FRAG_LOADING: 'FRAG_LOADING',\n  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n  WAITING_TRACK: 'WAITING_TRACK',\n  PARSING: 'PARSING',\n  PARSED: 'PARSED',\n  BUFFER_FLUSHING: 'BUFFER_FLUSHING',\n  ENDED: 'ENDED',\n  ERROR: 'ERROR',\n  WAITING_INIT_PTS: 'WAITING_INIT_PTS'\n};\n\nvar AudioStreamController = function (_EventHandler) {\n  _inherits(AudioStreamController, _EventHandler);\n\n  function AudioStreamController(hls) {\n    _classCallCheck(this, AudioStreamController);\n\n    var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.INIT_PTS_FOUND));\n\n    _this.config = hls.config;\n    _this.audioCodecSwap = false;\n    _this.ticks = 0;\n    _this._state = State.STOPPED;\n    _this.ontick = _this.tick.bind(_this);\n    _this.initPTS = [];\n    _this.waitingFragment = null;\n    return _this;\n  }\n\n  _createClass(AudioStreamController, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.stopLoad();\n      if (this.timer) {\n        clearInterval(this.timer);\n        this.timer = null;\n      }\n      _eventHandler2.default.prototype.destroy.call(this);\n      this.state = State.STOPPED;\n    }\n\n    //Signal that video PTS was found\n\n  }, {\n    key: 'onInitPtsFound',\n    value: function onInitPtsFound(data) {\n      var demuxerId = data.id,\n          cc = data.frag.cc,\n          initPTS = data.initPTS;\n      if (demuxerId === 'main') {\n        //Always update the new INIT PTS\n        //Can change due level switch\n        this.initPTS[cc] = initPTS;\n        _logger.logger.log('InitPTS for cc:' + cc + ' found from video track:' + initPTS);\n\n        //If we are waiting we need to demux/remux the waiting frag\n        //With the new initPTS\n        if (this.state === State.WAITING_INIT_PTS) {\n          _logger.logger.log('sending pending audio frag to demuxer');\n          this.state = State.FRAG_LOADING;\n          //We have audio frag waiting or video pts\n          //Let process it\n          this.onFragLoaded(this.waitingFragment);\n          //Lets clean the waiting frag\n          this.waitingFragment = null;\n        }\n      }\n    }\n  }, {\n    key: 'startLoad',\n    value: function startLoad(startPosition) {\n      if (this.tracks) {\n        var lastCurrentTime = this.lastCurrentTime;\n        this.stopLoad();\n        if (!this.timer) {\n          this.timer = setInterval(this.ontick, 100);\n        }\n        this.fragLoadError = 0;\n        if (lastCurrentTime > 0 && startPosition === -1) {\n          _logger.logger.log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));\n          this.state = State.IDLE;\n        } else {\n          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;\n          this.state = State.STARTING;\n        }\n        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;\n        this.tick();\n      } else {\n        this.startPosition = startPosition;\n        this.state = State.STOPPED;\n      }\n    }\n  }, {\n    key: 'stopLoad',\n    value: function stopLoad() {\n      var frag = this.fragCurrent;\n      if (frag) {\n        if (frag.loader) {\n          frag.loader.abort();\n        }\n        this.fragCurrent = null;\n      }\n      this.fragPrevious = null;\n      if (this.demuxer) {\n        this.demuxer.destroy();\n        this.demuxer = null;\n      }\n      this.state = State.STOPPED;\n    }\n  }, {\n    key: 'tick',\n    value: function tick() {\n      this.ticks++;\n      if (this.ticks === 1) {\n        this.doTick();\n        if (this.ticks > 1) {\n          setTimeout(this.tick, 1);\n        }\n        this.ticks = 0;\n      }\n    }\n  }, {\n    key: 'doTick',\n    value: function doTick() {\n      var _this2 = this;\n\n      var pos,\n          track,\n          trackDetails,\n          hls = this.hls,\n          config = hls.config;\n      //logger.log('audioStream:' + this.state);\n      var now;\n      var retryDate;\n      var isSeeking;\n\n      var _ret = function () {\n        switch (_this2.state) {\n          case State.ERROR:\n          //don't do anything in error state to avoid breaking further ...\n          case State.PAUSED:\n          //don't do anything in paused state either ...\n          case State.BUFFER_FLUSHING:\n            break;\n          case State.STARTING:\n            _this2.state = State.WAITING_TRACK;\n            _this2.loadedmetadata = false;\n            break;\n          case State.IDLE:\n            var tracks = _this2.tracks;\n            // audio tracks not received => exit loop\n            if (!tracks) {\n              break;\n            }\n            // if video not attached AND\n            // start fragment already requested OR start frag prefetch disable\n            // exit loop\n            // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n            if (!_this2.media && (_this2.startFragRequested || !config.startFragPrefetch)) {\n              break;\n            }\n            // determine next candidate fragment to be loaded, based on current position and\n            //  end of buffer position\n            // if we have not yet loaded any fragment, start loading from start position\n            if (_this2.loadedmetadata) {\n              pos = _this2.media.currentTime;\n            } else {\n              pos = _this2.nextLoadPosition;\n            }\n            var media = _this2.mediaBuffer ? _this2.mediaBuffer : _this2.media,\n                bufferInfo = _bufferHelper2.default.bufferInfo(media, pos, config.maxBufferHole),\n                bufferLen = bufferInfo.len,\n                bufferEnd = bufferInfo.end,\n                fragPrevious = _this2.fragPrevious,\n                maxBufLen = config.maxMaxBufferLength,\n                audioSwitch = _this2.audioSwitch,\n                trackId = _this2.trackId;\n\n            // if buffer length is less than maxBufLen try to load a new fragment\n            if (bufferLen < maxBufLen && trackId < tracks.length) {\n              trackDetails = tracks[trackId].details;\n              // if track info not retrieved yet, switch state and wait for track retrieval\n              if (typeof trackDetails === 'undefined') {\n                _this2.state = State.WAITING_TRACK;\n                break;\n              }\n\n              // we just got done loading the final fragment, check if we need to finalize media stream\n              if (!audioSwitch && !trackDetails.live && fragPrevious && fragPrevious.sn === trackDetails.endSN) {\n                // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos\n                // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching\n                // between different renditions. using half frag duration should help cope with these cases.\n                if (!_this2.media.seeking || _this2.media.duration - bufferEnd < fragPrevious.duration / 2) {\n                  // Finalize the media stream\n                  _this2.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });\n                  _this2.state = State.ENDED;\n                  break;\n                }\n              }\n\n              // find fragment index, contiguous with end of buffer position\n              var fragments = trackDetails.fragments,\n                  fragLen = fragments.length,\n                  start = fragments[0].start,\n                  end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,\n                  frag = void 0;\n\n              // When switching audio track, reload audio as close as possible to currentTime\n              if (audioSwitch) {\n                if (trackDetails.live && !trackDetails.PTSKnown) {\n                  _logger.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');\n                  bufferEnd = 0;\n                } else {\n                  bufferEnd = pos;\n                  // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime\n                  if (trackDetails.PTSKnown && pos < start) {\n                    // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start\n                    if (bufferInfo.end > start || bufferInfo.nextStart) {\n                      _logger.logger.log('alt audio track ahead of main track, seek to start of alt audio track');\n                      _this2.media.currentTime = start + 0.05;\n                    } else {\n                      return {\n                        v: void 0\n                      };\n                    }\n                  }\n                }\n              }\n              if (trackDetails.initSegment && !trackDetails.initSegment.data) {\n                frag = trackDetails.initSegment;\n              }\n              // if bufferEnd before start of playlist, load first fragment\n              else if (bufferEnd <= start) {\n                  frag = fragments[0];\n                  if (trackDetails.live && frag.loadIdx && frag.loadIdx === _this2.fragLoadIdx) {\n                    // we just loaded this first fragment, and we are still lagging behind the start of the live playlist\n                    // let's force seek to start\n                    var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;\n                    _logger.logger.log('no alt audio available @currentTime:' + _this2.media.currentTime + ', seeking @' + (nextBuffered + 0.05));\n                    _this2.media.currentTime = nextBuffered + 0.05;\n                    return {\n                      v: void 0\n                    };\n                  }\n                } else {\n                  (function () {\n                    var foundFrag = void 0;\n                    var maxFragLookUpTolerance = config.maxFragLookUpTolerance;\n                    var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;\n                    var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {\n                      // offset should be within fragment boundary - config.maxFragLookUpTolerance\n                      // this is to cope with situations like\n                      // bufferEnd = 9.991\n                      // frag[Ø] : [0,10]\n                      // frag[1] : [10,20]\n                      // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n                      //              frag start               frag start+duration\n                      //                  |-----------------------------|\n                      //              <--->                         <--->\n                      //  ...--------><-----------------------------><---------....\n                      // previous frag         matching fragment         next frag\n                      //  return -1             return 0                 return 1\n                      //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n                      // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n                      var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);\n                      if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n                        return 1;\n                      } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n                      else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n                          return -1;\n                        }\n                      return 0;\n                    };\n\n                    if (bufferEnd < end) {\n                      if (bufferEnd > end - maxFragLookUpTolerance) {\n                        maxFragLookUpTolerance = 0;\n                      }\n                      // Prefer the next fragment if it's within tolerance\n                      if (fragNext && !fragmentWithinToleranceTest(fragNext)) {\n                        foundFrag = fragNext;\n                      } else {\n                        foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);\n                      }\n                    } else {\n                      // reach end of playlist\n                      foundFrag = fragments[fragLen - 1];\n                    }\n                    if (foundFrag) {\n                      frag = foundFrag;\n                      start = foundFrag.start;\n                      //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);\n                      if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {\n                        if (frag.sn < trackDetails.endSN) {\n                          frag = fragments[frag.sn + 1 - trackDetails.startSN];\n                          _logger.logger.log('SN just loaded, load next one: ' + frag.sn);\n                        } else {\n                          frag = null;\n                        }\n                      }\n                    }\n                  })();\n                }\n              if (frag) {\n                //logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));\n                if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {\n                  _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId);\n                  _this2.state = State.KEY_LOADING;\n                  hls.trigger(_events2.default.KEY_LOADING, { frag: frag });\n                } else {\n                  _logger.logger.log('Loading ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));\n                  // ensure that we are not reloading the same fragments in loop ...\n                  if (_this2.fragLoadIdx !== undefined) {\n                    _this2.fragLoadIdx++;\n                  } else {\n                    _this2.fragLoadIdx = 0;\n                  }\n                  if (frag.loadCounter) {\n                    frag.loadCounter++;\n                    var maxThreshold = config.fragLoadingLoopThreshold;\n                    // if this frag has already been loaded 3 times, and if it has been reloaded recently\n                    if (frag.loadCounter > maxThreshold && Math.abs(_this2.fragLoadIdx - frag.loadIdx) < maxThreshold) {\n                      hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });\n                      return {\n                        v: void 0\n                      };\n                    }\n                  } else {\n                    frag.loadCounter = 1;\n                  }\n                  frag.loadIdx = _this2.fragLoadIdx;\n                  _this2.fragCurrent = frag;\n                  _this2.startFragRequested = true;\n                  if (!isNaN(frag.sn)) {\n                    _this2.nextLoadPosition = frag.start + frag.duration;\n                  }\n                  hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });\n                  _this2.state = State.FRAG_LOADING;\n                }\n              }\n            }\n            break;\n          case State.WAITING_TRACK:\n            track = _this2.tracks[_this2.trackId];\n            // check if playlist is already loaded\n            if (track && track.details) {\n              _this2.state = State.IDLE;\n            }\n            break;\n          case State.FRAG_LOADING_WAITING_RETRY:\n            now = performance.now();\n            retryDate = _this2.retryDate;\n\n            media = _this2.media;\n            isSeeking = media && media.seeking;\n            // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n\n            if (!retryDate || now >= retryDate || isSeeking) {\n              _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');\n              _this2.state = State.IDLE;\n            }\n            break;\n          case State.WAITING_INIT_PTS:\n          case State.STOPPED:\n          case State.FRAG_LOADING:\n          case State.PARSING:\n          case State.PARSED:\n          case State.ENDED:\n            break;\n          default:\n            break;\n        }\n      }();\n\n      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n    }\n  }, {\n    key: 'onMediaAttached',\n    value: function onMediaAttached(data) {\n      var media = this.media = this.mediaBuffer = data.media;\n      this.onvseeking = this.onMediaSeeking.bind(this);\n      this.onvended = this.onMediaEnded.bind(this);\n      media.addEventListener('seeking', this.onvseeking);\n      media.addEventListener('ended', this.onvended);\n      var config = this.config;\n      if (this.tracks && config.autoStartLoad) {\n        this.startLoad(config.startPosition);\n      }\n    }\n  }, {\n    key: 'onMediaDetaching',\n    value: function onMediaDetaching() {\n      var media = this.media;\n      if (media && media.ended) {\n        _logger.logger.log('MSE detaching and video ended, reset startPosition');\n        this.startPosition = this.lastCurrentTime = 0;\n      }\n\n      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery\n      var tracks = this.tracks;\n      if (tracks) {\n        // reset fragment load counter\n        tracks.forEach(function (track) {\n          if (track.details) {\n            track.details.fragments.forEach(function (fragment) {\n              fragment.loadCounter = undefined;\n            });\n          }\n        });\n      }\n      // remove video listeners\n      if (media) {\n        media.removeEventListener('seeking', this.onvseeking);\n        media.removeEventListener('ended', this.onvended);\n        this.onvseeking = this.onvseeked = this.onvended = null;\n      }\n      this.media = this.mediaBuffer = null;\n      this.loadedmetadata = false;\n      this.stopLoad();\n    }\n  }, {\n    key: 'onMediaSeeking',\n    value: function onMediaSeeking() {\n      if (this.state === State.ENDED) {\n        // switch to IDLE state to check for potential new fragment\n        this.state = State.IDLE;\n      }\n      if (this.media) {\n        this.lastCurrentTime = this.media.currentTime;\n      }\n      // avoid reporting fragment loop loading error in case user is seeking several times on same position\n      if (this.fragLoadIdx !== undefined) {\n        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;\n      }\n      // tick to speed up processing\n      this.tick();\n    }\n  }, {\n    key: 'onMediaEnded',\n    value: function onMediaEnded() {\n      // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n      this.startPosition = this.lastCurrentTime = 0;\n    }\n  }, {\n    key: 'onAudioTracksUpdated',\n    value: function onAudioTracksUpdated(data) {\n      _logger.logger.log('audio tracks updated');\n      this.tracks = data.audioTracks;\n    }\n  }, {\n    key: 'onAudioTrackSwitching',\n    value: function onAudioTrackSwitching(data) {\n      // if any URL found on new audio track, it is an alternate audio track\n      var altAudio = !!data.url;\n      this.trackId = data.id;\n      this.state = State.IDLE;\n\n      this.fragCurrent = null;\n      this.state = State.PAUSED;\n      this.waitingFragment = null;\n      // destroy useless demuxer when switching audio to main\n      if (!altAudio) {\n        if (this.demuxer) {\n          this.demuxer.destroy();\n          this.demuxer = null;\n        }\n      } else {\n        // switching to audio track, start timer if not already started\n        if (!this.timer) {\n          this.timer = setInterval(this.ontick, 100);\n        }\n      }\n\n      //should we switch tracks ?\n      if (altAudio) {\n        this.audioSwitch = true;\n        //main audio track are handled by stream-controller, just do something if switching to alt audio track\n        this.state = State.IDLE;\n        // increase fragment load Index to avoid frag loop loading error after buffer flush\n        if (this.fragLoadIdx !== undefined) {\n          this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;\n        }\n      }\n      this.tick();\n    }\n  }, {\n    key: 'onAudioTrackLoaded',\n    value: function onAudioTrackLoaded(data) {\n      var newDetails = data.details,\n          trackId = data.id,\n          track = this.tracks[trackId],\n          duration = newDetails.totalduration,\n          sliding = 0;\n\n      _logger.logger.log('track ' + trackId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);\n\n      if (newDetails.live) {\n        var curDetails = track.details;\n        if (curDetails && newDetails.fragments.length > 0) {\n          // we already have details for that level, merge them\n          _levelHelper2.default.mergeDetails(curDetails, newDetails);\n          sliding = newDetails.fragments[0].start;\n          // TODO\n          //this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);\n          if (newDetails.PTSKnown) {\n            _logger.logger.log('live audio playlist sliding:' + sliding.toFixed(3));\n          } else {\n            _logger.logger.log('live audio playlist - outdated PTS, unknown sliding');\n          }\n        } else {\n          newDetails.PTSKnown = false;\n          _logger.logger.log('live audio playlist - first load, unknown sliding');\n        }\n      } else {\n        newDetails.PTSKnown = false;\n      }\n      track.details = newDetails;\n\n      // compute start position\n      if (!this.startFragRequested) {\n        // compute start position if set to -1. use it straight away if value is defined\n        if (this.startPosition === -1) {\n          // first, check if start time offset has been set in playlist, if yes, use this value\n          var startTimeOffset = newDetails.startTimeOffset;\n          if (!isNaN(startTimeOffset)) {\n            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);\n            this.startPosition = startTimeOffset;\n          } else {\n            this.startPosition = 0;\n          }\n        }\n        this.nextLoadPosition = this.startPosition;\n      }\n      // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment\n      if (this.state === State.WAITING_TRACK) {\n        this.state = State.IDLE;\n      }\n      //trigger handler right now\n      this.tick();\n    }\n  }, {\n    key: 'onKeyLoaded',\n    value: function onKeyLoaded() {\n      if (this.state === State.KEY_LOADING) {\n        this.state = State.IDLE;\n        this.tick();\n      }\n    }\n  }, {\n    key: 'onFragLoaded',\n    value: function onFragLoaded(data) {\n      var fragCurrent = this.fragCurrent,\n          fragLoaded = data.frag;\n      if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'audio' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {\n        var track = this.tracks[this.trackId],\n            details = track.details,\n            duration = details.totalduration,\n            trackId = fragCurrent.level,\n            sn = fragCurrent.sn,\n            cc = fragCurrent.cc,\n            audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2',\n            stats = this.stats = data.stats;\n        if (sn === 'initSegment') {\n          this.state = State.IDLE;\n\n          stats.tparsed = stats.tbuffered = performance.now();\n          details.initSegment.data = data.payload;\n          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' });\n          this.tick();\n        } else {\n          this.state = State.PARSING;\n          // transmux the MPEG-TS data to ISO-BMFF segments\n          this.appended = false;\n          if (!this.demuxer) {\n            this.demuxer = new _demuxer2.default(this.hls, 'audio');\n          }\n          //Check if we have video initPTS\n          // If not we need to wait for it\n          var initPTS = this.initPTS[cc];\n          var initSegmentData = details.initSegment ? details.initSegment.data : [];\n          if (initSegmentData || initPTS !== undefined) {\n            this.pendingBuffering = true;\n            _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);\n            // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n            var accurateTimeOffset = false; //details.PTSKnown || !details.live;\n            this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);\n          } else {\n            _logger.logger.log('unknown video PTS for continuity counter ' + cc + ', waiting for video PTS before demuxing audio frag ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);\n            this.waitingFragment = data;\n            this.state = State.WAITING_INIT_PTS;\n          }\n        }\n      }\n      this.fragLoadError = 0;\n    }\n  }, {\n    key: 'onFragParsingInitSegment',\n    value: function onFragParsingInitSegment(data) {\n      var fragCurrent = this.fragCurrent;\n      var fragNew = data.frag;\n      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {\n        var tracks = data.tracks,\n            track = void 0;\n\n        // delete any video track found on audio demuxer\n        if (tracks.video) {\n          delete tracks.video;\n        }\n\n        // include levelCodec in audio and video tracks\n        track = tracks.audio;\n        if (track) {\n          track.levelCodec = 'mp4a.40.2';\n          track.id = data.id;\n          this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);\n          _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');\n          var initSegment = track.initSegment;\n          if (initSegment) {\n            var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };\n            if (this.audioSwitch) {\n              this.pendingData = [appendObj];\n            } else {\n              this.appended = true;\n              // arm pending Buffering flag before appending a segment\n              this.pendingBuffering = true;\n              this.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);\n            }\n          }\n          //trigger handler right now\n          this.tick();\n        }\n      }\n    }\n  }, {\n    key: 'onFragParsingData',\n    value: function onFragParsingData(data) {\n      var _this3 = this;\n\n      var fragCurrent = this.fragCurrent;\n      var fragNew = data.frag;\n      if (fragCurrent && data.id === 'audio' && data.type === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {\n        (function () {\n          var trackId = _this3.trackId,\n              track = _this3.tracks[trackId],\n              hls = _this3.hls;\n\n          if (isNaN(data.endPTS)) {\n            data.endPTS = data.startPTS + fragCurrent.duration;\n            data.endDTS = data.startDTS + fragCurrent.duration;\n          }\n\n          _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);\n          _levelHelper2.default.updateFragPTSDTS(track.details, fragCurrent.sn, data.startPTS, data.endPTS);\n\n          var audioSwitch = _this3.audioSwitch,\n              media = _this3.media,\n              appendOnBufferFlush = false;\n          //Only flush audio from old audio tracks when PTS is known on new audio track\n          if (audioSwitch && media) {\n            if (media.readyState) {\n              var currentTime = media.currentTime;\n              _logger.logger.log('switching audio track : currentTime:' + currentTime);\n              if (currentTime >= data.startPTS) {\n                _logger.logger.log('switching audio track : flushing all audio');\n                _this3.state = State.BUFFER_FLUSHING;\n                hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });\n                appendOnBufferFlush = true;\n                //Lets announce that the initial audio track switch flush occur\n                _this3.audioSwitch = false;\n                hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });\n              }\n            } else {\n              //Lets announce that the initial audio track switch flush occur\n              _this3.audioSwitch = false;\n              hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });\n            }\n          }\n\n          var pendingData = _this3.pendingData;\n          if (!_this3.audioSwitch) {\n            [data.data1, data.data2].forEach(function (buffer) {\n              if (buffer && buffer.length) {\n                pendingData.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });\n              }\n            });\n            if (!appendOnBufferFlush && pendingData.length) {\n              pendingData.forEach(function (appendObj) {\n                // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)\n                // in that case it is useless to append following segments\n                if (_this3.state === State.PARSING) {\n                  // arm pending Buffering flag before appending a segment\n                  _this3.pendingBuffering = true;\n                  _this3.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);\n                }\n              });\n              _this3.pendingData = [];\n              _this3.appended = true;\n            }\n          }\n          //trigger handler right now\n          _this3.tick();\n        })();\n      }\n    }\n  }, {\n    key: 'onFragParsed',\n    value: function onFragParsed(data) {\n      var fragCurrent = this.fragCurrent;\n      var fragNew = data.frag;\n      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {\n        this.stats.tparsed = performance.now();\n        this.state = State.PARSED;\n        this._checkAppendedParsed();\n      }\n    }\n  }, {\n    key: 'onBufferCreated',\n    value: function onBufferCreated(data) {\n      var audioTrack = data.tracks.audio;\n      if (audioTrack) {\n        this.mediaBuffer = audioTrack.buffer;\n        this.loadedmetadata = true;\n      }\n    }\n  }, {\n    key: 'onBufferAppended',\n    value: function onBufferAppended(data) {\n      if (data.parent === 'audio') {\n        var state = this.state;\n        if (state === State.PARSING || state === State.PARSED) {\n          // check if all buffers have been appended\n          this.pendingBuffering = data.pending > 0;\n          this._checkAppendedParsed();\n        }\n      }\n    }\n  }, {\n    key: '_checkAppendedParsed',\n    value: function _checkAppendedParsed() {\n      //trigger handler right now\n      if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {\n        var frag = this.fragCurrent,\n            stats = this.stats,\n            hls = this.hls;\n        if (frag) {\n          this.fragPrevious = frag;\n          stats.tbuffered = performance.now();\n          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });\n          var media = this.mediaBuffer ? this.mediaBuffer : this.media;\n          _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));\n          if (this.audioSwitch && this.appended) {\n            this.audioSwitch = false;\n            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: this.trackId });\n          }\n          this.state = State.IDLE;\n        }\n        this.tick();\n      }\n    }\n  }, {\n    key: 'onError',\n    value: function onError(data) {\n      var frag = data.frag;\n      // don't handle frag error not related to audio fragment\n      if (frag && frag.type !== 'audio') {\n        return;\n      }\n      switch (data.details) {\n        case _errors.ErrorDetails.FRAG_LOAD_ERROR:\n        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:\n          if (!data.fatal) {\n            var loadError = this.fragLoadError;\n            if (loadError) {\n              loadError++;\n            } else {\n              loadError = 1;\n            }\n            var config = this.config;\n            if (loadError <= config.fragLoadingMaxRetry) {\n              this.fragLoadError = loadError;\n              // reset load counter to avoid frag loop loading error\n              frag.loadCounter = 0;\n              // exponential backoff capped to config.fragLoadingMaxRetryTimeout\n              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);\n              _logger.logger.warn('audioStreamController: frag loading failed, retry in ' + delay + ' ms');\n              this.retryDate = performance.now() + delay;\n              // retry loading state\n              this.state = State.FRAG_LOADING_WAITING_RETRY;\n            } else {\n              _logger.logger.error('audioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');\n              // redispatch same error but with fatal set to true\n              data.fatal = true;\n              this.hls.trigger(_events2.default.ERROR, data);\n              this.state = State.ERROR;\n            }\n          }\n          break;\n        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:\n        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n        case _errors.ErrorDetails.KEY_LOAD_ERROR:\n        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:\n          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received\n          if (this.state !== State.ERROR) {\n            // if fatal error, stop processing, otherwise move to IDLE to retry loading\n            this.state = data.fatal ? State.ERROR : State.IDLE;\n            _logger.logger.warn('audioStreamController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');\n          }\n          break;\n        case _errors.ErrorDetails.BUFFER_FULL_ERROR:\n          // if in appending state\n          if (data.parent === 'audio' && (this.state === State.PARSING || this.state === State.PARSED)) {\n            var media = this.mediaBuffer,\n                currentTime = this.media.currentTime,\n                mediaBuffered = media && _bufferHelper2.default.isBuffered(media, currentTime) && _bufferHelper2.default.isBuffered(media, currentTime + 0.5);\n            // reduce max buf len if current position is buffered\n            if (mediaBuffered) {\n              var _config = this.config;\n              if (_config.maxMaxBufferLength >= _config.maxBufferLength) {\n                // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n                _config.maxMaxBufferLength /= 2;\n                _logger.logger.warn('audio:reduce max buffer length to ' + _config.maxMaxBufferLength + 's');\n                // increase fragment load Index to avoid frag loop loading error after buffer flush\n                this.fragLoadIdx += 2 * _config.fragLoadingLoopThreshold;\n              }\n              this.state = State.IDLE;\n            } else {\n              // current position is not buffered, but browser is still complaining about buffer full error\n              // this happens on IE/Edge, refer to https://github.com/dailymotion/hls.js/pull/708\n              // in that case flush the whole audio buffer to recover\n              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush audio buffer');\n              this.fragCurrent = null;\n              // flush everything\n              this.state = State.BUFFER_FLUSHING;\n              this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });\n            }\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }, {\n    key: 'onBufferFlushed',\n    value: function onBufferFlushed() {\n      var _this4 = this;\n\n      var pendingData = this.pendingData;\n      if (pendingData && pendingData.length) {\n        _logger.logger.log('appending pending audio data on Buffer Flushed');\n        pendingData.forEach(function (appendObj) {\n          _this4.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);\n        });\n        this.appended = true;\n        this.pendingData = [];\n        this.state = State.PARSED;\n      } else {\n        // move to IDLE once flush complete. this should trigger new fragment loading\n        this.state = State.IDLE;\n        // reset reference to frag\n        this.fragPrevious = null;\n        this.tick();\n      }\n    }\n  }, {\n    key: 'state',\n    set: function set(nextState) {\n      if (this.state !== nextState) {\n        var previousState = this.state;\n        this._state = nextState;\n        _logger.logger.log('audio stream:' + previousState + '->' + nextState);\n      }\n    },\n    get: function get() {\n      return this._state;\n    }\n  }]);\n\n  return AudioStreamController;\n}(_eventHandler2.default);\n\nexports.default = AudioStreamController;\n\n},{\"25\":25,\"31\":31,\"32\":32,\"33\":33,\"35\":35,\"36\":36,\"46\":46,\"50\":50,\"51\":51}],7:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar AudioTrackController = function (_EventHandler) {\n  _inherits(AudioTrackController, _EventHandler);\n\n  function AudioTrackController(hls) {\n    _classCallCheck(this, AudioTrackController);\n\n    var _this = _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.AUDIO_TRACK_LOADED));\n\n    _this.ticks = 0;\n    _this.ontick = _this.tick.bind(_this);\n    return _this;\n  }\n\n  _createClass(AudioTrackController, [{\n    key: 'destroy',\n    value: function destroy() {\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n  }, {\n    key: 'tick',\n    value: function tick() {\n      this.ticks++;\n      if (this.ticks === 1) {\n        this.doTick();\n        if (this.ticks > 1) {\n          setTimeout(this.tick, 1);\n        }\n        this.ticks = 0;\n      }\n    }\n  }, {\n    key: 'doTick',\n    value: function doTick() {\n      this.updateTrack(this.trackId);\n    }\n  }, {\n    key: 'onManifestLoading',\n    value: function onManifestLoading() {\n      // reset audio tracks on manifest loading\n      this.tracks = [];\n      this.trackId = -1;\n    }\n  }, {\n    key: 'onManifestLoaded',\n    value: function onManifestLoaded(data) {\n      var _this2 = this;\n\n      var tracks = data.audioTracks || [];\n      var defaultFound = false;\n      this.tracks = tracks;\n      this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });\n      // loop through available audio tracks and autoselect default if needed\n      var id = 0;\n      tracks.forEach(function (track) {\n        if (track.default) {\n          _this2.audioTrack = id;\n          defaultFound = true;\n          return;\n        }\n        id++;\n      });\n      if (defaultFound === false && tracks.length) {\n        _logger.logger.log('no default audio track defined, use first audio track as default');\n        this.audioTrack = 0;\n      }\n    }\n  }, {\n    key: 'onAudioTrackLoaded',\n    value: function onAudioTrackLoaded(data) {\n      if (data.id < this.tracks.length) {\n        _logger.logger.log('audioTrack ' + data.id + ' loaded');\n        this.tracks[data.id].details = data.details;\n        // check if current playlist is a live playlist\n        if (data.details.live && !this.timer) {\n          // if live playlist we will have to reload it periodically\n          // set reload period to playlist target duration\n          this.timer = setInterval(this.ontick, 1000 * data.details.targetduration);\n        }\n        if (!data.details.live && this.timer) {\n          // playlist is not live and timer is armed : stopping it\n          clearInterval(this.timer);\n          this.timer = null;\n        }\n      }\n    }\n\n    /** get alternate audio tracks list from playlist **/\n\n  }, {\n    key: 'setAudioTrackInternal',\n    value: function setAudioTrackInternal(newId) {\n      // check if level idx is valid\n      if (newId >= 0 && newId < this.tracks.length) {\n        // stopping live reloading timer if any\n        if (this.timer) {\n          clearInterval(this.timer);\n          this.timer = null;\n        }\n        this.trackId = newId;\n        _logger.logger.log('switching to audioTrack ' + newId);\n        var audioTrack = this.tracks[newId],\n            hls = this.hls,\n            type = audioTrack.type,\n            url = audioTrack.url,\n            eventObj = { id: newId, type: type, url: url };\n        // keep AUDIO_TRACK_SWITCH for legacy reason\n        hls.trigger(_events2.default.AUDIO_TRACK_SWITCH, eventObj);\n        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHING, eventObj);\n        // check if we need to load playlist for this audio Track\n        var details = audioTrack.details;\n        if (url && (details === undefined || details.live === true)) {\n          // track not retrieved yet, or live playlist we need to (re)load it\n          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);\n          hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });\n        }\n      }\n    }\n  }, {\n    key: 'updateTrack',\n    value: function updateTrack(newId) {\n      // check if level idx is valid\n      if (newId >= 0 && newId < this.tracks.length) {\n        // stopping live reloading timer if any\n        if (this.timer) {\n          clearInterval(this.timer);\n          this.timer = null;\n        }\n        this.trackId = newId;\n        _logger.logger.log('updating audioTrack ' + newId);\n        var audioTrack = this.tracks[newId],\n            url = audioTrack.url;\n        // check if we need to load playlist for this audio Track\n        var details = audioTrack.details;\n        if (url && (details === undefined || details.live === true)) {\n          // track not retrieved yet, or live playlist we need to (re)load it\n          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);\n          this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });\n        }\n      }\n    }\n  }, {\n    key: 'audioTracks',\n    get: function get() {\n      return this.tracks;\n    }\n\n    /** get index of the selected audio track (index in audio track lists) **/\n\n  }, {\n    key: 'audioTrack',\n    get: function get() {\n      return this.trackId;\n    }\n\n    /** select an audio track, based on its index in audio track lists**/\n    ,\n    set: function set(audioTrackId) {\n      if (this.trackId !== audioTrackId || this.tracks[audioTrackId].details === undefined) {\n        this.setAudioTrackInternal(audioTrackId);\n      }\n    }\n  }]);\n\n  return AudioTrackController;\n}(_eventHandler2.default);\n\nexports.default = AudioTrackController;\n\n},{\"32\":32,\"33\":33,\"50\":50}],8:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _logger = _dereq_(50);\n\nvar _errors = _dereq_(31);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar BufferController = function (_EventHandler) {\n  _inherits(BufferController, _EventHandler);\n\n  function BufferController(hls) {\n    _classCallCheck(this, BufferController);\n\n    // the value that we have set mediasource.duration to\n    // (the actual duration may be tweaked slighly by the browser)\n    var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_PTS_UPDATED, _events2.default.LEVEL_UPDATED));\n\n    _this._msDuration = null;\n    // the value that we want to set mediaSource.duration to\n    _this._levelDuration = null;\n\n    // Source Buffer listeners\n    _this.onsbue = _this.onSBUpdateEnd.bind(_this);\n    _this.onsbe = _this.onSBUpdateError.bind(_this);\n    _this.pendingTracks = {};\n    _this.tracks = {};\n    return _this;\n  }\n\n  _createClass(BufferController, [{\n    key: 'destroy',\n    value: function destroy() {\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n  }, {\n    key: 'onLevelPtsUpdated',\n    value: function onLevelPtsUpdated(data) {\n      var type = data.type;\n      var audioTrack = this.tracks.audio;\n\n      // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n      // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n      // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue\n      // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`\n      // event if SB is in updating state.\n      // More info here: https://github.com/dailymotion/hls.js/issues/332#issuecomment-257986486\n\n      if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') {\n        // Chrome audio mp3 track\n        var audioBuffer = this.sourceBuffer.audio;\n        var delta = Math.abs(audioBuffer.timestampOffset - data.start);\n\n        // adjust timestamp offset if time delta is greater than 100ms\n        if (delta > 0.1) {\n          var updating = audioBuffer.updating;\n\n          try {\n            audioBuffer.abort();\n          } catch (err) {\n            updating = true;\n            _logger.logger.warn('can not abort audio buffer: ' + err);\n          }\n\n          if (!updating) {\n            _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);\n            audioBuffer.timestampOffset = data.start;\n          } else {\n            this.audioTimestampOffset = data.start;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'onManifestParsed',\n    value: function onManifestParsed(data) {\n      var audioExpected = data.audio,\n          videoExpected = data.video,\n          sourceBufferNb = 0;\n      // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n      // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n      // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n      // it will contain the expected nb of source buffers, no need to compute it\n      if (data.altAudio && (audioExpected || videoExpected)) {\n        sourceBufferNb = (audioExpected ? 1 : 0) + (videoExpected ? 1 : 0);\n        _logger.logger.log(sourceBufferNb + ' sourceBuffer(s) expected');\n      }\n      this.sourceBufferNb = sourceBufferNb;\n    }\n  }, {\n    key: 'onMediaAttaching',\n    value: function onMediaAttaching(data) {\n      var media = this.media = data.media;\n      if (media) {\n        // setup the media source\n        var ms = this.mediaSource = new MediaSource();\n        //Media Source listeners\n        this.onmso = this.onMediaSourceOpen.bind(this);\n        this.onmse = this.onMediaSourceEnded.bind(this);\n        this.onmsc = this.onMediaSourceClose.bind(this);\n        ms.addEventListener('sourceopen', this.onmso);\n        ms.addEventListener('sourceended', this.onmse);\n        ms.addEventListener('sourceclose', this.onmsc);\n        // link video and media Source\n        media.src = URL.createObjectURL(ms);\n      }\n    }\n  }, {\n    key: 'onMediaDetaching',\n    value: function onMediaDetaching() {\n      _logger.logger.log('media source detaching');\n      var ms = this.mediaSource;\n      if (ms) {\n        if (ms.readyState === 'open') {\n          try {\n            // endOfStream could trigger exception if any sourcebuffer is in updating state\n            // we don't really care about checking sourcebuffer state here,\n            // as we are anyway detaching the MediaSource\n            // let's just avoid this exception to propagate\n            ms.endOfStream();\n          } catch (err) {\n            _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');\n          }\n        }\n        ms.removeEventListener('sourceopen', this.onmso);\n        ms.removeEventListener('sourceended', this.onmse);\n        ms.removeEventListener('sourceclose', this.onmsc);\n\n        // Detach properly the MediaSource from the HTMLMediaElement as\n        // suggested in https://github.com/w3c/media-source/issues/53.\n        if (this.media) {\n          URL.revokeObjectURL(this.media.src);\n          this.media.removeAttribute('src');\n          this.media.load();\n        }\n\n        this.mediaSource = null;\n        this.media = null;\n        this.pendingTracks = {};\n        this.tracks = {};\n        this.sourceBuffer = {};\n        this.flushRange = [];\n        this.segments = [];\n        this.appended = 0;\n      }\n      this.onmso = this.onmse = this.onmsc = null;\n      this.hls.trigger(_events2.default.MEDIA_DETACHED);\n    }\n  }, {\n    key: 'onMediaSourceOpen',\n    value: function onMediaSourceOpen() {\n      _logger.logger.log('media source opened');\n      this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });\n      var mediaSource = this.mediaSource;\n      if (mediaSource) {\n        // once received, don't listen anymore to sourceopen event\n        mediaSource.removeEventListener('sourceopen', this.onmso);\n      }\n      this.checkPendingTracks();\n    }\n  }, {\n    key: 'checkPendingTracks',\n    value: function checkPendingTracks() {\n      // if any buffer codecs pending, check if we have enough to create sourceBuffers\n      var pendingTracks = this.pendingTracks,\n          pendingTracksNb = Object.keys(pendingTracks).length;\n      // if any pending tracks and (if nb of pending tracks gt or equal than expected nb or if unknown expected nb)\n      if (pendingTracksNb && (this.sourceBufferNb <= pendingTracksNb || this.sourceBufferNb === 0)) {\n        // ok, let's create them now !\n        this.createSourceBuffers(pendingTracks);\n        this.pendingTracks = {};\n        // append any pending segments now !\n        this.doAppending();\n      }\n    }\n  }, {\n    key: 'onMediaSourceClose',\n    value: function onMediaSourceClose() {\n      _logger.logger.log('media source closed');\n    }\n  }, {\n    key: 'onMediaSourceEnded',\n    value: function onMediaSourceEnded() {\n      _logger.logger.log('media source ended');\n    }\n  }, {\n    key: 'onSBUpdateEnd',\n    value: function onSBUpdateEnd() {\n      // update timestampOffset\n      if (this.audioTimestampOffset) {\n        var audioBuffer = this.sourceBuffer.audio;\n        _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + this.audioTimestampOffset);\n        audioBuffer.timestampOffset = this.audioTimestampOffset;\n        delete this.audioTimestampOffset;\n      }\n\n      if (this._needsFlush) {\n        this.doFlush();\n      }\n\n      if (this._needsEos) {\n        this.checkEos();\n      }\n      this.appending = false;\n      var parent = this.parent;\n      // count nb of pending segments waiting for appending on this sourcebuffer\n      var pending = this.segments.reduce(function (counter, segment) {\n        return segment.parent === parent ? counter + 1 : counter;\n      }, 0);\n      this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: parent, pending: pending });\n\n      // don't append in flushing mode\n      if (!this._needsFlush) {\n        this.doAppending();\n      }\n\n      this.updateMediaElementDuration();\n    }\n  }, {\n    key: 'onSBUpdateError',\n    value: function onSBUpdateError(event) {\n      _logger.logger.error('sourceBuffer error:' + event);\n      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n      // this error might not always be fatal (it is fatal if decode error is set, in that case\n      // it will be followed by a mediaElement error ...)\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });\n      // we don't need to do more than that, as accordin to the spec, updateend will be fired just after\n    }\n  }, {\n    key: 'onBufferReset',\n    value: function onBufferReset() {\n      var sourceBuffer = this.sourceBuffer;\n      for (var type in sourceBuffer) {\n        var sb = sourceBuffer[type];\n        try {\n          this.mediaSource.removeSourceBuffer(sb);\n          sb.removeEventListener('updateend', this.onsbue);\n          sb.removeEventListener('error', this.onsbe);\n        } catch (err) {}\n      }\n      this.sourceBuffer = {};\n      this.flushRange = [];\n      this.segments = [];\n      this.appended = 0;\n    }\n  }, {\n    key: 'onBufferCodecs',\n    value: function onBufferCodecs(tracks) {\n      // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks\n      // if sourcebuffers already created, do nothing ...\n      if (Object.keys(this.sourceBuffer).length === 0) {\n        for (var trackName in tracks) {\n          this.pendingTracks[trackName] = tracks[trackName];\n        }\n        var mediaSource = this.mediaSource;\n        if (mediaSource && mediaSource.readyState === 'open') {\n          // try to create sourcebuffers if mediasource opened\n          this.checkPendingTracks();\n        }\n      }\n    }\n  }, {\n    key: 'createSourceBuffers',\n    value: function createSourceBuffers(tracks) {\n      var sourceBuffer = this.sourceBuffer,\n          mediaSource = this.mediaSource;\n\n      for (var trackName in tracks) {\n        if (!sourceBuffer[trackName]) {\n          var track = tracks[trackName];\n          // use levelCodec as first priority\n          var codec = track.levelCodec || track.codec;\n          var mimeType = track.container + ';codecs=' + codec;\n          _logger.logger.log('creating sourceBuffer(' + mimeType + ')');\n          try {\n            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);\n            sb.addEventListener('updateend', this.onsbue);\n            sb.addEventListener('error', this.onsbe);\n            this.tracks[trackName] = { codec: codec, container: track.container };\n            track.buffer = sb;\n          } catch (err) {\n            _logger.logger.error('error while trying to add sourceBuffer:' + err.message);\n            this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });\n          }\n        }\n      }\n      this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });\n    }\n  }, {\n    key: 'onBufferAppending',\n    value: function onBufferAppending(data) {\n      if (!this._needsFlush) {\n        if (!this.segments) {\n          this.segments = [data];\n        } else {\n          this.segments.push(data);\n        }\n        this.doAppending();\n      }\n    }\n  }, {\n    key: 'onBufferAppendFail',\n    value: function onBufferAppendFail(data) {\n      _logger.logger.error('sourceBuffer error:', data.event);\n      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n      // this error might not always be fatal (it is fatal if decode error is set, in that case\n      // it will be followed by a mediaElement error ...)\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });\n    }\n\n    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()\n\n  }, {\n    key: 'onBufferEos',\n    value: function onBufferEos(data) {\n      var sb = this.sourceBuffer;\n      var dataType = data.type;\n      for (var type in sb) {\n        if (!dataType || type === dataType) {\n          if (!sb[type].ended) {\n            sb[type].ended = true;\n            _logger.logger.log(type + ' sourceBuffer now EOS');\n          }\n        }\n      }\n      this.checkEos();\n    }\n\n    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.\n\n  }, {\n    key: 'checkEos',\n    value: function checkEos() {\n      var sb = this.sourceBuffer,\n          mediaSource = this.mediaSource;\n      if (!mediaSource || mediaSource.readyState !== 'open') {\n        this._needsEos = false;\n        return;\n      }\n      for (var type in sb) {\n        var sbobj = sb[type];\n        if (!sbobj.ended) {\n          return;\n        }\n        if (sbobj.updating) {\n          this._needsEos = true;\n          return;\n        }\n      }\n      _logger.logger.log('all media data available, signal endOfStream() to MediaSource and stop loading fragment');\n      //Notify the media element that it now has all of the media data\n      try {\n        mediaSource.endOfStream();\n      } catch (e) {\n        _logger.logger.warn('exception while calling mediaSource.endOfStream()');\n      }\n      this._needsEos = false;\n    }\n  }, {\n    key: 'onBufferFlushing',\n    value: function onBufferFlushing(data) {\n      this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });\n      // attempt flush immediatly\n      this.flushBufferCounter = 0;\n      this.doFlush();\n    }\n  }, {\n    key: 'onLevelUpdated',\n    value: function onLevelUpdated(event) {\n      var details = event.details;\n      if (details.fragments.length === 0) {\n        return;\n      }\n      this._levelDuration = details.totalduration + details.fragments[0].start;\n      this.updateMediaElementDuration();\n    }\n\n    // https://github.com/dailymotion/hls.js/issues/355\n\n  }, {\n    key: 'updateMediaElementDuration',\n    value: function updateMediaElementDuration() {\n      var media = this.media,\n          mediaSource = this.mediaSource,\n          sourceBuffer = this.sourceBuffer,\n          levelDuration = this._levelDuration;\n      if (levelDuration === null || !media || !mediaSource || !sourceBuffer || media.readyState === 0 || mediaSource.readyState !== 'open') {\n        return;\n      }\n      for (var type in sourceBuffer) {\n        if (sourceBuffer[type].updating) {\n          // can't set duration whilst a buffer is updating\n          return;\n        }\n      }\n      if (this._msDuration === null) {\n        // initialise to the value that the media source is reporting\n        this._msDuration = mediaSource.duration;\n      }\n      var duration = media.duration;\n      // levelDuration was the last value we set.\n      // not using mediaSource.duration as the browser may tweak this value\n      // only update mediasource duration if its value increase, this is to avoid\n      // flushing already buffered portion when switching between quality level\n      if (levelDuration > this._msDuration && levelDuration > duration || duration === Infinity || isNaN(duration)) {\n        _logger.logger.log('Updating mediasource duration to ' + levelDuration.toFixed(3));\n        this._msDuration = mediaSource.duration = levelDuration;\n      }\n    }\n  }, {\n    key: 'doFlush',\n    value: function doFlush() {\n      // loop through all buffer ranges to flush\n      while (this.flushRange.length) {\n        var range = this.flushRange[0];\n        // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer\n        if (this.flushBuffer(range.start, range.end, range.type)) {\n          // range flushed, remove from flush array\n          this.flushRange.shift();\n          this.flushBufferCounter = 0;\n        } else {\n          this._needsFlush = true;\n          // avoid looping, wait for SB update end to retrigger a flush\n          return;\n        }\n      }\n      if (this.flushRange.length === 0) {\n        // everything flushed\n        this._needsFlush = false;\n\n        // let's recompute this.appended, which is used to avoid flush looping\n        var appended = 0;\n        var sourceBuffer = this.sourceBuffer;\n        try {\n          for (var type in sourceBuffer) {\n            appended += sourceBuffer[type].buffered.length;\n          }\n        } catch (error) {\n          // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource\n          // this is harmess at this stage, catch this to avoid reporting an internal exception\n          _logger.logger.error('error while accessing sourceBuffer.buffered');\n        }\n        this.appended = appended;\n        this.hls.trigger(_events2.default.BUFFER_FLUSHED);\n      }\n    }\n  }, {\n    key: 'doAppending',\n    value: function doAppending() {\n      var hls = this.hls,\n          sourceBuffer = this.sourceBuffer,\n          segments = this.segments;\n      if (Object.keys(sourceBuffer).length) {\n        if (this.media.error) {\n          this.segments = [];\n          _logger.logger.error('trying to append although a media error occured, flush segment and abort');\n          return;\n        }\n        if (this.appending) {\n          //logger.log(`sb appending in progress`);\n          return;\n        }\n        if (segments && segments.length) {\n          var segment = segments.shift();\n          try {\n            var type = segment.type,\n                sb = sourceBuffer[type];\n            if (sb) {\n              if (!sb.updating) {\n                // reset sourceBuffer ended flag before appending segment\n                sb.ended = false;\n                //logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);\n                this.parent = segment.parent;\n                sb.appendBuffer(segment.data);\n                this.appendError = 0;\n                this.appended++;\n                this.appending = true;\n              } else {\n                segments.unshift(segment);\n              }\n            } else {\n              // in case we don't have any source buffer matching with this segment type,\n              // it means that Mediasource fails to create sourcebuffer\n              // discard this segment, and trigger update end\n              this.onSBUpdateEnd();\n            }\n          } catch (err) {\n            // in case any error occured while appending, put back segment in segments table\n            _logger.logger.error('error while trying to append buffer:' + err.message);\n            segments.unshift(segment);\n            var event = { type: _errors.ErrorTypes.MEDIA_ERROR, parent: segment.parent };\n            if (err.code !== 22) {\n              if (this.appendError) {\n                this.appendError++;\n              } else {\n                this.appendError = 1;\n              }\n              event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;\n              /* with UHD content, we could get loop of quota exceeded error until\n                browser is able to evict some data from sourcebuffer. retrying help recovering this\n              */\n              if (this.appendError > hls.config.appendErrorMaxRetry) {\n                _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');\n                segments = [];\n                event.fatal = true;\n                hls.trigger(_events2.default.ERROR, event);\n                return;\n              } else {\n                event.fatal = false;\n                hls.trigger(_events2.default.ERROR, event);\n              }\n            } else {\n              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n              // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n              this.segments = [];\n              event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;\n              event.fatal = false;\n              hls.trigger(_events2.default.ERROR, event);\n              return;\n            }\n          }\n        }\n      }\n    }\n\n    /*\n      flush specified buffered range,\n      return true once range has been flushed.\n      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end\n    */\n\n  }, {\n    key: 'flushBuffer',\n    value: function flushBuffer(startOffset, endOffset, typeIn) {\n      var sb,\n          i,\n          bufStart,\n          bufEnd,\n          flushStart,\n          flushEnd,\n          sourceBuffer = this.sourceBuffer;\n      if (Object.keys(sourceBuffer).length) {\n        _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime.toFixed(3) + '/' + startOffset + '/' + endOffset);\n        // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments\n        if (this.flushBufferCounter < this.appended) {\n          for (var type in sourceBuffer) {\n            // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one\n            // if no, let's flush all sourcebuffers\n            if (typeIn && type !== typeIn) {\n              continue;\n            }\n            sb = sourceBuffer[type];\n            // we are going to flush buffer, mark source buffer as 'not ended'\n            sb.ended = false;\n            if (!sb.updating) {\n              try {\n                for (i = 0; i < sb.buffered.length; i++) {\n                  bufStart = sb.buffered.start(i);\n                  bufEnd = sb.buffered.end(i);\n                  // workaround firefox not able to properly flush multiple buffered range.\n                  if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && endOffset === Number.POSITIVE_INFINITY) {\n                    flushStart = startOffset;\n                    flushEnd = endOffset;\n                  } else {\n                    flushStart = Math.max(bufStart, startOffset);\n                    flushEnd = Math.min(bufEnd, endOffset);\n                  }\n                  /* sometimes sourcebuffer.remove() does not flush\n                     the exact expected time range.\n                     to avoid rounding issues/infinite loop,\n                     only flush buffer range of length greater than 500ms.\n                  */\n                  if (Math.min(flushEnd, bufEnd) - flushStart > 0.5) {\n                    this.flushBufferCounter++;\n                    _logger.logger.log('flush ' + type + ' [' + flushStart + ',' + flushEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);\n                    sb.remove(flushStart, flushEnd);\n                    return false;\n                  }\n                }\n              } catch (e) {\n                _logger.logger.warn('exception while accessing sourcebuffer, it might have been removed from MediaSource');\n              }\n            } else {\n              //logger.log('abort ' + type + ' append in progress');\n              // this will abort any appending in progress\n              //sb.abort();\n              _logger.logger.warn('cannot flush, sb updating in progress');\n              return false;\n            }\n          }\n        } else {\n          _logger.logger.warn('abort flushing too many retries');\n        }\n        _logger.logger.log('buffer flushed');\n      }\n      // everything flushed !\n      return true;\n    }\n  }]);\n\n  return BufferController;\n}(_eventHandler2.default);\n\nexports.default = BufferController;\n\n},{\"31\":31,\"32\":32,\"33\":33,\"50\":50}],9:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar CapLevelController = function (_EventHandler) {\n  _inherits(CapLevelController, _EventHandler);\n\n  function CapLevelController(hls) {\n    _classCallCheck(this, CapLevelController);\n\n    return _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED));\n  }\n\n  _createClass(CapLevelController, [{\n    key: 'destroy',\n    value: function destroy() {\n      if (this.hls.config.capLevelToPlayerSize) {\n        this.media = this.restrictedLevels = null;\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        if (this.timer) {\n          this.timer = clearInterval(this.timer);\n        }\n      }\n    }\n  }, {\n    key: 'onFpsDropLevelCapping',\n    value: function onFpsDropLevelCapping(data) {\n      if (!this.restrictedLevels) {\n        this.restrictedLevels = [];\n      }\n      if (!this.isLevelRestricted(data.droppedLevel)) {\n        this.restrictedLevels.push(data.droppedLevel);\n      }\n    }\n  }, {\n    key: 'onMediaAttaching',\n    value: function onMediaAttaching(data) {\n      this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n    }\n  }, {\n    key: 'onManifestParsed',\n    value: function onManifestParsed(data) {\n      var hls = this.hls;\n      if (hls.config.capLevelToPlayerSize) {\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        this.levels = data.levels;\n        hls.firstLevel = this.getMaxLevel(data.firstLevel);\n        clearInterval(this.timer);\n        this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);\n        this.detectPlayerSize();\n      }\n    }\n  }, {\n    key: 'detectPlayerSize',\n    value: function detectPlayerSize() {\n      if (this.media) {\n        var levelsLength = this.levels ? this.levels.length : 0;\n        if (levelsLength) {\n          var hls = this.hls;\n          hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);\n          if (hls.autoLevelCapping > this.autoLevelCapping) {\n            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n            // usually happen when the user go to the fullscreen mode.\n            hls.streamController.nextLevelSwitch();\n          }\n          this.autoLevelCapping = hls.autoLevelCapping;\n        }\n      }\n    }\n\n    /*\n    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n    */\n\n  }, {\n    key: 'getMaxLevel',\n    value: function getMaxLevel(capLevelIndex) {\n      var result = 0,\n          i = void 0,\n          level = void 0,\n          mWidth = this.mediaWidth,\n          mHeight = this.mediaHeight,\n          lWidth = 0,\n          lHeight = 0;\n\n      for (i = 0; i <= capLevelIndex; i++) {\n        level = this.levels[i];\n        if (this.isLevelRestricted(i)) {\n          break;\n        }\n        result = i;\n        lWidth = level.width;\n        lHeight = level.height;\n        if (mWidth <= lWidth || mHeight <= lHeight) {\n          break;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: 'isLevelRestricted',\n    value: function isLevelRestricted(level) {\n      return this.restrictedLevels && this.restrictedLevels.indexOf(level) !== -1 ? true : false;\n    }\n  }, {\n    key: 'contentScaleFactor',\n    get: function get() {\n      var pixelRatio = 1;\n      try {\n        pixelRatio = window.devicePixelRatio;\n      } catch (e) {}\n      return pixelRatio;\n    }\n  }, {\n    key: 'mediaWidth',\n    get: function get() {\n      var width = void 0;\n      var media = this.media;\n      if (media) {\n        width = media.width || media.clientWidth || media.offsetWidth;\n        width *= this.contentScaleFactor;\n      }\n      return width;\n    }\n  }, {\n    key: 'mediaHeight',\n    get: function get() {\n      var height = void 0;\n      var media = this.media;\n      if (media) {\n        height = media.height || media.clientHeight || media.offsetHeight;\n        height *= this.contentScaleFactor;\n      }\n      return height;\n    }\n  }]);\n\n  return CapLevelController;\n}(_eventHandler2.default);\n\nexports.default = CapLevelController;\n\n},{\"32\":32,\"33\":33}],10:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _ewma = _dereq_(49);\n\nvar _ewma2 = _interopRequireDefault(_ewma);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EwmaBandWidthEstimator = function () {\n  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {\n    _classCallCheck(this, EwmaBandWidthEstimator);\n\n    this.hls = hls;\n    this.defaultEstimate_ = defaultEstimate;\n    this.minWeight_ = 0.001;\n    this.minDelayMs_ = 50;\n    this.slow_ = new _ewma2.default(slow);\n    this.fast_ = new _ewma2.default(fast);\n  }\n\n  _createClass(EwmaBandWidthEstimator, [{\n    key: 'sample',\n    value: function sample(durationMs, numBytes) {\n      durationMs = Math.max(durationMs, this.minDelayMs_);\n      var bandwidth = 8000 * numBytes / durationMs,\n\n      //console.log('instant bw:'+ Math.round(bandwidth));\n      // we weight sample using loading duration....\n      weight = durationMs / 1000;\n      this.fast_.sample(weight, bandwidth);\n      this.slow_.sample(weight, bandwidth);\n    }\n  }, {\n    key: 'canEstimate',\n    value: function canEstimate() {\n      var fast = this.fast_;\n      return fast && fast.getTotalWeight() >= this.minWeight_;\n    }\n  }, {\n    key: 'getEstimate',\n    value: function getEstimate() {\n      if (this.canEstimate()) {\n        //console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n        //console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n        // Take the minimum of these two estimates.  This should have the effect of\n        // adapting down quickly, but up more slowly.\n        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n      } else {\n        return this.defaultEstimate_;\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {}\n  }]);\n\n  return EwmaBandWidthEstimator;\n}();\n\nexports.default = EwmaBandWidthEstimator;\n\n},{\"49\":49}],11:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar FPSController = function (_EventHandler) {\n  _inherits(FPSController, _EventHandler);\n\n  function FPSController(hls) {\n    _classCallCheck(this, FPSController);\n\n    return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));\n  }\n\n  _createClass(FPSController, [{\n    key: 'destroy',\n    value: function destroy() {\n      if (this.timer) {\n        clearInterval(this.timer);\n      }\n      this.isVideoPlaybackQualityAvailable = false;\n    }\n  }, {\n    key: 'onMediaAttaching',\n    value: function onMediaAttaching(data) {\n      var config = this.hls.config;\n      if (config.capLevelOnFPSDrop) {\n        var video = this.video = data.media instanceof HTMLVideoElement ? data.media : null;\n        if (typeof video.getVideoPlaybackQuality === 'function') {\n          this.isVideoPlaybackQualityAvailable = true;\n        }\n        clearInterval(this.timer);\n        this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n      }\n    }\n  }, {\n    key: 'checkFPS',\n    value: function checkFPS(video, decodedFrames, droppedFrames) {\n      var currentTime = performance.now();\n      if (decodedFrames) {\n        if (this.lastTime) {\n          var currentPeriod = currentTime - this.lastTime,\n              currentDropped = droppedFrames - this.lastDroppedFrames,\n              currentDecoded = decodedFrames - this.lastDecodedFrames,\n              droppedFPS = 1000 * currentDropped / currentPeriod,\n              hls = this.hls;\n          hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });\n          if (droppedFPS > 0) {\n            //logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n            if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n              var currentLevel = hls.currentLevel;\n              _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n              if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n                currentLevel = currentLevel - 1;\n                hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls.currentLevel });\n                hls.autoLevelCapping = currentLevel;\n                hls.streamController.nextLevelSwitch();\n              }\n            }\n          }\n        }\n        this.lastTime = currentTime;\n        this.lastDroppedFrames = droppedFrames;\n        this.lastDecodedFrames = decodedFrames;\n      }\n    }\n  }, {\n    key: 'checkFPSInterval',\n    value: function checkFPSInterval() {\n      var video = this.video;\n      if (video) {\n        if (this.isVideoPlaybackQualityAvailable) {\n          var videoPlaybackQuality = video.getVideoPlaybackQuality();\n          this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n        } else {\n          this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n        }\n      }\n    }\n  }]);\n\n  return FPSController;\n}(_eventHandler2.default);\n\nexports.default = FPSController;\n\n},{\"32\":32,\"33\":33,\"50\":50}],12:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _logger = _dereq_(50);\n\nvar _errors = _dereq_(31);\n\nvar _bufferHelper = _dereq_(35);\n\nvar _bufferHelper2 = _interopRequireDefault(_bufferHelper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar LevelController = function (_EventHandler) {\n  _inherits(LevelController, _EventHandler);\n\n  function LevelController(hls) {\n    _classCallCheck(this, LevelController);\n\n    var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.FRAG_LOADED, _events2.default.ERROR));\n\n    _this.ontick = _this.tick.bind(_this);\n    _this._manualLevel = -1;\n    return _this;\n  }\n\n  _createClass(LevelController, [{\n    key: 'destroy',\n    value: function destroy() {\n      if (this.timer) {\n        clearTimeout(this.timer);\n        this.timer = null;\n      }\n      this._manualLevel = -1;\n    }\n  }, {\n    key: 'startLoad',\n    value: function startLoad() {\n      this.canload = true;\n      var levels = this._levels;\n      // clean up live level details to force reload them, and reset load errors\n      if (levels) {\n        levels.forEach(function (level) {\n          level.loadError = 0;\n          var levelDetails = level.details;\n          if (levelDetails && levelDetails.live) {\n            level.details = undefined;\n          }\n        });\n      }\n      // speed up live playlist refresh if timer exists\n      if (this.timer) {\n        this.tick();\n      }\n    }\n  }, {\n    key: 'stopLoad',\n    value: function stopLoad() {\n      this.canload = false;\n    }\n  }, {\n    key: 'onManifestLoaded',\n    value: function onManifestLoaded(data) {\n      var levels0 = [],\n          levels = [],\n          bitrateStart,\n          bitrateSet = {},\n          videoCodecFound = false,\n          audioCodecFound = false,\n          hls = this.hls,\n          brokenmp4inmp3 = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),\n          checkSupported = function checkSupported(type, codec) {\n        return MediaSource.isTypeSupported(type + '/mp4;codecs=' + codec);\n      };\n\n      // regroup redundant level together\n      data.levels.forEach(function (level) {\n        if (level.videoCodec) {\n          videoCodecFound = true;\n        }\n        // erase audio codec info if browser does not support mp4a.40.34. demuxer will autodetect codec and fallback to mpeg/audio\n        if (brokenmp4inmp3 && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {\n          level.audioCodec = undefined;\n        }\n        if (level.audioCodec || level.attrs && level.attrs.AUDIO) {\n          audioCodecFound = true;\n        }\n        var redundantLevelId = bitrateSet[level.bitrate];\n        if (redundantLevelId === undefined) {\n          bitrateSet[level.bitrate] = levels0.length;\n          level.url = [level.url];\n          level.urlId = 0;\n          levels0.push(level);\n        } else {\n          levels0[redundantLevelId].url.push(level.url);\n        }\n      });\n\n      // remove audio-only level if we also have levels with audio+video codecs signalled\n      if (videoCodecFound && audioCodecFound) {\n        levels0.forEach(function (level) {\n          if (level.videoCodec) {\n            levels.push(level);\n          }\n        });\n      } else {\n        levels = levels0;\n      }\n      // only keep level with supported audio/video codecs\n      levels = levels.filter(function (level) {\n        var audioCodec = level.audioCodec,\n            videoCodec = level.videoCodec;\n        return (!audioCodec || checkSupported('audio', audioCodec)) && (!videoCodec || checkSupported('video', videoCodec));\n      });\n\n      if (levels.length) {\n        // start bitrate is the first bitrate of the manifest\n        bitrateStart = levels[0].bitrate;\n        // sort level on bitrate\n        levels.sort(function (a, b) {\n          return a.bitrate - b.bitrate;\n        });\n        this._levels = levels;\n        // find index of first level in sorted levels\n        for (var i = 0; i < levels.length; i++) {\n          if (levels[i].bitrate === bitrateStart) {\n            this._firstLevel = i;\n            _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);\n            break;\n          }\n        }\n        hls.trigger(_events2.default.MANIFEST_PARSED, { levels: levels, firstLevel: this._firstLevel, stats: data.stats, audio: audioCodecFound, video: videoCodecFound, altAudio: data.audioTracks.length > 0 });\n      } else {\n        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: true, url: hls.url, reason: 'no level with compatible codecs found in manifest' });\n      }\n      return;\n    }\n  }, {\n    key: 'setLevelInternal',\n    value: function setLevelInternal(newLevel) {\n      var levels = this._levels;\n      var hls = this.hls;\n      // check if level idx is valid\n      if (newLevel >= 0 && newLevel < levels.length) {\n        // stopping live reloading timer if any\n        if (this.timer) {\n          clearTimeout(this.timer);\n          this.timer = null;\n        }\n        if (this._level !== newLevel) {\n          _logger.logger.log('switching to level ' + newLevel);\n          this._level = newLevel;\n          var levelProperties = levels[newLevel];\n          levelProperties.level = newLevel;\n          // LEVEL_SWITCH to be deprecated in next major release\n          hls.trigger(_events2.default.LEVEL_SWITCH, levelProperties);\n          hls.trigger(_events2.default.LEVEL_SWITCHING, levelProperties);\n        }\n        var level = levels[newLevel],\n            levelDetails = level.details;\n        // check if we need to load playlist for this level\n        if (!levelDetails || levelDetails.live === true) {\n          // level not retrieved yet, or live playlist we need to (re)load it\n          var urlId = level.urlId;\n          hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });\n        }\n      } else {\n        // invalid level id given, trigger error\n        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR, level: newLevel, fatal: false, reason: 'invalid level idx' });\n      }\n    }\n  }, {\n    key: 'onError',\n    value: function onError(data) {\n      if (data.fatal) {\n        return;\n      }\n\n      var details = data.details,\n          hls = this.hls,\n          levelId = void 0,\n          level = void 0,\n          levelError = false;\n      // try to recover not fatal errors\n      switch (details) {\n        case _errors.ErrorDetails.FRAG_LOAD_ERROR:\n        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:\n        case _errors.ErrorDetails.KEY_LOAD_ERROR:\n        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:\n          levelId = data.frag.level;\n          break;\n        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:\n        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n          levelId = data.context.level;\n          levelError = true;\n          break;\n        case _errors.ErrorDetails.REMUX_ALLOC_ERROR:\n          levelId = data.level;\n          break;\n        default:\n          break;\n      }\n      /* try to switch to a redundant stream if any available.\n       * if no redundant stream available, emergency switch down (if in auto mode and current level not 0)\n       * otherwise, we cannot recover this network error ...\n       */\n      if (levelId !== undefined) {\n        level = this._levels[levelId];\n        if (!level.loadError) {\n          level.loadError = 1;\n        } else {\n          level.loadError++;\n        }\n        // if any redundant streams available and if we haven't try them all (level.loadError is reseted on successful frag/level load.\n        // if level.loadError reaches nbRedundantLevel it means that we tried them all, no hope  => let's switch down\n        var nbRedundantLevel = level.url.length;\n        if (nbRedundantLevel > 1 && level.loadError < nbRedundantLevel) {\n          level.urlId = (level.urlId + 1) % nbRedundantLevel;\n          level.details = undefined;\n          _logger.logger.warn('level controller,' + details + ' for level ' + levelId + ': switching to redundant stream id ' + level.urlId);\n        } else {\n          // we could try to recover if in auto mode and current level not lowest level (0)\n          var recoverable = this._manualLevel === -1 && levelId;\n          if (recoverable) {\n            _logger.logger.warn('level controller,' + details + ': switch-down for next fragment');\n            hls.nextAutoLevel = Math.max(0, levelId - 1);\n          } else if (level && level.details && level.details.live) {\n            _logger.logger.warn('level controller,' + details + ' on live stream, discard');\n            if (levelError) {\n              // reset this._level so that another call to set level() will retrigger a frag load\n              this._level = undefined;\n            }\n            // other errors are handled by stream controller\n          } else if (details === _errors.ErrorDetails.LEVEL_LOAD_ERROR || details === _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT) {\n            var media = hls.media,\n\n            // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n            mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);\n            if (mediaBuffered) {\n              var retryDelay = hls.config.levelLoadingRetryDelay;\n              _logger.logger.warn('level controller,' + details + ', but media buffered, retry in ' + retryDelay + 'ms');\n              this.timer = setTimeout(this.ontick, retryDelay);\n            } else {\n              _logger.logger.error('cannot recover ' + details + ' error');\n              this._level = undefined;\n              // stopping live reloading timer if any\n              if (this.timer) {\n                clearTimeout(this.timer);\n                this.timer = null;\n              }\n              // redispatch same error but with fatal set to true\n              data.fatal = true;\n              hls.trigger(_events2.default.ERROR, data);\n            }\n          }\n        }\n      }\n    }\n\n    // reset level load error counter on successful frag loaded\n\n  }, {\n    key: 'onFragLoaded',\n    value: function onFragLoaded(data) {\n      var fragLoaded = data.frag;\n      if (fragLoaded && fragLoaded.type === 'main') {\n        var level = this._levels[fragLoaded.level];\n        if (level) {\n          level.loadError = 0;\n        }\n      }\n    }\n  }, {\n    key: 'onLevelLoaded',\n    value: function onLevelLoaded(data) {\n      var levelId = data.level;\n      // only process level loaded events matching with expected level\n      if (levelId === this._level) {\n        var curLevel = this._levels[levelId];\n        // reset level load error counter on successful level loaded\n        curLevel.loadError = 0;\n        var newDetails = data.details;\n        // if current playlist is a live playlist, arm a timer to reload it\n        if (newDetails.live) {\n          var reloadInterval = 1000 * (newDetails.averagetargetduration ? newDetails.averagetargetduration : newDetails.targetduration),\n              curDetails = curLevel.details;\n          if (curDetails && newDetails.endSN === curDetails.endSN) {\n            // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n            // changed then it MUST wait for a period of one-half the target\n            // duration before retrying.\n            reloadInterval /= 2;\n            _logger.logger.log('same live playlist, reload twice faster');\n          }\n          // decrement reloadInterval with level loading delay\n          reloadInterval -= performance.now() - data.stats.trequest;\n          // in any case, don't reload more than every second\n          reloadInterval = Math.max(1000, Math.round(reloadInterval));\n          _logger.logger.log('live playlist, reload in ' + reloadInterval + ' ms');\n          this.timer = setTimeout(this.ontick, reloadInterval);\n        } else {\n          this.timer = null;\n        }\n      }\n    }\n  }, {\n    key: 'tick',\n    value: function tick() {\n      var levelId = this._level;\n      if (levelId !== undefined && this.canload) {\n        var level = this._levels[levelId],\n            urlId = level.urlId;\n        this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: levelId, id: urlId });\n      }\n    }\n  }, {\n    key: 'levels',\n    get: function get() {\n      return this._levels;\n    }\n  }, {\n    key: 'level',\n    get: function get() {\n      return this._level;\n    },\n    set: function set(newLevel) {\n      var levels = this._levels;\n      if (levels && levels.length > newLevel) {\n        if (this._level !== newLevel || levels[newLevel].details === undefined) {\n          this.setLevelInternal(newLevel);\n        }\n      }\n    }\n  }, {\n    key: 'manualLevel',\n    get: function get() {\n      return this._manualLevel;\n    },\n    set: function set(newLevel) {\n      this._manualLevel = newLevel;\n      if (this._startLevel === undefined) {\n        this._startLevel = newLevel;\n      }\n      if (newLevel !== -1) {\n        this.level = newLevel;\n      }\n    }\n  }, {\n    key: 'firstLevel',\n    get: function get() {\n      return this._firstLevel;\n    },\n    set: function set(newLevel) {\n      this._firstLevel = newLevel;\n    }\n  }, {\n    key: 'startLevel',\n    get: function get() {\n      // hls.startLevel takes precedence over config.startLevel\n      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)\n      if (this._startLevel === undefined) {\n        var configStartLevel = this.hls.config.startLevel;\n        if (configStartLevel !== undefined) {\n          return configStartLevel;\n        } else {\n          return this._firstLevel;\n        }\n      } else {\n        return this._startLevel;\n      }\n    },\n    set: function set(newLevel) {\n      this._startLevel = newLevel;\n    }\n  }, {\n    key: 'nextLoadLevel',\n    get: function get() {\n      if (this._manualLevel !== -1) {\n        return this._manualLevel;\n      } else {\n        return this.hls.nextAutoLevel;\n      }\n    },\n    set: function set(nextLevel) {\n      this.level = nextLevel;\n      if (this._manualLevel === -1) {\n        this.hls.nextAutoLevel = nextLevel;\n      }\n    }\n  }]);\n\n  return LevelController;\n}(_eventHandler2.default);\n\nexports.default = LevelController;\n\n},{\"31\":31,\"32\":32,\"33\":33,\"35\":35,\"50\":50}],13:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _binarySearch = _dereq_(46);\n\nvar _binarySearch2 = _interopRequireDefault(_binarySearch);\n\nvar _bufferHelper = _dereq_(35);\n\nvar _bufferHelper2 = _interopRequireDefault(_bufferHelper);\n\nvar _demuxer = _dereq_(25);\n\nvar _demuxer2 = _interopRequireDefault(_demuxer);\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _levelHelper = _dereq_(36);\n\nvar _levelHelper2 = _interopRequireDefault(_levelHelper);\n\nvar _timeRanges = _dereq_(51);\n\nvar _timeRanges2 = _interopRequireDefault(_timeRanges);\n\nvar _errors = _dereq_(31);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar State = {\n  STOPPED: 'STOPPED',\n  IDLE: 'IDLE',\n  KEY_LOADING: 'KEY_LOADING',\n  FRAG_LOADING: 'FRAG_LOADING',\n  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n  WAITING_LEVEL: 'WAITING_LEVEL',\n  PARSING: 'PARSING',\n  PARSED: 'PARSED',\n  BUFFER_FLUSHING: 'BUFFER_FLUSHING',\n  ENDED: 'ENDED',\n  ERROR: 'ERROR'\n};\n\nvar StreamController = function (_EventHandler) {\n  _inherits(StreamController, _EventHandler);\n\n  function StreamController(hls) {\n    _classCallCheck(this, StreamController);\n\n    var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));\n\n    _this.config = hls.config;\n    _this.audioCodecSwap = false;\n    _this.ticks = 0;\n    _this._state = State.STOPPED;\n    _this.ontick = _this.tick.bind(_this);\n    return _this;\n  }\n\n  _createClass(StreamController, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.stopLoad();\n      if (this.timer) {\n        clearInterval(this.timer);\n        this.timer = null;\n      }\n      _eventHandler2.default.prototype.destroy.call(this);\n      this.state = State.STOPPED;\n    }\n  }, {\n    key: 'startLoad',\n    value: function startLoad(startPosition) {\n      if (this.levels) {\n        var lastCurrentTime = this.lastCurrentTime,\n            hls = this.hls;\n        this.stopLoad();\n        if (!this.timer) {\n          this.timer = setInterval(this.ontick, 100);\n        }\n        this.level = -1;\n        this.fragLoadError = 0;\n        if (!this.startFragRequested) {\n          // determine load level\n          var startLevel = hls.startLevel;\n          if (startLevel === -1) {\n            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n            startLevel = 0;\n            this.bitrateTest = true;\n          }\n          // set new level to playlist loader : this will trigger start level load\n          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n          this.level = hls.nextLoadLevel = startLevel;\n          this.loadedmetadata = false;\n        }\n        // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n        if (lastCurrentTime > 0 && startPosition === -1) {\n          _logger.logger.log('override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));\n          startPosition = lastCurrentTime;\n        }\n        this.state = State.IDLE;\n        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n        this.tick();\n      } else {\n        _logger.logger.warn('cannot start loading as manifest not parsed yet');\n        this.state = State.STOPPED;\n      }\n    }\n  }, {\n    key: 'stopLoad',\n    value: function stopLoad() {\n      var frag = this.fragCurrent;\n      if (frag) {\n        if (frag.loader) {\n          frag.loader.abort();\n        }\n        this.fragCurrent = null;\n      }\n      this.fragPrevious = null;\n      if (this.demuxer) {\n        this.demuxer.destroy();\n        this.demuxer = null;\n      }\n      this.state = State.STOPPED;\n    }\n  }, {\n    key: 'tick',\n    value: function tick() {\n      this.ticks++;\n      if (this.ticks === 1) {\n        this.doTick();\n        if (this.ticks > 1) {\n          setTimeout(this.tick, 1);\n        }\n        this.ticks = 0;\n      }\n    }\n  }, {\n    key: 'doTick',\n    value: function doTick() {\n      switch (this.state) {\n        case State.ERROR:\n          //don't do anything in error state to avoid breaking further ...\n          break;\n        case State.BUFFER_FLUSHING:\n          // in buffer flushing state, reset fragLoadError counter\n          this.fragLoadError = 0;\n          break;\n        case State.IDLE:\n          // when this returns false there was an error and we shall return immediatly\n          // from current tick\n          if (!this._doTickIdle()) {\n            return;\n          }\n          break;\n        case State.WAITING_LEVEL:\n          var level = this.levels[this.level];\n          // check if playlist is already loaded\n          if (level && level.details) {\n            this.state = State.IDLE;\n          }\n          break;\n        case State.FRAG_LOADING_WAITING_RETRY:\n          var now = performance.now();\n          var retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || this.media && this.media.seeking) {\n            _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');\n            this.state = State.IDLE;\n          }\n          break;\n        case State.ERROR:\n        case State.STOPPED:\n        case State.FRAG_LOADING:\n        case State.PARSING:\n        case State.PARSED:\n        case State.ENDED:\n          break;\n        default:\n          break;\n      }\n      // check buffer\n      this._checkBuffer();\n      // check/update current fragment\n      this._checkFragmentChanged();\n    }\n\n    // Ironically the \"idle\" state is the on we do the most logic in it seems ....\n    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently\n    //       played segment, or on pause/play/seek instead of naively checking every 100ms?\n\n  }, {\n    key: '_doTickIdle',\n    value: function _doTickIdle() {\n      var hls = this.hls,\n          config = hls.config,\n          media = this.media;\n\n      // if video not attached AND\n      // start fragment already requested OR start frag prefetch disable\n      // exit loop\n      // => if start level loaded and media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n      if (this.levelLastLoaded !== undefined && !media && (this.startFragRequested || !config.startFragPrefetch)) {\n        return true;\n      }\n\n      // if we have not yet loaded any fragment, start loading from start position\n      var pos = void 0;\n      if (this.loadedmetadata) {\n        pos = media.currentTime;\n      } else {\n        pos = this.nextLoadPosition;\n      }\n      // determine next load level\n      var level = hls.nextLoadLevel,\n          levelInfo = this.levels[level],\n          levelBitrate = levelInfo.bitrate,\n          maxBufLen = void 0;\n\n      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n      if (levelBitrate) {\n        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n      } else {\n        maxBufLen = config.maxBufferLength;\n      }\n      maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);\n\n      // determine next candidate fragment to be loaded, based on current position and end of buffer position\n      // ensure up to `config.maxMaxBufferLength` of buffer upfront\n\n      var bufferInfo = _bufferHelper2.default.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),\n          bufferLen = bufferInfo.len;\n      // Stay idle if we are still with buffer margins\n      if (bufferLen >= maxBufLen) {\n        return true;\n      }\n\n      // if buffer length is less than maxBufLen try to load a new fragment ...\n      _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');\n\n      // set next load level : this will trigger a playlist load if needed\n      this.level = hls.nextLoadLevel = level;\n\n      var levelDetails = levelInfo.details;\n      // if level info not retrieved yet, switch state and wait for level retrieval\n      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n      if (typeof levelDetails === 'undefined' || levelDetails.live && this.levelLastLoaded !== level) {\n        this.state = State.WAITING_LEVEL;\n        return true;\n      }\n\n      // we just got done loading the final fragment, check if we need to finalize media stream\n      var fragPrevious = this.fragPrevious;\n      if (!levelDetails.live && fragPrevious && fragPrevious.sn === levelDetails.endSN) {\n        // if everything (almost) til the end is buffered, let's signal eos\n        // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference\n        // using half frag duration should help cope with these cases.\n        // also cope with almost zero last frag duration (max last frag duration with 200ms) refer to https://github.com/dailymotion/hls.js/pull/657\n        if (media.duration - Math.max(bufferInfo.end, fragPrevious.start) <= Math.max(0.2, fragPrevious.duration / 2)) {\n          // Finalize the media stream\n          var data = {};\n          if (this.altAudio) {\n            data.type = 'video';\n          }\n          this.hls.trigger(_events2.default.BUFFER_EOS, data);\n          this.state = State.ENDED;\n          return true;\n        }\n      }\n\n      // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)\n      return this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);\n    }\n  }, {\n    key: '_fetchPayloadOrEos',\n    value: function _fetchPayloadOrEos(pos, bufferInfo, levelDetails) {\n      var fragPrevious = this.fragPrevious,\n          level = this.level,\n          fragments = levelDetails.fragments,\n          fragLen = fragments.length;\n\n      // empty playlist\n      if (fragLen === 0) {\n        return false;\n      }\n\n      // find fragment index, contiguous with end of buffer position\n      var start = fragments[0].start,\n          end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,\n          bufferEnd = bufferInfo.end,\n          frag = void 0;\n\n      if (levelDetails.initSegment && !levelDetails.initSegment.data) {\n        frag = levelDetails.initSegment;\n      } else {\n        // in case of live playlist we need to ensure that requested position is not located before playlist start\n        if (levelDetails.live) {\n          var initialLiveManifestSize = this.config.initialLiveManifestSize;\n          if (fragLen < initialLiveManifestSize) {\n            _logger.logger.warn('Can not start playback of a level, reason: not enough fragments ' + fragLen + ' < ' + initialLiveManifestSize);\n            return false;\n          }\n\n          frag = this._ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen);\n          // if it explicitely returns null don't load any fragment and exit function now\n          if (frag === null) {\n            return false;\n          }\n        } else {\n          // VoD playlist: if bufferEnd before start of playlist, load first fragment\n          if (bufferEnd < start) {\n            frag = fragments[0];\n          }\n        }\n      }\n      if (!frag) {\n        frag = this._findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails);\n      }\n      if (frag) {\n        return this._loadFragmentOrKey(frag, level, levelDetails, pos, bufferEnd);\n      }\n      return true;\n    }\n  }, {\n    key: '_ensureFragmentAtLivePoint',\n    value: function _ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen) {\n      var config = this.hls.config,\n          media = this.media;\n\n      var frag = void 0;\n\n      // check if requested position is within seekable boundaries :\n      //logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);\n      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n\n      if (bufferEnd < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {\n        var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);\n        _logger.logger.log('buffer end: ' + bufferEnd.toFixed(3) + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));\n        bufferEnd = liveSyncPosition;\n        if (media && media.readyState && media.duration > liveSyncPosition) {\n          media.currentTime = liveSyncPosition;\n        }\n      }\n\n      // if end of buffer greater than live edge, don't load any fragment\n      // this could happen if live playlist intermittently slides in the past.\n      // level 1 loaded [182580161,182580167]\n      // level 1 loaded [182580162,182580169]\n      // Loading 182580168 of [182580162 ,182580169],level 1 ..\n      // Loading 182580169 of [182580162 ,182580169],level 1 ..\n      // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168\n      // level 1 loaded [182580164,182580171]\n      //\n      // don't return null in case media not loaded yet (readystate === 0)\n      if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {\n        return null;\n      }\n\n      if (this.startFragRequested && !levelDetails.PTSKnown) {\n        /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...\n           try to load frag matching with next SN.\n           even if SN are not synchronized between playlists, loading this frag will help us\n           compute playlist sliding and find the right one after in case it was not the right consecutive one */\n        if (fragPrevious) {\n          var targetSN = fragPrevious.sn + 1;\n          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n            frag = fragments[targetSN - levelDetails.startSN];\n            _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);\n          }\n        }\n        if (!frag) {\n          /* we have no idea about which fragment should be loaded.\n             so let's load mid fragment. it will help computing playlist sliding and find the right one\n          */\n          frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];\n          _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);\n        }\n      }\n      return frag;\n    }\n  }, {\n    key: '_findFragment',\n    value: function _findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails) {\n      var config = this.hls.config;\n      var frag = void 0;\n      var foundFrag = void 0;\n      var maxFragLookUpTolerance = config.maxFragLookUpTolerance;\n      var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;\n      var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {\n        // offset should be within fragment boundary - config.maxFragLookUpTolerance\n        // this is to cope with situations like\n        // bufferEnd = 9.991\n        // frag[Ø] : [0,10]\n        // frag[1] : [10,20]\n        // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n        //              frag start               frag start+duration\n        //                  |-----------------------------|\n        //              <--->                         <--->\n        //  ...--------><-----------------------------><---------....\n        // previous frag         matching fragment         next frag\n        //  return -1             return 0                 return 1\n        //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n        // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n        var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);\n        if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n          return 1;\n        } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n        else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n            return -1;\n          }\n        return 0;\n      };\n\n      if (bufferEnd < end) {\n        if (bufferEnd > end - maxFragLookUpTolerance) {\n          maxFragLookUpTolerance = 0;\n        }\n        // Prefer the next fragment if it's within tolerance\n        if (fragNext && !fragmentWithinToleranceTest(fragNext)) {\n          foundFrag = fragNext;\n        } else {\n          foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);\n        }\n      } else {\n        // reach end of playlist\n        foundFrag = fragments[fragLen - 1];\n      }\n      if (foundFrag) {\n        frag = foundFrag;\n        var curSNIdx = frag.sn - levelDetails.startSN;\n        var sameLevel = fragPrevious && frag.level === fragPrevious.level;\n        var prevFrag = fragments[curSNIdx - 1];\n        var nextFrag = fragments[curSNIdx + 1];\n        //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);\n        if (sameLevel && frag.sn === fragPrevious.sn) {\n          if (frag.sn < levelDetails.endSN) {\n            var deltaPTS = fragPrevious.deltaPTS;\n            // if there is a significant delta between audio and video, larger than max allowed hole,\n            // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)\n            // let's try to load previous fragment again to get last keyframe\n            // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)\n            if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {\n              frag = prevFrag;\n              _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');\n              // decrement previous frag load counter to avoid frag loop loading error when next fragment will get reloaded\n              fragPrevious.loadCounter--;\n            } else {\n              frag = nextFrag;\n              _logger.logger.log('SN just loaded, load next one: ' + frag.sn);\n            }\n          } else {\n            frag = null;\n          }\n        } else if (frag.dropped && !sameLevel) {\n          // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes\n          if (nextFrag && nextFrag.backtracked) {\n            _logger.logger.warn('Already backtracked from fragment ' + (curSNIdx + 1) + ', will not backtrack to fragment ' + curSNIdx + '. Loading fragment ' + (curSNIdx + 1));\n            frag = nextFrag;\n          } else {\n            // If a fragment has dropped frames and it's in a different level/sequence, load the previous fragment to try and find the keyframe\n            // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment\n            _logger.logger.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');\n            frag.dropped = 0;\n            if (prevFrag && prevFrag.loadCounter) {\n              prevFrag.loadCounter--;\n              frag = prevFrag;\n            } else {\n              frag = null;\n            }\n          }\n        }\n      }\n      return frag;\n    }\n  }, {\n    key: '_loadFragmentOrKey',\n    value: function _loadFragmentOrKey(frag, level, levelDetails, pos, bufferEnd) {\n      var hls = this.hls,\n          config = hls.config;\n\n      //logger.log('loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));\n      if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {\n        _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);\n        this.state = State.KEY_LOADING;\n        hls.trigger(_events2.default.KEY_LOADING, { frag: frag });\n      } else {\n        _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos.toFixed(3) + ',bufferEnd:' + bufferEnd.toFixed(3));\n        // ensure that we are not reloading the same fragments in loop ...\n        if (this.fragLoadIdx !== undefined) {\n          this.fragLoadIdx++;\n        } else {\n          this.fragLoadIdx = 0;\n        }\n        if (frag.loadCounter) {\n          frag.loadCounter++;\n          var maxThreshold = config.fragLoadingLoopThreshold;\n          // if this frag has already been loaded 3 times, and if it has been reloaded recently\n          if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {\n            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });\n            return false;\n          }\n        } else {\n          frag.loadCounter = 1;\n        }\n        frag.loadIdx = this.fragLoadIdx;\n        this.fragCurrent = frag;\n        this.startFragRequested = true;\n        if (!isNaN(frag.sn)) {\n          this.nextLoadPosition = frag.start + frag.duration;\n        }\n        frag.autoLevel = hls.autoLevelEnabled;\n        frag.bitrateTest = this.bitrateTest;\n        hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });\n        // lazy demuxer init, as this could take some time ... do it during frag loading\n        if (!this.demuxer) {\n          this.demuxer = new _demuxer2.default(hls, 'main');\n        }\n        this.state = State.FRAG_LOADING;\n        return true;\n      }\n    }\n  }, {\n    key: 'getBufferRange',\n    value: function getBufferRange(position) {\n      return _binarySearch2.default.search(this.bufferRange, function (range) {\n        if (position < range.start) {\n          return -1;\n        } else if (position > range.end) {\n          return 1;\n        }\n        return 0;\n      });\n    }\n  }, {\n    key: 'followingBufferRange',\n    value: function followingBufferRange(range) {\n      if (range) {\n        // try to get range of next fragment (500ms after this range)\n        return this.getBufferRange(range.end + 0.5);\n      }\n      return null;\n    }\n  }, {\n    key: '_checkFragmentChanged',\n    value: function _checkFragmentChanged() {\n      var rangeCurrent,\n          currentTime,\n          video = this.media;\n      if (video && video.readyState && video.seeking === false) {\n        currentTime = video.currentTime;\n        /* if video element is in seeked state, currentTime can only increase.\n          (assuming that playback rate is positive ...)\n          As sometimes currentTime jumps back to zero after a\n          media decode error, check this, to avoid seeking back to\n          wrong position after a media decode error\n        */\n        if (currentTime > video.playbackRate * this.lastCurrentTime) {\n          this.lastCurrentTime = currentTime;\n        }\n        if (_bufferHelper2.default.isBuffered(video, currentTime)) {\n          rangeCurrent = this.getBufferRange(currentTime);\n        } else if (_bufferHelper2.default.isBuffered(video, currentTime + 0.1)) {\n          /* ensure that FRAG_CHANGED event is triggered at startup,\n            when first video frame is displayed and playback is paused.\n            add a tolerance of 100ms, in case current position is not buffered,\n            check if current pos+100ms is buffered and use that buffer range\n            for FRAG_CHANGED event reporting */\n          rangeCurrent = this.getBufferRange(currentTime + 0.1);\n        }\n        if (rangeCurrent) {\n          var fragPlaying = rangeCurrent.frag;\n          if (fragPlaying !== this.fragPlaying) {\n            this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });\n            var fragPlayingLevel = fragPlaying.level;\n            if (!this.fragPlaying || this.fragPlaying.level !== fragPlayingLevel) {\n              this.hls.trigger(_events2.default.LEVEL_SWITCHED, { level: fragPlayingLevel });\n            }\n            this.fragPlaying = fragPlaying;\n          }\n        }\n      }\n    }\n\n    /*\n      on immediate level switch :\n       - pause playback if playing\n       - cancel any pending load request\n       - and trigger a buffer flush\n    */\n\n  }, {\n    key: 'immediateLevelSwitch',\n    value: function immediateLevelSwitch() {\n      _logger.logger.log('immediateLevelSwitch');\n      if (!this.immediateSwitch) {\n        this.immediateSwitch = true;\n        var media = this.media,\n            previouslyPaused = void 0;\n        if (media) {\n          previouslyPaused = media.paused;\n          media.pause();\n        } else {\n          // don't restart playback after instant level switch in case media not attached\n          previouslyPaused = true;\n        }\n        this.previouslyPaused = previouslyPaused;\n      }\n      var fragCurrent = this.fragCurrent;\n      if (fragCurrent && fragCurrent.loader) {\n        fragCurrent.loader.abort();\n      }\n      this.fragCurrent = null;\n      // increase fragment load Index to avoid frag loop loading error after buffer flush\n      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;\n      // flush everything\n      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n    }\n\n    /*\n       on immediate level switch end, after new fragment has been buffered :\n        - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)\n        - resume the playback if needed\n    */\n\n  }, {\n    key: 'immediateLevelSwitchEnd',\n    value: function immediateLevelSwitchEnd() {\n      var media = this.media;\n      if (media && media.buffered.length) {\n        this.immediateSwitch = false;\n        if (_bufferHelper2.default.isBuffered(media, media.currentTime)) {\n          // only nudge if currentTime is buffered\n          media.currentTime -= 0.0001;\n        }\n        if (!this.previouslyPaused) {\n          media.play();\n        }\n      }\n    }\n  }, {\n    key: 'nextLevelSwitch',\n    value: function nextLevelSwitch() {\n      /* try to switch ASAP without breaking video playback :\n         in order to ensure smooth but quick level switching,\n        we need to find the next flushable buffer range\n        we should take into account new segment fetch time\n      */\n      var media = this.media;\n      // ensure that media is defined and that metadata are available (to retrieve currentTime)\n      if (media && media.readyState) {\n        var fetchdelay = void 0,\n            currentRange = void 0,\n            nextRange = void 0;\n        // increase fragment load Index to avoid frag loop loading error after buffer flush\n        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;\n        currentRange = this.getBufferRange(media.currentTime);\n        if (currentRange && currentRange.start > 1) {\n          // flush buffer preceding current fragment (flush until current fragment start offset)\n          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n          this.flushMainBuffer(0, currentRange.start - 1);\n        }\n        if (!media.paused) {\n          // add a safety delay of 1s\n          var nextLevelId = this.hls.nextLoadLevel,\n              nextLevel = this.levels[nextLevelId],\n              fragLastKbps = this.fragLastKbps;\n          if (fragLastKbps && this.fragCurrent) {\n            fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;\n          } else {\n            fetchdelay = 0;\n          }\n        } else {\n          fetchdelay = 0;\n        }\n        //logger.log('fetchdelay:'+fetchdelay);\n        // find buffer range that will be reached once new fragment will be fetched\n        nextRange = this.getBufferRange(media.currentTime + fetchdelay);\n        if (nextRange) {\n          // we can flush buffer range following this one without stalling playback\n          nextRange = this.followingBufferRange(nextRange);\n          if (nextRange) {\n            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n            var fragCurrent = this.fragCurrent;\n            if (fragCurrent && fragCurrent.loader) {\n              fragCurrent.loader.abort();\n            }\n            this.fragCurrent = null;\n            // flush position is the start position of this new buffer\n            this.flushMainBuffer(nextRange.start, Number.POSITIVE_INFINITY);\n          }\n        }\n      }\n    }\n  }, {\n    key: 'flushMainBuffer',\n    value: function flushMainBuffer(startOffset, endOffset) {\n      this.state = State.BUFFER_FLUSHING;\n      var flushScope = { startOffset: startOffset, endOffset: endOffset };\n      // if alternate audio tracks are used, only flush video, otherwise flush everything\n      if (this.altAudio) {\n        flushScope.type = 'video';\n      }\n      this.hls.trigger(_events2.default.BUFFER_FLUSHING, flushScope);\n    }\n  }, {\n    key: 'onMediaAttached',\n    value: function onMediaAttached(data) {\n      var media = this.media = this.mediaBuffer = data.media;\n      this.onvseeking = this.onMediaSeeking.bind(this);\n      this.onvseeked = this.onMediaSeeked.bind(this);\n      this.onvended = this.onMediaEnded.bind(this);\n      media.addEventListener('seeking', this.onvseeking);\n      media.addEventListener('seeked', this.onvseeked);\n      media.addEventListener('ended', this.onvended);\n      var config = this.config;\n      if (this.levels && config.autoStartLoad) {\n        this.hls.startLoad(config.startPosition);\n      }\n    }\n  }, {\n    key: 'onMediaDetaching',\n    value: function onMediaDetaching() {\n      var media = this.media;\n      if (media && media.ended) {\n        _logger.logger.log('MSE detaching and video ended, reset startPosition');\n        this.startPosition = this.lastCurrentTime = 0;\n      }\n\n      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery\n      var levels = this.levels;\n      if (levels) {\n        // reset fragment load counter\n        levels.forEach(function (level) {\n          if (level.details) {\n            level.details.fragments.forEach(function (fragment) {\n              fragment.loadCounter = undefined;\n              fragment.backtracked = undefined;\n            });\n          }\n        });\n      }\n      // remove video listeners\n      if (media) {\n        media.removeEventListener('seeking', this.onvseeking);\n        media.removeEventListener('seeked', this.onvseeked);\n        media.removeEventListener('ended', this.onvended);\n        this.onvseeking = this.onvseeked = this.onvended = null;\n      }\n      this.media = this.mediaBuffer = null;\n      this.loadedmetadata = false;\n      this.stopLoad();\n    }\n  }, {\n    key: 'onMediaSeeking',\n    value: function onMediaSeeking() {\n      var media = this.media,\n          currentTime = media ? media.currentTime : undefined,\n          config = this.config;\n      _logger.logger.log('media seeking to ' + currentTime.toFixed(3));\n      if (this.state === State.FRAG_LOADING) {\n        var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;\n        var bufferInfo = _bufferHelper2.default.bufferInfo(mediaBuffer, currentTime, this.config.maxBufferHole),\n            fragCurrent = this.fragCurrent;\n        // check if we are seeking to a unbuffered area AND if frag loading is in progress\n        if (bufferInfo.len === 0 && fragCurrent) {\n          var tolerance = config.maxFragLookUpTolerance,\n              fragStartOffset = fragCurrent.start - tolerance,\n              fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n          // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything\n          if (currentTime < fragStartOffset || currentTime > fragEndOffset) {\n            if (fragCurrent.loader) {\n              _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');\n              fragCurrent.loader.abort();\n            }\n            this.fragCurrent = null;\n            this.fragPrevious = null;\n            // switch to IDLE state to load new fragment\n            this.state = State.IDLE;\n          } else {\n            _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');\n          }\n        }\n      } else if (this.state === State.ENDED) {\n        // switch to IDLE state to check for potential new fragment\n        this.state = State.IDLE;\n      }\n      if (media) {\n        this.lastCurrentTime = currentTime;\n      }\n      // avoid reporting fragment loop loading error in case user is seeking several times on same position\n      if (this.state !== State.FRAG_LOADING && this.fragLoadIdx !== undefined) {\n        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;\n      }\n      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n      if (!this.loadedmetadata) {\n        this.nextLoadPosition = this.startPosition = currentTime;\n      }\n      // tick to speed up processing\n      this.tick();\n    }\n  }, {\n    key: 'onMediaSeeked',\n    value: function onMediaSeeked() {\n      _logger.logger.log('media seeked to ' + this.media.currentTime.toFixed(3));\n      // tick to speed up FRAGMENT_PLAYING triggering\n      this.tick();\n    }\n  }, {\n    key: 'onMediaEnded',\n    value: function onMediaEnded() {\n      _logger.logger.log('media ended');\n      // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n      this.startPosition = this.lastCurrentTime = 0;\n    }\n  }, {\n    key: 'onManifestLoading',\n    value: function onManifestLoading() {\n      // reset buffer on manifest loading\n      _logger.logger.log('trigger BUFFER_RESET');\n      this.hls.trigger(_events2.default.BUFFER_RESET);\n      this.bufferRange = [];\n      this.stalled = false;\n      this.startPosition = this.lastCurrentTime = 0;\n    }\n  }, {\n    key: 'onManifestParsed',\n    value: function onManifestParsed(data) {\n      var aac = false,\n          heaac = false,\n          codec;\n      data.levels.forEach(function (level) {\n        // detect if we have different kind of audio codecs used amongst playlists\n        codec = level.audioCodec;\n        if (codec) {\n          if (codec.indexOf('mp4a.40.2') !== -1) {\n            aac = true;\n          }\n          if (codec.indexOf('mp4a.40.5') !== -1) {\n            heaac = true;\n          }\n        }\n      });\n      this.audioCodecSwitch = aac && heaac;\n      if (this.audioCodecSwitch) {\n        _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n      }\n      this.levels = data.levels;\n      this.startLevelLoaded = false;\n      this.startFragRequested = false;\n      var config = this.config;\n      if (config.autoStartLoad) {\n        this.hls.startLoad(config.startPosition);\n      }\n    }\n  }, {\n    key: 'onLevelLoaded',\n    value: function onLevelLoaded(data) {\n      var newDetails = data.details,\n          newLevelId = data.level,\n          curLevel = this.levels[newLevelId],\n          duration = newDetails.totalduration,\n          sliding = 0;\n\n      _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);\n      this.levelLastLoaded = newLevelId;\n\n      if (newDetails.live) {\n        var curDetails = curLevel.details;\n        if (curDetails && newDetails.fragments.length > 0) {\n          // we already have details for that level, merge them\n          _levelHelper2.default.mergeDetails(curDetails, newDetails);\n          sliding = newDetails.fragments[0].start;\n          this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);\n          if (newDetails.PTSKnown) {\n            _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));\n          } else {\n            _logger.logger.log('live playlist - outdated PTS, unknown sliding');\n          }\n        } else {\n          newDetails.PTSKnown = false;\n          _logger.logger.log('live playlist - first load, unknown sliding');\n        }\n      } else {\n        newDetails.PTSKnown = false;\n      }\n      // override level info\n      curLevel.details = newDetails;\n      this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });\n\n      if (this.startFragRequested === false) {\n        // compute start position if set to -1. use it straight away if value is defined\n        if (this.startPosition === -1 || this.lastCurrentTime === -1) {\n          // first, check if start time offset has been set in playlist, if yes, use this value\n          var startTimeOffset = newDetails.startTimeOffset;\n          if (!isNaN(startTimeOffset)) {\n            if (startTimeOffset < 0) {\n              _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');\n              startTimeOffset = sliding + duration + startTimeOffset;\n            }\n            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);\n            this.startPosition = startTimeOffset;\n          } else {\n            // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)\n            if (newDetails.live) {\n              this.startPosition = this.computeLivePosition(sliding, newDetails);\n              _logger.logger.log('configure startPosition to ' + this.startPosition);\n            } else {\n              this.startPosition = 0;\n            }\n          }\n          this.lastCurrentTime = this.startPosition;\n        }\n        this.nextLoadPosition = this.startPosition;\n      }\n      // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment\n      if (this.state === State.WAITING_LEVEL) {\n        this.state = State.IDLE;\n      }\n      //trigger handler right now\n      this.tick();\n    }\n  }, {\n    key: 'onKeyLoaded',\n    value: function onKeyLoaded() {\n      if (this.state === State.KEY_LOADING) {\n        this.state = State.IDLE;\n        this.tick();\n      }\n    }\n  }, {\n    key: 'onFragLoaded',\n    value: function onFragLoaded(data) {\n      var fragCurrent = this.fragCurrent,\n          fragLoaded = data.frag;\n      if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'main' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {\n        var stats = data.stats,\n            currentLevel = this.levels[fragCurrent.level],\n            details = currentLevel.details;\n        _logger.logger.log('Loaded  ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.level);\n        // reset frag bitrate test in any case after frag loaded event\n        this.bitrateTest = false;\n        this.stats = stats;\n        // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0\n        // then this means that we should be able to load a fragment at a higher quality level\n        if (fragLoaded.bitrateTest === true && this.hls.nextLoadLevel) {\n          // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo\n          this.state = State.IDLE;\n          this.startFragRequested = false;\n          stats.tparsed = stats.tbuffered = performance.now();\n          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });\n          this.tick();\n        } else if (fragLoaded.sn === 'initSegment') {\n          this.state = State.IDLE;\n          stats.tparsed = stats.tbuffered = performance.now();\n          details.initSegment.data = data.payload;\n          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });\n          this.tick();\n        } else {\n          this.state = State.PARSING;\n          // transmux the MPEG-TS data to ISO-BMFF segments\n          var duration = details.totalduration,\n              level = fragCurrent.level,\n              sn = fragCurrent.sn,\n              audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n          if (this.audioCodecSwap) {\n            _logger.logger.log('swapping playlist audio codec');\n            if (audioCodec === undefined) {\n              audioCodec = this.lastAudioCodec;\n            }\n            if (audioCodec) {\n              if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n                audioCodec = 'mp4a.40.2';\n              } else {\n                audioCodec = 'mp4a.40.5';\n              }\n            }\n          }\n          this.pendingBuffering = true;\n          this.appended = false;\n          _logger.logger.log('Parsing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + level + ', cc ' + fragCurrent.cc);\n          var demuxer = this.demuxer;\n          if (!demuxer) {\n            demuxer = this.demuxer = new _demuxer2.default(this.hls, 'main');\n          }\n          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)\n          var media = this.media;\n          var mediaSeeking = media && media.seeking;\n          var accurateTimeOffset = !mediaSeeking && (details.PTSKnown || !details.live);\n          var initSegmentData = details.initSegment ? details.initSegment.data : [];\n          demuxer.push(data.payload, initSegmentData, audioCodec, currentLevel.videoCodec, fragCurrent, duration, accurateTimeOffset, undefined);\n        }\n      }\n      this.fragLoadError = 0;\n    }\n  }, {\n    key: 'onFragParsingInitSegment',\n    value: function onFragParsingInitSegment(data) {\n      var fragCurrent = this.fragCurrent;\n      var fragNew = data.frag;\n      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {\n        var tracks = data.tracks,\n            trackName,\n            track;\n\n        // if audio track is expected to come from audio stream controller, discard any coming from main\n        if (tracks.audio && this.altAudio) {\n          delete tracks.audio;\n        }\n        // include levelCodec in audio and video tracks\n        track = tracks.audio;\n        if (track) {\n          var audioCodec = this.levels[this.level].audioCodec,\n              ua = navigator.userAgent.toLowerCase();\n          if (audioCodec && this.audioCodecSwap) {\n            _logger.logger.log('swapping playlist audio codec');\n            if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n              audioCodec = 'mp4a.40.2';\n            } else {\n              audioCodec = 'mp4a.40.5';\n            }\n          }\n          // in case AAC and HE-AAC audio codecs are signalled in manifest\n          // force HE-AAC , as it seems that most browsers prefers that way,\n          // except for mono streams OR on FF\n          // these conditions might need to be reviewed ...\n          if (this.audioCodecSwitch) {\n            // don't force HE-AAC if mono stream\n            if (track.metadata.channelCount !== 1 &&\n            // don't force HE-AAC if firefox\n            ua.indexOf('firefox') === -1) {\n              audioCodec = 'mp4a.40.5';\n            }\n          }\n          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n          if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') {\n            // Exclude mpeg audio\n            audioCodec = 'mp4a.40.2';\n            _logger.logger.log('Android: force audio codec to ' + audioCodec);\n          }\n          track.levelCodec = audioCodec;\n          track.id = data.id;\n        }\n        track = tracks.video;\n        if (track) {\n          track.levelCodec = this.levels[this.level].videoCodec;\n          track.id = data.id;\n        }\n\n        // if remuxer specify that a unique track needs to generated,\n        // let's merge all tracks together\n        if (data.unique) {\n          var mergedTrack = {\n            codec: '',\n            levelCodec: ''\n          };\n          for (trackName in data.tracks) {\n            track = tracks[trackName];\n            mergedTrack.container = track.container;\n            if (mergedTrack.codec) {\n              mergedTrack.codec += ',';\n              mergedTrack.levelCodec += ',';\n            }\n            if (track.codec) {\n              mergedTrack.codec += track.codec;\n            }\n            if (track.levelCodec) {\n              mergedTrack.levelCodec += track.levelCodec;\n            }\n          }\n          tracks = { audiovideo: mergedTrack };\n        }\n        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);\n        // loop through tracks that are going to be provided to bufferController\n        for (trackName in tracks) {\n          track = tracks[trackName];\n          _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');\n          var initSegment = track.initSegment;\n          if (initSegment) {\n            this.appended = true;\n            // arm pending Buffering flag before appending a segment\n            this.pendingBuffering = true;\n            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });\n          }\n        }\n        //trigger handler right now\n        this.tick();\n      }\n    }\n  }, {\n    key: 'onFragParsingData',\n    value: function onFragParsingData(data) {\n      var _this2 = this;\n\n      var fragCurrent = this.fragCurrent;\n      var fragNew = data.frag;\n      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller\n      this.state === State.PARSING) {\n        var level = this.levels[this.level],\n            frag = fragCurrent;\n        if (isNaN(data.endPTS)) {\n          data.endPTS = data.startPTS + fragCurrent.duration;\n          data.endDTS = data.startDTS + fragCurrent.duration;\n        }\n\n        _logger.logger.log('Parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));\n\n        // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)\n        if (data.type === 'video') {\n          frag.dropped = data.dropped;\n          if (frag.dropped) {\n            if (!frag.backtracked) {\n              // Return back to the IDLE state without appending to buffer\n              // Causes findFragments to backtrack a segment and find the keyframe\n              // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment\n              frag.backtracked = true;\n              this.nextLoadPosition = data.startPTS;\n              this.state = State.IDLE;\n              this.tick();\n              return;\n            } else {\n              _logger.logger.warn('Already backtracked on this fragment, appending with the gap');\n            }\n          } else {\n            // Only reset the backtracked flag if we've loaded the frag without any dropped frames\n            frag.backtracked = false;\n          }\n        }\n\n        var drift = _levelHelper2.default.updateFragPTSDTS(level.details, frag.sn, data.startPTS, data.endPTS, data.startDTS, data.endDTS),\n            hls = this.hls;\n        hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });\n\n        // has remuxer dropped video frames located before first keyframe ?\n        [data.data1, data.data2].forEach(function (buffer) {\n          // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)\n          // in that case it is useless to append following segments\n          if (buffer && buffer.length && _this2.state === State.PARSING) {\n            _this2.appended = true;\n            // arm pending Buffering flag before appending a segment\n            _this2.pendingBuffering = true;\n            hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });\n          }\n        });\n        //trigger handler right now\n        this.tick();\n      }\n    }\n  }, {\n    key: 'onFragParsed',\n    value: function onFragParsed(data) {\n      var fragCurrent = this.fragCurrent;\n      var fragNew = data.frag;\n      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {\n        this.stats.tparsed = performance.now();\n        this.state = State.PARSED;\n        this._checkAppendedParsed();\n      }\n    }\n  }, {\n    key: 'onAudioTrackSwitching',\n    value: function onAudioTrackSwitching(data) {\n      // if any URL found on new audio track, it is an alternate audio track\n      var altAudio = !!data.url,\n          trackId = data.id;\n      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n      // don't do anything if we switch to alt audio: audio stream controller is handling it.\n      // we will just have to change buffer scheduling on audioTrackSwitched\n      if (!altAudio) {\n        if (this.mediaBuffer !== this.media) {\n          _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');\n          this.mediaBuffer = this.media;\n          var fragCurrent = this.fragCurrent;\n          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n          if (fragCurrent.loader) {\n            _logger.logger.log('switching to main audio track, cancel main fragment load');\n            fragCurrent.loader.abort();\n          }\n          this.fragCurrent = null;\n          this.fragPrevious = null;\n          // destroy demuxer to force init segment generation (following audio switch)\n          if (this.demuxer) {\n            this.demuxer.destroy();\n            this.demuxer = null;\n          }\n          // switch to IDLE state to load new fragment\n          this.state = State.IDLE;\n        }\n        var hls = this.hls;\n        // switching to main audio, flush all audio and trigger track switched\n        hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });\n        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });\n        this.altAudio = false;\n      }\n    }\n  }, {\n    key: 'onAudioTrackSwitched',\n    value: function onAudioTrackSwitched(data) {\n      var trackId = data.id,\n          altAudio = !!this.hls.audioTracks[trackId].url;\n      if (altAudio) {\n        var videoBuffer = this.videoBuffer;\n        // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n        if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n          _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');\n          this.mediaBuffer = videoBuffer;\n        }\n      }\n      this.altAudio = altAudio;\n      this.tick();\n    }\n  }, {\n    key: 'onBufferCreated',\n    value: function onBufferCreated(data) {\n      var tracks = data.tracks,\n          mediaTrack = void 0,\n          name = void 0,\n          alternate = false;\n      for (var type in tracks) {\n        var track = tracks[type];\n        if (track.id === 'main') {\n          name = type;\n          mediaTrack = track;\n          // keep video source buffer reference\n          if (type === 'video') {\n            this.videoBuffer = tracks[type].buffer;\n          }\n        } else {\n          alternate = true;\n        }\n      }\n      if (alternate && mediaTrack) {\n        _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');\n        this.mediaBuffer = mediaTrack.buffer;\n      } else {\n        this.mediaBuffer = this.media;\n      }\n    }\n  }, {\n    key: 'onBufferAppended',\n    value: function onBufferAppended(data) {\n      if (data.parent === 'main') {\n        var state = this.state;\n        if (state === State.PARSING || state === State.PARSED) {\n          // check if all buffers have been appended\n          this.pendingBuffering = data.pending > 0;\n          this._checkAppendedParsed();\n        }\n      }\n    }\n  }, {\n    key: '_checkAppendedParsed',\n    value: function _checkAppendedParsed() {\n      var _this3 = this;\n\n      //trigger handler right now\n      if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {\n        var frag = this.fragCurrent;\n        if (frag) {\n          (function () {\n            var media = _this3.mediaBuffer ? _this3.mediaBuffer : _this3.media;\n            _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));\n            // filter potentially evicted bufferRange. this is to avoid memleak on live streams\n            var bufferRange = _this3.bufferRange.filter(function (range) {\n              return _bufferHelper2.default.isBuffered(media, (range.start + range.end) / 2);\n            });\n            // push new range\n            bufferRange.push({ type: frag.type, start: frag.startPTS, end: frag.endPTS, frag: frag });\n            // sort, as we use BinarySearch for lookup in getBufferRange ...\n            _this3.bufferRange = bufferRange.sort(function (a, b) {\n              return a.start - b.start;\n            });\n            _this3.fragPrevious = frag;\n            var stats = _this3.stats;\n            stats.tbuffered = performance.now();\n            // we should get rid of this.fragLastKbps\n            _this3.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));\n            _this3.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });\n            _this3.state = State.IDLE;\n          })();\n        }\n        this.tick();\n      }\n    }\n  }, {\n    key: 'onError',\n    value: function onError(data) {\n      var frag = data.frag || this.fragCurrent;\n      // don't handle frag error not related to main fragment\n      if (frag && frag.type !== 'main') {\n        return;\n      }\n      var media = this.media,\n\n      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n      mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);\n      switch (data.details) {\n        case _errors.ErrorDetails.FRAG_LOAD_ERROR:\n        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case _errors.ErrorDetails.KEY_LOAD_ERROR:\n        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:\n          if (!data.fatal) {\n            var loadError = this.fragLoadError;\n            if (loadError) {\n              loadError++;\n            } else {\n              loadError = 1;\n            }\n            var config = this.config;\n            // keep retrying / don't raise fatal network error if current position is buffered or if in automode with current level not 0\n            if (loadError <= config.fragLoadingMaxRetry || mediaBuffered || frag.autoLevel && frag.level) {\n              this.fragLoadError = loadError;\n              // reset load counter to avoid frag loop loading error\n              frag.loadCounter = 0;\n              // exponential backoff capped to config.fragLoadingMaxRetryTimeout\n              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);\n              _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');\n              this.retryDate = performance.now() + delay;\n              // retry loading state\n              // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n              // in that case, reset startFragRequested flag\n              if (!this.loadedmetadata) {\n                this.startFragRequested = false;\n                this.nextLoadPosition = this.startPosition;\n              }\n              this.state = State.FRAG_LOADING_WAITING_RETRY;\n            } else {\n              _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');\n              // redispatch same error but with fatal set to true\n              data.fatal = true;\n              this.hls.trigger(_events2.default.ERROR, data);\n              this.state = State.ERROR;\n            }\n          }\n          break;\n        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:\n          if (!data.fatal) {\n            // if buffer is not empty\n            if (mediaBuffered) {\n              // try to reduce max buffer length : rationale is that we could get\n              // frag loop loading error because of buffer eviction\n              this._reduceMaxBufferLength(frag.duration);\n              this.state = State.IDLE;\n            } else {\n              // buffer empty. report as fatal if in manual mode or if lowest level.\n              // level controller takes care of emergency switch down logic\n              if (!frag.autoLevel || frag.level === 0) {\n                // redispatch same error but with fatal set to true\n                data.fatal = true;\n                this.hls.trigger(_events2.default.ERROR, data);\n                this.state = State.ERROR;\n              }\n            }\n          }\n          break;\n        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:\n        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n          if (this.state !== State.ERROR) {\n            if (data.fatal) {\n              // if fatal error, stop processing\n              this.state = State.ERROR;\n              _logger.logger.warn('streamController: ' + data.details + ',switch to ' + this.state + ' state ...');\n            } else {\n              // in cas of non fatal error while waiting level load to be completed, switch back to IDLE\n              if (this.state === State.WAITING_LEVEL) {\n                this.state = State.IDLE;\n              }\n            }\n          }\n          break;\n        case _errors.ErrorDetails.BUFFER_FULL_ERROR:\n          // if in appending state\n          if (data.parent === 'main' && (this.state === State.PARSING || this.state === State.PARSED)) {\n            // reduce max buf len if current position is buffered\n            if (mediaBuffered) {\n              this._reduceMaxBufferLength(this.config.maxBufferLength);\n              this.state = State.IDLE;\n            } else {\n              // current position is not buffered, but browser is still complaining about buffer full error\n              // this happens on IE/Edge, refer to https://github.com/dailymotion/hls.js/pull/708\n              // in that case flush the whole buffer to recover\n              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');\n              this.fragCurrent = null;\n              // flush everything\n              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n            }\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }, {\n    key: '_reduceMaxBufferLength',\n    value: function _reduceMaxBufferLength(minLength) {\n      var config = this.config;\n      if (config.maxMaxBufferLength >= minLength) {\n        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n        config.maxMaxBufferLength /= 2;\n        _logger.logger.warn('main:reduce max buffer length to ' + config.maxMaxBufferLength + 's');\n        // increase fragment load Index to avoid frag loop loading error after buffer flush\n        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;\n      }\n    }\n  }, {\n    key: '_checkBuffer',\n    value: function _checkBuffer() {\n      var media = this.media;\n      // if ready state different from HAVE_NOTHING (numeric value 0), we are allowed to seek\n      if (media && media.readyState) {\n        var currentTime = media.currentTime,\n            mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media,\n            buffered = mediaBuffer.buffered;\n        // adjust currentTime to start position on loaded metadata\n        if (!this.loadedmetadata && buffered.length && !media.seeking) {\n          this.loadedmetadata = true;\n          // only adjust currentTime if different from startPosition or if startPosition not buffered\n          // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n          var startPosition = this.startPosition,\n              startPositionBuffered = _bufferHelper2.default.isBuffered(mediaBuffer, startPosition);\n          // if currentTime not matching with expected startPosition or startPosition not buffered\n          if (currentTime !== startPosition || !startPositionBuffered) {\n            _logger.logger.log('target start position:' + startPosition);\n            // if startPosition not buffered, let's seek to buffered.start(0)\n            if (!startPositionBuffered) {\n              startPosition = buffered.start(0);\n              _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition);\n            }\n            _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + startPosition);\n            media.currentTime = startPosition;\n          }\n        } else if (this.immediateSwitch) {\n          this.immediateLevelSwitchEnd();\n        } else {\n          var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, 0),\n              expectedPlaying = !(media.paused || // not playing when media is paused\n          media.ended || // not playing when media is ended\n          media.buffered.length === 0),\n              // not playing if nothing buffered\n          jumpThreshold = 0.5,\n              // tolerance needed as some browsers stalls playback before reaching buffered range end\n          playheadMoving = currentTime !== this.lastCurrentTime,\n              config = this.config;\n\n          if (playheadMoving) {\n            // played moving, but was previously stalled => now not stuck anymore\n            if (this.stallReported) {\n              _logger.logger.warn('playback not stuck anymore @' + currentTime + ', after ' + Math.round(performance.now() - this.stalled) + 'ms');\n              this.stallReported = false;\n            }\n            this.stalled = undefined;\n            this.nudgeRetry = 0;\n          } else {\n            // playhead not moving\n            if (expectedPlaying) {\n              // playhead not moving BUT media expected to play\n              var tnow = performance.now();\n              var hls = this.hls;\n              if (!this.stalled) {\n                // stall just detected, store current time\n                this.stalled = tnow;\n                this.stallReported = false;\n              } else {\n                // playback already stalled, check stalling duration\n                // if stalling for more than a given threshold, let's try to recover\n                var stalledDuration = tnow - this.stalled;\n                var bufferLen = bufferInfo.len;\n                var nudgeRetry = this.nudgeRetry || 0;\n                // have we reached stall deadline ?\n                if (bufferLen <= jumpThreshold && stalledDuration > config.lowBufferWatchdogPeriod * 1000) {\n                  // report stalled error once\n                  if (!this.stallReported) {\n                    this.stallReported = true;\n                    _logger.logger.warn('playback stalling in low buffer @' + currentTime);\n                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false, buffer: bufferLen });\n                  }\n                  // if buffer len is below threshold, try to jump to start of next buffer range if close\n                  // no buffer available @ currentTime, check if next buffer is close (within a config.maxSeekHole second range)\n                  var nextBufferStart = bufferInfo.nextStart,\n                      delta = nextBufferStart - currentTime;\n                  if (nextBufferStart && delta < config.maxSeekHole && delta > 0) {\n                    this.nudgeRetry = ++nudgeRetry;\n                    var nudgeOffset = nudgeRetry * config.nudgeOffset;\n                    // next buffer is close ! adjust currentTime to nextBufferStart\n                    // this will ensure effective video decoding\n                    _logger.logger.log('adjust currentTime from ' + media.currentTime + ' to next buffered @ ' + nextBufferStart + ' + nudge ' + nudgeOffset);\n                    media.currentTime = nextBufferStart + nudgeOffset;\n                    // reset stalled so to rearm watchdog timer\n                    this.stalled = undefined;\n                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE, fatal: false, hole: nextBufferStart + nudgeOffset - currentTime });\n                  }\n                } else if (bufferLen > jumpThreshold && stalledDuration > config.highBufferWatchdogPeriod * 1000) {\n                  // report stalled error once\n                  if (!this.stallReported) {\n                    this.stallReported = true;\n                    _logger.logger.warn('playback stalling in high buffer @' + currentTime);\n                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false, buffer: bufferLen });\n                  }\n                  // reset stalled so to rearm watchdog timer\n                  this.stalled = undefined;\n                  this.nudgeRetry = ++nudgeRetry;\n                  if (nudgeRetry < config.nudgeMaxRetry) {\n                    var _currentTime = media.currentTime;\n                    var targetTime = _currentTime + nudgeRetry * config.nudgeOffset;\n                    _logger.logger.log('adjust currentTime from ' + _currentTime + ' to ' + targetTime);\n                    // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n                    media.currentTime = targetTime;\n                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_NUDGE_ON_STALL, fatal: false });\n                  } else {\n                    _logger.logger.error('still stuck in high buffer @' + currentTime + ' after ' + config.nudgeMaxRetry + ', raise fatal error');\n                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: true });\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: 'onFragLoadEmergencyAborted',\n    value: function onFragLoadEmergencyAborted() {\n      this.state = State.IDLE;\n      // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n      // in that case, reset startFragRequested flag\n      if (!this.loadedmetadata) {\n        this.startFragRequested = false;\n        this.nextLoadPosition = this.startPosition;\n      }\n      this.tick();\n    }\n  }, {\n    key: 'onBufferFlushed',\n    value: function onBufferFlushed() {\n      /* after successful buffer flushing, filter flushed fragments from bufferRange\n        use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)\n      */\n      var media = this.mediaBuffer ? this.mediaBuffer : this.media;\n      this.bufferRange = this.bufferRange.filter(function (range) {\n        return _bufferHelper2.default.isBuffered(media, (range.start + range.end) / 2);\n      });\n\n      // increase fragment load Index to avoid frag loop loading error after buffer flush\n      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;\n      // move to IDLE once flush complete. this should trigger new fragment loading\n      this.state = State.IDLE;\n      // reset reference to frag\n      this.fragPrevious = null;\n    }\n  }, {\n    key: 'swapAudioCodec',\n    value: function swapAudioCodec() {\n      this.audioCodecSwap = !this.audioCodecSwap;\n    }\n  }, {\n    key: 'computeLivePosition',\n    value: function computeLivePosition(sliding, levelDetails) {\n      var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;\n      return sliding + Math.max(0, levelDetails.totalduration - targetLatency);\n    }\n  }, {\n    key: 'state',\n    set: function set(nextState) {\n      if (this.state !== nextState) {\n        var previousState = this.state;\n        this._state = nextState;\n        _logger.logger.log('main stream:' + previousState + '->' + nextState);\n        this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });\n      }\n    },\n    get: function get() {\n      return this._state;\n    }\n  }, {\n    key: 'currentLevel',\n    get: function get() {\n      var media = this.media;\n      if (media) {\n        var range = this.getBufferRange(media.currentTime);\n        if (range) {\n          return range.frag.level;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: 'nextBufferRange',\n    get: function get() {\n      var media = this.media;\n      if (media) {\n        // first get end range of current fragment\n        return this.followingBufferRange(this.getBufferRange(media.currentTime));\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: 'nextLevel',\n    get: function get() {\n      var range = this.nextBufferRange;\n      if (range) {\n        return range.frag.level;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'liveSyncPosition',\n    get: function get() {\n      return this._liveSyncPosition;\n    },\n    set: function set(value) {\n      this._liveSyncPosition = value;\n    }\n  }]);\n\n  return StreamController;\n}(_eventHandler2.default);\n\nexports.default = StreamController;\n\n},{\"25\":25,\"31\":31,\"32\":32,\"33\":33,\"35\":35,\"36\":36,\"46\":46,\"50\":50,\"51\":51}],14:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Subtitle Stream Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar SubtitleStreamController = function (_EventHandler) {\n  _inherits(SubtitleStreamController, _EventHandler);\n\n  function SubtitleStreamController(hls) {\n    _classCallCheck(this, SubtitleStreamController);\n\n    var _this = _possibleConstructorReturn(this, (SubtitleStreamController.__proto__ || Object.getPrototypeOf(SubtitleStreamController)).call(this, hls, _events2.default.ERROR, _events2.default.SUBTITLE_TRACKS_UPDATED, _events2.default.SUBTITLE_TRACK_SWITCH, _events2.default.SUBTITLE_TRACK_LOADED, _events2.default.SUBTITLE_FRAG_PROCESSED));\n\n    _this.config = hls.config;\n    _this.vttFragSNsProcessed = {};\n    _this.vttFragQueues = undefined;\n    _this.currentlyProcessing = null;\n    _this.currentTrackId = -1;\n    return _this;\n  }\n\n  _createClass(SubtitleStreamController, [{\n    key: 'destroy',\n    value: function destroy() {\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n\n    // Remove all queued items and create a new, empty queue for each track.\n\n  }, {\n    key: 'clearVttFragQueues',\n    value: function clearVttFragQueues() {\n      var _this2 = this;\n\n      this.vttFragQueues = {};\n      this.tracks.forEach(function (track) {\n        _this2.vttFragQueues[track.id] = [];\n      });\n    }\n\n    // If no frag is being processed and queue isn't empty, initiate processing of next frag in line.\n\n  }, {\n    key: 'nextFrag',\n    value: function nextFrag() {\n      if (this.currentlyProcessing === null && this.currentTrackId > -1 && this.vttFragQueues[this.currentTrackId].length) {\n        var frag = this.currentlyProcessing = this.vttFragQueues[this.currentTrackId].shift();\n        this.hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });\n      }\n    }\n\n    // When fragment has finished processing, add sn to list of completed if successful.\n\n  }, {\n    key: 'onSubtitleFragProcessed',\n    value: function onSubtitleFragProcessed(data) {\n      if (data.success) {\n        this.vttFragSNsProcessed[data.frag.trackId].push(data.frag.sn);\n      }\n      this.currentlyProcessing = null;\n      this.nextFrag();\n    }\n\n    // If something goes wrong, procede to next frag, if we were processing one.\n\n  }, {\n    key: 'onError',\n    value: function onError(data) {\n      var frag = data.frag;\n      // don't handle frag error not related to subtitle fragment\n      if (frag && frag.type !== 'subtitle') {\n        return;\n      }\n      if (this.currentlyProcessing) {\n        this.currentlyProcessing = null;\n        this.nextFrag();\n      }\n    }\n\n    // Got all new subtitle tracks.\n\n  }, {\n    key: 'onSubtitleTracksUpdated',\n    value: function onSubtitleTracksUpdated(data) {\n      var _this3 = this;\n\n      _logger.logger.log('subtitle tracks updated');\n      this.tracks = data.subtitleTracks;\n      this.clearVttFragQueues();\n      this.vttFragSNsProcessed = {};\n      this.tracks.forEach(function (track) {\n        _this3.vttFragSNsProcessed[track.id] = [];\n      });\n    }\n  }, {\n    key: 'onSubtitleTrackSwitch',\n    value: function onSubtitleTrackSwitch(data) {\n      this.currentTrackId = data.id;\n      this.clearVttFragQueues();\n    }\n\n    // Got a new set of subtitle fragments.\n\n  }, {\n    key: 'onSubtitleTrackLoaded',\n    value: function onSubtitleTrackLoaded(data) {\n      var processedFragSNs = this.vttFragSNsProcessed[data.id],\n          fragQueue = this.vttFragQueues[data.id],\n          currentFragSN = !!this.currentlyProcessing ? this.currentlyProcessing.sn : -1;\n\n      var alreadyProcessed = function alreadyProcessed(frag) {\n        return processedFragSNs.indexOf(frag.sn) > -1;\n      };\n\n      var alreadyInQueue = function alreadyInQueue(frag) {\n        return fragQueue.some(function (fragInQueue) {\n          return fragInQueue.sn === frag.sn;\n        });\n      };\n\n      // Add all fragments that haven't been, aren't currently being and aren't waiting to be processed, to queue.\n      data.details.fragments.forEach(function (frag) {\n        if (!(alreadyProcessed(frag) || frag.sn === currentFragSN || alreadyInQueue(frag))) {\n          // Frags don't know their subtitle track ID, so let's just add that...\n          frag.trackId = data.id;\n          fragQueue.push(frag);\n        }\n      });\n\n      this.nextFrag();\n    }\n  }]);\n\n  return SubtitleStreamController;\n}(_eventHandler2.default);\n\nexports.default = SubtitleStreamController;\n\n},{\"32\":32,\"33\":33,\"50\":50}],15:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar SubtitleTrackController = function (_EventHandler) {\n  _inherits(SubtitleTrackController, _EventHandler);\n\n  function SubtitleTrackController(hls) {\n    _classCallCheck(this, SubtitleTrackController);\n\n    var _this = _possibleConstructorReturn(this, (SubtitleTrackController.__proto__ || Object.getPrototypeOf(SubtitleTrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.SUBTITLE_TRACK_LOADED));\n\n    _this.tracks = [];\n    _this.trackId = -1;\n    _this.media = undefined;\n    return _this;\n  }\n\n  _createClass(SubtitleTrackController, [{\n    key: 'destroy',\n    value: function destroy() {\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n\n    // Listen for subtitle track change, then extract the current track ID.\n\n  }, {\n    key: 'onMediaAttached',\n    value: function onMediaAttached(data) {\n      var _this2 = this;\n\n      this.media = data.media;\n      if (!this.media) {\n        return;\n      }\n\n      this.media.textTracks.addEventListener('change', function () {\n        // Media is undefined when switching streams via loadSource()\n        if (!_this2.media) {\n          return;\n        }\n\n        var trackId = -1;\n        var tracks = _this2.media.textTracks;\n        for (var id = 0; id < tracks.length; id++) {\n          if (tracks[id].mode === 'showing') {\n            trackId = id;\n          }\n        }\n        // Setting current subtitleTrack will invoke code.\n        _this2.subtitleTrack = trackId;\n      });\n    }\n  }, {\n    key: 'onMediaDetaching',\n    value: function onMediaDetaching() {\n      // TODO: Remove event listeners.\n      this.media = undefined;\n    }\n\n    // Reset subtitle tracks on manifest loading\n\n  }, {\n    key: 'onManifestLoading',\n    value: function onManifestLoading() {\n      this.tracks = [];\n      this.trackId = -1;\n    }\n\n    // Fired whenever a new manifest is loaded.\n\n  }, {\n    key: 'onManifestLoaded',\n    value: function onManifestLoaded(data) {\n      var _this3 = this;\n\n      var tracks = data.subtitles || [];\n      var defaultFound = false;\n      this.tracks = tracks;\n      this.trackId = -1;\n      this.hls.trigger(_events2.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });\n\n      // loop through available subtitle tracks and autoselect default if needed\n      // TODO: improve selection logic to handle forced, etc\n      tracks.forEach(function (track) {\n        if (track.default) {\n          _this3.subtitleTrack = track.id;\n          defaultFound = true;\n        }\n      });\n    }\n\n    // Trigger subtitle track playlist reload.\n\n  }, {\n    key: 'onTick',\n    value: function onTick() {\n      var trackId = this.trackId;\n      var subtitleTrack = this.tracks[trackId];\n      if (!subtitleTrack) {\n        return;\n      }\n\n      var details = subtitleTrack.details;\n      // check if we need to load playlist for this subtitle Track\n      if (details === undefined || details.live === true) {\n        // track not retrieved yet, or live playlist we need to (re)load it\n        _logger.logger.log('(re)loading playlist for subtitle track ' + trackId);\n        this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: trackId });\n      }\n    }\n  }, {\n    key: 'onSubtitleTrackLoaded',\n    value: function onSubtitleTrackLoaded(data) {\n      var _this4 = this;\n\n      if (data.id < this.tracks.length) {\n        _logger.logger.log('subtitle track ' + data.id + ' loaded');\n        this.tracks[data.id].details = data.details;\n        // check if current playlist is a live playlist\n        if (data.details.live && !this.timer) {\n          // if live playlist we will have to reload it periodically\n          // set reload period to playlist target duration\n          this.timer = setInterval(function () {\n            _this4.onTick();\n          }, 1000 * data.details.targetduration, this);\n        }\n        if (!data.details.live && this.timer) {\n          // playlist is not live and timer is armed : stopping it\n          clearInterval(this.timer);\n          this.timer = null;\n        }\n      }\n    }\n\n    /** get alternate subtitle tracks list from playlist **/\n\n  }, {\n    key: 'setSubtitleTrackInternal',\n    value: function setSubtitleTrackInternal(newId) {\n      // check if level idx is valid\n      if (newId >= 0 && newId < this.tracks.length) {\n        // stopping live reloading timer if any\n        if (this.timer) {\n          clearInterval(this.timer);\n          this.timer = null;\n        }\n        this.trackId = newId;\n        _logger.logger.log('switching to subtitle track ' + newId);\n        var subtitleTrack = this.tracks[newId];\n        this.hls.trigger(_events2.default.SUBTITLE_TRACK_SWITCH, { id: newId });\n        // check if we need to load playlist for this subtitle Track\n        var details = subtitleTrack.details;\n        if (details === undefined || details.live === true) {\n          // track not retrieved yet, or live playlist we need to (re)load it\n          _logger.logger.log('(re)loading playlist for subtitle track ' + newId);\n          this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: newId });\n        }\n      }\n    }\n  }, {\n    key: 'subtitleTracks',\n    get: function get() {\n      return this.tracks;\n    }\n\n    /** get index of the selected subtitle track (index in subtitle track lists) **/\n\n  }, {\n    key: 'subtitleTrack',\n    get: function get() {\n      return this.trackId;\n    }\n\n    /** select a subtitle track, based on its index in subtitle track lists**/\n    ,\n    set: function set(subtitleTrackId) {\n      if (this.trackId !== subtitleTrackId) {\n        // || this.tracks[subtitleTrackId].details === undefined) {\n        this.setSubtitleTrackInternal(subtitleTrackId);\n      }\n    }\n  }]);\n\n  return SubtitleTrackController;\n}(_eventHandler2.default);\n\nexports.default = SubtitleTrackController;\n\n},{\"32\":32,\"33\":33,\"50\":50}],16:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _cea608Parser = _dereq_(47);\n\nvar _cea608Parser2 = _interopRequireDefault(_cea608Parser);\n\nvar _webvttParser = _dereq_(54);\n\nvar _webvttParser2 = _interopRequireDefault(_webvttParser);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nfunction clearCurrentCues(track) {\n  if (track && track.cues) {\n    while (track.cues.length > 0) {\n      track.removeCue(track.cues[0]);\n    }\n  }\n}\n\nfunction reuseVttTextTrack(inUseTrack, manifestTrack) {\n  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);\n}\n\nfunction intersection(x1, x2, y1, y2) {\n  return Math.min(x2, y2) - Math.max(x1, y1);\n}\n\nvar TimelineController = function (_EventHandler) {\n  _inherits(TimelineController, _EventHandler);\n\n  function TimelineController(hls) {\n    _classCallCheck(this, TimelineController);\n\n    var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCHING, _events2.default.INIT_PTS_FOUND));\n\n    _this.hls = hls;\n    _this.config = hls.config;\n    _this.enabled = true;\n    _this.Cues = hls.config.cueHandler;\n    _this.textTracks = [];\n    _this.tracks = [];\n    _this.unparsedVttFrags = [];\n    _this.initPTS = undefined;\n    _this.cueRanges = [];\n\n    if (_this.config.enableCEA708Captions) {\n      var self = _this;\n      var sendAddTrackEvent = function sendAddTrackEvent(track, media) {\n        var e = null;\n        try {\n          e = new window.Event('addtrack');\n        } catch (err) {\n          //for IE11\n          e = document.createEvent('Event');\n          e.initEvent('addtrack', false, false);\n        }\n        e.track = track;\n        media.dispatchEvent(e);\n      };\n\n      var channel1 = {\n        'newCue': function newCue(startTime, endTime, screen) {\n          if (!self.textTrack1) {\n            //Enable reuse of existing text track.\n            var existingTrack1 = self.getExistingTrack('1');\n            if (!existingTrack1) {\n              self.textTrack1 = self.createTextTrack('captions', 'English', 'en');\n              self.textTrack1.textTrack1 = true;\n            } else {\n              self.textTrack1 = existingTrack1;\n              self.clearCurrentCues(self.textTrack1);\n\n              sendAddTrackEvent(self.textTrack1, self.media);\n            }\n          }\n          self.addCues('textTrack1', startTime, endTime, screen);\n        }\n      };\n\n      var channel2 = {\n        'newCue': function newCue(startTime, endTime, screen) {\n          if (!self.textTrack2) {\n            //Enable reuse of existing text track.\n            var existingTrack2 = self.getExistingTrack('2');\n            if (!existingTrack2) {\n              self.textTrack2 = self.createTextTrack('captions', 'Spanish', 'es');\n              self.textTrack2.textTrack2 = true;\n            } else {\n              self.textTrack2 = existingTrack2;\n\n              sendAddTrackEvent(self.textTrack2, self.media);\n            }\n          }\n          self.addCues('textTrack2', startTime, endTime, screen);\n        }\n      };\n\n      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);\n    }\n    return _this;\n  }\n\n  _createClass(TimelineController, [{\n    key: 'addCues',\n    value: function addCues(channel, startTime, endTime, screen) {\n      // skip cues which overlap more than 50% with previously parsed time ranges\n      var ranges = this.cueRanges;\n      var merged = false;\n      for (var i = ranges.length; i--;) {\n        var cueRange = ranges[i];\n        var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);\n        if (overlap >= 0) {\n          cueRange[0] = Math.min(cueRange[0], startTime);\n          cueRange[1] = Math.max(cueRange[1], endTime);\n          merged = true;\n          if (overlap / (endTime - startTime) > 0.5) {\n            return;\n          }\n        }\n      }\n      if (!merged) {\n        ranges.push([startTime, endTime]);\n      }\n      this.Cues.newCue(this[channel], startTime, endTime, screen);\n    }\n\n    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n\n  }, {\n    key: 'onInitPtsFound',\n    value: function onInitPtsFound(data) {\n      var _this2 = this;\n\n      if (typeof this.initPTS === 'undefined') {\n        this.initPTS = data.initPTS;\n      }\n\n      // Due to asynchrony, initial PTS may arrive later than the first VTT fragments are loaded.\n      // Parse any unparsed fragments upon receiving the initial PTS.\n      if (this.unparsedVttFrags.length) {\n        this.unparsedVttFrags.forEach(function (frag) {\n          _this2.onFragLoaded(frag);\n        });\n        this.unparsedVttFrags = [];\n      }\n    }\n  }, {\n    key: 'getExistingTrack',\n    value: function getExistingTrack(channelNumber) {\n      var media = this.media;\n      if (media) {\n        for (var i = 0; i < media.textTracks.length; i++) {\n          var textTrack = media.textTracks[i];\n          var propName = 'textTrack' + channelNumber;\n          if (textTrack[propName] === true) {\n            return textTrack;\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: 'createTextTrack',\n    value: function createTextTrack(kind, label, lang) {\n      if (this.media) {\n        return this.media.addTextTrack(kind, label, lang);\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n  }, {\n    key: 'onMediaAttaching',\n    value: function onMediaAttaching(data) {\n      this.media = data.media;\n    }\n  }, {\n    key: 'onMediaDetaching',\n    value: function onMediaDetaching() {\n      clearCurrentCues(this.textTrack1);\n      clearCurrentCues(this.textTrack2);\n    }\n  }, {\n    key: 'onManifestLoading',\n    value: function onManifestLoading() {\n      this.lastSn = -1; // Detect discontiguity in fragment parsing\n      this.prevCC = -1;\n      this.vttCCs = { ccOffset: 0, presentationOffset: 0 }; // Detect discontinuity in subtitle manifests\n    }\n  }, {\n    key: 'onManifestLoaded',\n    value: function onManifestLoaded(data) {\n      var _this3 = this;\n\n      this.textTracks = [];\n      this.unparsedVttFrags = this.unparsedVttFrags || [];\n      this.initPTS = undefined;\n      this.cueRanges = [];\n\n      if (this.config.enableWebVTT) {\n        (function () {\n          _this3.tracks = data.subtitles || [];\n          var inUseTracks = _this3.media ? _this3.media.textTracks : [];\n\n          _this3.tracks.forEach(function (track, index) {\n            var textTrack = void 0;\n            var inUseTrack = inUseTracks[index];\n            // Reuse tracks with the same label, but do not reuse 608/708 tracks\n            if (reuseVttTextTrack(inUseTrack, track)) {\n              textTrack = inUseTrack;\n            } else {\n              textTrack = _this3.createTextTrack('subtitles', track.name, track.lang);\n            }\n            textTrack.mode = track.default ? 'showing' : 'hidden';\n            _this3.textTracks.push(textTrack);\n          });\n        })();\n      }\n    }\n  }, {\n    key: 'onLevelSwitching',\n    value: function onLevelSwitching() {\n      this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';\n    }\n  }, {\n    key: 'onFragLoaded',\n    value: function onFragLoaded(data) {\n      var _this4 = this;\n\n      var frag = data.frag,\n          payload = data.payload;\n      if (frag.type === 'main') {\n        var sn = frag.sn;\n        // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack\n        if (sn !== this.lastSn + 1) {\n          this.cea608Parser.reset();\n        }\n        this.lastSn = sn;\n      }\n      // If fragment is subtitle type, parse as WebVTT.\n      else if (frag.type === 'subtitle') {\n          if (payload.byteLength) {\n            var _ret2 = function () {\n              // We need an initial synchronisation PTS. Store fragments as long as none has arrived.\n              if (typeof _this4.initPTS === 'undefined') {\n                _this4.unparsedVttFrags.push(data);\n                return {\n                  v: void 0\n                };\n              }\n              var vttCCs = _this4.vttCCs;\n              if (!vttCCs[frag.cc]) {\n                vttCCs[frag.cc] = { start: frag.start, prevCC: _this4.prevCC, new: true };\n                _this4.prevCC = frag.cc;\n              }\n              var textTracks = _this4.textTracks,\n                  hls = _this4.hls;\n\n              // Parse the WebVTT file contents.\n              _webvttParser2.default.parse(payload, _this4.initPTS, vttCCs, frag.cc, function (cues) {\n                // Add cues and trigger event with success true.\n                cues.forEach(function (cue) {\n                  textTracks[frag.trackId].addCue(cue);\n                });\n                hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });\n              }, function (e) {\n                // Something went wrong while parsing. Trigger event with success false.\n                _logger.logger.log('Failed to parse VTT cue: ' + e);\n                hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });\n              });\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n          } else {\n            // In case there is no payload, finish unsuccessfully.\n            this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });\n          }\n        }\n    }\n  }, {\n    key: 'onFragParsingUserdata',\n    value: function onFragParsingUserdata(data) {\n      // push all of the CEA-708 messages into the interpreter\n      // immediately. It will create the proper timestamps based on our PTS value\n      if (this.enabled && this.config.enableCEA708Captions) {\n        for (var i = 0; i < data.samples.length; i++) {\n          var ccdatas = this.extractCea608Data(data.samples[i].bytes);\n          this.cea608Parser.addData(data.samples[i].pts, ccdatas);\n        }\n      }\n    }\n  }, {\n    key: 'extractCea608Data',\n    value: function extractCea608Data(byteArray) {\n      var count = byteArray[0] & 31;\n      var position = 2;\n      var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;\n      var actualCCBytes = [];\n\n      for (var j = 0; j < count; j++) {\n        tmpByte = byteArray[position++];\n        ccbyte1 = 0x7F & byteArray[position++];\n        ccbyte2 = 0x7F & byteArray[position++];\n        ccValid = (4 & tmpByte) !== 0;\n        ccType = 3 & tmpByte;\n\n        if (ccbyte1 === 0 && ccbyte2 === 0) {\n          continue;\n        }\n\n        if (ccValid) {\n          if (ccType === 0) // || ccType === 1\n            {\n              actualCCBytes.push(ccbyte1);\n              actualCCBytes.push(ccbyte2);\n            }\n        }\n      }\n      return actualCCBytes;\n    }\n  }]);\n\n  return TimelineController;\n}(_eventHandler2.default);\n\nexports.default = TimelineController;\n\n},{\"32\":32,\"33\":33,\"47\":47,\"50\":50,\"54\":54}],17:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AESCrypto = function () {\n  function AESCrypto(subtle, iv) {\n    _classCallCheck(this, AESCrypto);\n\n    this.subtle = subtle;\n    this.aesIV = iv;\n  }\n\n  _createClass(AESCrypto, [{\n    key: 'decrypt',\n    value: function decrypt(data, key) {\n      return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);\n    }\n  }]);\n\n  return AESCrypto;\n}();\n\nexports.default = AESCrypto;\n\n},{}],18:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AESDecryptor = function () {\n  function AESDecryptor() {\n    _classCallCheck(this, AESDecryptor);\n\n    // Static after running initTable\n    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n    this.subMix = [];\n    this.subMix[0] = new Uint32Array(256);\n    this.subMix[1] = new Uint32Array(256);\n    this.subMix[2] = new Uint32Array(256);\n    this.subMix[3] = new Uint32Array(256);\n\n    this.invSubMix = [];\n    this.invSubMix[0] = new Uint32Array(256);\n    this.invSubMix[1] = new Uint32Array(256);\n    this.invSubMix[2] = new Uint32Array(256);\n    this.invSubMix[3] = new Uint32Array(256);\n\n    this.sBox = new Uint32Array(256);\n    this.invSBox = new Uint32Array(256);\n\n    // Changes during runtime\n    this.key = new Uint32Array(0);\n\n    this.initTable();\n  }\n\n  // Using view.getUint32() also swaps the byte order.\n\n\n  _createClass(AESDecryptor, [{\n    key: 'uint8ArrayToUint32Array_',\n    value: function uint8ArrayToUint32Array_(arrayBuffer) {\n      var view = new DataView(arrayBuffer);\n      var newArray = new Uint32Array(4);\n      for (var i = 0; i < newArray.length; i++) {\n        newArray[i] = view.getUint32(i * 4);\n      }\n      return newArray;\n    }\n  }, {\n    key: 'initTable',\n    value: function initTable() {\n      var sBox = this.sBox;\n      var invSBox = this.invSBox;\n      var subMix0 = this.subMix[0];\n      var subMix1 = this.subMix[1];\n      var subMix2 = this.subMix[2];\n      var subMix3 = this.subMix[3];\n      var invSubMix0 = this.invSubMix[0];\n      var invSubMix1 = this.invSubMix[1];\n      var invSubMix2 = this.invSubMix[2];\n      var invSubMix3 = this.invSubMix[3];\n\n      var d = new Uint32Array(256);\n      var x = 0;\n      var xi = 0;\n      var i = 0;\n      for (i = 0; i < 256; i++) {\n        if (i < 128) {\n          d[i] = i << 1;\n        } else {\n          d[i] = i << 1 ^ 0x11b;\n        }\n      }\n\n      for (i = 0; i < 256; i++) {\n        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n        sBox[x] = sx;\n        invSBox[sx] = x;\n\n        // Compute multiplication\n        var x2 = d[x];\n        var x4 = d[x2];\n        var x8 = d[x4];\n\n        // Compute sub/invSub bytes, mix columns tables\n        var t = d[sx] * 0x101 ^ sx * 0x1010100;\n        subMix0[x] = t << 24 | t >>> 8;\n        subMix1[x] = t << 16 | t >>> 16;\n        subMix2[x] = t << 8 | t >>> 24;\n        subMix3[x] = t;\n\n        // Compute inv sub bytes, inv mix columns tables\n        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n        invSubMix0[sx] = t << 24 | t >>> 8;\n        invSubMix1[sx] = t << 16 | t >>> 16;\n        invSubMix2[sx] = t << 8 | t >>> 24;\n        invSubMix3[sx] = t;\n\n        // Compute next counter\n        if (!x) {\n          x = xi = 1;\n        } else {\n          x = x2 ^ d[d[d[x8 ^ x2]]];\n          xi ^= d[d[xi]];\n        }\n      }\n    }\n  }, {\n    key: 'expandKey',\n    value: function expandKey(keyBuffer) {\n      // convert keyBuffer to Uint32Array\n      var key = this.uint8ArrayToUint32Array_(keyBuffer);\n      var sameKey = true;\n      var offset = 0;\n\n      while (offset < key.length && sameKey) {\n        sameKey = key[offset] === this.key[offset];\n        offset++;\n      }\n\n      if (sameKey) {\n        return;\n      }\n\n      this.key = key;\n      var keySize = this.keySize = key.length;\n\n      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n        throw new Error('Invalid aes key size=' + keySize);\n      }\n\n      var ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n      var ksRow = void 0;\n      var invKsRow = void 0;\n\n      var keySchedule = this.keySchedule = new Uint32Array(this.ksRows);\n      var invKeySchedule = this.invKeySchedule = new Uint32Array(this.ksRows);\n      var sbox = this.sBox;\n      var rcon = this.rcon;\n\n      var invSubMix0 = this.invSubMix[0];\n      var invSubMix1 = this.invSubMix[1];\n      var invSubMix2 = this.invSubMix[2];\n      var invSubMix3 = this.invSubMix[3];\n\n      var prev = void 0;\n      var t = void 0;\n\n      for (ksRow = 0; ksRow < ksRows; ksRow++) {\n        if (ksRow < keySize) {\n          prev = keySchedule[ksRow] = key[ksRow];\n          continue;\n        }\n        t = prev;\n\n        if (ksRow % keySize === 0) {\n          // Rot word\n          t = t << 8 | t >>> 24;\n\n          // Sub word\n          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n\n          // Mix Rcon\n          t ^= rcon[ksRow / keySize | 0] << 24;\n        } else if (keySize > 6 && ksRow % keySize === 4) {\n          // Sub word\n          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n        }\n\n        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n      }\n\n      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n        ksRow = ksRows - invKsRow;\n        if (invKsRow & 3) {\n          t = keySchedule[ksRow];\n        } else {\n          t = keySchedule[ksRow - 4];\n        }\n\n        if (invKsRow < 4 || ksRow <= 4) {\n          invKeySchedule[invKsRow] = t;\n        } else {\n          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n        }\n\n        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n      }\n    }\n\n    // Adding this as a method greatly improves performance.\n\n  }, {\n    key: 'networkToHostOrderSwap',\n    value: function networkToHostOrderSwap(word) {\n      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n    }\n  }, {\n    key: 'decrypt',\n    value: function decrypt(inputArrayBuffer, offset, aesIV) {\n      var nRounds = this.keySize + 6;\n      var invKeySchedule = this.invKeySchedule;\n      var invSBOX = this.invSBox;\n\n      var invSubMix0 = this.invSubMix[0];\n      var invSubMix1 = this.invSubMix[1];\n      var invSubMix2 = this.invSubMix[2];\n      var invSubMix3 = this.invSubMix[3];\n\n      var initVector = this.uint8ArrayToUint32Array_(aesIV);\n      var initVector0 = initVector[0];\n      var initVector1 = initVector[1];\n      var initVector2 = initVector[2];\n      var initVector3 = initVector[3];\n\n      var inputInt32 = new Int32Array(inputArrayBuffer);\n      var outputInt32 = new Int32Array(inputInt32.length);\n\n      var t0 = void 0,\n          t1 = void 0,\n          t2 = void 0,\n          t3 = void 0;\n      var s0 = void 0,\n          s1 = void 0,\n          s2 = void 0,\n          s3 = void 0;\n      var inputWords0 = void 0,\n          inputWords1 = void 0,\n          inputWords2 = void 0,\n          inputWords3 = void 0;\n\n      var ksRow, i;\n\n      while (offset < inputInt32.length) {\n        inputWords0 = this.networkToHostOrderSwap(inputInt32[offset]);\n        inputWords1 = this.networkToHostOrderSwap(inputInt32[offset + 1]);\n        inputWords2 = this.networkToHostOrderSwap(inputInt32[offset + 2]);\n        inputWords3 = this.networkToHostOrderSwap(inputInt32[offset + 3]);\n\n        s0 = inputWords0 ^ invKeySchedule[0];\n        s1 = inputWords3 ^ invKeySchedule[1];\n        s2 = inputWords2 ^ invKeySchedule[2];\n        s3 = inputWords1 ^ invKeySchedule[3];\n\n        ksRow = 4;\n\n        // Iterate through the rounds of decryption\n        for (i = 1; i < nRounds; i++) {\n          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n          // Update state\n          s0 = t0;\n          s1 = t1;\n          s2 = t2;\n          s3 = t3;\n\n          ksRow = ksRow + 4;\n        }\n\n        // Shift rows, sub bytes, add round key\n        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n        ksRow = ksRow + 3;\n\n        // Write\n        outputInt32[offset] = this.networkToHostOrderSwap(t0 ^ initVector0);\n        outputInt32[offset + 1] = this.networkToHostOrderSwap(t3 ^ initVector1);\n        outputInt32[offset + 2] = this.networkToHostOrderSwap(t2 ^ initVector2);\n        outputInt32[offset + 3] = this.networkToHostOrderSwap(t1 ^ initVector3);\n\n        // reset initVector to last 4 unsigned int\n        initVector0 = inputWords0;\n        initVector1 = inputWords1;\n        initVector2 = inputWords2;\n        initVector3 = inputWords3;\n\n        offset = offset + 4;\n      }\n\n      return outputInt32.buffer;\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.key = undefined;\n      this.keySize = undefined;\n      this.ksRows = undefined;\n\n      this.sBox = undefined;\n      this.invSBox = undefined;\n      this.subMix = undefined;\n      this.invSubMix = undefined;\n      this.keySchedule = undefined;\n      this.invKeySchedule = undefined;\n\n      this.rcon = undefined;\n    }\n  }]);\n\n  return AESDecryptor;\n}();\n\nexports.default = AESDecryptor;\n\n},{}],19:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aesCrypto = _dereq_(17);\n\nvar _aesCrypto2 = _interopRequireDefault(_aesCrypto);\n\nvar _fastAesKey = _dereq_(20);\n\nvar _fastAesKey2 = _interopRequireDefault(_fastAesKey);\n\nvar _aesDecryptor = _dereq_(18);\n\nvar _aesDecryptor2 = _interopRequireDefault(_aesDecryptor);\n\nvar _errors = _dereq_(31);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*globals self: false */\n\nvar Decrypter = function () {\n  function Decrypter(observer, config) {\n    _classCallCheck(this, Decrypter);\n\n    this.observer = observer;\n    this.config = config;\n    this.logEnabled = true;\n    try {\n      var browserCrypto = crypto ? crypto : self.crypto;\n      this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n    } catch (e) {}\n    this.disableWebCrypto = !this.subtle;\n  }\n\n  _createClass(Decrypter, [{\n    key: 'isSync',\n    value: function isSync() {\n      return this.disableWebCrypto && this.config.enableSoftwareAES;\n    }\n  }, {\n    key: 'decrypt',\n    value: function decrypt(data, key, iv, callback) {\n      var _this = this;\n\n      if (this.disableWebCrypto && this.config.enableSoftwareAES) {\n        if (this.logEnabled) {\n          _logger.logger.log('JS AES decrypt');\n          this.logEnabled = false;\n        }\n        var decryptor = this.decryptor;\n        if (!decryptor) {\n          this.decryptor = decryptor = new _aesDecryptor2.default();\n        }\n        decryptor.expandKey(key);\n        callback(decryptor.decrypt(data, 0, iv));\n      } else {\n        (function () {\n          if (_this.logEnabled) {\n            _logger.logger.log('WebCrypto AES decrypt');\n            _this.logEnabled = false;\n          }\n          var subtle = _this.subtle;\n          if (_this.key !== key) {\n            _this.key = key;\n            _this.fastAesKey = new _fastAesKey2.default(subtle, key);\n          }\n\n          _this.fastAesKey.expandKey().then(function (aesKey) {\n            // decrypt using web crypto\n            var crypto = new _aesCrypto2.default(subtle, iv);\n            crypto.decrypt(data, aesKey).catch(function (err) {\n              _this.onWebCryptoError(err, data, key, iv, callback);\n            }).then(function (result) {\n              callback(result);\n            });\n          }).catch(function (err) {\n            _this.onWebCryptoError(err, data, key, iv, callback);\n          });\n        })();\n      }\n    }\n  }, {\n    key: 'onWebCryptoError',\n    value: function onWebCryptoError(err, data, key, iv, callback) {\n      if (this.config.enableSoftwareAES) {\n        _logger.logger.log('WebCrypto Error, disable WebCrypto API');\n        this.disableWebCrypto = true;\n        this.logEnabled = true;\n        this.decrypt(data, key, iv, callback);\n      } else {\n        _logger.logger.error('decrypting error : ' + err.message);\n        this.observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      var decryptor = this.decryptor;\n      if (decryptor) {\n        decryptor.destroy();\n        this.decryptor = undefined;\n      }\n    }\n  }]);\n\n  return Decrypter;\n}();\n\nexports.default = Decrypter;\n\n},{\"17\":17,\"18\":18,\"20\":20,\"31\":31,\"50\":50}],20:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FastAESKey = function () {\n  function FastAESKey(subtle, key) {\n    _classCallCheck(this, FastAESKey);\n\n    this.subtle = subtle;\n    this.key = key;\n  }\n\n  _createClass(FastAESKey, [{\n    key: 'expandKey',\n    value: function expandKey() {\n      return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);\n    }\n  }]);\n\n  return FastAESKey;\n}();\n\nexports.default = FastAESKey;\n\n},{}],21:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _adts = _dereq_(22);\n\nvar _adts2 = _interopRequireDefault(_adts);\n\nvar _logger = _dereq_(50);\n\nvar _id = _dereq_(27);\n\nvar _id2 = _interopRequireDefault(_id);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AACDemuxer = function () {\n  function AACDemuxer(observer, remuxer, config) {\n    _classCallCheck(this, AACDemuxer);\n\n    this.observer = observer;\n    this.config = config;\n    this.remuxer = remuxer;\n  }\n\n  _createClass(AACDemuxer, [{\n    key: 'resetInitSegment',\n    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {\n      this._aacTrack = { container: 'audio/adts', type: 'audio', id: -1, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration };\n    }\n  }, {\n    key: 'resetTimeStamp',\n    value: function resetTimeStamp() {}\n  }, {\n    key: 'append',\n\n\n    // feed incoming data to the front of the parsing pipeline\n    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {\n      var track,\n          id3 = new _id2.default(data),\n          pts = 90 * id3.timeStamp,\n          config,\n          frameLength,\n          frameDuration,\n          frameIndex,\n          offset,\n          headerLength,\n          stamp,\n          len,\n          aacSample;\n\n      track = this._aacTrack;\n\n      // look for ADTS header (0xFFFx)\n      for (offset = id3.length, len = data.length; offset < len - 1; offset++) {\n        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {\n          break;\n        }\n      }\n\n      if (!track.audiosamplerate) {\n        config = _adts2.default.getAudioConfig(this.observer, data, offset, track.manifestCodec);\n        track.config = config.config;\n        track.audiosamplerate = config.samplerate;\n        track.channelCount = config.channelCount;\n        track.codec = config.codec;\n        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);\n      }\n      frameIndex = 0;\n      frameDuration = 1024 * 90000 / track.audiosamplerate;\n      while (offset + 5 < len) {\n        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;\n        // retrieve frame size\n        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;\n        frameLength -= headerLength;\n        //stamp = pes.pts;\n\n        if (frameLength > 0 && offset + headerLength + frameLength <= len) {\n          stamp = pts + frameIndex * frameDuration;\n          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);\n          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };\n          track.samples.push(aacSample);\n          track.len += frameLength;\n          offset += frameLength + headerLength;\n          frameIndex++;\n          // look for ADTS header (0xFFFx)\n          for (; offset < len - 1; offset++) {\n            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {\n              break;\n            }\n          }\n        } else {\n          break;\n        }\n      }\n      this.remuxer.remux(track, { samples: [] }, { samples: [{ pts: pts, dts: pts, unit: id3.payload }] }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {}\n  }], [{\n    key: 'probe',\n    value: function probe(data) {\n      // check if data contains ID3 timestamp and ADTS sync worc\n      var id3 = new _id2.default(data),\n          offset,\n          len;\n      if (id3.hasTimeStamp) {\n        // look for ADTS header (0xFFFx)\n        for (offset = id3.length, len = data.length; offset < len - 1; offset++) {\n          if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {\n            //logger.log('ADTS sync word found !');\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n  }]);\n\n  return AACDemuxer;\n}();\n\nexports.default = AACDemuxer;\n\n},{\"22\":22,\"27\":27,\"50\":50}],22:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  ADTS parser helper\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _logger = _dereq_(50);\n\nvar _errors = _dereq_(31);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ADTS = function () {\n  function ADTS() {\n    _classCallCheck(this, ADTS);\n  }\n\n  _createClass(ADTS, null, [{\n    key: 'getAudioConfig',\n    value: function getAudioConfig(observer, data, offset, audioCodec) {\n      var adtsObjectType,\n          // :int\n      adtsSampleingIndex,\n          // :int\n      adtsExtensionSampleingIndex,\n          // :int\n      adtsChanelConfig,\n          // :int\n      config,\n          userAgent = navigator.userAgent.toLowerCase(),\n          manifestCodec = audioCodec,\n          adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n      // byte 2\n      adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;\n      adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;\n      if (adtsSampleingIndex > adtsSampleingRates.length - 1) {\n        observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });\n        return;\n      }\n      adtsChanelConfig = (data[offset + 2] & 0x01) << 2;\n      // byte 3\n      adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;\n      _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);\n      // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n      if (/firefox/i.test(userAgent)) {\n        if (adtsSampleingIndex >= 6) {\n          adtsObjectType = 5;\n          config = new Array(4);\n          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n          // there is a factor 2 between frame sample rate and output sample rate\n          // multiply frequency by 2 (see table below, equivalent to substract 3)\n          adtsExtensionSampleingIndex = adtsSampleingIndex - 3;\n        } else {\n          adtsObjectType = 2;\n          config = new Array(2);\n          adtsExtensionSampleingIndex = adtsSampleingIndex;\n        }\n        // Android : always use AAC\n      } else if (userAgent.indexOf('android') !== -1) {\n        adtsObjectType = 2;\n        config = new Array(2);\n        adtsExtensionSampleingIndex = adtsSampleingIndex;\n      } else {\n        /*  for other browsers (Chrome/Vivaldi/Opera ...)\n            always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n        */\n        adtsObjectType = 5;\n        config = new Array(4);\n        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n        if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {\n          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n          // there is a factor 2 between frame sample rate and output sample rate\n          // multiply frequency by 2 (see table below, equivalent to substract 3)\n          adtsExtensionSampleingIndex = adtsSampleingIndex - 3;\n        } else {\n          // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n          // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n          if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || !audioCodec && adtsChanelConfig === 1) {\n            adtsObjectType = 2;\n            config = new Array(2);\n          }\n          adtsExtensionSampleingIndex = adtsSampleingIndex;\n        }\n      }\n      /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n          ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()\n        Audio Profile / Audio Object Type\n        0: Null\n        1: AAC Main\n        2: AAC LC (Low Complexity)\n        3: AAC SSR (Scalable Sample Rate)\n        4: AAC LTP (Long Term Prediction)\n        5: SBR (Spectral Band Replication)\n        6: AAC Scalable\n       sampling freq\n        0: 96000 Hz\n        1: 88200 Hz\n        2: 64000 Hz\n        3: 48000 Hz\n        4: 44100 Hz\n        5: 32000 Hz\n        6: 24000 Hz\n        7: 22050 Hz\n        8: 16000 Hz\n        9: 12000 Hz\n        10: 11025 Hz\n        11: 8000 Hz\n        12: 7350 Hz\n        13: Reserved\n        14: Reserved\n        15: frequency is written explictly\n        Channel Configurations\n        These are the channel configurations:\n        0: Defined in AOT Specifc Config\n        1: 1 channel: front-center\n        2: 2 channels: front-left, front-right\n      */\n      // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n      config[0] = adtsObjectType << 3;\n      // samplingFrequencyIndex\n      config[0] |= (adtsSampleingIndex & 0x0E) >> 1;\n      config[1] |= (adtsSampleingIndex & 0x01) << 7;\n      // channelConfiguration\n      config[1] |= adtsChanelConfig << 3;\n      if (adtsObjectType === 5) {\n        // adtsExtensionSampleingIndex\n        config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;\n        config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;\n        // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n        config[2] |= 2 << 2;\n        config[3] = 0;\n      }\n      return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType, manifestCodec: manifestCodec };\n    }\n  }]);\n\n  return ADTS;\n}();\n\nexports.default = ADTS;\n\n},{\"31\":31,\"50\":50}],23:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*  inline demuxer.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   probe fragments and instantiate appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _errors = _dereq_(31);\n\nvar _decrypter = _dereq_(19);\n\nvar _decrypter2 = _interopRequireDefault(_decrypter);\n\nvar _aacdemuxer = _dereq_(21);\n\nvar _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);\n\nvar _mp4demuxer = _dereq_(28);\n\nvar _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);\n\nvar _tsdemuxer = _dereq_(30);\n\nvar _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);\n\nvar _mp4Remuxer = _dereq_(43);\n\nvar _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);\n\nvar _passthroughRemuxer = _dereq_(44);\n\nvar _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DemuxerInline = function () {\n  function DemuxerInline(observer, typeSupported, config) {\n    _classCallCheck(this, DemuxerInline);\n\n    this.observer = observer;\n    this.typeSupported = typeSupported;\n    this.config = config;\n  }\n\n  _createClass(DemuxerInline, [{\n    key: 'destroy',\n    value: function destroy() {\n      var demuxer = this.demuxer;\n      if (demuxer) {\n        demuxer.destroy();\n      }\n    }\n  }, {\n    key: 'push',\n    value: function push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {\n      if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {\n        var decrypter = this.decrypter;\n        if (decrypter == null) {\n          decrypter = this.decrypter = new _decrypter2.default(this.observer, this.config);\n        }\n        var localthis = this;\n        // performance.now() not available on WebWorker, at least on Safari Desktop\n        var startTime;\n        try {\n          startTime = performance.now();\n        } catch (error) {\n          startTime = Date.now();\n        }\n        decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {\n          var endTime;\n          try {\n            endTime = performance.now();\n          } catch (error) {\n            endTime = Date.now();\n          }\n          localthis.observer.trigger(_events2.default.FRAG_DECRYPTED, { stats: { tstart: startTime, tdecrypt: endTime } });\n          localthis.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);\n        });\n      } else {\n        this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);\n      }\n    }\n  }, {\n    key: 'pushDecrypted',\n    value: function pushDecrypted(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {\n      var demuxer = this.demuxer;\n      if (!demuxer ||\n      // in case of continuity change, we might switch from content type (AAC container to TS container for example)\n      // so let's check that current demuxer is still valid\n      discontinuity && !this.probe(data)) {\n        var observer = this.observer;\n        var typeSupported = this.typeSupported;\n        var config = this.config;\n        var muxConfig = [{ demux: _tsdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _aacdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp4demuxer2.default, remux: _passthroughRemuxer2.default }];\n\n        // probe for content type\n        for (var i in muxConfig) {\n          var mux = muxConfig[i];\n          var probe = mux.demux.probe;\n          if (probe(data)) {\n            var _remuxer = this.remuxer = new mux.remux(observer, config, typeSupported);\n            demuxer = new mux.demux(observer, _remuxer, config, typeSupported);\n            this.probe = probe;\n            break;\n          }\n        }\n        if (!demuxer) {\n          observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });\n          return;\n        }\n        this.demuxer = demuxer;\n      }\n      var remuxer = this.remuxer;\n\n      if (discontinuity || trackSwitch) {\n        demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);\n        remuxer.resetInitSegment();\n      }\n      if (discontinuity) {\n        demuxer.resetTimeStamp();\n        remuxer.resetTimeStamp(defaultInitPTS);\n      }\n      if (typeof demuxer.setDecryptData === 'function') {\n        demuxer.setDecryptData(decryptdata);\n      }\n      demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);\n    }\n  }]);\n\n  return DemuxerInline;\n}();\n\nexports.default = DemuxerInline;\n\n},{\"19\":19,\"21\":21,\"28\":28,\"30\":30,\"31\":31,\"33\":33,\"43\":43,\"44\":44}],24:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _demuxerInline = _dereq_(23);\n\nvar _demuxerInline2 = _interopRequireDefault(_demuxerInline);\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _logger = _dereq_(50);\n\nvar _events3 = _dereq_(1);\n\nvar _events4 = _interopRequireDefault(_events3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* demuxer web worker.\n *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.\n *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.\n */\n\nvar DemuxerWorker = function DemuxerWorker(self) {\n  // observer setup\n  var observer = new _events4.default();\n  observer.trigger = function trigger(event) {\n    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      data[_key - 1] = arguments[_key];\n    }\n\n    observer.emit.apply(observer, [event, event].concat(data));\n  };\n\n  observer.off = function off(event) {\n    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      data[_key2 - 1] = arguments[_key2];\n    }\n\n    observer.removeListener.apply(observer, [event].concat(data));\n  };\n\n  var forwardMessage = function forwardMessage(ev, data) {\n    self.postMessage({ event: ev, data: data });\n  };\n\n  self.addEventListener('message', function (ev) {\n    var data = ev.data;\n    //console.log('demuxer cmd:' + data.cmd);\n    switch (data.cmd) {\n      case 'init':\n        var config = JSON.parse(data.config);\n        self.demuxer = new _demuxerInline2.default(observer, data.typeSupported, config);\n        try {\n          (0, _logger.enableLogs)(config.debug === true);\n        } catch (err) {\n          console.warn('demuxerWorker: unable to enable logs');\n        }\n        // signal end of worker init\n        forwardMessage('init', null);\n        break;\n      case 'demux':\n        self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);\n        break;\n      default:\n        break;\n    }\n  });\n\n  // forward events to main thread\n  observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);\n  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);\n  observer.on(_events2.default.FRAG_PARSED, forwardMessage);\n  observer.on(_events2.default.ERROR, forwardMessage);\n  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);\n  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);\n  observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);\n\n  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)\n  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {\n    var transferable = [];\n    var message = { event: ev, data: data };\n    if (data.data1) {\n      message.data1 = data.data1.buffer;\n      transferable.push(data.data1.buffer);\n      delete data.data1;\n    }\n    if (data.data2) {\n      message.data2 = data.data2.buffer;\n      transferable.push(data.data2.buffer);\n      delete data.data2;\n    }\n    self.postMessage(message, transferable);\n  });\n};\n\nexports.default = DemuxerWorker;\n\n},{\"1\":1,\"23\":23,\"33\":33,\"50\":50}],25:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _demuxerInline = _dereq_(23);\n\nvar _demuxerInline2 = _interopRequireDefault(_demuxerInline);\n\nvar _demuxerWorker = _dereq_(24);\n\nvar _demuxerWorker2 = _interopRequireDefault(_demuxerWorker);\n\nvar _logger = _dereq_(50);\n\nvar _errors = _dereq_(31);\n\nvar _events3 = _dereq_(1);\n\nvar _events4 = _interopRequireDefault(_events3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Demuxer = function () {\n  function Demuxer(hls, id) {\n    _classCallCheck(this, Demuxer);\n\n    this.hls = hls;\n    this.id = id;\n    // observer setup\n    var observer = this.observer = new _events4.default();\n    var config = hls.config;\n    observer.trigger = function trigger(event) {\n      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        data[_key - 1] = arguments[_key];\n      }\n\n      observer.emit.apply(observer, [event, event].concat(data));\n    };\n\n    observer.off = function off(event) {\n      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        data[_key2 - 1] = arguments[_key2];\n      }\n\n      observer.removeListener.apply(observer, [event].concat(data));\n    };\n\n    var forwardMessage = function (ev, data) {\n      data = data || {};\n      data.frag = this.frag;\n      data.id = this.id;\n      hls.trigger(ev, data);\n    }.bind(this);\n\n    // forward events to main thread\n    observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);\n    observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);\n    observer.on(_events2.default.FRAG_PARSING_DATA, forwardMessage);\n    observer.on(_events2.default.FRAG_PARSED, forwardMessage);\n    observer.on(_events2.default.ERROR, forwardMessage);\n    observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);\n    observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);\n    observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);\n\n    var typeSupported = {\n      mp4: MediaSource.isTypeSupported('video/mp4'),\n      mpeg: MediaSource.isTypeSupported('audio/mpeg'),\n      mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"')\n    };\n    if (config.enableWorker && typeof Worker !== 'undefined') {\n      _logger.logger.log('demuxing in webworker');\n      var w = void 0;\n      try {\n        var work = _dereq_(3);\n        w = this.w = work(_demuxerWorker2.default);\n        this.onwmsg = this.onWorkerMessage.bind(this);\n        w.addEventListener('message', this.onwmsg);\n        w.onerror = function (event) {\n          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });\n        };\n        w.postMessage({ cmd: 'init', typeSupported: typeSupported, id: id, config: JSON.stringify(config) });\n      } catch (err) {\n        _logger.logger.error('error while initializing DemuxerWorker, fallback on DemuxerInline');\n        if (w) {\n          // revoke the Object URL that was used to create demuxer worker, so as not to leak it\n          URL.revokeObjectURL(w.objectURL);\n        }\n        this.demuxer = new _demuxerInline2.default(observer, id, typeSupported, config);\n        this.w = undefined;\n      }\n    } else {\n      this.demuxer = new _demuxerInline2.default(observer, id, typeSupported, config);\n    }\n  }\n\n  _createClass(Demuxer, [{\n    key: 'destroy',\n    value: function destroy() {\n      var w = this.w;\n      if (w) {\n        w.removeEventListener('message', this.onwmsg);\n        w.terminate();\n        this.w = null;\n      } else {\n        var demuxer = this.demuxer;\n        if (demuxer) {\n          demuxer.destroy();\n          this.demuxer = null;\n        }\n      }\n      var observer = this.observer;\n      if (observer) {\n        observer.removeAllListeners();\n        this.observer = null;\n      }\n    }\n  }, {\n    key: 'push',\n    value: function push(data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {\n      var w = this.w;\n      var timeOffset = !isNaN(frag.startDTS) ? frag.startDTS : frag.start;\n      var decryptdata = frag.decryptdata;\n      var lastFrag = this.frag;\n      var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n      var trackSwitch = !(lastFrag && frag.level === lastFrag.level);\n      var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;\n      var contiguous = !discontinuity && !trackSwitch && nextSN;\n      if (discontinuity) {\n        _logger.logger.log(this.id + ':discontinuity detected');\n      }\n      if (trackSwitch) {\n        _logger.logger.log(this.id + ':switch detected');\n      }\n      this.frag = frag;\n      if (w) {\n        // post fragment payload as transferable objects (no copy)\n        w.postMessage({ cmd: 'demux', data: data, decryptdata: decryptdata, initSegment: initSegment, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, discontinuity: discontinuity, trackSwitch: trackSwitch, contiguous: contiguous, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, [data]);\n      } else {\n        var demuxer = this.demuxer;\n        if (demuxer) {\n          demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);\n        }\n      }\n    }\n  }, {\n    key: 'onWorkerMessage',\n    value: function onWorkerMessage(ev) {\n      var data = ev.data,\n          hls = this.hls;\n      //console.log('onWorkerMessage:' + data.event);\n      switch (data.event) {\n        case 'init':\n          // revoke the Object URL that was used to create demuxer worker, so as not to leak it\n          URL.revokeObjectURL(this.w.objectURL);\n          break;\n        // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects\n        case _events2.default.FRAG_PARSING_DATA:\n          data.data.data1 = new Uint8Array(data.data1);\n          if (data.data2) {\n            data.data.data2 = new Uint8Array(data.data2);\n          }\n        /* falls through */\n        default:\n          data.data = data.data || {};\n          data.data.frag = this.frag;\n          data.data.id = this.id;\n          hls.trigger(data.event, data.data);\n          break;\n      }\n    }\n  }]);\n\n  return Demuxer;\n}();\n\nexports.default = Demuxer;\n\n},{\"1\":1,\"23\":23,\"24\":24,\"3\":3,\"31\":31,\"33\":33,\"50\":50}],26:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _logger = _dereq_(50);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ExpGolomb = function () {\n  function ExpGolomb(data) {\n    _classCallCheck(this, ExpGolomb);\n\n    this.data = data;\n    // the number of bytes left to examine in this.data\n    this.bytesAvailable = data.byteLength;\n    // the current word being examined\n    this.word = 0; // :uint\n    // the number of bits left to examine in the current word\n    this.bitsAvailable = 0; // :uint\n  }\n\n  // ():void\n\n\n  _createClass(ExpGolomb, [{\n    key: 'loadWord',\n    value: function loadWord() {\n      var data = this.data,\n          bytesAvailable = this.bytesAvailable,\n          position = data.byteLength - bytesAvailable,\n          workingBytes = new Uint8Array(4),\n          availableBytes = Math.min(4, bytesAvailable);\n      if (availableBytes === 0) {\n        throw new Error('no bytes available');\n      }\n      workingBytes.set(data.subarray(position, position + availableBytes));\n      this.word = new DataView(workingBytes.buffer).getUint32(0);\n      // track the amount of this.data that has been processed\n      this.bitsAvailable = availableBytes * 8;\n      this.bytesAvailable -= availableBytes;\n    }\n\n    // (count:int):void\n\n  }, {\n    key: 'skipBits',\n    value: function skipBits(count) {\n      var skipBytes; // :int\n      if (this.bitsAvailable > count) {\n        this.word <<= count;\n        this.bitsAvailable -= count;\n      } else {\n        count -= this.bitsAvailable;\n        skipBytes = count >> 3;\n        count -= skipBytes >> 3;\n        this.bytesAvailable -= skipBytes;\n        this.loadWord();\n        this.word <<= count;\n        this.bitsAvailable -= count;\n      }\n    }\n\n    // (size:int):uint\n\n  }, {\n    key: 'readBits',\n    value: function readBits(size) {\n      var bits = Math.min(this.bitsAvailable, size),\n          // :uint\n      valu = this.word >>> 32 - bits; // :uint\n      if (size > 32) {\n        _logger.logger.error('Cannot read more than 32 bits at a time');\n      }\n      this.bitsAvailable -= bits;\n      if (this.bitsAvailable > 0) {\n        this.word <<= bits;\n      } else if (this.bytesAvailable > 0) {\n        this.loadWord();\n      }\n      bits = size - bits;\n      if (bits > 0 && this.bitsAvailable) {\n        return valu << bits | this.readBits(bits);\n      } else {\n        return valu;\n      }\n    }\n\n    // ():uint\n\n  }, {\n    key: 'skipLZ',\n    value: function skipLZ() {\n      var leadingZeroCount; // :uint\n      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n        if (0 !== (this.word & 0x80000000 >>> leadingZeroCount)) {\n          // the first bit of working word is 1\n          this.word <<= leadingZeroCount;\n          this.bitsAvailable -= leadingZeroCount;\n          return leadingZeroCount;\n        }\n      }\n      // we exhausted word and still have not found a 1\n      this.loadWord();\n      return leadingZeroCount + this.skipLZ();\n    }\n\n    // ():void\n\n  }, {\n    key: 'skipUEG',\n    value: function skipUEG() {\n      this.skipBits(1 + this.skipLZ());\n    }\n\n    // ():void\n\n  }, {\n    key: 'skipEG',\n    value: function skipEG() {\n      this.skipBits(1 + this.skipLZ());\n    }\n\n    // ():uint\n\n  }, {\n    key: 'readUEG',\n    value: function readUEG() {\n      var clz = this.skipLZ(); // :uint\n      return this.readBits(clz + 1) - 1;\n    }\n\n    // ():int\n\n  }, {\n    key: 'readEG',\n    value: function readEG() {\n      var valu = this.readUEG(); // :int\n      if (0x01 & valu) {\n        // the number is odd if the low order bit is set\n        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n      } else {\n        return -1 * (valu >>> 1); // divide by two then make it negative\n      }\n    }\n\n    // Some convenience functions\n    // :Boolean\n\n  }, {\n    key: 'readBoolean',\n    value: function readBoolean() {\n      return 1 === this.readBits(1);\n    }\n\n    // ():int\n\n  }, {\n    key: 'readUByte',\n    value: function readUByte() {\n      return this.readBits(8);\n    }\n\n    // ():int\n\n  }, {\n    key: 'readUShort',\n    value: function readUShort() {\n      return this.readBits(16);\n    }\n    // ():int\n\n  }, {\n    key: 'readUInt',\n    value: function readUInt() {\n      return this.readBits(32);\n    }\n\n    /**\n     * Advance the ExpGolomb decoder past a scaling list. The scaling\n     * list is optionally transmitted as part of a sequence parameter\n     * set and is not relevant to transmuxing.\n     * @param count {number} the number of entries in this scaling list\n     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n     */\n\n  }, {\n    key: 'skipScalingList',\n    value: function skipScalingList(count) {\n      var lastScale = 8,\n          nextScale = 8,\n          j,\n          deltaScale;\n      for (j = 0; j < count; j++) {\n        if (nextScale !== 0) {\n          deltaScale = this.readEG();\n          nextScale = (lastScale + deltaScale + 256) % 256;\n        }\n        lastScale = nextScale === 0 ? lastScale : nextScale;\n      }\n    }\n\n    /**\n     * Read a sequence parameter set and return some interesting video\n     * properties. A sequence parameter set is the H264 metadata that\n     * describes the properties of upcoming video frames.\n     * @param data {Uint8Array} the bytes of a sequence parameter set\n     * @return {object} an object with configuration parsed from the\n     * sequence parameter set, including the dimensions of the\n     * associated video frames.\n     */\n\n  }, {\n    key: 'readSPS',\n    value: function readSPS() {\n      var frameCropLeftOffset = 0,\n          frameCropRightOffset = 0,\n          frameCropTopOffset = 0,\n          frameCropBottomOffset = 0,\n          profileIdc,\n          profileCompat,\n          levelIdc,\n          numRefFramesInPicOrderCntCycle,\n          picWidthInMbsMinus1,\n          picHeightInMapUnitsMinus1,\n          frameMbsOnlyFlag,\n          scalingListCount,\n          i,\n          readUByte = this.readUByte.bind(this),\n          readBits = this.readBits.bind(this),\n          readUEG = this.readUEG.bind(this),\n          readBoolean = this.readBoolean.bind(this),\n          skipBits = this.skipBits.bind(this),\n          skipEG = this.skipEG.bind(this),\n          skipUEG = this.skipUEG.bind(this),\n          skipScalingList = this.skipScalingList.bind(this);\n\n      readUByte();\n      profileIdc = readUByte(); // profile_idc\n      profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)\n      skipBits(3); // reserved_zero_3bits u(3),\n      levelIdc = readUByte(); //level_idc u(8)\n      skipUEG(); // seq_parameter_set_id\n      // some profiles have more optional data we don't need\n      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n        var chromaFormatIdc = readUEG();\n        if (chromaFormatIdc === 3) {\n          skipBits(1); // separate_colour_plane_flag\n        }\n        skipUEG(); // bit_depth_luma_minus8\n        skipUEG(); // bit_depth_chroma_minus8\n        skipBits(1); // qpprime_y_zero_transform_bypass_flag\n        if (readBoolean()) {\n          // seq_scaling_matrix_present_flag\n          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n          for (i = 0; i < scalingListCount; i++) {\n            if (readBoolean()) {\n              // seq_scaling_list_present_flag[ i ]\n              if (i < 6) {\n                skipScalingList(16);\n              } else {\n                skipScalingList(64);\n              }\n            }\n          }\n        }\n      }\n      skipUEG(); // log2_max_frame_num_minus4\n      var picOrderCntType = readUEG();\n      if (picOrderCntType === 0) {\n        readUEG(); //log2_max_pic_order_cnt_lsb_minus4\n      } else if (picOrderCntType === 1) {\n        skipBits(1); // delta_pic_order_always_zero_flag\n        skipEG(); // offset_for_non_ref_pic\n        skipEG(); // offset_for_top_to_bottom_field\n        numRefFramesInPicOrderCntCycle = readUEG();\n        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n          skipEG(); // offset_for_ref_frame[ i ]\n        }\n      }\n      skipUEG(); // max_num_ref_frames\n      skipBits(1); // gaps_in_frame_num_value_allowed_flag\n      picWidthInMbsMinus1 = readUEG();\n      picHeightInMapUnitsMinus1 = readUEG();\n      frameMbsOnlyFlag = readBits(1);\n      if (frameMbsOnlyFlag === 0) {\n        skipBits(1); // mb_adaptive_frame_field_flag\n      }\n      skipBits(1); // direct_8x8_inference_flag\n      if (readBoolean()) {\n        // frame_cropping_flag\n        frameCropLeftOffset = readUEG();\n        frameCropRightOffset = readUEG();\n        frameCropTopOffset = readUEG();\n        frameCropBottomOffset = readUEG();\n      }\n      var pixelRatio = [1, 1];\n      if (readBoolean()) {\n        // vui_parameters_present_flag\n        if (readBoolean()) {\n          // aspect_ratio_info_present_flag\n          var aspectRatioIdc = readUByte();\n          switch (aspectRatioIdc) {\n            case 1:\n              pixelRatio = [1, 1];break;\n            case 2:\n              pixelRatio = [12, 11];break;\n            case 3:\n              pixelRatio = [10, 11];break;\n            case 4:\n              pixelRatio = [16, 11];break;\n            case 5:\n              pixelRatio = [40, 33];break;\n            case 6:\n              pixelRatio = [24, 11];break;\n            case 7:\n              pixelRatio = [20, 11];break;\n            case 8:\n              pixelRatio = [32, 11];break;\n            case 9:\n              pixelRatio = [80, 33];break;\n            case 10:\n              pixelRatio = [18, 11];break;\n            case 11:\n              pixelRatio = [15, 11];break;\n            case 12:\n              pixelRatio = [64, 33];break;\n            case 13:\n              pixelRatio = [160, 99];break;\n            case 14:\n              pixelRatio = [4, 3];break;\n            case 15:\n              pixelRatio = [3, 2];break;\n            case 16:\n              pixelRatio = [2, 1];break;\n            case 255:\n              {\n                pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n                break;\n              }\n          }\n        }\n      }\n      return {\n        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n        pixelRatio: pixelRatio\n      };\n    }\n  }, {\n    key: 'readSliceType',\n    value: function readSliceType() {\n      // skip NALu type\n      this.readUByte();\n      // discard first_mb_in_slice\n      this.readUEG();\n      // return slice_type\n      return this.readUEG();\n    }\n  }]);\n\n  return ExpGolomb;\n}();\n\nexports.default = ExpGolomb;\n\n},{\"50\":50}],27:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ID3 parser\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _logger = _dereq_(50);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//import Hex from '../utils/hex';\n\nvar ID3 = function () {\n  function ID3(data) {\n    _classCallCheck(this, ID3);\n\n    this._hasTimeStamp = false;\n    var offset = 0,\n        byte1,\n        byte2,\n        byte3,\n        byte4,\n        tagSize,\n        endPos,\n        header,\n        len;\n    do {\n      header = this.readUTF(data, offset, 3);\n      offset += 3;\n      // first check for ID3 header\n      if (header === 'ID3') {\n        // skip 24 bits\n        offset += 3;\n        // retrieve tag(s) length\n        byte1 = data[offset++] & 0x7f;\n        byte2 = data[offset++] & 0x7f;\n        byte3 = data[offset++] & 0x7f;\n        byte4 = data[offset++] & 0x7f;\n        tagSize = (byte1 << 21) + (byte2 << 14) + (byte3 << 7) + byte4;\n        endPos = offset + tagSize;\n        //logger.log(`ID3 tag found, size/end: ${tagSize}/${endPos}`);\n\n        // read ID3 tags\n        this._parseID3Frames(data, offset, endPos);\n        offset = endPos;\n      } else if (header === '3DI') {\n        // http://id3.org/id3v2.4.0-structure chapter 3.4.   ID3v2 footer\n        offset += 7;\n        _logger.logger.log('3DI footer found, end: ' + offset);\n      } else {\n        offset -= 3;\n        len = offset;\n        if (len) {\n          //logger.log(`ID3 len: ${len}`);\n          if (!this.hasTimeStamp) {\n            _logger.logger.warn('ID3 tag found, but no timestamp');\n          }\n          this._length = len;\n          this._payload = data.subarray(0, len);\n        }\n        return;\n      }\n    } while (true);\n  }\n\n  _createClass(ID3, [{\n    key: 'readUTF',\n    value: function readUTF(data, start, len) {\n\n      var result = '',\n          offset = start,\n          end = start + len;\n      do {\n        result += String.fromCharCode(data[offset++]);\n      } while (offset < end);\n      return result;\n    }\n  }, {\n    key: '_parseID3Frames',\n    value: function _parseID3Frames(data, offset, endPos) {\n      var tagId, tagLen, tagStart, tagFlags, timestamp;\n      while (offset + 8 <= endPos) {\n        tagId = this.readUTF(data, offset, 4);\n        offset += 4;\n\n        tagLen = data[offset++] << 24 + data[offset++] << 16 + data[offset++] << 8 + data[offset++];\n\n        tagFlags = data[offset++] << 8 + data[offset++];\n\n        tagStart = offset;\n        //logger.log(\"ID3 tag id:\" + tagId);\n        switch (tagId) {\n          case 'PRIV':\n            //logger.log('parse frame:' + Hex.hexDump(data.subarray(offset,endPos)));\n            // owner should be \"com.apple.streaming.transportStreamTimestamp\"\n            if (this.readUTF(data, offset, 44) === 'com.apple.streaming.transportStreamTimestamp') {\n              offset += 44;\n              // smelling even better ! we found the right descriptor\n              // skip null character (string end) + 3 first bytes\n              offset += 4;\n\n              // timestamp is 33 bit expressed as a big-endian eight-octet number, with the upper 31 bits set to zero.\n              var pts33Bit = data[offset++] & 0x1;\n              this._hasTimeStamp = true;\n\n              timestamp = ((data[offset++] << 23) + (data[offset++] << 15) + (data[offset++] << 7) + data[offset++]) / 45;\n\n              if (pts33Bit) {\n                timestamp += 47721858.84; // 2^32 / 90\n              }\n              timestamp = Math.round(timestamp);\n              _logger.logger.trace('ID3 timestamp found: ' + timestamp);\n              this._timeStamp = timestamp;\n            }\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  }, {\n    key: 'hasTimeStamp',\n    get: function get() {\n      return this._hasTimeStamp;\n    }\n  }, {\n    key: 'timeStamp',\n    get: function get() {\n      return this._timeStamp;\n    }\n  }, {\n    key: 'length',\n    get: function get() {\n      return this._length;\n    }\n  }, {\n    key: 'payload',\n    get: function get() {\n      return this._payload;\n    }\n  }]);\n\n  return ID3;\n}();\n\nexports.default = ID3;\n\n},{\"50\":50}],28:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP4 demuxer\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n//import {logger} from '../utils/logger';\n\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MP4Demuxer = function () {\n  function MP4Demuxer(observer, remuxer) {\n    _classCallCheck(this, MP4Demuxer);\n\n    this.observer = observer;\n    this.remuxer = remuxer;\n  }\n\n  _createClass(MP4Demuxer, [{\n    key: 'resetTimeStamp',\n    value: function resetTimeStamp() {}\n  }, {\n    key: 'resetInitSegment',\n    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {\n      //jshint unused:false\n      var initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);\n      var tracks = {};\n      if (initData.audio) {\n        tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: initSegment };\n      }\n      if (initData.video) {\n        tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: initSegment };\n      }\n      this.observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, { unique: false, tracks: tracks });\n    }\n  }, {\n    key: 'append',\n\n\n    // feed incoming data to the front of the parsing pipeline\n    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {\n      var initData = this.initData;\n      var startDTS = MP4Demuxer.startDTS(initData, data);\n      this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {}\n  }], [{\n    key: 'probe',\n    value: function probe(data) {\n      if (data.length >= 8) {\n        var dataType = MP4Demuxer.bin2str(data.subarray(4, 8));\n        return ['moof', 'ftyp', 'styp'].indexOf(dataType) >= 0;\n      }\n      return false;\n    }\n  }, {\n    key: 'bin2str',\n    value: function bin2str(buffer) {\n      return String.fromCharCode.apply(null, buffer);\n    }\n\n    // Find the data for a box specified by its path\n\n  }, {\n    key: 'findBox',\n    value: function findBox(data, path) {\n      var results = [],\n          i,\n          size,\n          type,\n          end,\n          subresults;\n\n      if (!path.length) {\n        // short-circuit the search for empty paths\n        return null;\n      }\n\n      for (i = 0; i < data.byteLength;) {\n        size = data[i] << 24;\n        size |= data[i + 1] << 16;\n        size |= data[i + 2] << 8;\n        size |= data[i + 3];\n\n        type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));\n\n        end = size > 1 ? i + size : data.byteLength;\n\n        if (type === path[0]) {\n          if (path.length === 1) {\n            // this is the end of the path and we've found the box we were\n            // looking for\n            results.push(data.subarray(i + 8, end));\n          } else {\n            // recursively search for the next box along the path\n            subresults = MP4Demuxer.findBox(data.subarray(i + 8, end), path.slice(1));\n            if (subresults.length) {\n              results = results.concat(subresults);\n            }\n          }\n        }\n        i = end;\n      }\n\n      // we've finished searching all of data\n      return results;\n    }\n\n    /**\n     * Parses an MP4 initialization segment and extracts stream type and\n     * timescale values for any declared tracks. Timescale values indicate the\n     * number of clock ticks per second to assume for time-based values\n     * elsewhere in the MP4.\n     *\n     * To determine the start time of an MP4, you need two pieces of\n     * information: the timescale unit and the earliest base media decode\n     * time. Multiple timescales can be specified within an MP4 but the\n     * base media decode time is always expressed in the timescale from\n     * the media header box for the track:\n     * ```\n     * moov > trak > mdia > mdhd.timescale\n     * moov > trak > mdia > hdlr\n     * ```\n     * @param init {Uint8Array} the bytes of the init segment\n     * @return {object} a hash of track type to timescale values or null if\n     * the init segment is malformed.\n     */\n\n  }, {\n    key: 'parseInitSegment',\n    value: function parseInitSegment(initSegment) {\n      var result = [];\n      var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);\n\n      traks.forEach(function (trak) {\n        var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];\n        if (tkhd) {\n          var version = tkhd[0];\n          var index = version === 0 ? 12 : 20;\n          var trackId = tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3];\n\n          trackId = trackId < 0 ? 4294967296 + trackId : trackId;\n\n          var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];\n          if (mdhd) {\n            version = mdhd[0];\n            index = version === 0 ? 12 : 20;\n            var timescale = mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3];\n\n            var hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];\n            if (hdlr) {\n              var hdlrType = MP4Demuxer.bin2str(hdlr.subarray(8, 12));\n              var type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];\n              if (type) {\n                result[trackId] = { timescale: timescale, type: type };\n                result[type] = { timescale: timescale, id: trackId };\n              }\n            }\n          }\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Determine the base media decode start time, in seconds, for an MP4\n     * fragment. If multiple fragments are specified, the earliest time is\n     * returned.\n     *\n     * The base media decode time can be parsed from track fragment\n     * metadata:\n     * ```\n     * moof > traf > tfdt.baseMediaDecodeTime\n     * ```\n     * It requires the timescale value from the mdhd to interpret.\n     *\n     * @param timescale {object} a hash of track ids to timescale values.\n     * @return {number} the earliest base media decode start time for the\n     * fragment, in seconds\n     */\n\n  }, {\n    key: 'startDTS',\n    value: function startDTS(initData, fragment) {\n      var trafs, baseTimes, result;\n\n      // we need info from two childrend of each track fragment box\n      trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);\n\n      // determine the start times for each track\n      baseTimes = [].concat.apply([], trafs.map(function (traf) {\n        return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {\n          var id, scale, baseTime;\n\n          // get the track id from the tfhd\n          id = tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7];\n          // assume a 90kHz clock if no timescale was specified\n          scale = initData[id].timescale || 90e3;\n\n          // get the base media decode time from the tfdt\n          baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {\n            var version, result;\n\n            version = tfdt[0];\n            result = tfdt[4] << 24 | tfdt[5] << 16 | tfdt[6] << 8 | tfdt[7];\n            if (version === 1) {\n              result *= Math.pow(2, 32);\n              result += tfdt[8] << 24 | tfdt[9] << 16 | tfdt[10] << 8 | tfdt[11];\n            }\n            return result;\n          })[0];\n          baseTime = baseTime || Infinity;\n\n          // convert base time to seconds\n          return baseTime / scale;\n        });\n      }));\n\n      // return the minimum\n      result = Math.min.apply(null, baseTimes);\n      return isFinite(result) ? result : 0;\n    }\n  }]);\n\n  return MP4Demuxer;\n}();\n\nexports.default = MP4Demuxer;\n\n},{\"33\":33}],29:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SAMPLE-AES decrypter\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _decrypter = _dereq_(19);\n\nvar _decrypter2 = _interopRequireDefault(_decrypter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SampleAesDecrypter = function () {\n  function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {\n    _classCallCheck(this, SampleAesDecrypter);\n\n    this.decryptdata = decryptdata;\n    this.discardEPB = discardEPB;\n    this.decrypter = new _decrypter2.default(observer, config);\n  }\n\n  _createClass(SampleAesDecrypter, [{\n    key: 'decryptBuffer',\n    value: function decryptBuffer(encryptedData, callback) {\n      this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);\n    }\n\n    // AAC - encrypt all full 16 bytes blocks starting from offset 16\n\n  }, {\n    key: 'decryptAacSample',\n    value: function decryptAacSample(samples, sampleIndex, callback, sync) {\n      var curUnit = samples[sampleIndex].unit;\n      var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n      var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n\n      var localthis = this;\n      this.decryptBuffer(encryptedBuffer, function (decryptedData) {\n        decryptedData = new Uint8Array(decryptedData);\n        curUnit.set(decryptedData, 16);\n\n        if (!sync) {\n          localthis.decryptAacSamples(samples, sampleIndex + 1, callback);\n        }\n      });\n    }\n  }, {\n    key: 'decryptAacSamples',\n    value: function decryptAacSamples(samples, sampleIndex, callback) {\n      for (;; sampleIndex++) {\n        if (sampleIndex >= samples.length) {\n          callback();\n          return;\n        }\n\n        if (samples[sampleIndex].unit.length < 32) {\n          continue;\n        }\n\n        var sync = this.decrypter.isSync();\n\n        this.decryptAacSample(samples, sampleIndex, callback, sync);\n\n        if (!sync) {\n          return;\n        }\n      }\n    }\n\n    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n\n  }, {\n    key: 'getAvcEncryptedData',\n    value: function getAvcEncryptedData(decodedData) {\n      var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n      var encryptedData = new Int8Array(encryptedDataLen);\n      var outputPos = 0;\n      for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {\n        encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n      }\n      return encryptedData;\n    }\n  }, {\n    key: 'getAvcDecryptedUnit',\n    value: function getAvcDecryptedUnit(decodedData, decryptedData) {\n      decryptedData = new Uint8Array(decryptedData);\n      var inputPos = 0;\n      for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {\n        decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);\n      }\n      return decodedData;\n    }\n  }, {\n    key: 'decryptAvcSample',\n    value: function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {\n      var decodedData = this.discardEPB(curUnit.data);\n      var encryptedData = this.getAvcEncryptedData(decodedData);\n      var localthis = this;\n\n      this.decryptBuffer(encryptedData.buffer, function (decryptedData) {\n        curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);\n\n        if (!sync) {\n          localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n        }\n      });\n    }\n  }, {\n    key: 'decryptAvcSamples',\n    value: function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n      for (;; sampleIndex++, unitIndex = 0) {\n        if (sampleIndex >= samples.length) {\n          callback();\n          return;\n        }\n\n        var curUnits = samples[sampleIndex].units.units;\n        for (;; unitIndex++) {\n          if (unitIndex >= curUnits.length) {\n            break;\n          }\n\n          var curUnit = curUnits[unitIndex];\n          if (curUnit.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n            continue;\n          }\n\n          var sync = this.decrypter.isSync();\n\n          this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);\n\n          if (!sync) {\n            return;\n          }\n        }\n      }\n    }\n  }]);\n\n  return SampleAesDecrypter;\n}();\n\nexports.default = SampleAesDecrypter;\n\n},{\"19\":19}],30:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\n// import Hex from '../utils/hex';\n\n\nvar _adts = _dereq_(22);\n\nvar _adts2 = _interopRequireDefault(_adts);\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _expGolomb = _dereq_(26);\n\nvar _expGolomb2 = _interopRequireDefault(_expGolomb);\n\nvar _sampleAes = _dereq_(29);\n\nvar _sampleAes2 = _interopRequireDefault(_sampleAes);\n\nvar _logger = _dereq_(50);\n\nvar _errors = _dereq_(31);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TSDemuxer = function () {\n  function TSDemuxer(observer, remuxer, config, typeSupported) {\n    _classCallCheck(this, TSDemuxer);\n\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.remuxer = remuxer;\n    this.sampleAes = null;\n  }\n\n  _createClass(TSDemuxer, [{\n    key: 'setDecryptData',\n    value: function setDecryptData(decryptdata) {\n      if (decryptdata != null && decryptdata.key != null && decryptdata.method === 'SAMPLE-AES') {\n        this.sampleAes = new _sampleAes2.default(this.observer, this.config, decryptdata, this.discardEPB);\n      } else {\n        this.sampleAes = null;\n      }\n    }\n  }, {\n    key: 'resetInitSegment',\n    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {\n      this.pmtParsed = false;\n      this._pmtId = -1;\n      this._avcTrack = { container: 'video/mp2t', type: 'video', id: -1, sequenceNumber: 0, samples: [], len: 0, dropped: 0 };\n      this._audioTrack = { container: 'video/mp2t', type: 'audio', id: -1, sequenceNumber: 0, samples: [], len: 0, isAAC: true };\n      this._id3Track = { type: 'id3', id: -1, sequenceNumber: 0, samples: [], len: 0 };\n      this._txtTrack = { type: 'text', id: -1, sequenceNumber: 0, samples: [], len: 0 };\n      // flush any partial content\n      this.aacOverFlow = null;\n      this.aacLastPTS = null;\n      this.avcSample = null;\n      this.audioCodec = audioCodec;\n      this.videoCodec = videoCodec;\n      this._duration = duration;\n    }\n  }, {\n    key: 'resetTimeStamp',\n    value: function resetTimeStamp() {}\n\n    // feed incoming data to the front of the parsing pipeline\n\n  }, {\n    key: 'append',\n    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {\n      var start,\n          len = data.length,\n          stt,\n          pid,\n          atf,\n          offset,\n          pes,\n          unknownPIDs = false;\n      this.contiguous = contiguous;\n      var pmtParsed = this.pmtParsed,\n          avcTrack = this._avcTrack,\n          audioTrack = this._audioTrack,\n          id3Track = this._id3Track,\n          avcId = avcTrack.id,\n          audioId = audioTrack.id,\n          id3Id = id3Track.id,\n          pmtId = this._pmtId,\n          avcData = avcTrack.pesData,\n          audioData = audioTrack.pesData,\n          id3Data = id3Track.pesData,\n          parsePAT = this._parsePAT,\n          parsePMT = this._parsePMT,\n          parsePES = this._parsePES,\n          parseAVCPES = this._parseAVCPES.bind(this),\n          parseAACPES = this._parseAACPES.bind(this),\n          parseMPEGPES = this._parseMPEGPES.bind(this),\n          parseID3PES = this._parseID3PES.bind(this);\n\n      // don't parse last TS packet if incomplete\n      len -= len % 188;\n      // loop through TS packets\n      for (start = 0; start < len; start += 188) {\n        if (data[start] === 0x47) {\n          stt = !!(data[start + 1] & 0x40);\n          // pid is a 13-bit field starting at the last bit of TS[1]\n          pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];\n          atf = (data[start + 3] & 0x30) >> 4;\n          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n          if (atf > 1) {\n            offset = start + 5 + data[start + 4];\n            // continue if there is only adaptation field\n            if (offset === start + 188) {\n              continue;\n            }\n          } else {\n            offset = start + 4;\n          }\n          switch (pid) {\n            case avcId:\n              if (stt) {\n                if (avcData && (pes = parsePES(avcData))) {\n                  parseAVCPES(pes, false);\n                }\n                avcData = { data: [], size: 0 };\n              }\n              if (avcData) {\n                avcData.data.push(data.subarray(offset, start + 188));\n                avcData.size += start + 188 - offset;\n              }\n              break;\n            case audioId:\n              if (stt) {\n                if (audioData && (pes = parsePES(audioData))) {\n                  if (audioTrack.isAAC) {\n                    parseAACPES(pes);\n                  } else {\n                    parseMPEGPES(pes);\n                  }\n                }\n                audioData = { data: [], size: 0 };\n              }\n              if (audioData) {\n                audioData.data.push(data.subarray(offset, start + 188));\n                audioData.size += start + 188 - offset;\n              }\n              break;\n            case id3Id:\n              if (stt) {\n                if (id3Data && (pes = parsePES(id3Data))) {\n                  parseID3PES(pes);\n                }\n                id3Data = { data: [], size: 0 };\n              }\n              if (id3Data) {\n                id3Data.data.push(data.subarray(offset, start + 188));\n                id3Data.size += start + 188 - offset;\n              }\n              break;\n            case 0:\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n              pmtId = this._pmtId = parsePAT(data, offset);\n              break;\n            case pmtId:\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n              var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);\n\n              // only update track id if track PID found while parsing PMT\n              // this is to avoid resetting the PID to -1 in case\n              // track PID transiently disappears from the stream\n              // this could happen in case of transient missing audio samples for example\n              avcId = parsedPIDs.avc;\n              if (avcId > 0) {\n                avcTrack.id = avcId;\n              }\n              audioId = parsedPIDs.audio;\n              if (audioId > 0) {\n                audioTrack.id = audioId;\n                audioTrack.isAAC = parsedPIDs.isAAC;\n              }\n              id3Id = parsedPIDs.id3;\n              if (id3Id > 0) {\n                id3Track.id = id3Id;\n              }\n              if (unknownPIDs && !pmtParsed) {\n                _logger.logger.log('reparse from beginning');\n                unknownPIDs = false;\n                // we set it to -188, the += 188 in the for loop will reset start to 0\n                start = -188;\n              }\n              pmtParsed = this.pmtParsed = true;\n              break;\n            case 17:\n            case 0x1fff:\n              break;\n            default:\n              unknownPIDs = true;\n              break;\n          }\n        } else {\n          this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });\n        }\n      }\n      // try to parse last PES packets\n      if (avcData && (pes = parsePES(avcData))) {\n        parseAVCPES(pes, true);\n        avcTrack.pesData = null;\n      } else {\n        // either avcData null or PES truncated, keep it for next frag parsing\n        avcTrack.pesData = avcData;\n      }\n\n      if (audioData && (pes = parsePES(audioData))) {\n        if (audioTrack.isAAC) {\n          parseAACPES(pes);\n        } else {\n          parseMPEGPES(pes);\n        }\n        audioTrack.pesData = null;\n      } else {\n        if (audioData && audioData.size) {\n          _logger.logger.log('last AAC PES packet truncated,might overlap between fragments');\n        }\n        // either audioData null or PES truncated, keep it for next frag parsing\n        audioTrack.pesData = audioData;\n      }\n\n      if (id3Data && (pes = parsePES(id3Data))) {\n        parseID3PES(pes);\n        id3Track.pesData = null;\n      } else {\n        // either id3Data null or PES truncated, keep it for next frag parsing\n        id3Track.pesData = id3Data;\n      }\n\n      if (this.sampleAes == null) {\n        this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);\n      } else {\n        this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);\n      }\n    }\n  }, {\n    key: 'decryptAndRemux',\n    value: function decryptAndRemux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {\n      var _this = this;\n\n      if (audioTrack.samples && audioTrack.isAAC) {\n        (function () {\n          var localthis = _this;\n          _this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {\n            localthis.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);\n          });\n        })();\n      } else {\n        this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);\n      }\n    }\n  }, {\n    key: 'decryptAndRemuxAvc',\n    value: function decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {\n      var _this2 = this;\n\n      if (videoTrack.samples) {\n        (function () {\n          var localthis = _this2;\n          _this2.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n            localthis.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);\n          });\n        })();\n      } else {\n        this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this._initPTS = this._initDTS = undefined;\n      this._duration = 0;\n    }\n  }, {\n    key: '_parsePAT',\n    value: function _parsePAT(data, offset) {\n      // skip the PSI header and parse the first PMT entry\n      return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];\n      //logger.log('PMT PID:'  + this._pmtId);\n    }\n  }, {\n    key: '_parsePMT',\n    value: function _parsePMT(data, offset, mpegSupported, isSampleAes) {\n      var sectionLength,\n          tableEnd,\n          programInfoLength,\n          pid,\n          result = { audio: -1, avc: -1, id3: -1, isAAC: true };\n      sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n      tableEnd = offset + 3 + sectionLength - 4;\n      // to determine where the table is, we have to figure out how\n      // long the program info descriptors are\n      programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n      // advance the offset to the first entry in the mapping table\n      offset += 12 + programInfoLength;\n      while (offset < tableEnd) {\n        pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];\n        switch (data[offset]) {\n          case 0xcf:\n            // SAMPLE-AES AAC\n            if (!isSampleAes) {\n              _logger.logger.log('unkown stream type:' + data[offset]);\n              break;\n            }\n          /* falls through */\n\n          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n          case 0x0f:\n            //logger.log('AAC PID:'  + pid);\n            if (result.audio === -1) {\n              result.audio = pid;\n            }\n            break;\n\n          // Packetized metadata (ID3)\n          case 0x15:\n            //logger.log('ID3 PID:'  + pid);\n            if (result.id3 === -1) {\n              result.id3 = pid;\n            }\n            break;\n\n          case 0xdb:\n            // SAMPLE-AES AVC\n            if (!isSampleAes) {\n              _logger.logger.log('unkown stream type:' + data[offset]);\n              break;\n            }\n          /* falls through */\n\n          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n          case 0x1b:\n            //logger.log('AVC PID:'  + pid);\n            if (result.avc === -1) {\n              result.avc = pid;\n            }\n            break;\n\n          // ISO/IEC 11172-3 (MPEG-1 audio)\n          // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n          case 0x03:\n          case 0x04:\n            //logger.log('MPEG PID:'  + pid);\n            if (!mpegSupported) {\n              _logger.logger.log('MPEG audio found, not supported in this browser for now');\n            } else if (result.audio === -1) {\n              result.audio = pid;\n              result.isAAC = false;\n            }\n            break;\n\n          case 0x24:\n            _logger.logger.warn('HEVC stream type found, not supported for now');\n            break;\n\n          default:\n            _logger.logger.log('unkown stream type:' + data[offset]);\n            break;\n        }\n        // move to the next table entry\n        // skip past the elementary stream descriptors, if present\n        offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;\n      }\n      return result;\n    }\n  }, {\n    key: '_parsePES',\n    value: function _parsePES(stream) {\n      var i = 0,\n          frag,\n          pesFlags,\n          pesPrefix,\n          pesLen,\n          pesHdrLen,\n          pesData,\n          pesPts,\n          pesDts,\n          payloadStartOffset,\n          data = stream.data;\n      // safety check\n      if (!stream || stream.size === 0) {\n        return null;\n      }\n\n      // we might need up to 19 bytes to read PES header\n      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n      // usually only one merge is needed (and this is rare ...)\n      while (data[0].length < 19 && data.length > 1) {\n        var newData = new Uint8Array(data[0].length + data[1].length);\n        newData.set(data[0]);\n        newData.set(data[1], data[0].length);\n        data[0] = newData;\n        data.splice(1, 1);\n      }\n      //retrieve PTS/DTS from first fragment\n      frag = data[0];\n      pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n      if (pesPrefix === 1) {\n        pesLen = (frag[4] << 8) + frag[5];\n        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n        // minus 6 : PES header size\n        if (pesLen && pesLen > stream.size - 6) {\n          return null;\n        }\n        pesFlags = frag[7];\n        if (pesFlags & 0xC0) {\n          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n              as Bitwise operators treat their operands as a sequence of 32 bits */\n          pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29\n          (frag[10] & 0xFF) * 4194304 + // 1 << 22\n          (frag[11] & 0xFE) * 16384 + // 1 << 14\n          (frag[12] & 0xFF) * 128 + // 1 << 7\n          (frag[13] & 0xFE) / 2;\n          // check if greater than 2^32 -1\n          if (pesPts > 4294967295) {\n            // decrement 2^33\n            pesPts -= 8589934592;\n          }\n          if (pesFlags & 0x40) {\n            pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29\n            (frag[15] & 0xFF) * 4194304 + // 1 << 22\n            (frag[16] & 0xFE) * 16384 + // 1 << 14\n            (frag[17] & 0xFF) * 128 + // 1 << 7\n            (frag[18] & 0xFE) / 2;\n            // check if greater than 2^32 -1\n            if (pesDts > 4294967295) {\n              // decrement 2^33\n              pesDts -= 8589934592;\n            }\n            if (pesPts - pesDts > 60 * 90000) {\n              _logger.logger.warn(Math.round((pesPts - pesDts) / 90000) + 's delta between PTS and DTS, align them');\n              pesPts = pesDts;\n            }\n          } else {\n            pesDts = pesPts;\n          }\n        }\n        pesHdrLen = frag[8];\n        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n        payloadStartOffset = pesHdrLen + 9;\n\n        stream.size -= payloadStartOffset;\n        //reassemble PES packet\n        pesData = new Uint8Array(stream.size);\n        for (var j = 0, dataLen = data.length; j < dataLen; j++) {\n          frag = data[j];\n          var len = frag.byteLength;\n          if (payloadStartOffset) {\n            if (payloadStartOffset > len) {\n              // trim full frag if PES header bigger than frag\n              payloadStartOffset -= len;\n              continue;\n            } else {\n              // trim partial frag if PES header smaller than frag\n              frag = frag.subarray(payloadStartOffset);\n              len -= payloadStartOffset;\n              payloadStartOffset = 0;\n            }\n          }\n          pesData.set(frag, i);\n          i += len;\n        }\n        if (pesLen) {\n          // payload size : remove PES header + PES extension\n          pesLen -= pesHdrLen + 3;\n        }\n        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: 'pushAccesUnit',\n    value: function pushAccesUnit(avcSample, avcTrack) {\n      if (avcSample.units.units.length && avcSample.frame) {\n        // only push AVC sample if starting with a keyframe is not mandatory OR\n        //    if keyframe already found in this fragment OR\n        //       keyframe found in last fragment (track.sps) AND\n        //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous\n        if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (avcTrack.samples.length || this.contiguous)) {\n          avcTrack.samples.push(avcSample);\n        } else {\n          // dropped samples, track it\n          avcTrack.dropped++;\n        }\n      }\n      if (avcSample.debug.length) {\n        _logger.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug + ',' + avcSample.units.length);\n      }\n    }\n  }, {\n    key: '_parseAVCPES',\n    value: function _parseAVCPES(pes, last) {\n      var _this3 = this;\n\n      //logger.log('parse new PES');\n      var track = this._avcTrack,\n          units = this._parseAVCNALu(pes.data),\n          debug = false,\n          expGolombDecoder,\n          avcSample = this.avcSample,\n          push,\n          i;\n      //free pes.data to save up some memory\n      pes.data = null;\n\n      units.forEach(function (unit) {\n        switch (unit.type) {\n          //NDR\n          case 1:\n            push = true;\n            if (debug && avcSample) {\n              avcSample.debug += 'NDR ';\n            }\n            avcSample.frame = true;\n            // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n            var data = unit.data;\n            if (data.length > 4) {\n              var sliceType = new _expGolomb2.default(data).readSliceType();\n              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n              //if (sliceType === 2 || sliceType === 7) {\n              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                avcSample.key = true;\n              }\n            }\n            break;\n          //IDR\n          case 5:\n            push = true;\n            // handle PES not starting with AUD\n            if (!avcSample) {\n              avcSample = _this3.avcSample = _this3._createAVCSample(true, pes.pts, pes.dts, '');\n            }\n            if (debug) {\n              avcSample.debug += 'IDR ';\n            }\n            avcSample.key = true;\n            avcSample.frame = true;\n            break;\n          //SEI\n          case 6:\n            push = true;\n            if (debug && avcSample) {\n              avcSample.debug += 'SEI ';\n            }\n            expGolombDecoder = new _expGolomb2.default(_this3.discardEPB(unit.data));\n\n            // skip frameType\n            expGolombDecoder.readUByte();\n\n            var payloadType = 0;\n            var payloadSize = 0;\n            var endOfCaptions = false;\n            var b = 0;\n\n            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {\n              payloadType = 0;\n              do {\n                b = expGolombDecoder.readUByte();\n                payloadType += b;\n              } while (b === 0xFF);\n\n              // Parse payload size.\n              payloadSize = 0;\n              do {\n                b = expGolombDecoder.readUByte();\n                payloadSize += b;\n              } while (b === 0xFF);\n\n              // TODO: there can be more than one payload in an SEI packet...\n              // TODO: need to read type and size in a while loop to get them all\n              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {\n\n                endOfCaptions = true;\n\n                var countryCode = expGolombDecoder.readUByte();\n\n                if (countryCode === 181) {\n                  var providerCode = expGolombDecoder.readUShort();\n\n                  if (providerCode === 49) {\n                    var userStructure = expGolombDecoder.readUInt();\n\n                    if (userStructure === 0x47413934) {\n                      var userDataType = expGolombDecoder.readUByte();\n\n                      // Raw CEA-608 bytes wrapped in CEA-708 packet\n                      if (userDataType === 3) {\n                        var firstByte = expGolombDecoder.readUByte();\n                        var secondByte = expGolombDecoder.readUByte();\n\n                        var totalCCs = 31 & firstByte;\n                        var byteArray = [firstByte, secondByte];\n\n                        for (i = 0; i < totalCCs; i++) {\n                          // 3 bytes per CC\n                          byteArray.push(expGolombDecoder.readUByte());\n                          byteArray.push(expGolombDecoder.readUByte());\n                          byteArray.push(expGolombDecoder.readUByte());\n                        }\n\n                        _this3._insertSampleInOrder(_this3._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });\n                      }\n                    }\n                  }\n                }\n              } else if (payloadSize < expGolombDecoder.bytesAvailable) {\n                for (i = 0; i < payloadSize; i++) {\n                  expGolombDecoder.readUByte();\n                }\n              }\n            }\n            break;\n          //SPS\n          case 7:\n            push = true;\n            if (debug && avcSample) {\n              avcSample.debug += 'SPS ';\n            }\n            if (!track.sps) {\n              expGolombDecoder = new _expGolomb2.default(unit.data);\n              var config = expGolombDecoder.readSPS();\n              track.width = config.width;\n              track.height = config.height;\n              track.pixelRatio = config.pixelRatio;\n              track.sps = [unit.data];\n              track.duration = _this3._duration;\n              var codecarray = unit.data.subarray(1, 4);\n              var codecstring = 'avc1.';\n              for (i = 0; i < 3; i++) {\n                var h = codecarray[i].toString(16);\n                if (h.length < 2) {\n                  h = '0' + h;\n                }\n                codecstring += h;\n              }\n              track.codec = codecstring;\n            }\n            break;\n          //PPS\n          case 8:\n            push = true;\n            if (debug && avcSample) {\n              avcSample.debug += 'PPS ';\n            }\n            if (!track.pps) {\n              track.pps = [unit.data];\n            }\n            break;\n          // AUD\n          case 9:\n            push = false;\n            if (avcSample) {\n              _this3.pushAccesUnit(avcSample, track);\n            }\n            avcSample = _this3.avcSample = _this3._createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');\n            break;\n          // Filler Data\n          case 12:\n            push = false;\n            break;\n          default:\n            push = false;\n            if (avcSample) {\n              avcSample.debug += 'unknown NAL ' + unit.type + ' ';\n            }\n            break;\n        }\n        if (avcSample && push) {\n          var _units = avcSample.units;\n          _units.units.push(unit);\n        }\n      });\n      // if last PES packet, push samples\n      if (last && avcSample) {\n        this.pushAccesUnit(avcSample, track);\n        this.avcSample = null;\n      }\n    }\n  }, {\n    key: '_createAVCSample',\n    value: function _createAVCSample(key, pts, dts, debug) {\n      return { key: key, pts: pts, dts: dts, units: { units: [], length: 0 }, debug: debug };\n    }\n  }, {\n    key: '_insertSampleInOrder',\n    value: function _insertSampleInOrder(arr, data) {\n      var len = arr.length;\n      if (len > 0) {\n        if (data.pts >= arr[len - 1].pts) {\n          arr.push(data);\n        } else {\n          for (var pos = len - 1; pos >= 0; pos--) {\n            if (data.pts < arr[pos].pts) {\n              arr.splice(pos, 0, data);\n              break;\n            }\n          }\n        }\n      } else {\n        arr.push(data);\n      }\n    }\n  }, {\n    key: '_getLastNalUnit',\n    value: function _getLastNalUnit() {\n      var avcSample = this.avcSample,\n          lastUnit = void 0;\n      // try to fallback to previous sample if current one is empty\n      if (!avcSample || avcSample.units.units.length === 0) {\n        var track = this._avcTrack,\n            samples = track.samples;\n        avcSample = samples[samples.length - 1];\n      }\n      if (avcSample) {\n        var units = avcSample.units.units;\n        lastUnit = units[units.length - 1];\n      }\n      return lastUnit;\n    }\n  }, {\n    key: '_parseAVCNALu',\n    value: function _parseAVCNALu(array) {\n      var i = 0,\n          len = array.byteLength,\n          value,\n          overflow,\n          track = this._avcTrack,\n          state = track.naluState || 0,\n          lastState = state;\n      var units = [],\n          unit,\n          unitType,\n          lastUnitStart = -1,\n          lastUnitType;\n      //logger.log('PES:' + Hex.hexDump(array));\n\n      if (state === -1) {\n        // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n        lastUnitStart = 0;\n        // NALu type is value read from offset 0\n        lastUnitType = array[0] & 0x1f;\n        state = 0;\n        i = 1;\n      }\n\n      while (i < len) {\n        value = array[i++];\n        // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n        if (!state) {\n          state = value ? 0 : 1;\n          continue;\n        }\n        if (state === 1) {\n          state = value ? 0 : 2;\n          continue;\n        }\n        // here we have state either equal to 2 or 3\n        if (!value) {\n          state = 3;\n        } else if (value === 1) {\n          if (lastUnitStart >= 0) {\n            unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };\n            //logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n            units.push(unit);\n          } else {\n            // lastUnitStart is undefined => this is the first start code found in this PES packet\n            // first check if start code delimiter is overlapping between 2 PES packets,\n            // ie it started in last packet (lastState not zero)\n            // and ended at the beginning of this PES packet (i <= 4 - lastState)\n            var lastUnit = this._getLastNalUnit();\n            if (lastUnit) {\n              if (lastState && i <= 4 - lastState) {\n                // start delimiter overlapping between PES packets\n                // strip start delimiter bytes from the end of last NAL unit\n                // check if lastUnit had a state different from zero\n                if (lastUnit.state) {\n                  // strip last bytes\n                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n                }\n              }\n              // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n              overflow = i - state - 1;\n              if (overflow > 0) {\n                //logger.log('first NALU found with overflow:' + overflow);\n                var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);\n                tmp.set(lastUnit.data, 0);\n                tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);\n                lastUnit.data = tmp;\n              }\n            }\n          }\n          // check if we can read unit type\n          if (i < len) {\n            unitType = array[i] & 0x1f;\n            //logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n            lastUnitStart = i;\n            lastUnitType = unitType;\n            state = 0;\n          } else {\n            // not enough byte to read unit type. let's read it on next PES parsing\n            state = -1;\n          }\n        } else {\n          state = 0;\n        }\n      }\n      if (lastUnitStart >= 0 && state >= 0) {\n        unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };\n        units.push(unit);\n        //logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n      }\n      // no NALu found\n      if (units.length === 0) {\n        // append pes.data to previous NAL unit\n        var _lastUnit = this._getLastNalUnit();\n        if (_lastUnit) {\n          var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);\n          _tmp.set(_lastUnit.data, 0);\n          _tmp.set(array, _lastUnit.data.byteLength);\n          _lastUnit.data = _tmp;\n        }\n      }\n      track.naluState = state;\n      return units;\n    }\n\n    /**\n     * remove Emulation Prevention bytes from a RBSP\n     */\n\n  }, {\n    key: 'discardEPB',\n    value: function discardEPB(data) {\n      var length = data.byteLength,\n          EPBPositions = [],\n          i = 1,\n          newLength,\n          newData;\n\n      // Find all `Emulation Prevention Bytes`\n      while (i < length - 2) {\n        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n          EPBPositions.push(i + 2);\n          i += 2;\n        } else {\n          i++;\n        }\n      }\n\n      // If no Emulation Prevention Bytes were found just return the original\n      // array\n      if (EPBPositions.length === 0) {\n        return data;\n      }\n\n      // Create a new array to hold the NAL unit data\n      newLength = length - EPBPositions.length;\n      newData = new Uint8Array(newLength);\n      var sourceIndex = 0;\n\n      for (i = 0; i < newLength; sourceIndex++, i++) {\n        if (sourceIndex === EPBPositions[0]) {\n          // Skip this byte\n          sourceIndex++;\n          // Remove this position index\n          EPBPositions.shift();\n        }\n        newData[i] = data[sourceIndex];\n      }\n      return newData;\n    }\n  }, {\n    key: '_parseAACPES',\n    value: function _parseAACPES(pes) {\n      var track = this._audioTrack,\n          data = pes.data,\n          pts = pes.pts,\n          startOffset = 0,\n          aacOverFlow = this.aacOverFlow,\n          aacLastPTS = this.aacLastPTS,\n          config,\n          frameLength,\n          frameDuration,\n          frameIndex,\n          offset,\n          headerLength,\n          stamp,\n          len,\n          aacSample;\n      if (aacOverFlow) {\n        var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);\n        tmp.set(aacOverFlow, 0);\n        tmp.set(data, aacOverFlow.byteLength);\n        //logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);\n        data = tmp;\n      }\n      // look for ADTS header (0xFFFx)\n      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {\n          break;\n        }\n      }\n      // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n      if (offset) {\n        var reason, fatal;\n        if (offset < len - 1) {\n          reason = 'AAC PES did not start with ADTS header,offset:' + offset;\n          fatal = false;\n        } else {\n          reason = 'no ADTS header found in AAC PES';\n          fatal = true;\n        }\n        _logger.logger.warn('parsing error:' + reason);\n        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });\n        if (fatal) {\n          return;\n        }\n      }\n      if (!track.audiosamplerate) {\n        var audioCodec = this.audioCodec;\n        config = _adts2.default.getAudioConfig(this.observer, data, offset, audioCodec);\n        track.config = config.config;\n        track.audiosamplerate = config.samplerate;\n        track.channelCount = config.channelCount;\n        track.codec = config.codec;\n        track.manifestCodec = config.manifestCodec;\n        track.duration = this._duration;\n        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);\n      }\n      frameIndex = 0;\n      frameDuration = 1024 * 90000 / track.audiosamplerate;\n\n      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n      // first sample PTS should be equal to last sample PTS + frameDuration\n      if (aacOverFlow && aacLastPTS) {\n        var newPTS = aacLastPTS + frameDuration;\n        if (Math.abs(newPTS - pts) > 1) {\n          _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));\n          pts = newPTS;\n        }\n      }\n\n      while (offset + 5 < len) {\n        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;\n        // retrieve frame size\n        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;\n        frameLength -= headerLength;\n        //stamp = pes.pts;\n\n        if (frameLength > 0 && offset + headerLength + frameLength <= len) {\n          stamp = pts + frameIndex * frameDuration;\n          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);\n          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };\n          track.samples.push(aacSample);\n          track.len += frameLength;\n          offset += frameLength + headerLength;\n          frameIndex++;\n          // look for ADTS header (0xFFFx)\n          for (; offset < len - 1; offset++) {\n            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {\n              break;\n            }\n          }\n        } else {\n          break;\n        }\n      }\n      if (offset < len) {\n        aacOverFlow = data.subarray(offset, len);\n        //logger.log(`AAC: overflow detected:${len-offset}`);\n      } else {\n        aacOverFlow = null;\n      }\n      this.aacOverFlow = aacOverFlow;\n      this.aacLastPTS = stamp;\n    }\n  }, {\n    key: '_parseMPEGPES',\n    value: function _parseMPEGPES(pes) {\n      var data = pes.data;\n      var pts = pes.pts;\n      var length = data.length;\n      var frameIndex = 0;\n      var offset = 0;\n      var parsed;\n\n      while (offset < length && (parsed = this._parseMpeg(data, offset, length, frameIndex++, pts)) > 0) {\n        offset += parsed;\n      }\n    }\n  }, {\n    key: '_onMpegFrame',\n    value: function _onMpegFrame(data, bitRate, sampleRate, channelCount, frameIndex, pts) {\n      var frameDuration = 1152 / sampleRate * 1000;\n      var stamp = pts + frameIndex * frameDuration;\n      var track = this._audioTrack;\n\n      track.config = [];\n      track.channelCount = channelCount;\n      track.audiosamplerate = sampleRate;\n      track.duration = this._duration;\n      track.samples.push({ unit: data, pts: stamp, dts: stamp });\n      track.len += data.length;\n    }\n  }, {\n    key: '_onMpegNoise',\n    value: function _onMpegNoise(data) {\n      _logger.logger.warn('mpeg audio has noise: ' + data.length + ' bytes');\n    }\n  }, {\n    key: '_parseMpeg',\n    value: function _parseMpeg(data, start, end, frameIndex, pts) {\n      var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\n      var SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\n\n      if (start + 2 > end) {\n        return -1; // we need at least 2 bytes to detect sync pattern\n      }\n      if (data[start] === 0xFF || (data[start + 1] & 0xE0) === 0xE0) {\n        // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n        if (start + 24 > end) {\n          return -1;\n        }\n        var headerB = data[start + 1] >> 3 & 3;\n        var headerC = data[start + 1] >> 1 & 3;\n        var headerE = data[start + 2] >> 4 & 15;\n        var headerF = data[start + 2] >> 2 & 3;\n        var headerG = !!(data[start + 2] & 2);\n        if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {\n          var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;\n          var bitRate = BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;\n          var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;\n          var sampleRate = SamplingRateMap[columnInSampleRates * 3 + headerF];\n          var padding = headerG ? 1 : 0;\n          var channelCount = data[start + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n          var frameLength = headerC === 3 ? (headerB === 3 ? 12 : 6) * bitRate / sampleRate + padding << 2 : (headerB === 3 ? 144 : 72) * bitRate / sampleRate + padding | 0;\n          if (start + frameLength > end) {\n            return -1;\n          }\n          if (this._onMpegFrame) {\n            this._onMpegFrame(data.subarray(start, start + frameLength), bitRate, sampleRate, channelCount, frameIndex, pts);\n          }\n          return frameLength;\n        }\n      }\n      // noise or ID3, trying to skip\n      var offset = start + 2;\n      while (offset < end) {\n        if (data[offset - 1] === 0xFF && (data[offset] & 0xE0) === 0xE0) {\n          // sync pattern is found\n          if (this._onMpegNoise) {\n            this._onMpegNoise(data.subarray(start, offset - 1));\n          }\n          return offset - start - 1;\n        }\n        offset++;\n      }\n      return -1;\n    }\n  }, {\n    key: '_parseID3PES',\n    value: function _parseID3PES(pes) {\n      this._id3Track.samples.push(pes);\n    }\n  }], [{\n    key: 'probe',\n    value: function probe(data) {\n      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47\n      if (data.length >= 3 * 188 && data[0] === 0x47 && data[188] === 0x47 && data[2 * 188] === 0x47) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }]);\n\n  return TSDemuxer;\n}();\n\nexports.default = TSDemuxer;\n\n},{\"22\":22,\"26\":26,\"29\":29,\"31\":31,\"33\":33,\"50\":50}],31:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ErrorTypes = exports.ErrorTypes = {\n  // Identifier for a network error (loading error / timeout ...)\n  NETWORK_ERROR: 'networkError',\n  // Identifier for a media Error (video/parsing/mediasource error)\n  MEDIA_ERROR: 'mediaError',\n  // Identifier for a mux Error (demuxing/remuxing)\n  MUX_ERROR: 'muxError',\n  // Identifier for all other errors\n  OTHER_ERROR: 'otherError'\n};\n\nvar ErrorDetails = exports.ErrorDetails = {\n  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  MANIFEST_LOAD_ERROR: 'manifestLoadError',\n  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',\n  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}\n  MANIFEST_PARSING_ERROR: 'manifestParsingError',\n  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}\n  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',\n  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  LEVEL_LOAD_ERROR: 'levelLoadError',\n  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',\n  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}\n  LEVEL_SWITCH_ERROR: 'levelSwitchError',\n  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',\n  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',\n  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n  FRAG_LOAD_ERROR: 'fragLoadError',\n  // Identifier for fragment loop loading error - data: { frag : fragment object}\n  FRAG_LOOP_LOADING_ERROR: 'fragLoopLoadingError',\n  // Identifier for fragment load timeout error - data: { frag : fragment object}\n  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',\n  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }\n  FRAG_DECRYPT_ERROR: 'fragDecryptError',\n  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }\n  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release\n  FRAG_PARSING_ERROR: 'fragParsingError',\n  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }\n  REMUX_ALLOC_ERROR: 'remuxAllocError',\n  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n  KEY_LOAD_ERROR: 'keyLoadError',\n  // Identifier for decrypt key load timeout error - data: { frag : fragment object}\n  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',\n  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }\n  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',\n  // Identifier for a buffer append error - data: append error description\n  BUFFER_APPEND_ERROR: 'bufferAppendError',\n  // Identifier for a buffer appending error event - data: appending error description\n  BUFFER_APPENDING_ERROR: 'bufferAppendingError',\n  // Identifier for a buffer stalled error event\n  BUFFER_STALLED_ERROR: 'bufferStalledError',\n  // Identifier for a buffer full event\n  BUFFER_FULL_ERROR: 'bufferFullError',\n  // Identifier for a buffer seek over hole event\n  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',\n  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)\n  BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',\n  // Identifier for an internal exception happening inside hls.js while handling an event\n  INTERNAL_EXCEPTION: 'internalException',\n  // Malformed WebVTT contents\n  WEBVTT_EXCEPTION: 'webVTTException'\n};\n\n},{}],32:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _logger = _dereq_(50);\n\nvar _errors = _dereq_(31);\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EventHandler = function () {\n  function EventHandler(hls) {\n    _classCallCheck(this, EventHandler);\n\n    this.hls = hls;\n    this.onEvent = this.onEvent.bind(this);\n\n    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      events[_key - 1] = arguments[_key];\n    }\n\n    this.handledEvents = events;\n    this.useGenericHandler = true;\n\n    this.registerListeners();\n  }\n\n  _createClass(EventHandler, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.unregisterListeners();\n    }\n  }, {\n    key: 'isEventHandler',\n    value: function isEventHandler() {\n      return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';\n    }\n  }, {\n    key: 'registerListeners',\n    value: function registerListeners() {\n      if (this.isEventHandler()) {\n        this.handledEvents.forEach(function (event) {\n          if (event === 'hlsEventGeneric') {\n            throw new Error('Forbidden event name: ' + event);\n          }\n          this.hls.on(event, this.onEvent);\n        }.bind(this));\n      }\n    }\n  }, {\n    key: 'unregisterListeners',\n    value: function unregisterListeners() {\n      if (this.isEventHandler()) {\n        this.handledEvents.forEach(function (event) {\n          this.hls.off(event, this.onEvent);\n        }.bind(this));\n      }\n    }\n\n    /**\n     * arguments: event (string), data (any)\n     */\n\n  }, {\n    key: 'onEvent',\n    value: function onEvent(event, data) {\n      this.onEventGeneric(event, data);\n    }\n  }, {\n    key: 'onEventGeneric',\n    value: function onEventGeneric(event, data) {\n      var eventToFunction = function eventToFunction(event, data) {\n        var funcName = 'on' + event.replace('hls', '');\n        if (typeof this[funcName] !== 'function') {\n          throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');\n        }\n        return this[funcName].bind(this, data);\n      };\n      try {\n        eventToFunction.call(this, event, data).call();\n      } catch (err) {\n        _logger.logger.error('internal error happened while processing ' + event + ':' + err.message);\n        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });\n      }\n    }\n  }]);\n\n  return EventHandler;\n}();\n\nexports.default = EventHandler;\n\n},{\"31\":31,\"33\":33,\"50\":50}],33:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = {\n  // fired before MediaSource is attaching to media element - data: { media }\n  MEDIA_ATTACHING: 'hlsMediaAttaching',\n  // fired when MediaSource has been succesfully attached to media element - data: { }\n  MEDIA_ATTACHED: 'hlsMediaAttached',\n  // fired before detaching MediaSource from media element - data: { }\n  MEDIA_DETACHING: 'hlsMediaDetaching',\n  // fired when MediaSource has been detached from media element - data: { }\n  MEDIA_DETACHED: 'hlsMediaDetached',\n  // fired when we buffer is going to be resetted\n  BUFFER_RESET: 'hlsBufferReset',\n  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}\n  BUFFER_CODECS: 'hlsBufferCodecs',\n  // fired when sourcebuffers have been created data: { tracks : tracks}\n  BUFFER_CREATED: 'hlsBufferCreated',\n  // fired when we append a segment to the buffer - data: { segment: segment object }\n  BUFFER_APPENDING: 'hlsBufferAppending',\n  // fired when we are done with appending a media segment to the buffer data : { parent : segment parent that triggered BUFFER_APPENDING , pending : nb of segments waiting for appending for this segment parent}\n  BUFFER_APPENDED: 'hlsBufferAppended',\n  // fired when the stream is finished and we want to notify the media buffer that there will be no more data\n  BUFFER_EOS: 'hlsBufferEos',\n  // fired when the media buffer should be flushed - data {startOffset, endOffset}\n  BUFFER_FLUSHING: 'hlsBufferFlushing',\n  // fired when the media has been flushed\n  BUFFER_FLUSHED: 'hlsBufferFlushed',\n  // fired to signal that a manifest loading starts - data: { url : manifestURL}\n  MANIFEST_LOADING: 'hlsManifestLoading',\n  // fired after manifest has been loaded - data: { levels : [available quality levels] , audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}\n  MANIFEST_LOADED: 'hlsManifestLoaded',\n  // fired after manifest has been parsed - data: { levels : [available quality levels] , firstLevel : index of first quality level appearing in Manifest}\n  MANIFEST_PARSED: 'hlsManifestParsed',\n  // fired when a level switch is requested - data: { level : id of new level } // deprecated in favor LEVEL_SWITCHING\n  LEVEL_SWITCH: 'hlsLevelSwitch',\n  // fired when a level switch is requested - data: { level : id of new level }\n  LEVEL_SWITCHING: 'hlsLevelSwitching',\n  // fired when a level switch is effective - data: { level : id of new level }\n  LEVEL_SWITCHED: 'hlsLevelSwitched',\n  // fired when a level playlist loading starts - data: { url : level URL  level : id of level being loaded}\n  LEVEL_LOADING: 'hlsLevelLoading',\n  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }\n  LEVEL_LOADED: 'hlsLevelLoaded',\n  // fired when a level's details have been updated based on previous details, after it has been loaded. - data: { details : levelDetails object, level : id of updated level }\n  LEVEL_UPDATED: 'hlsLevelUpdated',\n  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }\n  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',\n  // fired to notify that audio track lists has been updated data: { audioTracks : audioTracks}\n  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',\n  // fired when an audio track switch occurs - data: {  id : audio track id} // deprecated in favor AUDIO_TRACK_SWITCHING\n  AUDIO_TRACK_SWITCH: 'hlsAudioTrackSwitch',\n  // fired when an audio track switching is requested - data: {  id : audio track id}\n  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',\n  // fired when an audio track switch actually occurs - data: {  id : audio track id}\n  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',\n  // fired when an audio track loading starts - data: { url : audio track URL  id : audio track id}\n  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',\n  // fired when an audio track loading  finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime} }\n  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',\n  // fired to notify that subtitle track lists has been updated data: { subtitleTracks : subtitleTracks}\n  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',\n  // fired when an subtitle track switch occurs - data: {  id : subtitle track id}\n  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',\n  // fired when an subtitle track loading starts - data: { url : subtitle track URL  id : subtitle track id}\n  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',\n  // fired when an subtitle track loading  finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime} }\n  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',\n  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag}\n  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',\n  // fired when the first timestamp is found. - data: { id : demuxer id, initPTS: initPTS , frag : fragment object}\n  INIT_PTS_FOUND: 'hlsInitPtsFound',\n  // fired when a fragment loading starts - data: { frag : fragment object}\n  FRAG_LOADING: 'hlsFragLoading',\n  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded}}\n  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',\n  // Identifier for fragment load aborting for emergency switch down - data: {frag : fragment object}\n  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',\n  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length}}\n  FRAG_LOADED: 'hlsFragLoaded',\n  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, stats : {tstart,tdecrypt} }\n  FRAG_DECRYPTED: 'hlsFragDecrypted',\n  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment}\n  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',\n  // fired when parsing sei text is completed - data: { id : demuxer id, , frag: fragment object, samples : [ sei samples pes ] }\n  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',\n  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }\n  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',\n  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}\n  FRAG_PARSING_DATA: 'hlsFragParsingData',\n  // fired when fragment parsing is completed - data: { id : demuxer id,frag: fragment object }\n  FRAG_PARSED: 'hlsFragParsed',\n  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id,frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length} }\n  FRAG_BUFFERED: 'hlsFragBuffered',\n  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }\n  FRAG_CHANGED: 'hlsFragChanged',\n  // Identifier for a FPS drop event - data: {curentDropped, currentDecoded, totalDroppedFrames}\n  FPS_DROP: 'hlsFpsDrop',\n  //triggered when FPS drop triggers auto level capping - data: {level, droppedlevel}\n  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',\n  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data}\n  ERROR: 'hlsError',\n  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example\n  DESTROYING: 'hlsDestroying',\n  // fired when a decrypt key loading starts - data: { frag : fragment object}\n  KEY_LOADING: 'hlsKeyLoading',\n  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length}}\n  KEY_LOADED: 'hlsKeyLoaded',\n  // fired upon stream controller state transitions - data: {previousState, nextState}\n  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'\n};\n\n},{}],34:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *  AAC helper\n */\n\nvar AAC = function () {\n  function AAC() {\n    _classCallCheck(this, AAC);\n  }\n\n  _createClass(AAC, null, [{\n    key: 'getSilentFrame',\n    value: function getSilentFrame(codec, channelCount) {\n      switch (codec) {\n        case 'mp4a.40.2':\n          if (channelCount === 1) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n          } else if (channelCount === 2) {\n            return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n          } else if (channelCount === 3) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n          } else if (channelCount === 4) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n          } else if (channelCount === 5) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n          } else if (channelCount === 6) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n          }\n          break;\n        // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n        default:\n          if (channelCount === 1) {\n            // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n          } else if (channelCount === 2) {\n            // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n          } else if (channelCount === 3) {\n            // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n          }\n          break;\n      }\n      return null;\n    }\n  }]);\n\n  return AAC;\n}();\n\nexports.default = AAC;\n\n},{}],35:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Buffer Helper class, providing methods dealing buffer length retrieval\n*/\n\nvar BufferHelper = function () {\n  function BufferHelper() {\n    _classCallCheck(this, BufferHelper);\n  }\n\n  _createClass(BufferHelper, null, [{\n    key: \"isBuffered\",\n    value: function isBuffered(media, position) {\n      if (media) {\n        var buffered = media.buffered;\n        for (var i = 0; i < buffered.length; i++) {\n          if (position >= buffered.start(i) && position <= buffered.end(i)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"bufferInfo\",\n    value: function bufferInfo(media, pos, maxHoleDuration) {\n      if (media) {\n        var vbuffered = media.buffered,\n            buffered = [],\n            i;\n        for (i = 0; i < vbuffered.length; i++) {\n          buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });\n        }\n        return this.bufferedInfo(buffered, pos, maxHoleDuration);\n      } else {\n        return { len: 0, start: pos, end: pos, nextStart: undefined };\n      }\n    }\n  }, {\n    key: \"bufferedInfo\",\n    value: function bufferedInfo(buffered, pos, maxHoleDuration) {\n      var buffered2 = [],\n\n      // bufferStart and bufferEnd are buffer boundaries around current video position\n      bufferLen,\n          bufferStart,\n          bufferEnd,\n          bufferStartNext,\n          i;\n      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n      buffered.sort(function (a, b) {\n        var diff = a.start - b.start;\n        if (diff) {\n          return diff;\n        } else {\n          return b.end - a.end;\n        }\n      });\n      // there might be some small holes between buffer time range\n      // consider that holes smaller than maxHoleDuration are irrelevant and build another\n      // buffer time range representations that discards those holes\n      for (i = 0; i < buffered.length; i++) {\n        var buf2len = buffered2.length;\n        if (buf2len) {\n          var buf2end = buffered2[buf2len - 1].end;\n          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n          if (buffered[i].start - buf2end < maxHoleDuration) {\n            // merge overlapping time ranges\n            // update lastRange.end only if smaller than item.end\n            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n            if (buffered[i].end > buf2end) {\n              buffered2[buf2len - 1].end = buffered[i].end;\n            }\n          } else {\n            // big hole\n            buffered2.push(buffered[i]);\n          }\n        } else {\n          // first value\n          buffered2.push(buffered[i]);\n        }\n      }\n      for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {\n        var start = buffered2[i].start,\n            end = buffered2[i].end;\n        //logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n        if (pos + maxHoleDuration >= start && pos < end) {\n          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n          bufferStart = start;\n          bufferEnd = end;\n          bufferLen = bufferEnd - pos;\n        } else if (pos + maxHoleDuration < start) {\n          bufferStartNext = start;\n          break;\n        }\n      }\n      return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };\n    }\n  }]);\n\n  return BufferHelper;\n}();\n\nexports.default = BufferHelper;\n\n},{}],36:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Level Helper class, providing methods dealing with playlist sliding and drift\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _logger = _dereq_(50);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LevelHelper = function () {\n  function LevelHelper() {\n    _classCallCheck(this, LevelHelper);\n  }\n\n  _createClass(LevelHelper, null, [{\n    key: 'mergeDetails',\n    value: function mergeDetails(oldDetails, newDetails) {\n      var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN,\n          end = Math.min(oldDetails.endSN, newDetails.endSN) - newDetails.startSN,\n          delta = newDetails.startSN - oldDetails.startSN,\n          oldfragments = oldDetails.fragments,\n          newfragments = newDetails.fragments,\n          ccOffset = 0,\n          PTSFrag;\n\n      // check if old/new playlists have fragments in common\n      if (end < start) {\n        newDetails.PTSKnown = false;\n        return;\n      }\n      // loop through overlapping SN and update startPTS , cc, and duration if any found\n      for (var i = start; i <= end; i++) {\n        var oldFrag = oldfragments[delta + i],\n            newFrag = newfragments[i];\n        if (newFrag && oldFrag) {\n          ccOffset = oldFrag.cc - newFrag.cc;\n          if (!isNaN(oldFrag.startPTS)) {\n            newFrag.start = newFrag.startPTS = oldFrag.startPTS;\n            newFrag.endPTS = oldFrag.endPTS;\n            newFrag.duration = oldFrag.duration;\n            PTSFrag = newFrag;\n          }\n        }\n      }\n\n      if (ccOffset) {\n        _logger.logger.log('discontinuity sliding from playlist, take drift into account');\n        for (i = 0; i < newfragments.length; i++) {\n          newfragments[i].cc += ccOffset;\n        }\n      }\n\n      // if at least one fragment contains PTS info, recompute PTS information for all fragments\n      if (PTSFrag) {\n        LevelHelper.updateFragPTSDTS(newDetails, PTSFrag.sn, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n      } else {\n        // ensure that delta is within oldfragments range\n        // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n        // in that case we also need to adjust start offset of all fragments\n        if (delta >= 0 && delta < oldfragments.length) {\n          // adjust start by sliding offset\n          var sliding = oldfragments[delta].start;\n          for (i = 0; i < newfragments.length; i++) {\n            newfragments[i].start += sliding;\n          }\n        }\n      }\n      // if we are here, it means we have fragments overlapping between\n      // old and new level. reliable PTS info is thus relying on old level\n      newDetails.PTSKnown = oldDetails.PTSKnown;\n      return;\n    }\n  }, {\n    key: 'updateFragPTSDTS',\n    value: function updateFragPTSDTS(details, sn, startPTS, endPTS, startDTS, endDTS) {\n      var fragIdx, fragments, frag, i;\n      // exit if sn out of range\n      if (!details || sn < details.startSN || sn > details.endSN) {\n        return 0;\n      }\n      fragIdx = sn - details.startSN;\n      fragments = details.fragments;\n      frag = fragments[fragIdx];\n      if (!isNaN(frag.startPTS)) {\n        // delta PTS between audio and video\n        var deltaPTS = Math.abs(frag.startPTS - startPTS);\n        if (isNaN(frag.deltaPTS)) {\n          frag.deltaPTS = deltaPTS;\n        } else {\n          frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n        }\n        startPTS = Math.min(startPTS, frag.startPTS);\n        endPTS = Math.max(endPTS, frag.endPTS);\n        startDTS = Math.min(startDTS, frag.startDTS);\n        endDTS = Math.max(endDTS, frag.endDTS);\n      }\n\n      var drift = startPTS - frag.start;\n\n      frag.start = frag.startPTS = startPTS;\n      frag.endPTS = endPTS;\n      frag.startDTS = startDTS;\n      frag.endDTS = endDTS;\n      frag.duration = endPTS - startPTS;\n      // adjust fragment PTS/duration from seqnum-1 to frag 0\n      for (i = fragIdx; i > 0; i--) {\n        LevelHelper.updatePTS(fragments, i, i - 1);\n      }\n\n      // adjust fragment PTS/duration from seqnum to last frag\n      for (i = fragIdx; i < fragments.length - 1; i++) {\n        LevelHelper.updatePTS(fragments, i, i + 1);\n      }\n      details.PTSKnown = true;\n      //logger.log(`                                            frag start/end:${startPTS.toFixed(3)}/${endPTS.toFixed(3)}`);\n\n      return drift;\n    }\n  }, {\n    key: 'updatePTS',\n    value: function updatePTS(fragments, fromIdx, toIdx) {\n      var fragFrom = fragments[fromIdx],\n          fragTo = fragments[toIdx],\n          fragToPTS = fragTo.startPTS;\n      // if we know startPTS[toIdx]\n      if (!isNaN(fragToPTS)) {\n        // update fragment duration.\n        // it helps to fix drifts between playlist reported duration and fragment real duration\n        if (toIdx > fromIdx) {\n          fragFrom.duration = fragToPTS - fragFrom.start;\n          if (fragFrom.duration < 0) {\n            _logger.logger.warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');\n          }\n        } else {\n          fragTo.duration = fragFrom.start - fragToPTS;\n          if (fragTo.duration < 0) {\n            _logger.logger.warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');\n          }\n        }\n      } else {\n        // we dont know startPTS[toIdx]\n        if (toIdx > fromIdx) {\n          fragTo.start = fragFrom.start + fragFrom.duration;\n        } else {\n          fragTo.start = fragFrom.start - fragTo.duration;\n        }\n      }\n    }\n  }]);\n\n  return LevelHelper;\n}();\n\nexports.default = LevelHelper;\n\n},{\"50\":50}],37:[function(_dereq_,module,exports){\n/**\n * HLS interface\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _errors = _dereq_(31);\n\nvar _playlistLoader = _dereq_(41);\n\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\n\nvar _fragmentLoader = _dereq_(39);\n\nvar _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);\n\nvar _keyLoader = _dereq_(40);\n\nvar _keyLoader2 = _interopRequireDefault(_keyLoader);\n\nvar _streamController = _dereq_(13);\n\nvar _streamController2 = _interopRequireDefault(_streamController);\n\nvar _levelController = _dereq_(12);\n\nvar _levelController2 = _interopRequireDefault(_levelController);\n\nvar _logger = _dereq_(50);\n\nvar _events3 = _dereq_(1);\n\nvar _events4 = _interopRequireDefault(_events3);\n\nvar _config = _dereq_(4);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Hls = function () {\n  _createClass(Hls, null, [{\n    key: 'isSupported',\n    value: function isSupported() {\n      window.MediaSource = window.MediaSource || window.WebKitMediaSource;\n      return window.MediaSource && typeof window.MediaSource.isTypeSupported === 'function' && window.MediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"');\n    }\n  }, {\n    key: 'version',\n    get: function get() {\n      // replaced with browserify-versionify transform\n      return '0.7.2';\n    }\n  }, {\n    key: 'Events',\n    get: function get() {\n      return _events2.default;\n    }\n  }, {\n    key: 'ErrorTypes',\n    get: function get() {\n      return _errors.ErrorTypes;\n    }\n  }, {\n    key: 'ErrorDetails',\n    get: function get() {\n      return _errors.ErrorDetails;\n    }\n  }, {\n    key: 'DefaultConfig',\n    get: function get() {\n      if (!Hls.defaultConfig) {\n        return _config.hlsDefaultConfig;\n      }\n      return Hls.defaultConfig;\n    },\n    set: function set(defaultConfig) {\n      Hls.defaultConfig = defaultConfig;\n    }\n  }]);\n\n  function Hls() {\n    var _this = this;\n\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Hls);\n\n    var defaultConfig = Hls.DefaultConfig;\n\n    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {\n      throw new Error('Illegal hls.js config: don\\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');\n    }\n\n    for (var prop in defaultConfig) {\n      if (prop in config) {\n        continue;\n      }\n      config[prop] = defaultConfig[prop];\n    }\n\n    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {\n      throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be gt \"liveSyncDurationCount\"');\n    }\n\n    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {\n      throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be gt \"liveSyncDuration\"');\n    }\n\n    (0, _logger.enableLogs)(config.debug);\n    this.config = config;\n    this._autoLevelCapping = -1;\n    // observer setup\n    var observer = this.observer = new _events4.default();\n    observer.trigger = function trigger(event) {\n      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        data[_key - 1] = arguments[_key];\n      }\n\n      observer.emit.apply(observer, [event, event].concat(data));\n    };\n\n    observer.off = function off(event) {\n      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        data[_key2 - 1] = arguments[_key2];\n      }\n\n      observer.removeListener.apply(observer, [event].concat(data));\n    };\n    this.on = observer.on.bind(observer);\n    this.off = observer.off.bind(observer);\n    this.trigger = observer.trigger.bind(observer);\n\n    // core controllers and network loaders\n    var abrController = this.abrController = new config.abrController(this);\n    var bufferController = new config.bufferController(this);\n    var capLevelController = new config.capLevelController(this);\n    var fpsController = new config.fpsController(this);\n    var playListLoader = new _playlistLoader2.default(this);\n    var fragmentLoader = new _fragmentLoader2.default(this);\n    var keyLoader = new _keyLoader2.default(this);\n\n    // network controllers\n    var levelController = this.levelController = new _levelController2.default(this);\n    var streamController = this.streamController = new _streamController2.default(this);\n    var networkControllers = [levelController, streamController];\n\n    // optional audio stream controller\n    var Controller = config.audioStreamController;\n    if (Controller) {\n      networkControllers.push(new Controller(this));\n    }\n    this.networkControllers = networkControllers;\n\n    var coreComponents = [playListLoader, fragmentLoader, keyLoader, abrController, bufferController, capLevelController, fpsController];\n\n    // optional audio track and subtitle controller\n    Controller = config.audioTrackController;\n    if (Controller) {\n      var audioTrackController = new Controller(this);\n      this.audioTrackController = audioTrackController;\n      coreComponents.push(audioTrackController);\n    }\n\n    Controller = config.subtitleTrackController;\n    if (Controller) {\n      var subtitleTrackController = new Controller(this);\n      this.subtitleTrackController = subtitleTrackController;\n      coreComponents.push(subtitleTrackController);\n    }\n\n    // optional subtitle controller\n    [config.subtitleStreamController, config.timelineController].forEach(function (Controller) {\n      if (Controller) {\n        coreComponents.push(new Controller(_this));\n      }\n    });\n    this.coreComponents = coreComponents;\n  }\n\n  _createClass(Hls, [{\n    key: 'destroy',\n    value: function destroy() {\n      _logger.logger.log('destroy');\n      this.trigger(_events2.default.DESTROYING);\n      this.detachMedia();\n      this.coreComponents.concat(this.networkControllers).forEach(function (component) {\n        component.destroy();\n      });\n      this.url = null;\n      this.observer.removeAllListeners();\n      this._autoLevelCapping = -1;\n    }\n  }, {\n    key: 'attachMedia',\n    value: function attachMedia(media) {\n      _logger.logger.log('attachMedia');\n      this.media = media;\n      this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });\n    }\n  }, {\n    key: 'detachMedia',\n    value: function detachMedia() {\n      _logger.logger.log('detachMedia');\n      this.trigger(_events2.default.MEDIA_DETACHING);\n      this.media = null;\n    }\n  }, {\n    key: 'loadSource',\n    value: function loadSource(url) {\n      _logger.logger.log('loadSource:' + url);\n      this.url = url;\n      // when attaching to a source URL, trigger a playlist load\n      this.trigger(_events2.default.MANIFEST_LOADING, { url: url });\n    }\n  }, {\n    key: 'startLoad',\n    value: function startLoad() {\n      var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n\n      _logger.logger.log('startLoad(' + startPosition + ')');\n      this.networkControllers.forEach(function (controller) {\n        controller.startLoad(startPosition);\n      });\n    }\n  }, {\n    key: 'stopLoad',\n    value: function stopLoad() {\n      _logger.logger.log('stopLoad');\n      this.networkControllers.forEach(function (controller) {\n        controller.stopLoad();\n      });\n    }\n  }, {\n    key: 'swapAudioCodec',\n    value: function swapAudioCodec() {\n      _logger.logger.log('swapAudioCodec');\n      this.streamController.swapAudioCodec();\n    }\n  }, {\n    key: 'recoverMediaError',\n    value: function recoverMediaError() {\n      _logger.logger.log('recoverMediaError');\n      var media = this.media;\n      this.detachMedia();\n      this.attachMedia(media);\n    }\n\n    /** Return all quality levels **/\n\n  }, {\n    key: 'levels',\n    get: function get() {\n      return this.levelController.levels;\n    }\n\n    /** Return current playback quality level **/\n\n  }, {\n    key: 'currentLevel',\n    get: function get() {\n      return this.streamController.currentLevel;\n    }\n\n    /* set quality level immediately (-1 for automatic level selection) */\n    ,\n    set: function set(newLevel) {\n      _logger.logger.log('set currentLevel:' + newLevel);\n      this.loadLevel = newLevel;\n      this.streamController.immediateLevelSwitch();\n    }\n\n    /** Return next playback quality level (quality level of next fragment) **/\n\n  }, {\n    key: 'nextLevel',\n    get: function get() {\n      return this.streamController.nextLevel;\n    }\n\n    /* set quality level for next fragment (-1 for automatic level selection) */\n    ,\n    set: function set(newLevel) {\n      _logger.logger.log('set nextLevel:' + newLevel);\n      this.levelController.manualLevel = newLevel;\n      this.streamController.nextLevelSwitch();\n    }\n\n    /** Return the quality level of current/last loaded fragment **/\n\n  }, {\n    key: 'loadLevel',\n    get: function get() {\n      return this.levelController.level;\n    }\n\n    /* set quality level for current/next loaded fragment (-1 for automatic level selection) */\n    ,\n    set: function set(newLevel) {\n      _logger.logger.log('set loadLevel:' + newLevel);\n      this.levelController.manualLevel = newLevel;\n    }\n\n    /** Return the quality level of next loaded fragment **/\n\n  }, {\n    key: 'nextLoadLevel',\n    get: function get() {\n      return this.levelController.nextLoadLevel;\n    }\n\n    /** set quality level of next loaded fragment **/\n    ,\n    set: function set(level) {\n      this.levelController.nextLoadLevel = level;\n    }\n\n    /** Return first level (index of first level referenced in manifest)\n    **/\n\n  }, {\n    key: 'firstLevel',\n    get: function get() {\n      return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n    }\n\n    /** set first level (index of first level referenced in manifest)\n    **/\n    ,\n    set: function set(newLevel) {\n      _logger.logger.log('set firstLevel:' + newLevel);\n      this.levelController.firstLevel = newLevel;\n    }\n\n    /** Return start level (level of first fragment that will be played back)\n        if not overrided by user, first level appearing in manifest will be used as start level\n        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)\n    **/\n\n  }, {\n    key: 'startLevel',\n    get: function get() {\n      return this.levelController.startLevel;\n    }\n\n    /** set  start level (level of first fragment that will be played back)\n        if not overrided by user, first level appearing in manifest will be used as start level\n        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)\n    **/\n    ,\n    set: function set(newLevel) {\n      _logger.logger.log('set startLevel:' + newLevel);\n      var hls = this;\n      // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n      if (newLevel !== -1) {\n        newLevel = Math.max(newLevel, hls.minAutoLevel);\n      }\n      hls.levelController.startLevel = newLevel;\n    }\n\n    /** Return the capping/max level value that could be used by automatic level selection algorithm **/\n\n  }, {\n    key: 'autoLevelCapping',\n    get: function get() {\n      return this._autoLevelCapping;\n    }\n\n    /** set the capping/max level value that could be used by automatic level selection algorithm **/\n    ,\n    set: function set(newLevel) {\n      _logger.logger.log('set autoLevelCapping:' + newLevel);\n      this._autoLevelCapping = newLevel;\n    }\n\n    /* check if we are in automatic level selection mode */\n\n  }, {\n    key: 'autoLevelEnabled',\n    get: function get() {\n      return this.levelController.manualLevel === -1;\n    }\n\n    /* return manual level */\n\n  }, {\n    key: 'manualLevel',\n    get: function get() {\n      return this.levelController.manualLevel;\n    }\n\n    /* return min level selectable in auto mode according to config.minAutoBitrate */\n\n  }, {\n    key: 'minAutoLevel',\n    get: function get() {\n      var hls = this,\n          levels = hls.levels,\n          minAutoBitrate = hls.config.minAutoBitrate,\n          len = levels ? levels.length : 0;\n      for (var i = 0; i < len; i++) {\n        var levelNextBitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;\n        if (levelNextBitrate > minAutoBitrate) {\n          return i;\n        }\n      }\n      return 0;\n    }\n\n    /* return max level selectable in auto mode according to autoLevelCapping */\n\n  }, {\n    key: 'maxAutoLevel',\n    get: function get() {\n      var hls = this;\n      var levels = hls.levels;\n      var autoLevelCapping = hls.autoLevelCapping;\n      var maxAutoLevel = void 0;\n      if (autoLevelCapping === -1 && levels && levels.length) {\n        maxAutoLevel = levels.length - 1;\n      } else {\n        maxAutoLevel = autoLevelCapping;\n      }\n      return maxAutoLevel;\n    }\n\n    // return next auto level\n\n  }, {\n    key: 'nextAutoLevel',\n    get: function get() {\n      var hls = this;\n      // ensure next auto level is between  min and max auto level\n      return Math.min(Math.max(hls.abrController.nextAutoLevel, hls.minAutoLevel), hls.maxAutoLevel);\n    }\n\n    // this setter is used to force next auto level\n    // this is useful to force a switch down in auto mode : in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n    // forced value is valid for one fragment. upon succesful frag loading at forced level, this value will be resetted to -1 by ABR controller\n    ,\n    set: function set(nextLevel) {\n      var hls = this;\n      hls.abrController.nextAutoLevel = Math.max(hls.minAutoLevel, nextLevel);\n    }\n\n    /** get alternate audio tracks list from playlist **/\n\n  }, {\n    key: 'audioTracks',\n    get: function get() {\n      var audioTrackController = this.audioTrackController;\n      return audioTrackController ? audioTrackController.audioTracks : [];\n    }\n\n    /** get index of the selected audio track (index in audio track lists) **/\n\n  }, {\n    key: 'audioTrack',\n    get: function get() {\n      var audioTrackController = this.audioTrackController;\n      return audioTrackController ? audioTrackController.audioTrack : -1;\n    }\n\n    /** select an audio track, based on its index in audio track lists**/\n    ,\n    set: function set(audioTrackId) {\n      var audioTrackController = this.audioTrackController;\n      if (audioTrackController) {\n        audioTrackController.audioTrack = audioTrackId;\n      }\n    }\n  }, {\n    key: 'liveSyncPosition',\n    get: function get() {\n      return this.streamController.liveSyncPosition;\n    }\n\n    /** get alternate subtitle tracks list from playlist **/\n\n  }, {\n    key: 'subtitleTracks',\n    get: function get() {\n      var subtitleTrackController = this.subtitleTrackController;\n      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n    }\n\n    /** get index of the selected subtitle track (index in subtitle track lists) **/\n\n  }, {\n    key: 'subtitleTrack',\n    get: function get() {\n      var subtitleTrackController = this.subtitleTrackController;\n      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n    }\n\n    /** select an subtitle track, based on its index in subtitle track lists**/\n    ,\n    set: function set(subtitleTrackId) {\n      var subtitleTrackController = this.subtitleTrackController;\n      if (subtitleTrackController) {\n        subtitleTrackController.subtitleTrack = subtitleTrackId;\n      }\n    }\n  }]);\n\n  return Hls;\n}();\n\nexports.default = Hls;\n\n},{\"1\":1,\"12\":12,\"13\":13,\"31\":31,\"33\":33,\"39\":39,\"4\":4,\"40\":40,\"41\":41,\"50\":50}],38:[function(_dereq_,module,exports){\n'use strict';\n\n// This is mostly for support of the es6 module export\n// syntax with the babel compiler, it looks like it doesnt support\n// function exports like we are used to in node/commonjs\nmodule.exports = _dereq_(37).default;\n\n},{\"37\":37}],39:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _errors = _dereq_(31);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar FragmentLoader = function (_EventHandler) {\n  _inherits(FragmentLoader, _EventHandler);\n\n  function FragmentLoader(hls) {\n    _classCallCheck(this, FragmentLoader);\n\n    var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));\n\n    _this.loaders = {};\n    return _this;\n  }\n\n  _createClass(FragmentLoader, [{\n    key: 'destroy',\n    value: function destroy() {\n      var loaders = this.loaders;\n      for (var loaderName in loaders) {\n        var loader = loaders[loaderName];\n        if (loader) {\n          loader.destroy();\n        }\n      }\n      this.loaders = {};\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n  }, {\n    key: 'onFragLoading',\n    value: function onFragLoading(data) {\n      var frag = data.frag,\n          type = frag.type,\n          loader = this.loaders[type],\n          config = this.hls.config;\n\n      frag.loaded = 0;\n      if (loader) {\n        _logger.logger.warn('abort previous fragment loader for type:' + type);\n        loader.abort();\n      }\n      loader = this.loaders[type] = frag.loader = typeof config.fLoader !== 'undefined' ? new config.fLoader(config) : new config.loader(config);\n\n      var loaderContext = void 0,\n          loaderConfig = void 0,\n          loaderCallbacks = void 0;\n      loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };\n      var start = frag.byteRangeStartOffset,\n          end = frag.byteRangeEndOffset;\n      if (!isNaN(start) && !isNaN(end)) {\n        loaderContext.rangeStart = start;\n        loaderContext.rangeEnd = end;\n      }\n      loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: config.fragLoadingMaxRetryTimeout };\n      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) };\n      loader.load(loaderContext, loaderConfig, loaderCallbacks);\n    }\n  }, {\n    key: 'loadsuccess',\n    value: function loadsuccess(response, stats, context) {\n      var payload = response.data,\n          frag = context.frag;\n      // detach fragment loader on load success\n      frag.loader = undefined;\n      this.loaders[frag.type] = undefined;\n      this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats });\n    }\n  }, {\n    key: 'loaderror',\n    value: function loaderror(response, context) {\n      var loader = context.loader;\n      if (loader) {\n        loader.abort();\n      }\n      this.loaders[context.type] = undefined;\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response });\n    }\n  }, {\n    key: 'loadtimeout',\n    value: function loadtimeout(stats, context) {\n      var loader = context.loader;\n      if (loader) {\n        loader.abort();\n      }\n      this.loaders[context.type] = undefined;\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag });\n    }\n\n    // data will be used for progressive parsing\n\n  }, {\n    key: 'loadprogress',\n    value: function loadprogress(stats, context, data) {\n      // jshint ignore:line\n      var frag = context.frag;\n      frag.loaded = stats.loaded;\n      this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats });\n    }\n  }]);\n\n  return FragmentLoader;\n}(_eventHandler2.default);\n\nexports.default = FragmentLoader;\n\n},{\"31\":31,\"32\":32,\"33\":33,\"50\":50}],40:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _errors = _dereq_(31);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar KeyLoader = function (_EventHandler) {\n  _inherits(KeyLoader, _EventHandler);\n\n  function KeyLoader(hls) {\n    _classCallCheck(this, KeyLoader);\n\n    var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));\n\n    _this.loaders = {};\n    _this.decryptkey = null;\n    _this.decrypturl = null;\n    return _this;\n  }\n\n  _createClass(KeyLoader, [{\n    key: 'destroy',\n    value: function destroy() {\n      for (var loaderName in this.loaders) {\n        var loader = this.loaders[loaderName];\n        if (loader) {\n          loader.destroy();\n        }\n      }\n      this.loaders = {};\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n  }, {\n    key: 'onKeyLoading',\n    value: function onKeyLoading(data) {\n      var frag = data.frag,\n          type = frag.type,\n          loader = this.loaders[type],\n          decryptdata = frag.decryptdata,\n          uri = decryptdata.uri;\n      // if uri is different from previous one or if decrypt key not retrieved yet\n      if (uri !== this.decrypturl || this.decryptkey === null) {\n        var config = this.hls.config;\n\n        if (loader) {\n          _logger.logger.warn('abort previous key loader for type:' + type);\n          loader.abort();\n        }\n        frag.loader = this.loaders[type] = new config.loader(config);\n        this.decrypturl = uri;\n        this.decryptkey = null;\n\n        var loaderContext = void 0,\n            loaderConfig = void 0,\n            loaderCallbacks = void 0;\n        loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };\n        loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: config.fragLoadingMaxRetry, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };\n        loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };\n        frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);\n      } else if (this.decryptkey) {\n        // we already loaded this key, return it\n        decryptdata.key = this.decryptkey;\n        this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });\n      }\n    }\n  }, {\n    key: 'loadsuccess',\n    value: function loadsuccess(response, stats, context) {\n      var frag = context.frag;\n      this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);\n      // detach fragment loader on load success\n      frag.loader = undefined;\n      this.loaders[frag.type] = undefined;\n      this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });\n    }\n  }, {\n    key: 'loaderror',\n    value: function loaderror(response, context) {\n      var frag = context.frag,\n          loader = frag.loader;\n      if (loader) {\n        loader.abort();\n      }\n      this.loaders[context.type] = undefined;\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });\n    }\n  }, {\n    key: 'loadtimeout',\n    value: function loadtimeout(stats, context) {\n      var frag = context.frag,\n          loader = frag.loader;\n      if (loader) {\n        loader.abort();\n      }\n      this.loaders[context.type] = undefined;\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });\n    }\n  }]);\n\n  return KeyLoader;\n}(_eventHandler2.default);\n\nexports.default = KeyLoader;\n\n},{\"31\":31,\"32\":32,\"33\":33,\"50\":50}],41:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Playlist Loader\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _urlToolkit = _dereq_(2);\n\nvar _urlToolkit2 = _interopRequireDefault(_urlToolkit);\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _errors = _dereq_(31);\n\nvar _attrList = _dereq_(45);\n\nvar _attrList2 = _interopRequireDefault(_attrList);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// https://regex101.com is your friend\nvar MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\n\\r]*)[\\r\\n]+([^\\r\\n]+)/g;\nvar MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\nvar LEVEL_PLAYLIST_REGEX_FAST = /#EXTINF:(\\d*(?:\\.\\d+)?)(?:,(.*))?|(?!#)(\\S.+)|#EXT-X-BYTERANGE: *(.+)|#EXT-X-PROGRAM-DATE-TIME:(.+)|#.*/g;\nvar LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\\d+))|(?:#EXT-X-(TARGETDURATION): *(\\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\\r?\\n?/;\n\nvar LevelKey = function () {\n  function LevelKey() {\n    _classCallCheck(this, LevelKey);\n\n    this.method = null;\n    this.key = null;\n    this.iv = null;\n    this._uri = null;\n  }\n\n  _createClass(LevelKey, [{\n    key: 'uri',\n    get: function get() {\n      if (!this._uri && this.reluri) {\n        this._uri = _urlToolkit2.default.buildAbsoluteURL(this.baseuri, this.reluri);\n      }\n      return this._uri;\n    }\n  }]);\n\n  return LevelKey;\n}();\n\nvar Fragment = function () {\n  function Fragment() {\n    _classCallCheck(this, Fragment);\n\n    this._url = null;\n    this._byteRange = null;\n    this._decryptdata = null;\n    this.tagList = [];\n  }\n\n  _createClass(Fragment, [{\n    key: 'createInitializationVector',\n\n\n    /**\n     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment\n     * @returns {Uint8Array}\n     */\n    value: function createInitializationVector(segmentNumber) {\n      var uint8View = new Uint8Array(16);\n\n      for (var i = 12; i < 16; i++) {\n        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n      }\n\n      return uint8View;\n    }\n\n    /**\n     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data\n     * @param levelkey - a playlist's encryption info\n     * @param segmentNumber - the fragment's segment number\n     * @returns {*} - an object to be applied as a fragment's decryptdata\n     */\n\n  }, {\n    key: 'fragmentDecryptdataFromLevelkey',\n    value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {\n      var decryptdata = levelkey;\n\n      if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {\n        decryptdata = new LevelKey();\n        decryptdata.method = levelkey.method;\n        decryptdata.baseuri = levelkey.baseuri;\n        decryptdata.reluri = levelkey.reluri;\n        decryptdata.iv = this.createInitializationVector(segmentNumber);\n      }\n\n      return decryptdata;\n    }\n  }, {\n    key: 'cloneObj',\n    value: function cloneObj(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n  }, {\n    key: 'url',\n    get: function get() {\n      if (!this._url && this.relurl) {\n        this._url = _urlToolkit2.default.buildAbsoluteURL(this.baseurl, this.relurl);\n      }\n      return this._url;\n    },\n    set: function set(value) {\n      this._url = value;\n    }\n  }, {\n    key: 'programDateTime',\n    get: function get() {\n      if (!this._programDateTime && this.rawProgramDateTime) {\n        this._programDateTime = new Date(Date.parse(this.rawProgramDateTime));\n      }\n      return this._programDateTime;\n    }\n  }, {\n    key: 'byteRange',\n    get: function get() {\n      if (!this._byteRange) {\n        var byteRange = this._byteRange = [];\n        if (this.rawByteRange) {\n          var params = this.rawByteRange.split('@', 2);\n          if (params.length === 1) {\n            var lastByteRangeEndOffset = this.lastByteRangeEndOffset;\n            byteRange[0] = lastByteRangeEndOffset ? lastByteRangeEndOffset : 0;\n          } else {\n            byteRange[0] = parseInt(params[1]);\n          }\n          byteRange[1] = parseInt(params[0]) + byteRange[0];\n        }\n      }\n      return this._byteRange;\n    }\n  }, {\n    key: 'byteRangeStartOffset',\n    get: function get() {\n      return this.byteRange[0];\n    }\n  }, {\n    key: 'byteRangeEndOffset',\n    get: function get() {\n      return this.byteRange[1];\n    }\n  }, {\n    key: 'decryptdata',\n    get: function get() {\n      if (!this._decryptdata) {\n        this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);\n      }\n      return this._decryptdata;\n    }\n  }]);\n\n  return Fragment;\n}();\n\nvar PlaylistLoader = function (_EventHandler) {\n  _inherits(PlaylistLoader, _EventHandler);\n\n  function PlaylistLoader(hls) {\n    _classCallCheck(this, PlaylistLoader);\n\n    var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING, _events2.default.SUBTITLE_TRACK_LOADING));\n\n    _this.loaders = {};\n    return _this;\n  }\n\n  _createClass(PlaylistLoader, [{\n    key: 'destroy',\n    value: function destroy() {\n      for (var loaderName in this.loaders) {\n        var loader = this.loaders[loaderName];\n        if (loader) {\n          loader.destroy();\n        }\n      }\n      this.loaders = {};\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n  }, {\n    key: 'onManifestLoading',\n    value: function onManifestLoading(data) {\n      this.load(data.url, { type: 'manifest' });\n    }\n  }, {\n    key: 'onLevelLoading',\n    value: function onLevelLoading(data) {\n      this.load(data.url, { type: 'level', level: data.level, id: data.id });\n    }\n  }, {\n    key: 'onAudioTrackLoading',\n    value: function onAudioTrackLoading(data) {\n      this.load(data.url, { type: 'audioTrack', id: data.id });\n    }\n  }, {\n    key: 'onSubtitleTrackLoading',\n    value: function onSubtitleTrackLoading(data) {\n      this.load(data.url, { type: 'subtitleTrack', id: data.id });\n    }\n  }, {\n    key: 'load',\n    value: function load(url, context) {\n      var loader = this.loaders[context.type];\n      if (loader) {\n        var loaderContext = loader.context;\n        if (loaderContext && loaderContext.url === url) {\n          _logger.logger.trace('playlist request ongoing');\n          return;\n        } else {\n          _logger.logger.warn('abort previous loader for type:' + context.type);\n          loader.abort();\n        }\n      }\n      var config = this.hls.config,\n          retry = void 0,\n          timeout = void 0,\n          retryDelay = void 0,\n          maxRetryDelay = void 0;\n      if (context.type === 'manifest') {\n        retry = config.manifestLoadingMaxRetry;\n        timeout = config.manifestLoadingTimeOut;\n        retryDelay = config.manifestLoadingRetryDelay;\n        maxRetryDelay = config.manifestLoadingMaxRetryTimeout;\n      } else {\n        retry = config.levelLoadingMaxRetry;\n        timeout = config.levelLoadingTimeOut;\n        retryDelay = config.levelLoadingRetryDelay;\n        maxRetryDelay = config.levelLoadingMaxRetryTimeout;\n        _logger.logger.log('loading playlist for ' + context.type + ' ' + (context.level || context.id));\n      }\n      loader = this.loaders[context.type] = context.loader = typeof config.pLoader !== 'undefined' ? new config.pLoader(config) : new config.loader(config);\n      context.url = url;\n      context.responseType = '';\n\n      var loaderConfig = void 0,\n          loaderCallbacks = void 0;\n      loaderConfig = { timeout: timeout, maxRetry: retry, retryDelay: retryDelay, maxRetryDelay: maxRetryDelay };\n      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };\n      loader.load(context, loaderConfig, loaderCallbacks);\n    }\n  }, {\n    key: 'resolve',\n    value: function resolve(url, baseUrl) {\n      return _urlToolkit2.default.buildAbsoluteURL(baseUrl, url);\n    }\n  }, {\n    key: 'parseMasterPlaylist',\n    value: function parseMasterPlaylist(string, baseurl) {\n      var levels = [],\n          result = void 0;\n      MASTER_PLAYLIST_REGEX.lastIndex = 0;\n      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n        var level = {};\n\n        var attrs = level.attrs = new _attrList2.default(result[1]);\n        level.url = this.resolve(result[2], baseurl);\n\n        var resolution = attrs.decimalResolution('RESOLUTION');\n        if (resolution) {\n          level.width = resolution.width;\n          level.height = resolution.height;\n        }\n        level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');\n        level.name = attrs.NAME;\n\n        var codecs = attrs.CODECS;\n        if (codecs) {\n          codecs = codecs.split(/[ ,]+/);\n          for (var i = 0; i < codecs.length; i++) {\n            var codec = codecs[i];\n            if (codec.indexOf('avc1') !== -1) {\n              level.videoCodec = this.avc1toavcoti(codec);\n            } else {\n              level.audioCodec = codec;\n            }\n          }\n        }\n\n        levels.push(level);\n      }\n      return levels;\n    }\n  }, {\n    key: 'parseMasterPlaylistMedia',\n    value: function parseMasterPlaylistMedia(string, baseurl, type) {\n      var result = void 0,\n          medias = [],\n          id = 0;\n      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) != null) {\n        var media = {};\n        var attrs = new _attrList2.default(result[1]);\n        if (attrs.TYPE === type) {\n          media.groupId = attrs['GROUP-ID'];\n          media.name = attrs.NAME;\n          media.type = type;\n          media.default = attrs.DEFAULT === 'YES';\n          media.autoselect = attrs.AUTOSELECT === 'YES';\n          media.forced = attrs.FORCED === 'YES';\n          if (attrs.URI) {\n            media.url = this.resolve(attrs.URI, baseurl);\n          }\n          media.lang = attrs.LANGUAGE;\n          if (!media.name) {\n            media.name = media.lang;\n          }\n          media.id = id++;\n          medias.push(media);\n        }\n      }\n      return medias;\n    }\n  }, {\n    key: 'avc1toavcoti',\n    value: function avc1toavcoti(codec) {\n      var result,\n          avcdata = codec.split('.');\n      if (avcdata.length > 2) {\n        result = avcdata.shift() + '.';\n        result += parseInt(avcdata.shift()).toString(16);\n        result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);\n      } else {\n        result = codec;\n      }\n      return result;\n    }\n  }, {\n    key: 'parseLevelPlaylist',\n    value: function parseLevelPlaylist(string, baseurl, id, type) {\n      var currentSN = 0,\n          totalduration = 0,\n          level = { type: null, version: null, url: baseurl, fragments: [], live: true, startSN: 0 },\n          levelkey = new LevelKey(),\n          cc = 0,\n          prevFrag = null,\n          frag = new Fragment(),\n          result,\n          i;\n\n      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n\n      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n        var duration = result[1];\n        if (duration) {\n          // INF\n          frag.duration = parseFloat(duration);\n          // avoid sliced strings    https://github.com/dailymotion/hls.js/issues/939\n          var title = (' ' + result[2]).slice(1);\n          frag.title = title ? title : null;\n          frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n        } else if (result[3]) {\n          // url\n          if (!isNaN(frag.duration)) {\n            var sn = currentSN++;\n            frag.type = type;\n            frag.start = totalduration;\n            frag.levelkey = levelkey;\n            frag.sn = sn;\n            frag.level = id;\n            frag.cc = cc;\n            frag.baseurl = baseurl;\n            // avoid sliced strings    https://github.com/dailymotion/hls.js/issues/939\n            frag.relurl = (' ' + result[3]).slice(1);\n\n            level.fragments.push(frag);\n            prevFrag = frag;\n            totalduration += frag.duration;\n\n            frag = new Fragment();\n          }\n        } else if (result[4]) {\n          // X-BYTERANGE\n          frag.rawByteRange = (' ' + result[4]).slice(1);\n          if (prevFrag) {\n            var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;\n            if (lastByteRangeEndOffset) {\n              frag.lastByteRangeEndOffset = lastByteRangeEndOffset;\n            }\n          }\n        } else if (result[5]) {\n          // PROGRAM-DATE-TIME\n          // avoid sliced strings    https://github.com/dailymotion/hls.js/issues/939\n          frag.rawProgramDateTime = (' ' + result[5]).slice(1);\n          frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);\n        } else {\n          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n          for (i = 1; i < result.length; i++) {\n            if (result[i] !== undefined) {\n              break;\n            }\n          }\n\n          // avoid sliced strings    https://github.com/dailymotion/hls.js/issues/939\n          var value1 = (' ' + result[i + 1]).slice(1);\n          var value2 = (' ' + result[i + 2]).slice(1);\n\n          switch (result[i]) {\n            case '#':\n              frag.tagList.push(value2 ? [value1, value2] : [value1]);\n              break;\n            case 'PLAYLIST-TYPE':\n              level.type = value1.toUpperCase();\n              break;\n            case 'MEDIA-SEQUENCE':\n              currentSN = level.startSN = parseInt(value1);\n              break;\n            case 'TARGETDURATION':\n              level.targetduration = parseFloat(value1);\n              break;\n            case 'VERSION':\n              level.version = parseInt(value1);\n              break;\n            case 'EXTM3U':\n              break;\n            case 'ENDLIST':\n              level.live = false;\n              break;\n            case 'DIS':\n              cc++;\n              frag.tagList.push(['DIS']);\n              break;\n            case 'DISCONTINUITY-SEQ':\n              cc = parseInt(value1);\n              break;\n            case 'KEY':\n              // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4\n              var decryptparams = value1;\n              var keyAttrs = new _attrList2.default(decryptparams);\n              var decryptmethod = keyAttrs.enumeratedString('METHOD'),\n                  decrypturi = keyAttrs.URI,\n                  decryptiv = keyAttrs.hexadecimalInteger('IV');\n              if (decryptmethod) {\n                levelkey = new LevelKey();\n                if (decrypturi && ['AES-128', 'SAMPLE-AES'].indexOf(decryptmethod) >= 0) {\n                  levelkey.method = decryptmethod;\n                  // URI to get the key\n                  levelkey.baseuri = baseurl;\n                  levelkey.reluri = decrypturi;\n                  levelkey.key = null;\n                  // Initialization Vector (IV)\n                  levelkey.iv = decryptiv;\n                }\n              }\n              break;\n            case 'START':\n              var startParams = value1;\n              var startAttrs = new _attrList2.default(startParams);\n              var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n              //TIME-OFFSET can be 0\n              if (!isNaN(startTimeOffset)) {\n                level.startTimeOffset = startTimeOffset;\n              }\n              break;\n            case 'MAP':\n              var mapAttrs = new _attrList2.default(value1);\n              frag.relurl = mapAttrs.URI;\n              frag.rawByteRange = mapAttrs.BYTERANGE;\n              frag.baseurl = baseurl;\n              frag.level = id;\n              frag.type = type;\n              frag.sn = 'initSegment';\n              level.initSegment = frag;\n              frag = new Fragment();\n              break;\n            default:\n              _logger.logger.warn('line parsed but not handled: ' + result);\n              break;\n          }\n        }\n      }\n      frag = prevFrag;\n      //logger.log('found ' + level.fragments.length + ' fragments');\n      if (frag && !frag.relurl) {\n        level.fragments.pop();\n        totalduration -= frag.duration;\n      }\n      level.totalduration = totalduration;\n      level.averagetargetduration = totalduration / level.fragments.length;\n      level.endSN = currentSN - 1;\n      return level;\n    }\n  }, {\n    key: 'loadsuccess',\n    value: function loadsuccess(response, stats, context) {\n      var string = response.data,\n          url = response.url,\n          type = context.type,\n          id = context.id,\n          level = context.level,\n          hls = this.hls;\n\n      this.loaders[type] = undefined;\n      // responseURL not supported on some browsers (it is used to detect URL redirection)\n      // data-uri mode also not supported (but no need to detect redirection)\n      if (url === undefined || url.indexOf('data:') === 0) {\n        // fallback to initial URL\n        url = context.url;\n      }\n      stats.tload = performance.now();\n      //stats.mtime = new Date(target.getResponseHeader('Last-Modified'));\n      if (string.indexOf('#EXTM3U') === 0) {\n        if (string.indexOf('#EXTINF:') > 0) {\n          var isLevel = type !== 'audioTrack' && type !== 'subtitleTrack',\n              levelId = !isNaN(level) ? level : !isNaN(id) ? id : 0,\n              levelDetails = this.parseLevelPlaylist(string, url, levelId, type === 'audioTrack' ? 'audio' : type === 'subtitleTrack' ? 'subtitle' : 'main');\n          levelDetails.tload = stats.tload;\n          if (type === 'manifest') {\n            // first request, stream manifest (no master playlist), fire manifest loaded event with level details\n            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: [{ url: url, details: levelDetails }], audioTracks: [], url: url, stats: stats });\n          }\n          stats.tparsed = performance.now();\n          if (levelDetails.targetduration) {\n            if (isLevel) {\n              hls.trigger(_events2.default.LEVEL_LOADED, { details: levelDetails, level: level || 0, id: id || 0, stats: stats });\n            } else {\n              if (type === 'audioTrack') {\n                hls.trigger(_events2.default.AUDIO_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });\n              } else if (type === 'subtitleTrack') {\n                hls.trigger(_events2.default.SUBTITLE_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });\n              }\n            }\n          } else {\n            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'invalid targetduration' });\n          }\n        } else {\n          var levels = this.parseMasterPlaylist(string, url);\n          // multi level playlist, parse level info\n          if (levels.length) {\n            var audioTracks = this.parseMasterPlaylistMedia(string, url, 'AUDIO');\n            var subtitles = this.parseMasterPlaylistMedia(string, url, 'SUBTITLES');\n            if (audioTracks.length) {\n              // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n              var embeddedAudioFound = false;\n              audioTracks.forEach(function (audioTrack) {\n                if (!audioTrack.url) {\n                  embeddedAudioFound = true;\n                }\n              });\n              // if no embedded audio track defined, but audio codec signaled in quality level, we need to signal this main audio track\n              // this could happen with playlists with alt audio rendition in which quality levels (main) contains both audio+video. but with mixed audio track not signaled\n              if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n                _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');\n                audioTracks.unshift({ type: 'main', name: 'main' });\n              }\n            }\n            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: levels, audioTracks: audioTracks, subtitles: subtitles, url: url, stats: stats });\n          } else {\n            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no level found in manifest' });\n          }\n        }\n      } else {\n        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no EXTM3U delimiter' });\n      }\n    }\n  }, {\n    key: 'loaderror',\n    value: function loaderror(response, context) {\n      var details,\n          fatal,\n          loader = context.loader;\n      switch (context.type) {\n        case 'manifest':\n          details = _errors.ErrorDetails.MANIFEST_LOAD_ERROR;\n          fatal = true;\n          break;\n        case 'level':\n          details = _errors.ErrorDetails.LEVEL_LOAD_ERROR;\n          fatal = false;\n          break;\n        case 'audioTrack':\n          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n          fatal = false;\n          break;\n      }\n      if (loader) {\n        loader.abort();\n        this.loaders[context.type] = undefined;\n      }\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, response: response, context: context });\n    }\n  }, {\n    key: 'loadtimeout',\n    value: function loadtimeout(stats, context) {\n      var details,\n          fatal,\n          loader = context.loader;\n      switch (context.type) {\n        case 'manifest':\n          details = _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT;\n          fatal = true;\n          break;\n        case 'level':\n          details = _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT;\n          fatal = false;\n          break;\n        case 'audioTrack':\n          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT;\n          fatal = false;\n          break;\n      }\n      if (loader) {\n        loader.abort();\n        this.loaders[context.type] = undefined;\n      }\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, context: context });\n    }\n  }]);\n\n  return PlaylistLoader;\n}(_eventHandler2.default);\n\nexports.default = PlaylistLoader;\n\n},{\"2\":2,\"31\":31,\"32\":32,\"33\":33,\"45\":45,\"50\":50}],42:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Generate MP4 Box\n*/\n\n//import Hex from '../utils/hex';\nvar MP4 = function () {\n  function MP4() {\n    _classCallCheck(this, MP4);\n  }\n\n  _createClass(MP4, null, [{\n    key: 'init',\n    value: function init() {\n      MP4.types = {\n        avc1: [], // codingname\n        avcC: [],\n        btrt: [],\n        dinf: [],\n        dref: [],\n        esds: [],\n        ftyp: [],\n        hdlr: [],\n        mdat: [],\n        mdhd: [],\n        mdia: [],\n        mfhd: [],\n        minf: [],\n        moof: [],\n        moov: [],\n        mp4a: [],\n        '.mp3': [],\n        mvex: [],\n        mvhd: [],\n        pasp: [],\n        sdtp: [],\n        stbl: [],\n        stco: [],\n        stsc: [],\n        stsd: [],\n        stsz: [],\n        stts: [],\n        tfdt: [],\n        tfhd: [],\n        traf: [],\n        trak: [],\n        trun: [],\n        trex: [],\n        tkhd: [],\n        vmhd: [],\n        smhd: []\n      };\n\n      var i;\n      for (i in MP4.types) {\n        if (MP4.types.hasOwnProperty(i)) {\n          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n        }\n      }\n\n      var videoHdlr = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n      ]);\n\n      var audioHdlr = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n      ]);\n\n      MP4.HDLR_TYPES = {\n        'video': videoHdlr,\n        'audio': audioHdlr\n      };\n\n      var dref = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // entry_count\n      0x00, 0x00, 0x00, 0x0c, // entry_size\n      0x75, 0x72, 0x6c, 0x20, // 'url' type\n      0x00, // version 0\n      0x00, 0x00, 0x01 // entry_flags\n      ]);\n\n      var stco = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00 // entry_count\n      ]);\n\n      MP4.STTS = MP4.STSC = MP4.STCO = stco;\n\n      MP4.STSZ = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // sample_size\n      0x00, 0x00, 0x00, 0x00]);\n      MP4.VMHD = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x01, // flags\n      0x00, 0x00, // graphicsmode\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n      ]);\n      MP4.SMHD = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, // balance\n      0x00, 0x00 // reserved\n      ]);\n\n      MP4.STSD = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01]); // entry_count\n\n      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n      var minorVersion = new Uint8Array([0, 0, 0, 1]);\n\n      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n    }\n  }, {\n    key: 'box',\n    value: function box(type) {\n      var payload = Array.prototype.slice.call(arguments, 1),\n          size = 8,\n          i = payload.length,\n          len = i,\n          result;\n      // calculate the total size we need to allocate\n      while (i--) {\n        size += payload[i].byteLength;\n      }\n      result = new Uint8Array(size);\n      result[0] = size >> 24 & 0xff;\n      result[1] = size >> 16 & 0xff;\n      result[2] = size >> 8 & 0xff;\n      result[3] = size & 0xff;\n      result.set(type, 4);\n      // copy the payload into the result\n      for (i = 0, size = 8; i < len; i++) {\n        // copy payload[i] array @ offset size\n        result.set(payload[i], size);\n        size += payload[i].byteLength;\n      }\n      return result;\n    }\n  }, {\n    key: 'hdlr',\n    value: function hdlr(type) {\n      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n    }\n  }, {\n    key: 'mdat',\n    value: function mdat(data) {\n      return MP4.box(MP4.types.mdat, data);\n    }\n  }, {\n    key: 'mdhd',\n    value: function mdhd(timescale, duration) {\n      duration *= timescale;\n      return MP4.box(MP4.types.mdhd, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x02, // creation_time\n      0x00, 0x00, 0x00, 0x03, // modification_time\n      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale\n      duration >> 24, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration\n      0x55, 0xc4, // 'und' language (undetermined)\n      0x00, 0x00]));\n    }\n  }, {\n    key: 'mdia',\n    value: function mdia(track) {\n      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n    }\n  }, {\n    key: 'mfhd',\n    value: function mfhd(sequenceNumber) {\n      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags\n      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]));\n    }\n  }, {\n    key: 'minf',\n    value: function minf(track) {\n      if (track.type === 'audio') {\n        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n      } else {\n        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n      }\n    }\n  }, {\n    key: 'moof',\n    value: function moof(sn, baseMediaDecodeTime, track) {\n      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n    }\n    /**\n     * @param tracks... (optional) {array} the tracks associated with this movie\n     */\n\n  }, {\n    key: 'moov',\n    value: function moov(tracks) {\n      var i = tracks.length,\n          boxes = [];\n\n      while (i--) {\n        boxes[i] = MP4.trak(tracks[i]);\n      }\n\n      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));\n    }\n  }, {\n    key: 'mvex',\n    value: function mvex(tracks) {\n      var i = tracks.length,\n          boxes = [];\n\n      while (i--) {\n        boxes[i] = MP4.trex(tracks[i]);\n      }\n      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));\n    }\n  }, {\n    key: 'mvhd',\n    value: function mvhd(timescale, duration) {\n      duration *= timescale;\n      var bytes = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // creation_time\n      0x00, 0x00, 0x00, 0x02, // modification_time\n      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale\n      duration >> 24 & 0xFF, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration\n      0x00, 0x01, 0x00, 0x00, // 1.0 rate\n      0x01, 0x00, // 1.0 volume\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n      0xff, 0xff, 0xff, 0xff // next_track_ID\n      ]);\n      return MP4.box(MP4.types.mvhd, bytes);\n    }\n  }, {\n    key: 'sdtp',\n    value: function sdtp(track) {\n      var samples = track.samples || [],\n          bytes = new Uint8Array(4 + samples.length),\n          flags,\n          i;\n      // leave the full box header (4 bytes) all zero\n      // write the sample table\n      for (i = 0; i < samples.length; i++) {\n        flags = samples[i].flags;\n        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n      }\n\n      return MP4.box(MP4.types.sdtp, bytes);\n    }\n  }, {\n    key: 'stbl',\n    value: function stbl(track) {\n      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n    }\n  }, {\n    key: 'avc1',\n    value: function avc1(track) {\n      var sps = [],\n          pps = [],\n          i,\n          data,\n          len;\n      // assemble the SPSs\n\n      for (i = 0; i < track.sps.length; i++) {\n        data = track.sps[i];\n        len = data.byteLength;\n        sps.push(len >>> 8 & 0xFF);\n        sps.push(len & 0xFF);\n        sps = sps.concat(Array.prototype.slice.call(data)); // SPS\n      }\n\n      // assemble the PPSs\n      for (i = 0; i < track.pps.length; i++) {\n        data = track.pps[i];\n        len = data.byteLength;\n        pps.push(len >>> 8 & 0xFF);\n        pps.push(len & 0xFF);\n        pps = pps.concat(Array.prototype.slice.call(data));\n      }\n\n      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version\n      sps[3], // profile\n      sps[4], // profile compat\n      sps[5], // level\n      0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes\n      0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n      ]).concat(pps))),\n          // \"PPS\"\n      width = track.width,\n          height = track.height,\n          hSpacing = track.pixelRatio[0],\n          vSpacing = track.pixelRatio[1];\n      //console.log('avcc:' + Hex.hexDump(avcc));\n      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n      width >> 8 & 0xFF, width & 0xff, // width\n      height >> 8 & 0xFF, height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n      0x12, 0x64, 0x61, 0x69, 0x6C, //dailymotion/hls.js\n      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11]), // pre_defined = -1\n      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n      0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate\n      MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing\n      hSpacing >> 16 & 0xFF, hSpacing >> 8 & 0xFF, hSpacing & 0xFF, vSpacing >> 24, // vSpacing\n      vSpacing >> 16 & 0xFF, vSpacing >> 8 & 0xFF, vSpacing & 0xFF])));\n    }\n  }, {\n    key: 'esds',\n    value: function esds(track) {\n      var configlen = track.config.length;\n      return new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n\n      0x03, // descriptor_type\n      0x17 + configlen, // length\n      0x00, 0x01, //es_id\n      0x00, // stream_priority\n\n      0x04, // descriptor_type\n      0x0f + configlen, // length\n      0x40, //codec : mpeg4_audio\n      0x15, // stream_type\n      0x00, 0x00, 0x00, // buffer_size\n      0x00, 0x00, 0x00, 0x00, // maxBitrate\n      0x00, 0x00, 0x00, 0x00, // avgBitrate\n\n      0x05 // descriptor_type\n      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\n    }\n  }, {\n    key: 'mp4a',\n    value: function mp4a(track) {\n      var audiosamplerate = track.audiosamplerate;\n      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, track.channelCount, // channelcount\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, 0x00, 0x00, // reserved2\n      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //\n      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));\n    }\n  }, {\n    key: 'mp3',\n    value: function mp3(track) {\n      var audiosamplerate = track.audiosamplerate;\n      return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, track.channelCount, // channelcount\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, 0x00, 0x00, // reserved2\n      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //\n      0x00, 0x00]));\n    }\n  }, {\n    key: 'stsd',\n    value: function stsd(track) {\n      if (track.type === 'audio') {\n        if (!track.isAAC && track.codec === 'mp3') {\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n        }\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n      } else {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n      }\n    }\n  }, {\n    key: 'tkhd',\n    value: function tkhd(track) {\n      var id = track.id,\n          duration = track.duration * track.timescale,\n          width = track.width,\n          height = track.height;\n      return MP4.box(MP4.types.tkhd, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x07, // flags\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // modification_time\n      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID\n      0x00, 0x00, 0x00, 0x00, // reserved\n      duration >> 24, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, // layer\n      0x00, 0x00, // alternate_group\n      0x00, 0x00, // non-audio track volume\n      0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width\n      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height\n      ]));\n    }\n  }, {\n    key: 'traf',\n    value: function traf(track, baseMediaDecodeTime) {\n      var sampleDependencyTable = MP4.sdtp(track),\n          id = track.id;\n      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF])), MP4.box(MP4.types.tfdt, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      baseMediaDecodeTime >> 24, baseMediaDecodeTime >> 16 & 0XFF, baseMediaDecodeTime >> 8 & 0XFF, baseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd\n      16 + // tfdt\n      8 + // traf header\n      16 + // mfhd\n      8 + // moof header\n      8), // mdat header\n      sampleDependencyTable);\n    }\n\n    /**\n     * Generate a track box.\n     * @param track {object} a track definition\n     * @return {Uint8Array} the track box\n     */\n\n  }, {\n    key: 'trak',\n    value: function trak(track) {\n      track.duration = track.duration || 0xffffffff;\n      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n    }\n  }, {\n    key: 'trex',\n    value: function trex(track) {\n      var id = track.id;\n      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x00, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x01, 0x00, 0x01 // default_sample_flags\n      ]));\n    }\n  }, {\n    key: 'trun',\n    value: function trun(track, offset) {\n      var samples = track.samples || [],\n          len = samples.length,\n          arraylen = 12 + 16 * len,\n          array = new Uint8Array(arraylen),\n          i,\n          sample,\n          duration,\n          size,\n          flags,\n          cts;\n      offset += 8 + arraylen;\n      array.set([0x00, // version 0\n      0x00, 0x0f, 0x01, // flags\n      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count\n      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset\n      ], 0);\n      for (i = 0; i < len; i++) {\n        sample = samples[i];\n        duration = sample.duration;\n        size = sample.size;\n        flags = sample.flags;\n        cts = sample.cts;\n        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration\n        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size\n        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags\n        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset\n        ], 12 + 16 * i);\n      }\n      return MP4.box(MP4.types.trun, array);\n    }\n  }, {\n    key: 'initSegment',\n    value: function initSegment(tracks) {\n      if (!MP4.types) {\n        MP4.init();\n      }\n      var movie = MP4.moov(tracks),\n          result;\n      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);\n      result.set(MP4.FTYP);\n      result.set(movie, MP4.FTYP.byteLength);\n      return result;\n    }\n  }]);\n\n  return MP4;\n}();\n\nexports.default = MP4;\n\n},{}],43:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fMP4 remuxer\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _aac = _dereq_(34);\n\nvar _aac2 = _interopRequireDefault(_aac);\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _logger = _dereq_(50);\n\nvar _mp4Generator = _dereq_(42);\n\nvar _mp4Generator2 = _interopRequireDefault(_mp4Generator);\n\nvar _errors = _dereq_(31);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MP4Remuxer = function () {\n  function MP4Remuxer(observer, config, typeSupported) {\n    _classCallCheck(this, MP4Remuxer);\n\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.ISGenerated = false;\n    this.PES2MP4SCALEFACTOR = 4;\n    this.PES_TIMESCALE = 90000;\n    this.MP4_TIMESCALE = this.PES_TIMESCALE / this.PES2MP4SCALEFACTOR;\n  }\n\n  _createClass(MP4Remuxer, [{\n    key: 'destroy',\n    value: function destroy() {}\n  }, {\n    key: 'resetTimeStamp',\n    value: function resetTimeStamp(defaultTimeStamp) {\n      this._initPTS = this._initDTS = defaultTimeStamp;\n    }\n  }, {\n    key: 'resetInitSegment',\n    value: function resetInitSegment() {\n      this.ISGenerated = false;\n    }\n  }, {\n    key: 'remux',\n    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {\n      // generate Init Segment if needed\n      if (!this.ISGenerated) {\n        this.generateIS(audioTrack, videoTrack, timeOffset);\n      }\n\n      if (this.ISGenerated) {\n        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is\n        // calculated in remuxAudio.\n        //logger.log('nb AAC samples:' + audioTrack.samples.length);\n        if (audioTrack.samples.length) {\n          var audioData = this.remuxAudio(audioTrack, timeOffset, contiguous, accurateTimeOffset);\n          //logger.log('nb AVC samples:' + videoTrack.samples.length);\n          if (videoTrack.samples.length) {\n            var audioTrackLength = void 0;\n            if (audioData) {\n              audioTrackLength = audioData.endPTS - audioData.startPTS;\n            }\n            this.remuxVideo(videoTrack, timeOffset, contiguous, audioTrackLength);\n          }\n        } else {\n          var videoData = void 0;\n          //logger.log('nb AVC samples:' + videoTrack.samples.length);\n          if (videoTrack.samples.length) {\n            videoData = this.remuxVideo(videoTrack, timeOffset, contiguous);\n          }\n          if (videoData && audioTrack.codec) {\n            this.remuxEmptyAudio(audioTrack, timeOffset, contiguous, videoData);\n          }\n        }\n      }\n      //logger.log('nb ID3 samples:' + audioTrack.samples.length);\n      if (id3Track.samples.length) {\n        this.remuxID3(id3Track, timeOffset);\n      }\n      //logger.log('nb ID3 samples:' + audioTrack.samples.length);\n      if (textTrack.samples.length) {\n        this.remuxText(textTrack, timeOffset);\n      }\n      //notify end of parsing\n      this.observer.trigger(_events2.default.FRAG_PARSED);\n    }\n  }, {\n    key: 'generateIS',\n    value: function generateIS(audioTrack, videoTrack, timeOffset) {\n      var observer = this.observer,\n          audioSamples = audioTrack.samples,\n          videoSamples = videoTrack.samples,\n          pesTimeScale = this.PES_TIMESCALE,\n          typeSupported = this.typeSupported,\n          container = 'audio/mp4',\n          tracks = {},\n          data = { tracks: tracks, unique: false },\n          computePTSDTS = this._initPTS === undefined,\n          initPTS,\n          initDTS;\n\n      if (computePTSDTS) {\n        initPTS = initDTS = Infinity;\n      }\n      if (audioTrack.config && audioSamples.length) {\n        audioTrack.timescale = audioTrack.audiosamplerate;\n        // MP4 duration (track duration in seconds multiplied by timescale) is coded on 32 bits\n        // we know that each AAC sample contains 1024 frames....\n        // in order to avoid overflowing the 32 bit counter for large duration, we use smaller timescale (timescale/gcd)\n        // we just need to ensure that AAC sample duration will still be an integer (will be 1024/gcd)\n        if (audioTrack.timescale * audioTrack.duration > Math.pow(2, 32)) {\n          (function () {\n            var greatestCommonDivisor = function greatestCommonDivisor(a, b) {\n              if (!b) {\n                return a;\n              }\n              return greatestCommonDivisor(b, a % b);\n            };\n            audioTrack.timescale = audioTrack.audiosamplerate / greatestCommonDivisor(audioTrack.audiosamplerate, audioTrack.isAAC ? 1024 : 1152);\n          })();\n        }\n        _logger.logger.log('audio mp4 timescale :' + audioTrack.timescale);\n        if (!audioTrack.isAAC) {\n          if (typeSupported.mpeg) {\n            // Chrome and Safari\n            container = 'audio/mpeg';\n            audioTrack.codec = '';\n          } else if (typeSupported.mp3) {\n            // Firefox\n            audioTrack.codec = 'mp3';\n          }\n        }\n        tracks.audio = {\n          container: container,\n          codec: audioTrack.codec,\n          initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : _mp4Generator2.default.initSegment([audioTrack]),\n          metadata: {\n            channelCount: audioTrack.channelCount\n          }\n        };\n        if (computePTSDTS) {\n          // remember first PTS of this demuxing context. for audio, PTS = DTS\n          initPTS = initDTS = audioSamples[0].pts - pesTimeScale * timeOffset;\n        }\n      }\n\n      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n        videoTrack.timescale = this.MP4_TIMESCALE;\n        tracks.video = {\n          container: 'video/mp4',\n          codec: videoTrack.codec,\n          initSegment: _mp4Generator2.default.initSegment([videoTrack]),\n          metadata: {\n            width: videoTrack.width,\n            height: videoTrack.height\n          }\n        };\n        if (computePTSDTS) {\n          initPTS = Math.min(initPTS, videoSamples[0].pts - pesTimeScale * timeOffset);\n          initDTS = Math.min(initDTS, videoSamples[0].dts - pesTimeScale * timeOffset);\n          this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });\n        }\n      }\n\n      if (Object.keys(tracks).length) {\n        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);\n        this.ISGenerated = true;\n        if (computePTSDTS) {\n          this._initPTS = initPTS;\n          this._initDTS = initDTS;\n        }\n      } else {\n        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });\n      }\n    }\n  }, {\n    key: 'remuxVideo',\n    value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n      var offset = 8,\n          pesTimeScale = this.PES_TIMESCALE,\n          pes2mp4ScaleFactor = this.PES2MP4SCALEFACTOR,\n          mp4SampleDuration,\n          mdat,\n          moof,\n          firstPTS,\n          firstDTS,\n          nextDTS,\n          lastPTS,\n          lastDTS,\n          inputSamples = track.samples,\n          outputSamples = [],\n          nbSamples = inputSamples.length,\n          ptsNormalize = this._PTSNormalize,\n          initDTS = this._initDTS;\n\n      // for (let i = 0; i < track.samples.length; i++) {\n      //   let avcSample = track.samples[i];\n      //   let units = avcSample.units.units;\n      //   let unitsString = '';\n      //   for (let j = 0; j < units.length ; j++) {\n      //     unitsString += units[j].type + ',';\n      //     if (units[j].data.length < 500) {\n      //       unitsString += Hex.hexDump(units[j].data);\n      //     }\n      //   }\n      //   logger.log(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);\n      // }\n\n      // sort video samples by DTS then PTS order\n      inputSamples.sort(function (a, b) {\n        var deltadts = a.dts - b.dts;\n        return deltadts ? deltadts : a.pts - b.pts;\n      });\n\n      // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)\n      var PTSDTSshift = inputSamples.reduce(function (prev, curr) {\n        return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);\n      }, 0);\n      if (PTSDTSshift < 0) {\n        _logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');\n        for (var i = 0; i < inputSamples.length; i++) {\n          inputSamples[i].dts += PTSDTSshift;\n        }\n      }\n\n      // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n      // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n      var nextAvcDts = void 0;\n      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n      if (contiguous) {\n        // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n        nextAvcDts = this.nextAvcDts;\n      } else {\n        // if not contiguous, let's use target timeOffset\n        nextAvcDts = timeOffset * pesTimeScale;\n      }\n\n      // compute first DTS and last DTS, normalize them against reference value\n      var sample = inputSamples[0];\n      firstDTS = Math.max(ptsNormalize(sample.dts - initDTS, nextAvcDts), 0);\n      firstPTS = Math.max(ptsNormalize(sample.pts - initDTS, nextAvcDts), 0);\n\n      // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)\n      var delta = Math.round((firstDTS - nextAvcDts) / 90);\n      // if fragment are contiguous, detect hole/overlapping between fragments\n      if (contiguous) {\n        if (delta) {\n          if (delta > 1) {\n            _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');\n          } else if (delta < -1) {\n            _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');\n          }\n          // remove hole/gap : set DTS to next expected DTS\n          firstDTS = nextAvcDts;\n          inputSamples[0].dts = firstDTS + initDTS;\n          // offset PTS as well, ensure that PTS is smaller or equal than new DTS\n          firstPTS = Math.max(firstPTS - delta, nextAvcDts);\n          inputSamples[0].pts = firstPTS + initDTS;\n          _logger.logger.log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');\n        }\n      }\n      nextDTS = firstDTS;\n\n      // compute lastPTS/lastDTS\n      sample = inputSamples[inputSamples.length - 1];\n      lastDTS = Math.max(ptsNormalize(sample.dts - initDTS, nextAvcDts), 0);\n      lastPTS = Math.max(ptsNormalize(sample.pts - initDTS, nextAvcDts), 0);\n      lastPTS = Math.max(lastPTS, lastDTS);\n\n      var vendor = navigator.vendor,\n          userAgent = navigator.userAgent,\n          isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');\n\n      // on Safari let's signal the same sample duration for all samples\n      // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n      // set this constant duration as being the avg delta between consecutive DTS.\n      if (isSafari) {\n        mp4SampleDuration = Math.round((lastDTS - firstDTS) / (pes2mp4ScaleFactor * (inputSamples.length - 1)));\n      }\n\n      var nbNalu = 0,\n          naluLen = 0;\n      for (var _i = 0; _i < nbSamples; _i++) {\n        // compute total/avc sample length and nb of NAL units\n        var _sample = inputSamples[_i],\n            units = _sample.units.units,\n            nbUnits = units.length,\n            sampleLen = 0;\n        for (var j = 0; j < nbUnits; j++) {\n          sampleLen += units[j].data.length;\n        }\n        naluLen += sampleLen;\n        nbNalu += nbUnits;\n        _sample.length = sampleLen;\n\n        // normalize PTS/DTS\n        if (isSafari) {\n          // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples\n          _sample.dts = firstDTS + _i * pes2mp4ScaleFactor * mp4SampleDuration;\n        } else {\n          // ensure sample monotonic DTS\n          _sample.dts = Math.max(ptsNormalize(_sample.dts - initDTS, nextAvcDts), firstDTS);\n          // ensure dts is a multiple of scale factor to avoid rounding issues\n          _sample.dts = Math.round(_sample.dts / pes2mp4ScaleFactor) * pes2mp4ScaleFactor;\n        }\n        // we normalize PTS against nextAvcDts, we also substract initDTS (some streams don't start @ PTS O)\n        // and we ensure that computed value is greater or equal than sample DTS\n        _sample.pts = Math.max(ptsNormalize(_sample.pts - initDTS, nextAvcDts), _sample.dts);\n        // ensure pts is a multiple of scale factor to avoid rounding issues\n        _sample.pts = Math.round(_sample.pts / pes2mp4ScaleFactor) * pes2mp4ScaleFactor;\n      }\n\n      /* concatenate the video data and construct the mdat in place\n        (need 8 more bytes to fill length and mpdat type) */\n      var mdatSize = naluLen + 4 * nbNalu + 8;\n      try {\n        mdat = new Uint8Array(mdatSize);\n      } catch (err) {\n        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating video mdat ' + mdatSize });\n        return;\n      }\n      var view = new DataView(mdat.buffer);\n      view.setUint32(0, mdatSize);\n      mdat.set(_mp4Generator2.default.types.mdat, 4);\n\n      for (var _i2 = 0; _i2 < nbSamples; _i2++) {\n        var avcSample = inputSamples[_i2],\n            avcSampleUnits = avcSample.units.units,\n            mp4SampleLength = 0,\n            compositionTimeOffset = void 0;\n        // convert NALU bitstream to MP4 format (prepend NALU with size field)\n        for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {\n          var unit = avcSampleUnits[_j],\n              unitData = unit.data,\n              unitDataLen = unit.data.byteLength;\n          view.setUint32(offset, unitDataLen);\n          offset += 4;\n          mdat.set(unitData, offset);\n          offset += unitDataLen;\n          mp4SampleLength += 4 + unitDataLen;\n        }\n\n        if (!isSafari) {\n          // expected sample duration is the Decoding Timestamp diff of consecutive samples\n          if (_i2 < nbSamples - 1) {\n            mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;\n          } else {\n            var config = this.config,\n                lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;\n            if (config.stretchShortVideoTrack) {\n              // In some cases, a segment's audio track duration may exceed the video track duration.\n              // Since we've already remuxed audio, and we know how long the audio track is, we look to\n              // see if the delta to the next segment is longer than the minimum of maxBufferHole and\n              // maxSeekHole. If so, playback would potentially get stuck, so we artificially inflate\n              // the duration of the last frame to minimize any potential gap between segments.\n              var maxBufferHole = config.maxBufferHole,\n                  maxSeekHole = config.maxSeekHole,\n                  gapTolerance = Math.floor(Math.min(maxBufferHole, maxSeekHole) * pesTimeScale),\n                  deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * pesTimeScale : this.nextAudioPts) - avcSample.pts;\n              if (deltaToFrameEnd > gapTolerance) {\n                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n                // frame overlap. maxBufferHole/maxSeekHole should be >> lastFrameDuration anyway.\n                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n                if (mp4SampleDuration < 0) {\n                  mp4SampleDuration = lastFrameDuration;\n                }\n                _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');\n              } else {\n                mp4SampleDuration = lastFrameDuration;\n              }\n            } else {\n              mp4SampleDuration = lastFrameDuration;\n            }\n          }\n          mp4SampleDuration /= pes2mp4ScaleFactor;\n          compositionTimeOffset = Math.round((avcSample.pts - avcSample.dts) / pes2mp4ScaleFactor);\n        } else {\n          compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / (pes2mp4ScaleFactor * mp4SampleDuration)));\n        }\n\n        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');\n        outputSamples.push({\n          size: mp4SampleLength,\n          // constant duration\n          duration: mp4SampleDuration,\n          cts: compositionTimeOffset,\n          flags: {\n            isLeading: 0,\n            isDependedOn: 0,\n            hasRedundancy: 0,\n            degradPrio: 0,\n            dependsOn: avcSample.key ? 2 : 1,\n            isNonSync: avcSample.key ? 0 : 1\n          }\n        });\n      }\n      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n      this.nextAvcDts = lastDTS + mp4SampleDuration * pes2mp4ScaleFactor;\n      var dropped = track.dropped;\n      track.len = 0;\n      track.nbNalu = 0;\n      track.dropped = 0;\n      if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {\n        var flags = outputSamples[0].flags;\n        // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue\n        // https://code.google.com/p/chromium/issues/detail?id=229412\n        flags.dependsOn = 2;\n        flags.isNonSync = 0;\n      }\n      track.samples = outputSamples;\n      moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / pes2mp4ScaleFactor, track);\n      track.samples = [];\n\n      var data = {\n        data1: moof,\n        data2: mdat,\n        startPTS: firstPTS / pesTimeScale,\n        endPTS: (lastPTS + pes2mp4ScaleFactor * mp4SampleDuration) / pesTimeScale,\n        startDTS: firstDTS / pesTimeScale,\n        endDTS: this.nextAvcDts / pesTimeScale,\n        type: 'video',\n        nb: outputSamples.length,\n        dropped: dropped\n      };\n      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);\n      return data;\n    }\n  }, {\n    key: 'remuxAudio',\n    value: function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {\n      var pesTimeScale = this.PES_TIMESCALE,\n          mp4timeScale = track.timescale,\n          pes2mp4ScaleFactor = pesTimeScale / mp4timeScale,\n          expectedSampleDuration = track.timescale * (track.isAAC ? 1024 : 1152) / track.audiosamplerate,\n          pesFrameDuration = expectedSampleDuration * pes2mp4ScaleFactor,\n          ptsNormalize = this._PTSNormalize,\n          initDTS = this._initDTS,\n          rawMPEG = !track.isAAC && this.typeSupported.mpeg;\n\n      var view,\n          offset = rawMPEG ? 0 : 8,\n          audioSample,\n          mp4Sample,\n          unit,\n          mdat,\n          moof,\n          firstPTS,\n          firstDTS,\n          lastDTS,\n          pts,\n          dts,\n          ptsnorm,\n          dtsnorm,\n          outputSamples = [],\n          inputSamples = [],\n          fillFrame,\n          newStamp,\n          nextAudioPts;\n\n      track.samples.sort(function (a, b) {\n        return a.pts - b.pts;\n      });\n      inputSamples = track.samples;\n\n      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n      // for sake of clarity:\n      // consecutive fragments are frags with\n      //  - less than 100ms gaps between new time offset and next expected PTS OR\n      //  - less than 20 audio frames distance\n      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n      // this helps ensuring audio continuity\n      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n\n      nextAudioPts = this.nextAudioPts;\n      contiguous |= inputSamples.length && nextAudioPts && (Math.abs(timeOffset - nextAudioPts / pesTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - this._initDTS) < 20 * pesFrameDuration);\n\n      if (!contiguous) {\n        // if fragments are not contiguous, let's use timeOffset to compute next Audio PTS\n        nextAudioPts = timeOffset * pesTimeScale;\n      }\n      // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n      // In an effort to prevent this from happening, we inject frames here where there are gaps.\n      // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n      // frame.\n\n      // only inject/drop audio frames in case time offset is accurate\n      if (accurateTimeOffset && track.isAAC) {\n        for (var i = 0, nextPtsNorm = nextAudioPts; i < inputSamples.length;) {\n          // First, let's see how far off this frame is from where we expect it to be\n          var sample = inputSamples[i],\n              ptsNorm = ptsNormalize(sample.pts - initDTS, nextAudioPts),\n              delta = ptsNorm - nextPtsNorm;\n\n          // If we're overlapping by more than a duration, drop this sample\n          if (delta <= -pesFrameDuration) {\n            _logger.logger.warn('Dropping 1 audio frame @ ' + Math.round(nextPtsNorm / 90) / 1000 + 's due to ' + Math.round(Math.abs(delta / 90)) + ' ms overlap.');\n            inputSamples.splice(i, 1);\n            track.len -= sample.unit.length;\n            // Don't touch nextPtsNorm or i\n          }\n          // Otherwise, if we're more than a frame away from where we should be, insert missing frames\n          // also only inject silent audio frames if currentTime !== 0 (nextPtsNorm !== 0)\n          else if (delta >= pesFrameDuration && nextPtsNorm) {\n              var missing = Math.round(delta / pesFrameDuration);\n              _logger.logger.warn('Injecting ' + missing + ' audio frame @ ' + Math.round(nextPtsNorm / 90) / 1000 + 's due to ' + Math.round(delta / 90) + ' ms gap.');\n              for (var j = 0; j < missing; j++) {\n                newStamp = nextPtsNorm + initDTS;\n                newStamp = Math.max(newStamp, initDTS);\n                fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                if (!fillFrame) {\n                  _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');\n                  fillFrame = sample.unit.subarray();\n                }\n                inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });\n                track.len += fillFrame.length;\n                nextPtsNorm += pesFrameDuration;\n                i += 1;\n              }\n\n              // Adjust sample to next expected pts\n              sample.pts = sample.dts = nextPtsNorm + initDTS;\n              nextPtsNorm += pesFrameDuration;\n              i += 1;\n            }\n            // Otherwise, we're within half a frame duration, so just adjust pts\n            else {\n                if (Math.abs(delta) > 0.1 * pesFrameDuration) {\n                  //logger.log(`Invalid frame delta ${Math.round(ptsNorm - nextPtsNorm + pesFrameDuration)} at PTS ${Math.round(ptsNorm / 90)} (should be ${Math.round(pesFrameDuration)}).`);\n                }\n                nextPtsNorm += pesFrameDuration;\n                if (i === 0) {\n                  sample.pts = sample.dts = initDTS + nextAudioPts;\n                } else {\n                  sample.pts = sample.dts = inputSamples[i - 1].pts + pesFrameDuration;\n                }\n                i += 1;\n              }\n        }\n      }\n\n      for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {\n        audioSample = inputSamples[_j2];\n        unit = audioSample.unit;\n        pts = audioSample.pts - initDTS;\n        dts = audioSample.dts - initDTS;\n        //logger.log(`Audio/PTS:${Math.round(pts/90)}`);\n        // if not first sample\n        if (lastDTS !== undefined) {\n          ptsnorm = ptsNormalize(pts, lastDTS);\n          dtsnorm = ptsNormalize(dts, lastDTS);\n          mp4Sample.duration = Math.round((dtsnorm - lastDTS) / pes2mp4ScaleFactor);\n        } else {\n          ptsnorm = ptsNormalize(pts, nextAudioPts);\n          dtsnorm = ptsNormalize(dts, nextAudioPts);\n          var _delta = Math.round(1000 * (ptsnorm - nextAudioPts) / pesTimeScale),\n              numMissingFrames = 0;\n          // if fragment are contiguous, detect hole/overlapping between fragments\n          // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n          if (contiguous && track.isAAC) {\n            // log delta\n            if (_delta) {\n              if (_delta > 0) {\n                numMissingFrames = Math.round((ptsnorm - nextAudioPts) / pesFrameDuration);\n                _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');\n                if (numMissingFrames > 0) {\n                  fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                  if (!fillFrame) {\n                    fillFrame = unit.subarray();\n                  }\n                  track.len += numMissingFrames * fillFrame.length;\n                }\n                // if we have frame overlap, overlapping for more than half a frame duraion\n              } else if (_delta < -12) {\n                // drop overlapping audio frames... browser will deal with it\n                _logger.logger.log(-_delta + ' ms overlapping between AAC samples detected, drop frame');\n                track.len -= unit.byteLength;\n                continue;\n              }\n              // set PTS/DTS to expected PTS/DTS\n              ptsnorm = dtsnorm = nextAudioPts;\n            }\n          }\n          // remember first PTS of our audioSamples, ensure value is positive\n          firstPTS = Math.max(0, ptsnorm);\n          firstDTS = Math.max(0, dtsnorm);\n          if (track.len > 0) {\n            /* concatenate the audio data and construct the mdat in place\n              (need 8 more bytes to fill length and mdat type) */\n\n            var mdatSize = rawMPEG ? track.len : track.len + 8;\n            try {\n              mdat = new Uint8Array(mdatSize);\n            } catch (err) {\n              this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating audio mdat ' + mdatSize });\n              return;\n            }\n            if (!rawMPEG) {\n              view = new DataView(mdat.buffer);\n              view.setUint32(0, mdatSize);\n              mdat.set(_mp4Generator2.default.types.mdat, 4);\n            }\n          } else {\n            // no audio samples\n            return;\n          }\n          for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {\n            newStamp = ptsnorm - (numMissingFrames - _i3) * pesFrameDuration;\n            fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n            if (!fillFrame) {\n              _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');\n              fillFrame = unit.subarray();\n            }\n            mdat.set(fillFrame, offset);\n            offset += fillFrame.byteLength;\n            mp4Sample = {\n              size: fillFrame.byteLength,\n              cts: 0,\n              duration: 1024,\n              flags: {\n                isLeading: 0,\n                isDependedOn: 0,\n                hasRedundancy: 0,\n                degradPrio: 0,\n                dependsOn: 1\n              }\n            };\n            outputSamples.push(mp4Sample);\n          }\n        }\n        mdat.set(unit, offset);\n        var unitLen = unit.byteLength;\n        offset += unitLen;\n        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');\n        mp4Sample = {\n          size: unitLen,\n          cts: 0,\n          duration: 0,\n          flags: {\n            isLeading: 0,\n            isDependedOn: 0,\n            hasRedundancy: 0,\n            degradPrio: 0,\n            dependsOn: 1\n          }\n        };\n        outputSamples.push(mp4Sample);\n        lastDTS = dtsnorm;\n      }\n      var lastSampleDuration = 0;\n      var nbSamples = outputSamples.length;\n      //set last sample duration as being identical to previous sample\n      if (nbSamples >= 2) {\n        lastSampleDuration = outputSamples[nbSamples - 2].duration;\n        mp4Sample.duration = lastSampleDuration;\n      }\n      if (nbSamples) {\n        // next audio sample PTS should be equal to last sample PTS + duration\n        this.nextAudioPts = ptsnorm + pes2mp4ScaleFactor * lastSampleDuration;\n        //logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));\n        track.len = 0;\n        track.samples = outputSamples;\n        if (rawMPEG) {\n          moof = new Uint8Array();\n        } else {\n          moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / pes2mp4ScaleFactor, track);\n        }\n        track.samples = [];\n        var audioData = {\n          data1: moof,\n          data2: mdat,\n          startPTS: firstPTS / pesTimeScale,\n          endPTS: this.nextAudioPts / pesTimeScale,\n          startDTS: firstDTS / pesTimeScale,\n          endDTS: (dtsnorm + pes2mp4ScaleFactor * lastSampleDuration) / pesTimeScale,\n          type: 'audio',\n          nb: nbSamples\n        };\n        this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);\n        return audioData;\n      }\n      return null;\n    }\n  }, {\n    key: 'remuxEmptyAudio',\n    value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n      var pesTimeScale = this.PES_TIMESCALE,\n          mp4timeScale = track.timescale ? track.timescale : track.audiosamplerate,\n          pes2mp4ScaleFactor = pesTimeScale / mp4timeScale,\n          nextAudioPts = this.nextAudioPts,\n\n\n      // sync with video's timestamp\n      startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * pesTimeScale) + this._initDTS,\n          endDTS = videoData.endDTS * pesTimeScale + this._initDTS,\n\n      // one sample's duration value\n      sampleDuration = 1024,\n          frameDuration = pes2mp4ScaleFactor * sampleDuration,\n\n\n      // samples count of this segment's duration\n      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),\n\n\n      // silent frame\n      silentFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n\n      _logger.logger.warn('remux empty Audio');\n      // Can't remux if we can't generate a silent frame...\n      if (!silentFrame) {\n        _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');\n        return;\n      }\n\n      var samples = [];\n      for (var i = 0; i < nbSamples; i++) {\n        var stamp = startDTS + i * frameDuration;\n        samples.push({ unit: silentFrame, pts: stamp, dts: stamp });\n        track.len += silentFrame.length;\n      }\n      track.samples = samples;\n\n      this.remuxAudio(track, timeOffset, contiguous);\n    }\n  }, {\n    key: 'remuxID3',\n    value: function remuxID3(track, timeOffset) {\n      var length = track.samples.length,\n          sample;\n      // consume samples\n      if (length) {\n        for (var index = 0; index < length; index++) {\n          sample = track.samples[index];\n          // setting id3 pts, dts to relative time\n          // using this._initPTS and this._initDTS to calculate relative time\n          sample.pts = (sample.pts - this._initPTS) / this.PES_TIMESCALE;\n          sample.dts = (sample.dts - this._initDTS) / this.PES_TIMESCALE;\n        }\n        this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {\n          samples: track.samples\n        });\n      }\n\n      track.samples = [];\n      timeOffset = timeOffset;\n    }\n  }, {\n    key: 'remuxText',\n    value: function remuxText(track, timeOffset) {\n      track.samples.sort(function (a, b) {\n        return a.pts - b.pts;\n      });\n\n      var length = track.samples.length,\n          sample;\n      // consume samples\n      if (length) {\n        for (var index = 0; index < length; index++) {\n          sample = track.samples[index];\n          // setting text pts, dts to relative time\n          // using this._initPTS and this._initDTS to calculate relative time\n          sample.pts = (sample.pts - this._initPTS) / this.PES_TIMESCALE;\n        }\n        this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {\n          samples: track.samples\n        });\n      }\n\n      track.samples = [];\n      timeOffset = timeOffset;\n    }\n  }, {\n    key: '_PTSNormalize',\n    value: function _PTSNormalize(value, reference) {\n      var offset;\n      if (reference === undefined) {\n        return value;\n      }\n      if (reference < value) {\n        // - 2^33\n        offset = -8589934592;\n      } else {\n        // + 2^33\n        offset = 8589934592;\n      }\n      /* PTS is 33bit (from 0 to 2^33 -1)\n        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n        PTS looping occured. fill the gap */\n      while (Math.abs(value - reference) > 4294967296) {\n        value += offset;\n      }\n      return value;\n    }\n  }]);\n\n  return MP4Remuxer;\n}();\n\nexports.default = MP4Remuxer;\n\n},{\"31\":31,\"33\":33,\"34\":34,\"42\":42,\"50\":50}],44:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PassThroughRemuxer = function () {\n  function PassThroughRemuxer(observer) {\n    _classCallCheck(this, PassThroughRemuxer);\n\n    this.observer = observer;\n  }\n\n  _createClass(PassThroughRemuxer, [{\n    key: 'destroy',\n    value: function destroy() {}\n  }, {\n    key: 'resetTimeStamp',\n    value: function resetTimeStamp() {}\n  }, {\n    key: 'resetInitSegment',\n    value: function resetInitSegment() {}\n  }, {\n    key: 'remux',\n    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {\n      var observer = this.observer;\n      var streamType = '';\n      if (audioTrack) {\n        streamType += 'audio';\n      }\n      if (videoTrack) {\n        streamType += 'video';\n      }\n      observer.trigger(_events2.default.FRAG_PARSING_DATA, {\n        data1: rawData,\n        startPTS: timeOffset,\n        startDTS: timeOffset,\n        type: streamType,\n        nb: 1,\n        dropped: 0\n      });\n      //notify end of parsing\n      observer.trigger(_events2.default.FRAG_PARSED);\n    }\n  }]);\n\n  return PassThroughRemuxer;\n}();\n\nexports.default = PassThroughRemuxer;\n\n},{\"33\":33}],45:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/;\nvar ATTR_LIST_REGEX = /\\s*(.+?)\\s*=((?:\\\".*?\\\")|.*?)(?:,|$)/g;\n\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\n\nvar AttrList = function () {\n  function AttrList(attrs) {\n    _classCallCheck(this, AttrList);\n\n    if (typeof attrs === 'string') {\n      attrs = AttrList.parseAttrList(attrs);\n    }\n    for (var attr in attrs) {\n      if (attrs.hasOwnProperty(attr)) {\n        this[attr] = attrs[attr];\n      }\n    }\n  }\n\n  _createClass(AttrList, [{\n    key: 'decimalInteger',\n    value: function decimalInteger(attrName) {\n      var intValue = parseInt(this[attrName], 10);\n      if (intValue > Number.MAX_SAFE_INTEGER) {\n        return Infinity;\n      }\n      return intValue;\n    }\n  }, {\n    key: 'hexadecimalInteger',\n    value: function hexadecimalInteger(attrName) {\n      if (this[attrName]) {\n        var stringValue = (this[attrName] || '0x').slice(2);\n        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n\n        var value = new Uint8Array(stringValue.length / 2);\n        for (var i = 0; i < stringValue.length / 2; i++) {\n          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n        }\n        return value;\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: 'hexadecimalIntegerAsNumber',\n    value: function hexadecimalIntegerAsNumber(attrName) {\n      var intValue = parseInt(this[attrName], 16);\n      if (intValue > Number.MAX_SAFE_INTEGER) {\n        return Infinity;\n      }\n      return intValue;\n    }\n  }, {\n    key: 'decimalFloatingPoint',\n    value: function decimalFloatingPoint(attrName) {\n      return parseFloat(this[attrName]);\n    }\n  }, {\n    key: 'enumeratedString',\n    value: function enumeratedString(attrName) {\n      return this[attrName];\n    }\n  }, {\n    key: 'decimalResolution',\n    value: function decimalResolution(attrName) {\n      var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n      if (res === null) {\n        return undefined;\n      }\n      return {\n        width: parseInt(res[1], 10),\n        height: parseInt(res[2], 10)\n      };\n    }\n  }], [{\n    key: 'parseAttrList',\n    value: function parseAttrList(input) {\n      var match,\n          attrs = {};\n      ATTR_LIST_REGEX.lastIndex = 0;\n      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n        var value = match[2],\n            quote = '\"';\n\n        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n          value = value.slice(1, -1);\n        }\n        attrs[match[1]] = value;\n      }\n      return attrs;\n    }\n  }]);\n\n  return AttrList;\n}();\n\nexports.default = AttrList;\n\n},{}],46:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar BinarySearch = {\n    /**\n     * Searches for an item in an array which matches a certain condition.\n     * This requires the condition to only match one item in the array,\n     * and for the array to be ordered.\n     *\n     * @param {Array} list The array to search.\n     * @param {Function} comparisonFunction\n     *      Called and provided a candidate item as the first argument.\n     *      Should return:\n     *          > -1 if the item should be located at a lower index than the provided item.\n     *          > 1 if the item should be located at a higher index than the provided item.\n     *          > 0 if the item is the item you're looking for.\n     *\n     * @return {*} The object if it is found or null otherwise.\n     */\n    search: function search(list, comparisonFunction) {\n        var minIndex = 0;\n        var maxIndex = list.length - 1;\n        var currentIndex = null;\n        var currentElement = null;\n\n        while (minIndex <= maxIndex) {\n            currentIndex = (minIndex + maxIndex) / 2 | 0;\n            currentElement = list[currentIndex];\n\n            var comparisonResult = comparisonFunction(currentElement);\n            if (comparisonResult > 0) {\n                minIndex = currentIndex + 1;\n            } else if (comparisonResult < 0) {\n                maxIndex = currentIndex - 1;\n            } else {\n                return currentElement;\n            }\n        }\n\n        return null;\n    }\n};\n\nmodule.exports = BinarySearch;\n\n},{}],47:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *\n * This code was ported from the dash.js project at:\n *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js\n *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2\n *\n * The original copyright appears below:\n *\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2015-2016, DASH Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  2. Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n */\n\nvar specialCea608CharsCodes = {\n    0x2a: 0xe1, // lowercase a, acute accent\n    0x5c: 0xe9, // lowercase e, acute accent\n    0x5e: 0xed, // lowercase i, acute accent\n    0x5f: 0xf3, // lowercase o, acute accent\n    0x60: 0xfa, // lowercase u, acute accent\n    0x7b: 0xe7, // lowercase c with cedilla\n    0x7c: 0xf7, // division symbol\n    0x7d: 0xd1, // uppercase N tilde\n    0x7e: 0xf1, // lowercase n tilde\n    0x7f: 0x2588, // Full block\n    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n    // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n    0x80: 0xae, // Registered symbol (R)\n    0x81: 0xb0, // degree sign\n    0x82: 0xbd, // 1/2 symbol\n    0x83: 0xbf, // Inverted (open) question mark\n    0x84: 0x2122, // Trademark symbol (TM)\n    0x85: 0xa2, // Cents symbol\n    0x86: 0xa3, // Pounds sterling\n    0x87: 0x266a, // Music 8'th note\n    0x88: 0xe0, // lowercase a, grave accent\n    0x89: 0x20, // transparent space (regular)\n    0x8a: 0xe8, // lowercase e, grave accent\n    0x8b: 0xe2, // lowercase a, circumflex accent\n    0x8c: 0xea, // lowercase e, circumflex accent\n    0x8d: 0xee, // lowercase i, circumflex accent\n    0x8e: 0xf4, // lowercase o, circumflex accent\n    0x8f: 0xfb, // lowercase u, circumflex accent\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n    0x90: 0xc1, // capital letter A with acute\n    0x91: 0xc9, // capital letter E with acute\n    0x92: 0xd3, // capital letter O with acute\n    0x93: 0xda, // capital letter U with acute\n    0x94: 0xdc, // capital letter U with diaresis\n    0x95: 0xfc, // lowercase letter U with diaeresis\n    0x96: 0x2018, // opening single quote\n    0x97: 0xa1, // inverted exclamation mark\n    0x98: 0x2a, // asterisk\n    0x99: 0x2019, // closing single quote\n    0x9a: 0x2501, // box drawings heavy horizontal\n    0x9b: 0xa9, // copyright sign\n    0x9c: 0x2120, // Service mark\n    0x9d: 0x2022, // (round) bullet\n    0x9e: 0x201c, // Left double quotation mark\n    0x9f: 0x201d, // Right double quotation mark\n    0xa0: 0xc0, // uppercase A, grave accent\n    0xa1: 0xc2, // uppercase A, circumflex\n    0xa2: 0xc7, // uppercase C with cedilla\n    0xa3: 0xc8, // uppercase E, grave accent\n    0xa4: 0xca, // uppercase E, circumflex\n    0xa5: 0xcb, // capital letter E with diaresis\n    0xa6: 0xeb, // lowercase letter e with diaresis\n    0xa7: 0xce, // uppercase I, circumflex\n    0xa8: 0xcf, // uppercase I, with diaresis\n    0xa9: 0xef, // lowercase i, with diaresis\n    0xaa: 0xd4, // uppercase O, circumflex\n    0xab: 0xd9, // uppercase U, grave accent\n    0xac: 0xf9, // lowercase u, grave accent\n    0xad: 0xdb, // uppercase U, circumflex\n    0xae: 0xab, // left-pointing double angle quotation mark\n    0xaf: 0xbb, // right-pointing double angle quotation mark\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n    0xb0: 0xc3, // Uppercase A, tilde\n    0xb1: 0xe3, // Lowercase a, tilde\n    0xb2: 0xcd, // Uppercase I, acute accent\n    0xb3: 0xcc, // Uppercase I, grave accent\n    0xb4: 0xec, // Lowercase i, grave accent\n    0xb5: 0xd2, // Uppercase O, grave accent\n    0xb6: 0xf2, // Lowercase o, grave accent\n    0xb7: 0xd5, // Uppercase O, tilde\n    0xb8: 0xf5, // Lowercase o, tilde\n    0xb9: 0x7b, // Open curly brace\n    0xba: 0x7d, // Closing curly brace\n    0xbb: 0x5c, // Backslash\n    0xbc: 0x5e, // Caret\n    0xbd: 0x5f, // Underscore\n    0xbe: 0x7c, // Pipe (vertical line)\n    0xbf: 0x223c, // Tilde operator\n    0xc0: 0xc4, // Uppercase A, umlaut\n    0xc1: 0xe4, // Lowercase A, umlaut\n    0xc2: 0xd6, // Uppercase O, umlaut\n    0xc3: 0xf6, // Lowercase o, umlaut\n    0xc4: 0xdf, // Esszett (sharp S)\n    0xc5: 0xa5, // Yen symbol\n    0xc6: 0xa4, // Generic currency sign\n    0xc7: 0x2503, // Box drawings heavy vertical\n    0xc8: 0xc5, // Uppercase A, ring\n    0xc9: 0xe5, // Lowercase A, ring\n    0xca: 0xd8, // Uppercase O, stroke\n    0xcb: 0xf8, // Lowercase o, strok\n    0xcc: 0x250f, // Box drawings heavy down and right\n    0xcd: 0x2513, // Box drawings heavy down and left\n    0xce: 0x2517, // Box drawings heavy up and right\n    0xcf: 0x251b // Box drawings heavy up and left\n};\n\n/**\n * Utils\n */\nvar getCharForByte = function getCharForByte(byte) {\n    var charCode = byte;\n    if (specialCea608CharsCodes.hasOwnProperty(byte)) {\n        charCode = specialCea608CharsCodes[byte];\n    }\n    return String.fromCharCode(charCode);\n};\n\nvar NR_ROWS = 15,\n    NR_COLS = 100;\n// Tables to look up row from PAC data\nvar rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };\nvar rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };\nvar rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };\nvar rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };\n\nvar backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\n\n/**\n * Simple logger class to be able to write with time-stamps and filter on level.\n */\nvar logger = {\n    verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },\n    time: null,\n    verboseLevel: 0, // Only write errors\n    setTime: function setTime(newTime) {\n        this.time = newTime;\n    },\n    log: function log(severity, msg) {\n        var minLevel = this.verboseFilter[severity];\n        if (this.verboseLevel >= minLevel) {\n            console.log(this.time + ' [' + severity + '] ' + msg);\n        }\n    }\n};\n\nvar numArrayToHexArray = function numArrayToHexArray(numArray) {\n    var hexArray = [];\n    for (var j = 0; j < numArray.length; j++) {\n        hexArray.push(numArray[j].toString(16));\n    }\n    return hexArray;\n};\n\nvar PenState = function () {\n    function PenState(foreground, underline, italics, background, flash) {\n        _classCallCheck(this, PenState);\n\n        this.foreground = foreground || 'white';\n        this.underline = underline || false;\n        this.italics = italics || false;\n        this.background = background || 'black';\n        this.flash = flash || false;\n    }\n\n    _createClass(PenState, [{\n        key: 'reset',\n        value: function reset() {\n            this.foreground = 'white';\n            this.underline = false;\n            this.italics = false;\n            this.background = 'black';\n            this.flash = false;\n        }\n    }, {\n        key: 'setStyles',\n        value: function setStyles(styles) {\n            var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];\n            for (var i = 0; i < attribs.length; i++) {\n                var style = attribs[i];\n                if (styles.hasOwnProperty(style)) {\n                    this[style] = styles[style];\n                }\n            }\n        }\n    }, {\n        key: 'isDefault',\n        value: function isDefault() {\n            return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;\n        }\n    }, {\n        key: 'equals',\n        value: function equals(other) {\n            return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n        }\n    }, {\n        key: 'copy',\n        value: function copy(newPenState) {\n            this.foreground = newPenState.foreground;\n            this.underline = newPenState.underline;\n            this.italics = newPenState.italics;\n            this.background = newPenState.background;\n            this.flash = newPenState.flash;\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;\n        }\n    }]);\n\n    return PenState;\n}();\n\n/**\n * Unicode character with styling and background.\n * @constructor\n */\n\n\nvar StyledUnicodeChar = function () {\n    function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {\n        _classCallCheck(this, StyledUnicodeChar);\n\n        this.uchar = uchar || ' '; // unicode character\n        this.penState = new PenState(foreground, underline, italics, background, flash);\n    }\n\n    _createClass(StyledUnicodeChar, [{\n        key: 'reset',\n        value: function reset() {\n            this.uchar = ' ';\n            this.penState.reset();\n        }\n    }, {\n        key: 'setChar',\n        value: function setChar(uchar, newPenState) {\n            this.uchar = uchar;\n            this.penState.copy(newPenState);\n        }\n    }, {\n        key: 'setPenState',\n        value: function setPenState(newPenState) {\n            this.penState.copy(newPenState);\n        }\n    }, {\n        key: 'equals',\n        value: function equals(other) {\n            return this.uchar === other.uchar && this.penState.equals(other.penState);\n        }\n    }, {\n        key: 'copy',\n        value: function copy(newChar) {\n            this.uchar = newChar.uchar;\n            this.penState.copy(newChar.penState);\n        }\n    }, {\n        key: 'isEmpty',\n        value: function isEmpty() {\n            return this.uchar === ' ' && this.penState.isDefault();\n        }\n    }]);\n\n    return StyledUnicodeChar;\n}();\n\n/**\n * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n * @constructor\n */\n\n\nvar Row = function () {\n    function Row() {\n        _classCallCheck(this, Row);\n\n        this.chars = [];\n        for (var i = 0; i < NR_COLS; i++) {\n            this.chars.push(new StyledUnicodeChar());\n        }\n        this.pos = 0;\n        this.currPenState = new PenState();\n    }\n\n    _createClass(Row, [{\n        key: 'equals',\n        value: function equals(other) {\n            var equal = true;\n            for (var i = 0; i < NR_COLS; i++) {\n                if (!this.chars[i].equals(other.chars[i])) {\n                    equal = false;\n                    break;\n                }\n            }\n            return equal;\n        }\n    }, {\n        key: 'copy',\n        value: function copy(other) {\n            for (var i = 0; i < NR_COLS; i++) {\n                this.chars[i].copy(other.chars[i]);\n            }\n        }\n    }, {\n        key: 'isEmpty',\n        value: function isEmpty() {\n            var empty = true;\n            for (var i = 0; i < NR_COLS; i++) {\n                if (!this.chars[i].isEmpty()) {\n                    empty = false;\n                    break;\n                }\n            }\n            return empty;\n        }\n\n        /**\n         *  Set the cursor to a valid column.\n         */\n\n    }, {\n        key: 'setCursor',\n        value: function setCursor(absPos) {\n            if (this.pos !== absPos) {\n                this.pos = absPos;\n            }\n            if (this.pos < 0) {\n                logger.log('ERROR', 'Negative cursor position ' + this.pos);\n                this.pos = 0;\n            } else if (this.pos > NR_COLS) {\n                logger.log('ERROR', 'Too large cursor position ' + this.pos);\n                this.pos = NR_COLS;\n            }\n        }\n\n        /**\n         * Move the cursor relative to current position.\n         */\n\n    }, {\n        key: 'moveCursor',\n        value: function moveCursor(relPos) {\n            var newPos = this.pos + relPos;\n            if (relPos > 1) {\n                for (var i = this.pos + 1; i < newPos + 1; i++) {\n                    this.chars[i].setPenState(this.currPenState);\n                }\n            }\n            this.setCursor(newPos);\n        }\n\n        /**\n         * Backspace, move one step back and clear character.\n         */\n\n    }, {\n        key: 'backSpace',\n        value: function backSpace() {\n            this.moveCursor(-1);\n            this.chars[this.pos].setChar(' ', this.currPenState);\n        }\n    }, {\n        key: 'insertChar',\n        value: function insertChar(byte) {\n            if (byte >= 0x90) {\n                //Extended char\n                this.backSpace();\n            }\n            var char = getCharForByte(byte);\n            if (this.pos >= NR_COLS) {\n                logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');\n                return;\n            }\n            this.chars[this.pos].setChar(char, this.currPenState);\n            this.moveCursor(1);\n        }\n    }, {\n        key: 'clearFromPos',\n        value: function clearFromPos(startPos) {\n            var i;\n            for (i = startPos; i < NR_COLS; i++) {\n                this.chars[i].reset();\n            }\n        }\n    }, {\n        key: 'clear',\n        value: function clear() {\n            this.clearFromPos(0);\n            this.pos = 0;\n            this.currPenState.reset();\n        }\n    }, {\n        key: 'clearToEndOfRow',\n        value: function clearToEndOfRow() {\n            this.clearFromPos(this.pos);\n        }\n    }, {\n        key: 'getTextString',\n        value: function getTextString() {\n            var chars = [];\n            var empty = true;\n            for (var i = 0; i < NR_COLS; i++) {\n                var char = this.chars[i].uchar;\n                if (char !== ' ') {\n                    empty = false;\n                }\n                chars.push(char);\n            }\n            if (empty) {\n                return '';\n            } else {\n                return chars.join('');\n            }\n        }\n    }, {\n        key: 'setPenStyles',\n        value: function setPenStyles(styles) {\n            this.currPenState.setStyles(styles);\n            var currChar = this.chars[this.pos];\n            currChar.setPenState(this.currPenState);\n        }\n    }]);\n\n    return Row;\n}();\n\n/**\n * Keep a CEA-608 screen of 32x15 styled characters\n * @constructor\n*/\n\n\nvar CaptionScreen = function () {\n    function CaptionScreen() {\n        _classCallCheck(this, CaptionScreen);\n\n        this.rows = [];\n        for (var i = 0; i < NR_ROWS; i++) {\n            this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)\n        }\n        this.currRow = NR_ROWS - 1;\n        this.nrRollUpRows = null;\n        this.reset();\n    }\n\n    _createClass(CaptionScreen, [{\n        key: 'reset',\n        value: function reset() {\n            for (var i = 0; i < NR_ROWS; i++) {\n                this.rows[i].clear();\n            }\n            this.currRow = NR_ROWS - 1;\n        }\n    }, {\n        key: 'equals',\n        value: function equals(other) {\n            var equal = true;\n            for (var i = 0; i < NR_ROWS; i++) {\n                if (!this.rows[i].equals(other.rows[i])) {\n                    equal = false;\n                    break;\n                }\n            }\n            return equal;\n        }\n    }, {\n        key: 'copy',\n        value: function copy(other) {\n            for (var i = 0; i < NR_ROWS; i++) {\n                this.rows[i].copy(other.rows[i]);\n            }\n        }\n    }, {\n        key: 'isEmpty',\n        value: function isEmpty() {\n            var empty = true;\n            for (var i = 0; i < NR_ROWS; i++) {\n                if (!this.rows[i].isEmpty()) {\n                    empty = false;\n                    break;\n                }\n            }\n            return empty;\n        }\n    }, {\n        key: 'backSpace',\n        value: function backSpace() {\n            var row = this.rows[this.currRow];\n            row.backSpace();\n        }\n    }, {\n        key: 'clearToEndOfRow',\n        value: function clearToEndOfRow() {\n            var row = this.rows[this.currRow];\n            row.clearToEndOfRow();\n        }\n\n        /**\n         * Insert a character (without styling) in the current row.\n         */\n\n    }, {\n        key: 'insertChar',\n        value: function insertChar(char) {\n            var row = this.rows[this.currRow];\n            row.insertChar(char);\n        }\n    }, {\n        key: 'setPen',\n        value: function setPen(styles) {\n            var row = this.rows[this.currRow];\n            row.setPenStyles(styles);\n        }\n    }, {\n        key: 'moveCursor',\n        value: function moveCursor(relPos) {\n            var row = this.rows[this.currRow];\n            row.moveCursor(relPos);\n        }\n    }, {\n        key: 'setCursor',\n        value: function setCursor(absPos) {\n            logger.log('INFO', 'setCursor: ' + absPos);\n            var row = this.rows[this.currRow];\n            row.setCursor(absPos);\n        }\n    }, {\n        key: 'setPAC',\n        value: function setPAC(pacData) {\n            logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));\n            var newRow = pacData.row - 1;\n            if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n                newRow = this.nrRollUpRows - 1;\n            }\n\n            //Make sure this only affects Roll-up Captions by checking this.nrRollUpRows\n            if (this.nrRollUpRows && this.currRow !== newRow) {\n                //clear all rows first\n                for (var i = 0; i < NR_ROWS; i++) {\n                    this.rows[i].clear();\n                }\n\n                //Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location\n                //topRowIndex - the start of rows to copy (inclusive index)\n                var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n                //We only copy if the last position was already shown.\n                //We use the cueStartTime value to check this.\n                var lastOutputScreen = this.lastOutputScreen;\n                if (lastOutputScreen) {\n                    var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;\n                    if (prevLineTime && prevLineTime < logger.time) {\n                        for (var _i = 0; _i < this.nrRollUpRows; _i++) {\n                            this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);\n                        }\n                    }\n                }\n            }\n\n            this.currRow = newRow;\n            var row = this.rows[this.currRow];\n            if (pacData.indent !== null) {\n                var indent = pacData.indent;\n                var prevPos = Math.max(indent - 1, 0);\n                row.setCursor(pacData.indent);\n                pacData.color = row.chars[prevPos].penState.foreground;\n            }\n            var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };\n            this.setPen(styles);\n        }\n\n        /**\n         * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n         */\n\n    }, {\n        key: 'setBkgData',\n        value: function setBkgData(bkgData) {\n\n            logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));\n            this.backSpace();\n            this.setPen(bkgData);\n            this.insertChar(0x20); //Space\n        }\n    }, {\n        key: 'setRollUpRows',\n        value: function setRollUpRows(nrRows) {\n            this.nrRollUpRows = nrRows;\n        }\n    }, {\n        key: 'rollUp',\n        value: function rollUp() {\n            if (this.nrRollUpRows === null) {\n                logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');\n                return; //Not properly setup\n            }\n            logger.log('TEXT', this.getDisplayText());\n            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n            var topRow = this.rows.splice(topRowIndex, 1)[0];\n            topRow.clear();\n            this.rows.splice(this.currRow, 0, topRow);\n            logger.log('INFO', 'Rolling up');\n            //logger.log('TEXT', this.get_display_text())\n        }\n\n        /**\n         * Get all non-empty rows with as unicode text.\n         */\n\n    }, {\n        key: 'getDisplayText',\n        value: function getDisplayText(asOneRow) {\n            asOneRow = asOneRow || false;\n            var displayText = [];\n            var text = '';\n            var rowNr = -1;\n            for (var i = 0; i < NR_ROWS; i++) {\n                var rowText = this.rows[i].getTextString();\n                if (rowText) {\n                    rowNr = i + 1;\n                    if (asOneRow) {\n                        displayText.push('Row ' + rowNr + ': \\'' + rowText + '\\'');\n                    } else {\n                        displayText.push(rowText.trim());\n                    }\n                }\n            }\n            if (displayText.length > 0) {\n                if (asOneRow) {\n                    text = '[' + displayText.join(' | ') + ']';\n                } else {\n                    text = displayText.join('\\n');\n                }\n            }\n            return text;\n        }\n    }, {\n        key: 'getTextAndFormat',\n        value: function getTextAndFormat() {\n            return this.rows;\n        }\n    }]);\n\n    return CaptionScreen;\n}();\n\n//var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];\n\nvar Cea608Channel = function () {\n    function Cea608Channel(channelNumber, outputFilter) {\n        _classCallCheck(this, Cea608Channel);\n\n        this.chNr = channelNumber;\n        this.outputFilter = outputFilter;\n        this.mode = null;\n        this.verbose = 0;\n        this.displayedMemory = new CaptionScreen();\n        this.nonDisplayedMemory = new CaptionScreen();\n        this.lastOutputScreen = new CaptionScreen();\n        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n        this.writeScreen = this.displayedMemory;\n        this.mode = null;\n        this.cueStartTime = null; // Keeps track of where a cue started.\n    }\n\n    _createClass(Cea608Channel, [{\n        key: 'reset',\n        value: function reset() {\n            this.mode = null;\n            this.displayedMemory.reset();\n            this.nonDisplayedMemory.reset();\n            this.lastOutputScreen.reset();\n            this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n            this.writeScreen = this.displayedMemory;\n            this.mode = null;\n            this.cueStartTime = null;\n            this.lastCueEndTime = null;\n        }\n    }, {\n        key: 'getHandler',\n        value: function getHandler() {\n            return this.outputFilter;\n        }\n    }, {\n        key: 'setHandler',\n        value: function setHandler(newHandler) {\n            this.outputFilter = newHandler;\n        }\n    }, {\n        key: 'setPAC',\n        value: function setPAC(pacData) {\n            this.writeScreen.setPAC(pacData);\n        }\n    }, {\n        key: 'setBkgData',\n        value: function setBkgData(bkgData) {\n            this.writeScreen.setBkgData(bkgData);\n        }\n    }, {\n        key: 'setMode',\n        value: function setMode(newMode) {\n            if (newMode === this.mode) {\n                return;\n            }\n            this.mode = newMode;\n            logger.log('INFO', 'MODE=' + newMode);\n            if (this.mode === 'MODE_POP-ON') {\n                this.writeScreen = this.nonDisplayedMemory;\n            } else {\n                this.writeScreen = this.displayedMemory;\n                this.writeScreen.reset();\n            }\n            if (this.mode !== 'MODE_ROLL-UP') {\n                this.displayedMemory.nrRollUpRows = null;\n                this.nonDisplayedMemory.nrRollUpRows = null;\n            }\n            this.mode = newMode;\n        }\n    }, {\n        key: 'insertChars',\n        value: function insertChars(chars) {\n            for (var i = 0; i < chars.length; i++) {\n                this.writeScreen.insertChar(chars[i]);\n            }\n            var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';\n            logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));\n            if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {\n                logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));\n                this.outputDataUpdate();\n            }\n        }\n    }, {\n        key: 'ccRCL',\n        value: function ccRCL() {\n            // Resume Caption Loading (switch mode to Pop On)\n            logger.log('INFO', 'RCL - Resume Caption Loading');\n            this.setMode('MODE_POP-ON');\n        }\n    }, {\n        key: 'ccBS',\n        value: function ccBS() {\n            // BackSpace\n            logger.log('INFO', 'BS - BackSpace');\n            if (this.mode === 'MODE_TEXT') {\n                return;\n            }\n            this.writeScreen.backSpace();\n            if (this.writeScreen === this.displayedMemory) {\n                this.outputDataUpdate();\n            }\n        }\n    }, {\n        key: 'ccAOF',\n        value: function ccAOF() {\n            // Reserved (formerly Alarm Off)\n            return;\n        }\n    }, {\n        key: 'ccAON',\n        value: function ccAON() {\n            // Reserved (formerly Alarm On)\n            return;\n        }\n    }, {\n        key: 'ccDER',\n        value: function ccDER() {\n            // Delete to End of Row\n            logger.log('INFO', 'DER- Delete to End of Row');\n            this.writeScreen.clearToEndOfRow();\n            this.outputDataUpdate();\n        }\n    }, {\n        key: 'ccRU',\n        value: function ccRU(nrRows) {\n            //Roll-Up Captions-2,3,or 4 Rows\n            logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');\n            this.writeScreen = this.displayedMemory;\n            this.setMode('MODE_ROLL-UP');\n            this.writeScreen.setRollUpRows(nrRows);\n        }\n    }, {\n        key: 'ccFON',\n        value: function ccFON() {\n            //Flash On\n            logger.log('INFO', 'FON - Flash On');\n            this.writeScreen.setPen({ flash: true });\n        }\n    }, {\n        key: 'ccRDC',\n        value: function ccRDC() {\n            // Resume Direct Captioning (switch mode to PaintOn)\n            logger.log('INFO', 'RDC - Resume Direct Captioning');\n            this.setMode('MODE_PAINT-ON');\n        }\n    }, {\n        key: 'ccTR',\n        value: function ccTR() {\n            // Text Restart in text mode (not supported, however)\n            logger.log('INFO', 'TR');\n            this.setMode('MODE_TEXT');\n        }\n    }, {\n        key: 'ccRTD',\n        value: function ccRTD() {\n            // Resume Text Display in Text mode (not supported, however)\n            logger.log('INFO', 'RTD');\n            this.setMode('MODE_TEXT');\n        }\n    }, {\n        key: 'ccEDM',\n        value: function ccEDM() {\n            // Erase Displayed Memory\n            logger.log('INFO', 'EDM - Erase Displayed Memory');\n            this.displayedMemory.reset();\n            this.outputDataUpdate();\n        }\n    }, {\n        key: 'ccCR',\n        value: function ccCR() {\n            // Carriage Return\n            logger.log('CR - Carriage Return');\n            this.writeScreen.rollUp();\n            this.outputDataUpdate();\n        }\n    }, {\n        key: 'ccENM',\n        value: function ccENM() {\n            //Erase Non-Displayed Memory\n            logger.log('INFO', 'ENM - Erase Non-displayed Memory');\n            this.nonDisplayedMemory.reset();\n        }\n    }, {\n        key: 'ccEOC',\n        value: function ccEOC() {\n            //End of Caption (Flip Memories)\n            logger.log('INFO', 'EOC - End Of Caption');\n            if (this.mode === 'MODE_POP-ON') {\n                var tmp = this.displayedMemory;\n                this.displayedMemory = this.nonDisplayedMemory;\n                this.nonDisplayedMemory = tmp;\n                this.writeScreen = this.nonDisplayedMemory;\n                logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());\n            }\n            this.outputDataUpdate();\n        }\n    }, {\n        key: 'ccTO',\n        value: function ccTO(nrCols) {\n            // Tab Offset 1,2, or 3 columns\n            logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');\n            this.writeScreen.moveCursor(nrCols);\n        }\n    }, {\n        key: 'ccMIDROW',\n        value: function ccMIDROW(secondByte) {\n            // Parse MIDROW command\n            var styles = { flash: false };\n            styles.underline = secondByte % 2 === 1;\n            styles.italics = secondByte >= 0x2e;\n            if (!styles.italics) {\n                var colorIndex = Math.floor(secondByte / 2) - 0x10;\n                var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];\n                styles.foreground = colors[colorIndex];\n            } else {\n                styles.foreground = 'white';\n            }\n            logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));\n            this.writeScreen.setPen(styles);\n        }\n    }, {\n        key: 'outputDataUpdate',\n        value: function outputDataUpdate() {\n            var t = logger.time;\n            if (t === null) {\n                return;\n            }\n            if (this.outputFilter) {\n                if (this.outputFilter.updateData) {\n                    this.outputFilter.updateData(t, this.displayedMemory);\n                }\n                if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n                    // Start of a new cue\n                    this.cueStartTime = t;\n                } else {\n                    if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n                        if (this.outputFilter.newCue) {\n                            this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);\n                        }\n                        this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;\n                    }\n                }\n                this.lastOutputScreen.copy(this.displayedMemory);\n            }\n        }\n    }, {\n        key: 'cueSplitAtTime',\n        value: function cueSplitAtTime(t) {\n            if (this.outputFilter) {\n                if (!this.displayedMemory.isEmpty()) {\n                    if (this.outputFilter.newCue) {\n                        this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n                    }\n                    this.cueStartTime = t;\n                }\n            }\n        }\n    }]);\n\n    return Cea608Channel;\n}();\n\nvar Cea608Parser = function () {\n    function Cea608Parser(field, out1, out2) {\n        _classCallCheck(this, Cea608Parser);\n\n        this.field = field || 1;\n        this.outputs = [out1, out2];\n        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];\n        this.currChNr = -1; // Will be 1 or 2\n        this.lastCmdA = null; // First byte of last command\n        this.lastCmdB = null; // Second byte of last command\n        this.bufferedData = [];\n        this.startTime = null;\n        this.lastTime = null;\n        this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };\n    }\n\n    _createClass(Cea608Parser, [{\n        key: 'getHandler',\n        value: function getHandler(index) {\n            return this.channels[index].getHandler();\n        }\n    }, {\n        key: 'setHandler',\n        value: function setHandler(index, newHandler) {\n            this.channels[index].setHandler(newHandler);\n        }\n\n        /**\n         * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n         */\n\n    }, {\n        key: 'addData',\n        value: function addData(t, byteList) {\n            var cmdFound,\n                a,\n                b,\n                charsFound = false;\n\n            this.lastTime = t;\n            logger.setTime(t);\n\n            for (var i = 0; i < byteList.length; i += 2) {\n                a = byteList[i] & 0x7f;\n                b = byteList[i + 1] & 0x7f;\n                if (a === 0 && b === 0) {\n                    this.dataCounters.padding += 2;\n                    continue;\n                } else {\n                    logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');\n                }\n                cmdFound = this.parseCmd(a, b);\n                if (!cmdFound) {\n                    cmdFound = this.parseMidrow(a, b);\n                }\n                if (!cmdFound) {\n                    cmdFound = this.parsePAC(a, b);\n                }\n                if (!cmdFound) {\n                    cmdFound = this.parseBackgroundAttributes(a, b);\n                }\n                if (!cmdFound) {\n                    charsFound = this.parseChars(a, b);\n                    if (charsFound) {\n                        if (this.currChNr && this.currChNr >= 0) {\n                            var channel = this.channels[this.currChNr - 1];\n                            channel.insertChars(charsFound);\n                        } else {\n                            logger.log('WARNING', 'No channel found yet. TEXT-MODE?');\n                        }\n                    }\n                }\n                if (cmdFound) {\n                    this.dataCounters.cmd += 2;\n                } else if (charsFound) {\n                    this.dataCounters.char += 2;\n                } else {\n                    this.dataCounters.other += 2;\n                    logger.log('WARNING', 'Couldn\\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));\n                }\n            }\n        }\n\n        /**\n         * Parse Command.\n         * @returns {Boolean} Tells if a command was found\n         */\n\n    }, {\n        key: 'parseCmd',\n        value: function parseCmd(a, b) {\n            var chNr = null;\n\n            var cond1 = (a === 0x14 || a === 0x1C) && 0x20 <= b && b <= 0x2F;\n            var cond2 = (a === 0x17 || a === 0x1F) && 0x21 <= b && b <= 0x23;\n            if (!(cond1 || cond2)) {\n                return false;\n            }\n\n            if (a === this.lastCmdA && b === this.lastCmdB) {\n                this.lastCmdA = null;\n                this.lastCmdB = null; // Repeated commands are dropped (once)\n                logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');\n                return true;\n            }\n\n            if (a === 0x14 || a === 0x17) {\n                chNr = 1;\n            } else {\n                chNr = 2; // (a === 0x1C || a=== 0x1f)\n            }\n\n            var channel = this.channels[chNr - 1];\n\n            if (a === 0x14 || a === 0x1C) {\n                if (b === 0x20) {\n                    channel.ccRCL();\n                } else if (b === 0x21) {\n                    channel.ccBS();\n                } else if (b === 0x22) {\n                    channel.ccAOF();\n                } else if (b === 0x23) {\n                    channel.ccAON();\n                } else if (b === 0x24) {\n                    channel.ccDER();\n                } else if (b === 0x25) {\n                    channel.ccRU(2);\n                } else if (b === 0x26) {\n                    channel.ccRU(3);\n                } else if (b === 0x27) {\n                    channel.ccRU(4);\n                } else if (b === 0x28) {\n                    channel.ccFON();\n                } else if (b === 0x29) {\n                    channel.ccRDC();\n                } else if (b === 0x2A) {\n                    channel.ccTR();\n                } else if (b === 0x2B) {\n                    channel.ccRTD();\n                } else if (b === 0x2C) {\n                    channel.ccEDM();\n                } else if (b === 0x2D) {\n                    channel.ccCR();\n                } else if (b === 0x2E) {\n                    channel.ccENM();\n                } else if (b === 0x2F) {\n                    channel.ccEOC();\n                }\n            } else {\n                //a == 0x17 || a == 0x1F\n                channel.ccTO(b - 0x20);\n            }\n            this.lastCmdA = a;\n            this.lastCmdB = b;\n            this.currChNr = chNr;\n            return true;\n        }\n\n        /**\n         * Parse midrow styling command\n         * @returns {Boolean}\n         */\n\n    }, {\n        key: 'parseMidrow',\n        value: function parseMidrow(a, b) {\n            var chNr = null;\n\n            if ((a === 0x11 || a === 0x19) && 0x20 <= b && b <= 0x2f) {\n                if (a === 0x11) {\n                    chNr = 1;\n                } else {\n                    chNr = 2;\n                }\n                if (chNr !== this.currChNr) {\n                    logger.log('ERROR', 'Mismatch channel in midrow parsing');\n                    return false;\n                }\n                var channel = this.channels[chNr - 1];\n                channel.ccMIDROW(b);\n                logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');\n                return true;\n            }\n            return false;\n        }\n        /**\n         * Parse Preable Access Codes (Table 53).\n         * @returns {Boolean} Tells if PAC found\n         */\n\n    }, {\n        key: 'parsePAC',\n        value: function parsePAC(a, b) {\n\n            var chNr = null;\n            var row = null;\n\n            var case1 = (0x11 <= a && a <= 0x17 || 0x19 <= a && a <= 0x1F) && 0x40 <= b && b <= 0x7F;\n            var case2 = (a === 0x10 || a === 0x18) && 0x40 <= b && b <= 0x5F;\n            if (!(case1 || case2)) {\n                return false;\n            }\n\n            if (a === this.lastCmdA && b === this.lastCmdB) {\n                this.lastCmdA = null;\n                this.lastCmdB = null;\n                return true; // Repeated commands are dropped (once)\n            }\n\n            chNr = a <= 0x17 ? 1 : 2;\n\n            if (0x40 <= b && b <= 0x5F) {\n                row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n            } else {\n                // 0x60 <= b <= 0x7F\n                row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n            }\n            var pacData = this.interpretPAC(row, b);\n            var channel = this.channels[chNr - 1];\n            channel.setPAC(pacData);\n            this.lastCmdA = a;\n            this.lastCmdB = b;\n            this.currChNr = chNr;\n            return true;\n        }\n\n        /**\n         * Interpret the second byte of the pac, and return the information.\n         * @returns {Object} pacData with style parameters.\n         */\n\n    }, {\n        key: 'interpretPAC',\n        value: function interpretPAC(row, byte) {\n            var pacIndex = byte;\n            var pacData = { color: null, italics: false, indent: null, underline: false, row: row };\n\n            if (byte > 0x5F) {\n                pacIndex = byte - 0x60;\n            } else {\n                pacIndex = byte - 0x40;\n            }\n            pacData.underline = (pacIndex & 1) === 1;\n            if (pacIndex <= 0xd) {\n                pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];\n            } else if (pacIndex <= 0xf) {\n                pacData.italics = true;\n                pacData.color = 'white';\n            } else {\n                pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n            }\n            return pacData; // Note that row has zero offset. The spec uses 1.\n        }\n\n        /**\n         * Parse characters.\n         * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n         */\n\n    }, {\n        key: 'parseChars',\n        value: function parseChars(a, b) {\n\n            var channelNr = null,\n                charCodes = null,\n                charCode1 = null;\n\n            if (a >= 0x19) {\n                channelNr = 2;\n                charCode1 = a - 8;\n            } else {\n                channelNr = 1;\n                charCode1 = a;\n            }\n            if (0x11 <= charCode1 && charCode1 <= 0x13) {\n                // Special character\n                var oneCode = b;\n                if (charCode1 === 0x11) {\n                    oneCode = b + 0x50;\n                } else if (charCode1 === 0x12) {\n                    oneCode = b + 0x70;\n                } else {\n                    oneCode = b + 0x90;\n                }\n                logger.log('INFO', 'Special char \\'' + getCharForByte(oneCode) + '\\' in channel ' + channelNr);\n                charCodes = [oneCode];\n            } else if (0x20 <= a && a <= 0x7f) {\n                charCodes = b === 0 ? [a] : [a, b];\n            }\n            if (charCodes) {\n                var hexCodes = numArrayToHexArray(charCodes);\n                logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));\n                this.lastCmdA = null;\n                this.lastCmdB = null;\n            }\n            return charCodes;\n        }\n\n        /**\n        * Parse extended background attributes as well as new foreground color black.\n        * @returns{Boolean} Tells if background attributes are found\n        */\n\n    }, {\n        key: 'parseBackgroundAttributes',\n        value: function parseBackgroundAttributes(a, b) {\n            var bkgData, index, chNr, channel;\n\n            var case1 = (a === 0x10 || a === 0x18) && 0x20 <= b && b <= 0x2f;\n            var case2 = (a === 0x17 || a === 0x1f) && 0x2d <= b && b <= 0x2f;\n            if (!(case1 || case2)) {\n                return false;\n            }\n            bkgData = {};\n            if (a === 0x10 || a === 0x18) {\n                index = Math.floor((b - 0x20) / 2);\n                bkgData.background = backgroundColors[index];\n                if (b % 2 === 1) {\n                    bkgData.background = bkgData.background + '_semi';\n                }\n            } else if (b === 0x2d) {\n                bkgData.background = 'transparent';\n            } else {\n                bkgData.foreground = 'black';\n                if (b === 0x2f) {\n                    bkgData.underline = true;\n                }\n            }\n            chNr = a < 0x18 ? 1 : 2;\n            channel = this.channels[chNr - 1];\n            channel.setBkgData(bkgData);\n            this.lastCmdA = null;\n            this.lastCmdB = null;\n            return true;\n        }\n\n        /**\n         * Reset state of parser and its channels.\n         */\n\n    }, {\n        key: 'reset',\n        value: function reset() {\n            for (var i = 0; i < this.channels.length; i++) {\n                if (this.channels[i]) {\n                    this.channels[i].reset();\n                }\n            }\n            this.lastCmdA = null;\n            this.lastCmdB = null;\n        }\n\n        /**\n         * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n         */\n\n    }, {\n        key: 'cueSplitAtTime',\n        value: function cueSplitAtTime(t) {\n            for (var i = 0; i < this.channels.length; i++) {\n                if (this.channels[i]) {\n                    this.channels[i].cueSplitAtTime(t);\n                }\n            }\n        }\n    }]);\n\n    return Cea608Parser;\n}();\n\nexports.default = Cea608Parser;\n\n},{}],48:[function(_dereq_,module,exports){\n'use strict';\n\nvar _vttparser = _dereq_(53);\n\nvar Cues = {\n\n  newCue: function newCue(track, startTime, endTime, captionScreen) {\n    var row;\n    var cue;\n    var indenting;\n    var indent;\n    var text;\n    var VTTCue = window.VTTCue || window.TextTrackCue;\n\n    for (var r = 0; r < captionScreen.rows.length; r++) {\n      row = captionScreen.rows[r];\n      indenting = true;\n      indent = 0;\n      text = '';\n\n      if (!row.isEmpty()) {\n        for (var c = 0; c < row.chars.length; c++) {\n          if (row.chars[c].uchar.match(/\\s/) && indenting) {\n            indent++;\n          } else {\n            text += row.chars[c].uchar;\n            indenting = false;\n          }\n        }\n        //To be used for cleaning-up orphaned roll-up captions\n        row.cueStartTime = startTime;\n        cue = new VTTCue(startTime, endTime, (0, _vttparser.fixLineBreaks)(text.trim()));\n\n        if (indent >= 16) {\n          indent--;\n        } else {\n          indent++;\n        }\n\n        // VTTCue.line get's flakey when using controls, so let's now include line 13&14\n        // also, drop line 1 since it's to close to the top\n        if (navigator.userAgent.match(/Firefox\\//)) {\n          cue.line = r + 1;\n        } else {\n          cue.line = r > 7 ? r - 2 : r + 1;\n        }\n        cue.align = 'left';\n        // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break\n        cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\\//) ? 50 : 0)));\n        track.addCue(cue);\n      }\n    }\n  }\n\n};\n\nmodule.exports = Cues;\n\n},{\"53\":53}],49:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\n * compute an Exponential Weighted moving average\n * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n *  - heavily inspired from shaka-player\n */\n\nvar EWMA = function () {\n\n  //  About half of the estimated value will be from the last |halfLife| samples by weight.\n  function EWMA(halfLife) {\n    _classCallCheck(this, EWMA);\n\n    // Larger values of alpha expire historical data more slowly.\n    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n    this.estimate_ = 0;\n    this.totalWeight_ = 0;\n  }\n\n  _createClass(EWMA, [{\n    key: \"sample\",\n    value: function sample(weight, value) {\n      var adjAlpha = Math.pow(this.alpha_, weight);\n      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n      this.totalWeight_ += weight;\n    }\n  }, {\n    key: \"getTotalWeight\",\n    value: function getTotalWeight() {\n      return this.totalWeight_;\n    }\n  }, {\n    key: \"getEstimate\",\n    value: function getEstimate() {\n      if (this.alpha_) {\n        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n        return this.estimate_ / zeroFactor;\n      } else {\n        return this.estimate_;\n      }\n    }\n  }]);\n\n  return EWMA;\n}();\n\nexports.default = EWMA;\n\n},{}],50:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction noop() {}\n\nvar fakeLogger = {\n  trace: noop,\n  debug: noop,\n  log: noop,\n  warn: noop,\n  info: noop,\n  error: noop\n};\n\nvar exportedLogger = fakeLogger;\n\n/*globals self: false */\n\n//let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\n\nfunction formatMsg(type, msg) {\n  msg = '[' + type + '] > ' + msg;\n  return msg;\n}\n\nfunction consolePrintFn(type) {\n  var func = self.console[type];\n  if (func) {\n    return function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (args[0]) {\n        args[0] = formatMsg(type, args[0]);\n      }\n      func.apply(self.console, args);\n    };\n  }\n  return noop;\n}\n\nfunction exportLoggerFunctions(debugConfig) {\n  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    functions[_key2 - 1] = arguments[_key2];\n  }\n\n  functions.forEach(function (type) {\n    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n  });\n}\n\nvar enableLogs = exports.enableLogs = function enableLogs(debugConfig) {\n  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {\n    exportLoggerFunctions(debugConfig,\n    // Remove out from list here to hard-disable a log-level\n    //'trace',\n    'debug', 'log', 'info', 'warn', 'error');\n    // Some browsers don't allow to use bind on console object anyway\n    // fallback to default if needed\n    try {\n      exportedLogger.log();\n    } catch (e) {\n      exportedLogger = fakeLogger;\n    }\n  } else {\n    exportedLogger = fakeLogger;\n  }\n};\n\nvar logger = exports.logger = exportedLogger;\n\n},{}],51:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *  TimeRanges to string helper\n */\n\nvar TimeRanges = function () {\n  function TimeRanges() {\n    _classCallCheck(this, TimeRanges);\n  }\n\n  _createClass(TimeRanges, null, [{\n    key: 'toString',\n    value: function toString(r) {\n      var log = '',\n          len = r.length;\n      for (var i = 0; i < len; i++) {\n        log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';\n      }\n      return log;\n    }\n  }]);\n\n  return TimeRanges;\n}();\n\nexports.default = TimeRanges;\n\n},{}],52:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexports.default = function () {\n  if (typeof window !== 'undefined' && window.VTTCue) {\n    return window.VTTCue;\n  }\n\n  var autoKeyword = 'auto';\n  var directionSetting = {\n    '': true,\n    lr: true,\n    rl: true\n  };\n  var alignSetting = {\n    start: true,\n    middle: true,\n    end: true,\n    left: true,\n    right: true\n  };\n\n  function findDirectionSetting(value) {\n    if (typeof value !== 'string') {\n      return false;\n    }\n    var dir = directionSetting[value.toLowerCase()];\n    return dir ? value.toLowerCase() : false;\n  }\n\n  function findAlignSetting(value) {\n    if (typeof value !== 'string') {\n      return false;\n    }\n    var align = alignSetting[value.toLowerCase()];\n    return align ? value.toLowerCase() : false;\n  }\n\n  function extend(obj) {\n    var i = 1;\n    for (; i < arguments.length; i++) {\n      var cobj = arguments[i];\n      for (var p in cobj) {\n        obj[p] = cobj[p];\n      }\n    }\n\n    return obj;\n  }\n\n  function VTTCue(startTime, endTime, text) {\n    var cue = this;\n    var isIE8 = function () {\n      if (typeof navigator === 'undefined') {\n        return;\n      }\n      return (/MSIE\\s8\\.0/.test(navigator.userAgent)\n      );\n    }();\n    var baseObj = {};\n\n    if (isIE8) {\n      cue = document.createElement('custom');\n    } else {\n      baseObj.enumerable = true;\n    }\n\n    /**\n     * Shim implementation specific properties. These properties are not in\n     * the spec.\n     */\n\n    // Lets us know when the VTTCue's data has changed in such a way that we need\n    // to recompute its display state. This lets us compute its display state\n    // lazily.\n    cue.hasBeenReset = false;\n\n    /**\n     * VTTCue and TextTrackCue properties\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\n     */\n\n    var _id = '';\n    var _pauseOnExit = false;\n    var _startTime = startTime;\n    var _endTime = endTime;\n    var _text = text;\n    var _region = null;\n    var _vertical = '';\n    var _snapToLines = true;\n    var _line = 'auto';\n    var _lineAlign = 'start';\n    var _position = 50;\n    var _positionAlign = 'middle';\n    var _size = 50;\n    var _align = 'middle';\n\n    Object.defineProperty(cue, 'id', extend({}, baseObj, {\n      get: function get() {\n        return _id;\n      },\n      set: function set(value) {\n        _id = '' + value;\n      }\n    }));\n\n    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {\n      get: function get() {\n        return _pauseOnExit;\n      },\n      set: function set(value) {\n        _pauseOnExit = !!value;\n      }\n    }));\n\n    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {\n      get: function get() {\n        return _startTime;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('Start time must be set to a number.');\n        }\n        _startTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {\n      get: function get() {\n        return _endTime;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('End time must be set to a number.');\n        }\n        _endTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'text', extend({}, baseObj, {\n      get: function get() {\n        return _text;\n      },\n      set: function set(value) {\n        _text = '' + value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'region', extend({}, baseObj, {\n      get: function get() {\n        return _region;\n      },\n      set: function set(value) {\n        _region = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {\n      get: function get() {\n        return _vertical;\n      },\n      set: function set(value) {\n        var setting = findDirectionSetting(value);\n        // Have to check for false because the setting an be an empty string.\n        if (setting === false) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _vertical = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {\n      get: function get() {\n        return _snapToLines;\n      },\n      set: function set(value) {\n        _snapToLines = !!value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'line', extend({}, baseObj, {\n      get: function get() {\n        return _line;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number' && value !== autoKeyword) {\n          throw new SyntaxError('An invalid number or illegal string was specified.');\n        }\n        _line = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {\n      get: function get() {\n        return _lineAlign;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _lineAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'position', extend({}, baseObj, {\n      get: function get() {\n        return _position;\n      },\n      set: function set(value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Position must be between 0 and 100.');\n        }\n        _position = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {\n      get: function get() {\n        return _positionAlign;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _positionAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'size', extend({}, baseObj, {\n      get: function get() {\n        return _size;\n      },\n      set: function set(value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Size must be between 0 and 100.');\n        }\n        _size = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'align', extend({}, baseObj, {\n      get: function get() {\n        return _align;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _align = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    /**\n     * Other <track> spec defined properties\n     */\n\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n    cue.displayState = undefined;\n\n    if (isIE8) {\n      return cue;\n    }\n  }\n\n  /**\n   * VTTCue methods\n   */\n\n  VTTCue.prototype.getCueAsHTML = function () {\n    // Assume WebVTT.convertCueToDOMTree is on the global.\n    var WebVTT = window.WebVTT;\n    return WebVTT.convertCueToDOMTree(window, this.text);\n  };\n\n  return VTTCue;\n}();\n\n},{}],53:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fixLineBreaks = undefined;\n\nvar _vttcue = _dereq_(52);\n\nvar _vttcue2 = _interopRequireDefault(_vttcue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar StringDecoder = function StringDecoder() {\n  return {\n    decode: function decode(data) {\n      if (!data) {\n        return '';\n      }\n      if (typeof data !== 'string') {\n        throw new Error('Error - expected string data.');\n      }\n      return decodeURIComponent(encodeURIComponent(data));\n    }\n  };\n}; /*\n    * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716\n    */\n\nfunction VTTParser() {\n  this.window = window;\n  this.state = 'INITIAL';\n  this.buffer = '';\n  this.decoder = new StringDecoder();\n  this.regionList = [];\n}\n\n// Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\n  }\n\n  var m = input.match(/^(\\d+):(\\d{2})(:\\d{2})?\\.(\\d{3})/);\n  if (!m) {\n    return null;\n  }\n\n  if (m[3]) {\n    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\n    return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);\n  } else if (m[1] > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[1], m[2], 0, m[4]);\n  } else {\n    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\n    return computeSeconds(0, m[1], m[2], m[4]);\n  }\n}\n\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nfunction Settings() {\n  this.values = Object.create(null);\n}\n\nSettings.prototype = {\n  // Only accept the first assignment to any key.\n  set: function set(k, v) {\n    if (!this.get(k) && v !== '') {\n      this.values[k] = v;\n    }\n  },\n  // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  get: function get(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n    return this.has(k) ? this.values[k] : dflt;\n  },\n  // Check whether we have a value for a key.\n  has: function has(k) {\n    return k in this.values;\n  },\n  // Accept a setting if its one of the given alternatives.\n  alt: function alt(k, v, a) {\n    for (var n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  },\n  // Accept a setting if its a valid (signed) integer.\n  integer: function integer(k, v) {\n    if (/^-?\\d+$/.test(v)) {\n      // integer\n      this.set(k, parseInt(v, 10));\n    }\n  },\n  // Accept a setting if its a valid percentage.\n  percent: function percent(k, v) {\n    var m;\n    if (m = v.match(/^([\\d]{1,3})(\\.[\\d]*)?%$/)) {\n      v = parseFloat(v);\n      if (v >= 0 && v <= 100) {\n        this.set(k, v);\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\n// Helper function to parse input into groups separated by 'groupDelim', and\n// interprete each group as a key/value pair separated by 'keyValueDelim'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  var groups = groupDelim ? input.split(groupDelim) : [input];\n  for (var i in groups) {\n    if (typeof groups[i] !== 'string') {\n      continue;\n    }\n    var kv = groups[i].split(keyValueDelim);\n    if (kv.length !== 2) {\n      continue;\n    }\n    var k = kv[0];\n    var v = kv[1];\n    callback(k, v);\n  }\n}\n\nvar defaults = new _vttcue2.default(0, 0, 0);\n// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244\n// Chrome and Safari don't yet support this change, but FF does\nvar center = defaults.align === 'middle' ? 'middle' : 'center';\n\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  var oInput = input;\n  // 4.1 WebVTT timestamp\n  function consumeTimeStamp() {\n    var ts = parseTimeStamp(input);\n    if (ts === null) {\n      throw new Error('Malformed timestamp: ' + oInput);\n    }\n    // Remove time stamp from input.\n    input = input.replace(/^[^\\sa-zA-Z-]+/, '');\n    return ts;\n  }\n\n  // 4.4.2 WebVTT cue settings\n  function consumeCueSettings(input, cue) {\n    var settings = new Settings();\n\n    parseOptions(input, function (k, v) {\n      switch (k) {\n        case 'region':\n          // Find the last region we parsed with the same region id.\n          for (var i = regionList.length - 1; i >= 0; i--) {\n            if (regionList[i].id === v) {\n              settings.set(k, regionList[i].region);\n              break;\n            }\n          }\n          break;\n        case 'vertical':\n          settings.alt(k, v, ['rl', 'lr']);\n          break;\n        case 'line':\n          var vals = v.split(','),\n              vals0 = vals[0];\n          settings.integer(k, vals0);\n          if (settings.percent(k, vals0)) {\n            settings.set('snapToLines', false);\n          }\n          settings.alt(k, vals0, ['auto']);\n          if (vals.length === 2) {\n            settings.alt('lineAlign', vals[1], ['start', center, 'end']);\n          }\n          break;\n        case 'position':\n          vals = v.split(',');\n          settings.percent(k, vals[0]);\n          if (vals.length === 2) {\n            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);\n          }\n          break;\n        case 'size':\n          settings.percent(k, v);\n          break;\n        case 'align':\n          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);\n          break;\n      }\n    }, /:/, /\\s/);\n\n    // Apply default values for any missing fields.\n    cue.region = settings.get('region', null);\n    cue.vertical = settings.get('vertical', '');\n    var line = settings.get('line', 'auto');\n    if (line === 'auto' && defaults.line === -1) {\n      // set numeric line number for Safari\n      line = -1;\n    }\n    cue.line = line;\n    cue.lineAlign = settings.get('lineAlign', 'start');\n    cue.snapToLines = settings.get('snapToLines', true);\n    cue.size = settings.get('size', 100);\n    cue.align = settings.get('align', center);\n    var position = settings.get('position', 'auto');\n    if (position === 'auto' && defaults.position === 50) {\n      // set numeric position for Safari\n      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;\n    }\n    cue.position = position;\n  }\n\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, '');\n  }\n\n  // 4.1 WebVTT cue timings.\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n  skipWhitespace();\n  if (input.substr(0, 3) !== '-->') {\n    // (3) next characters must match '-->'\n    throw new Error('Malformed time stamp (time stamps must be separated by \\'-->\\'): ' + oInput);\n  }\n  input = input.substr(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n  // 4.1 WebVTT cue settings list.\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\n\nfunction fixLineBreaks(input) {\n  return input.replace(/<br(?: \\/)?>/gi, '\\n');\n}\n\nVTTParser.prototype = {\n  parse: function parse(data) {\n    var self = this;\n\n    // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n    if (data) {\n      // Try to decode the data that we received.\n      self.buffer += self.decoder.decode(data, { stream: true });\n    }\n\n    function collectNextLine() {\n      var buffer = self.buffer;\n      var pos = 0;\n\n      buffer = fixLineBreaks(buffer);\n\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n      var line = buffer.substr(0, pos);\n      // Advance the buffer early in case we fail below.\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n      self.buffer = buffer.substr(pos);\n      return line;\n    }\n\n    // 3.2 WebVTT metadata header syntax\n    function parseHeader(input) {\n      parseOptions(input, function (k, v) {\n        switch (k) {\n          case 'Region':\n            // 3.3 WebVTT region metadata header syntax\n            console.log('parse region', v);\n            //parseRegion(v);\n            break;\n        }\n      }, /:/);\n    }\n\n    // 5.1 WebVTT file parsing.\n    try {\n      var line;\n      if (self.state === 'INITIAL') {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(self.buffer)) {\n          return this;\n        }\n\n        line = collectNextLine();\n\n        var m = line.match(/^WEBVTT([ \\t].*)?$/);\n        if (!m || !m[0]) {\n          throw new Error('Malformed WebVTT signature.');\n        }\n\n        self.state = 'HEADER';\n      }\n\n      var alreadyCollectedLine = false;\n      while (self.buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(self.buffer)) {\n          return this;\n        }\n\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n\n        switch (self.state) {\n          case 'HEADER':\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n            if (/:/.test(line)) {\n              parseHeader(line);\n            } else if (!line) {\n              // An empty line terminates the header and starts the body (cues).\n              self.state = 'ID';\n            }\n            continue;\n          case 'NOTE':\n            // Ignore NOTE blocks.\n            if (!line) {\n              self.state = 'ID';\n            }\n            continue;\n          case 'ID':\n            // Check for the start of NOTE blocks.\n            if (/^NOTE($|[ \\t])/.test(line)) {\n              self.state = 'NOTE';\n              break;\n            }\n            // 19-29 - Allow any number of line terminators, then initialize new cue values.\n            if (!line) {\n              continue;\n            }\n            self.cue = new _vttcue2.default(0, 0, '');\n            self.state = 'CUE';\n            // 30-39 - Check if self line contains an optional identifier or timing data.\n            if (line.indexOf('-->') === -1) {\n              self.cue.id = line;\n              continue;\n            }\n          // Process line as start of a cue.\n          /*falls through*/\n          case 'CUE':\n            // 40 - Collect cue timings and settings.\n            try {\n              parseCue(line, self.cue, self.regionList);\n            } catch (e) {\n              // In case of an error ignore rest of the cue.\n              self.cue = null;\n              self.state = 'BADCUE';\n              continue;\n            }\n            self.state = 'CUETEXT';\n            continue;\n          case 'CUETEXT':\n            var hasSubstring = line.indexOf('-->') !== -1;\n            // 34 - If we have an empty line then report the cue.\n            // 35 - If we have the special substring '-->' then report the cue,\n            // but do not collect the line as we need to process the current\n            // one as a new cue.\n            if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n              // We are done parsing self cue.\n              if (self.oncue) {\n                self.oncue(self.cue);\n              }\n              self.cue = null;\n              self.state = 'ID';\n              continue;\n            }\n            if (self.cue.text) {\n              self.cue.text += '\\n';\n            }\n            self.cue.text += line;\n            continue;\n          case 'BADCUE':\n            // BADCUE\n            // 54-62 - Collect and discard the remaining cue.\n            if (!line) {\n              self.state = 'ID';\n            }\n            continue;\n        }\n      }\n    } catch (e) {\n\n      // If we are currently parsing a cue, report what we have.\n      if (self.state === 'CUETEXT' && self.cue && self.oncue) {\n        self.oncue(self.cue);\n      }\n      self.cue = null;\n      // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n      self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';\n    }\n    return this;\n  },\n  flush: function flush() {\n    var self = this;\n    try {\n      // Finish decoding the stream.\n      self.buffer += self.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (self.cue || self.state === 'HEADER') {\n        self.buffer += '\\n\\n';\n        self.parse();\n      }\n      // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n      if (self.state === 'INITIAL') {\n        throw new Error('Malformed WebVTT signature.');\n      }\n    } catch (e) {\n      throw e;\n    }\n    if (self.onflush) {\n      self.onflush();\n    }\n    return this;\n  }\n};\n\nexports.fixLineBreaks = fixLineBreaks;\nexports.default = VTTParser;\n\n},{\"52\":52}],54:[function(_dereq_,module,exports){\n'use strict';\n\nvar _vttparser = _dereq_(53);\n\nvar _vttparser2 = _interopRequireDefault(_vttparser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar cueString2millis = function cueString2millis(timeString) {\n    var ts = parseInt(timeString.substr(-3));\n    var secs = parseInt(timeString.substr(-6, 2));\n    var mins = parseInt(timeString.substr(-9, 2));\n    var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;\n\n    if (isNaN(ts) || isNaN(secs) || isNaN(mins) || isNaN(hours)) {\n        return -1;\n    }\n\n    ts += 1000 * secs;\n    ts += 60 * 1000 * mins;\n    ts += 60 * 60 * 1000 * hours;\n\n    return ts;\n};\n\nvar calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {\n    var currCC = vttCCs[cc];\n    var prevCC = vttCCs[currCC.prevCC];\n\n    // This is the first discontinuity or cues have been processed since the last discontinuity\n    // Offset = current discontinuity time\n    if (!prevCC || !prevCC.new && currCC.new) {\n        vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;\n        currCC.new = false;\n        return;\n    }\n\n    // There have been discontinuities since cues were last parsed.\n    // Offset = time elapsed\n    while (prevCC && prevCC.new) {\n        vttCCs.ccOffset += currCC.start - prevCC.start;\n        currCC.new = false;\n        currCC = prevCC;\n        prevCC = vttCCs[currCC.prevCC];\n    }\n\n    vttCCs.presentationOffset = presentationTime;\n};\n\nvar WebVTTParser = {\n    parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {\n        // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character.\n        var re = /\\r\\n|\\n\\r|\\n|\\r/g;\n        var vttLines = String.fromCharCode.apply(null, new Uint8Array(vttByteArray)).trim().replace(re, '\\n').split('\\n');\n        var cueTime = '00:00.000';\n        var mpegTs = 0;\n        var localTime = 0;\n        var presentationTime = 0;\n        var cues = [];\n        var parsingError = void 0;\n        var inHeader = true;\n        // let VTTCue = VTTCue || window.TextTrackCue;\n\n        // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.\n        var parser = new _vttparser2.default();\n\n        parser.oncue = function (cue) {\n            // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.\n            var currCC = vttCCs[cc];\n            var cueOffset = vttCCs.ccOffset;\n\n            // Update offsets for new discontinuities\n            if (currCC && currCC.new) {\n                if (localTime) {\n                    // When local time is provided, offset = discontinuity start time - local time\n                    cueOffset = vttCCs.ccOffset = currCC.start;\n                } else {\n                    calculateOffset(vttCCs, cc, presentationTime);\n                }\n            }\n\n            if (presentationTime && !localTime) {\n                // If we have MPEGTS but no LOCAL time, offset = presentation time + discontinuity offset\n                cueOffset = presentationTime + vttCCs.ccOffset - vttCCs.presentationOffset;\n            }\n\n            cue.startTime += cueOffset - localTime;\n            cue.endTime += cueOffset - localTime;\n\n            // Fix encoding of special characters. TODO: Test with all sorts of weird characters.\n            cue.text = decodeURIComponent(escape(cue.text));\n            if (cue.endTime > 0) {\n                cues.push(cue);\n            }\n        };\n\n        parser.onparsingerror = function (e) {\n            parsingError = e;\n        };\n\n        parser.onflush = function () {\n            if (parsingError && errorCallBack) {\n                errorCallBack(parsingError);\n                return;\n            }\n            callBack(cues);\n        };\n\n        // Go through contents line by line.\n        vttLines.forEach(function (line) {\n            if (inHeader) {\n                // Look for X-TIMESTAMP-MAP in header.\n                if (line.startsWith('X-TIMESTAMP-MAP=')) {\n                    // Once found, no more are allowed anyway, so stop searching.\n                    inHeader = false;\n                    // Extract LOCAL and MPEGTS.\n                    line.substr(16).split(',').forEach(function (timestamp) {\n                        if (timestamp.startsWith('LOCAL:')) {\n                            cueTime = timestamp.substr(6);\n                        } else if (timestamp.startsWith('MPEGTS:')) {\n                            mpegTs = parseInt(timestamp.substr(7));\n                        }\n                    });\n                    try {\n                        // Calculate subtitle offset in milliseconds.\n                        // If sync PTS is less than zero, we have a 33-bit wraparound, which is fixed by adding 2^33 = 8589934592.\n                        syncPTS = syncPTS < 0 ? syncPTS + 8589934592 : syncPTS;\n                        // Adjust MPEGTS by sync PTS.\n                        mpegTs -= syncPTS;\n                        // Convert cue time to seconds\n                        localTime = cueString2millis(cueTime) / 1000;\n                        // Convert MPEGTS to seconds from 90kHz.\n                        presentationTime = mpegTs / 90000;\n\n                        if (localTime === -1) {\n                            parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);\n                        }\n                    } catch (e) {\n                        parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);\n                    }\n                    // Return without parsing X-TIMESTAMP-MAP line.\n                    return;\n                } else if (line === '') {\n                    inHeader = false;\n                }\n            }\n            // Parse line by default.\n            parser.parse(line + '\\n');\n        });\n\n        parser.flush();\n    }\n};\n\nmodule.exports = WebVTTParser;\n\n},{\"53\":53}],55:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _logger = _dereq_(50);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar XhrLoader = function () {\n  function XhrLoader(config) {\n    _classCallCheck(this, XhrLoader);\n\n    if (config && config.xhrSetup) {\n      this.xhrSetup = config.xhrSetup;\n    }\n  }\n\n  _createClass(XhrLoader, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.abort();\n      this.loader = null;\n    }\n  }, {\n    key: 'abort',\n    value: function abort() {\n      var loader = this.loader;\n      if (loader && loader.readyState !== 4) {\n        this.stats.aborted = true;\n        loader.abort();\n      }\n\n      window.clearTimeout(this.requestTimeout);\n      this.requestTimeout = null;\n      window.clearTimeout(this.retryTimeout);\n      this.retryTimeout = null;\n    }\n  }, {\n    key: 'load',\n    value: function load(context, config, callbacks) {\n      this.context = context;\n      this.config = config;\n      this.callbacks = callbacks;\n      this.stats = { trequest: performance.now(), retry: 0 };\n      this.retryDelay = config.retryDelay;\n      this.loadInternal();\n    }\n  }, {\n    key: 'loadInternal',\n    value: function loadInternal() {\n      var xhr,\n          context = this.context;\n\n      if (typeof XDomainRequest !== 'undefined') {\n        xhr = this.loader = new XDomainRequest();\n      } else {\n        xhr = this.loader = new XMLHttpRequest();\n      }\n\n      xhr.onreadystatechange = this.readystatechange.bind(this);\n      xhr.onprogress = this.loadprogress.bind(this);\n\n      xhr.open('GET', context.url, true);\n\n      if (context.rangeEnd) {\n        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n      }\n      xhr.responseType = context.responseType;\n      var stats = this.stats;\n      stats.tfirst = 0;\n      stats.loaded = 0;\n      if (this.xhrSetup) {\n        this.xhrSetup(xhr, context.url);\n      }\n      // setup timeout before we perform request\n      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);\n      xhr.send();\n    }\n  }, {\n    key: 'readystatechange',\n    value: function readystatechange(event) {\n      var xhr = event.currentTarget,\n          readyState = xhr.readyState,\n          stats = this.stats,\n          context = this.context,\n          config = this.config;\n\n      // don't proceed if xhr has been aborted\n      if (stats.aborted) {\n        return;\n      }\n\n      // >= HEADERS_RECEIVED\n      if (readyState >= 2) {\n        // clear xhr timeout and rearm it if readyState less than 4\n        window.clearTimeout(this.requestTimeout);\n        if (stats.tfirst === 0) {\n          stats.tfirst = Math.max(performance.now(), stats.trequest);\n        }\n        if (readyState === 4) {\n          var status = xhr.status;\n          // http status between 200 to 299 are all successful\n          if (status >= 200 && status < 300) {\n            stats.tload = Math.max(stats.tfirst, performance.now());\n            var data = void 0,\n                len = void 0;\n            if (context.responseType === 'arraybuffer') {\n              data = xhr.response;\n              len = data.byteLength;\n            } else {\n              data = xhr.responseText;\n              len = data.length;\n            }\n            stats.loaded = stats.total = len;\n            var response = { url: xhr.responseURL, data: data };\n            this.callbacks.onSuccess(response, stats, context);\n          } else {\n            // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n            if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {\n              _logger.logger.error(status + ' while loading ' + context.url);\n              this.callbacks.onError({ code: status, text: xhr.statusText }, context);\n            } else {\n              // retry\n              _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');\n              // aborts and resets internal state\n              this.destroy();\n              // schedule retry\n              this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n              // set exponential backoff\n              this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);\n              stats.retry++;\n            }\n          }\n        } else {\n          // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n          this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);\n        }\n      }\n    }\n  }, {\n    key: 'loadtimeout',\n    value: function loadtimeout() {\n      _logger.logger.warn('timeout while loading ' + this.context.url);\n      this.callbacks.onTimeout(this.stats, this.context);\n    }\n  }, {\n    key: 'loadprogress',\n    value: function loadprogress(event) {\n      var stats = this.stats;\n      stats.loaded = event.loaded;\n      if (event.lengthComputable) {\n        stats.total = event.total;\n      }\n      var onProgress = this.callbacks.onProgress;\n      if (onProgress) {\n        // last args is to provide on progress data\n        onProgress(stats, this.context, null);\n      }\n    }\n  }]);\n\n  return XhrLoader;\n}();\n\nexports.default = XhrLoader;\n\n},{\"50\":50}]},{},[38])(38)\n});\n//# sourceMappingURL=hls.js.map\n\n\n/***/ }),\n\n/***/ 38:\n/***/ (function(module, exports, __webpack_require__) {\n\n// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\n__webpack_require__(77);\nmodule.exports = self.fetch.bind(self);\n\n\n/***/ }),\n\n/***/ 56:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2016 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tclasses.push(classNames.apply(null, arg));\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t\t\treturn classNames;\n\t\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n\n\n/***/ }),\n\n/***/ 593:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(21);\nmodule.exports = __webpack_require__(264);\n\n\n/***/ }),\n\n/***/ 74:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _getPrototypeOf = __webpack_require__(4);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(5);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(6);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(8);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(7);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _style = __webpack_require__(11);\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _react = __webpack_require__(2);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _container = __webpack_require__(14);\n\nvar _container2 = _interopRequireDefault(_container);\n\nvar _menuItem = __webpack_require__(75);\n\nvar _menuItem2 = _interopRequireDefault(_menuItem);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _class = function (_React$Component) {\n    (0, _inherits3.default)(_class, _React$Component);\n\n    function _class(props) {\n        (0, _classCallCheck3.default)(this, _class);\n\n        return (0, _possibleConstructorReturn3.default)(this, (_class.__proto__ || (0, _getPrototypeOf2.default)(_class)).call(this, props));\n    }\n\n    (0, _createClass3.default)(_class, [{\n        key: 'render',\n        value: function render() {\n            return _react2.default.createElement('div', { className: 'header', 'data-jsx': 3006156612\n            }, _react2.default.createElement(_container2.default, { flex: true }, _react2.default.createElement('img', { src: '/static/logo.svg', 'data-jsx': 3006156612\n            }), _react2.default.createElement('div', { className: 'menu', 'data-jsx': 3006156612\n            }, _react2.default.createElement(_menuItem2.default, null, '\\u6CE8\\u518C'), _react2.default.createElement(_menuItem2.default, null, '\\u767B\\u5F55'), _react2.default.createElement(_menuItem2.default, null, '\\u5173\\u4E8E'))), _react2.default.createElement(_style2.default, {\n                styleId: 3006156612,\n                css: '.header[data-jsx=\"3006156612\"] {position: fixed;height: 40px;background: #000;width: 100%;z-index: 9999;}.header[data-jsx=\"3006156612\"] img[data-jsx=\"3006156612\"] {display: block;max-height: 100%;width: 40px;}.container[data-jsx=\"3006156612\"] {width: 1050px;height: 100%;margin: 0 auto;display:-webkit-flex; display:flex;}.menu[data-jsx=\"3006156612\"] {display:-webkit-flex; display:flex;align-items: center;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHNcXGhlYWRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF1QjRCLEFBQ0MsZ0NBQ1csZ0JBQ0gsYUFDSSxpQkFDTCxZQUNFLGNBQ2pCLENBQ1ksMkRBQ00sZUFDRSxpQkFDTCxZQUNmLENBQ1csbUNBQ00sY0FDRCxhQUNFLGVBQ0QsbUNBQ2pCLENBQ00sOEJBQ1csbUNBQ00sb0JBQ3ZCIiwiZmlsZSI6ImNvbXBvbmVudHNcXGhlYWRlci5qcyIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9BYmFpanVuL0RvY3VtZW50cy9HaXRIdWIvbG9saSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL2NvbnRhaW5lcidcclxuaW1wb3J0IE1lbnVJdGVtIGZyb20gJy4vbWVudUl0ZW0nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJcIj5cclxuICAgICAgICAgICAgICAgIDxDb250YWluZXIgZmxleD17dHJ1ZX0+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiL3N0YXRpYy9sb2dvLnN2Z1wiLz4gICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1lbnVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPE1lbnVJdGVtPuazqOWGjDwvTWVudUl0ZW0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxNZW51SXRlbT7nmbvlvZU8L01lbnVJdGVtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TWVudUl0ZW0+5YWz5LqOPC9NZW51SXRlbT5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvQ29udGFpbmVyPlxyXG5cclxuICAgICAgICAgICAgICAgIDxzdHlsZSBqc3g+e2BcclxuICAgICAgICAgICAgICAgICAgICAuaGVhZGVyIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDQwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICMwMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6LWluZGV4OiA5OTk5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAuaGVhZGVyIGltZyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXgtaGVpZ2h0OiAxMDAlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDBweDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbnRhaW5lciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDUwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC5tZW51IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBgfTwvc3R5bGU+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIClcclxuICAgIH1cclxufSJdfQ== */\\n/*@ sourceURL=components\\\\header.js */'\n            }));\n        }\n    }]);\n\n    return _class;\n}(_react2.default.Component);\n\nexports.default = _class;\n\n ;(function register() { /* react-hot-loader/webpack */ if (process.env.NODE_ENV !== 'production') { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\components\\\\header.js\"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\components\\\\header.js\"); } } })();\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n\n/***/ 75:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _getPrototypeOf = __webpack_require__(4);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(5);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(6);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(8);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(7);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _style = __webpack_require__(11);\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _react = __webpack_require__(2);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _container = __webpack_require__(14);\n\nvar _container2 = _interopRequireDefault(_container);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _class = function (_React$Component) {\n    (0, _inherits3.default)(_class, _React$Component);\n\n    function _class(props) {\n        (0, _classCallCheck3.default)(this, _class);\n\n        return (0, _possibleConstructorReturn3.default)(this, (_class.__proto__ || (0, _getPrototypeOf2.default)(_class)).call(this, props));\n    }\n\n    (0, _createClass3.default)(_class, [{\n        key: 'render',\n        value: function render() {\n            return _react2.default.createElement('li', { className: 'menu-item', 'data-jsx': 3111979664\n            }, this.props.children, _react2.default.createElement(_style2.default, {\n                styleId: 3111979664,\n                css: '.menu-item[data-jsx=\"3111979664\"] {color: #fff;padding: 5px 0;position: relative;text-decoration: none;-webkit-transition: opacity .1s linear;-webkit-transition: opacity .1s linear;-moz-transition: opacity .1s linear;-ms-transition: opacity .1s linear;transition: opacity .1s linear;margin-right: 20px;cursor: pointer;}.menu-item[data-jsx=\"3111979664\"]:after {border-bottom: 2px solid #6fb900;bottom: 0;content: \"\";left: 0;pointer-events: none;position: absolute;right: 0;}.menu-item[data-jsx=\"3111979664\"]:hover {opacity: .7;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHNcXG1lbnVJdGVtLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWM0QixBQUNJLG1DQUNJLFlBQ0csZUFDSSxtQkFDRyxzQkFDaUIsdUNBQ1IsNklBQ1osbUJBQ0gsZ0JBQ25CLENBQ2lCLHlDQUNtQixpQ0FDdkIsVUFDRSxZQUNKLFFBQ2EscUJBQ0YsbUJBQ1YsU0FDWixDQUNpQix5Q0FDRixZQUNmIiwiZmlsZSI6ImNvbXBvbmVudHNcXG1lbnVJdGVtLmpzIiwic291cmNlUm9vdCI6IkM6L1VzZXJzL0FiYWlqdW4vRG9jdW1lbnRzL0dpdEh1Yi9sb2xpIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vY29udGFpbmVyJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm1lbnUtaXRlbVwiPlxyXG4gICAgICAgICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XHJcblxyXG4gICAgICAgICAgICAgICAgPHN0eWxlIGpzeD57YFxyXG4gICAgICAgICAgICAgICAgICAgIC5tZW51LWl0ZW0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogI2ZmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogNXB4IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgLjFzIGxpbmVhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAuMXMgbGluZWFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDIwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLm1lbnUtaXRlbTphZnRlciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAjNmZiOTAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAubWVudS1pdGVtOmhvdmVyIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogLjc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYH08L3N0eWxlPlxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgIClcclxuICAgIH1cclxufSJdfQ== */\\n/*@ sourceURL=components\\\\menuItem.js */'\n            }));\n        }\n    }]);\n\n    return _class;\n}(_react2.default.Component);\n\nexports.default = _class;\n\n ;(function register() { /* react-hot-loader/webpack */ if (process.env.NODE_ENV !== 'production') { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\components\\\\menuItem.js\"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\components\\\\menuItem.js\"); } } })();\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n\n/***/ 77:\n/***/ (function(module, exports) {\n\n(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ })\n\n},[593]);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRhaW5lci5qcz8zMDFlZWIxIiwid2VicGFjazovLy8uL2xpYi90b29sLmpzPzMwMWVlYjEiLCJ3ZWJwYWNrOi8vLy4vcGFnZXMvbW92aWUuanM/MzAxZWViMSIsIndlYnBhY2s6Ly8vLi9+L2hscy5qcy9kaXN0L2hscy5qcz8zMDFlZWIxIiwid2VicGFjazovLy8uL34vaXNvbW9ycGhpYy1mZXRjaC9mZXRjaC1ucG0tYnJvd3NlcmlmeS5qcz8zMDFlZWIxIiwid2VicGFjazovLy8uL34vY2xhc3NuYW1lcy9pbmRleC5qcz8zMDFlZWIxIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvaGVhZGVyLmpzPzMwMWVlYjEiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9tZW51SXRlbS5qcz8zMDFlZWIxIiwid2VicGFjazovLy8uL34vd2hhdHdnLWZldGNoL2ZldGNoLmpzPzMwMWVlYjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPOzs7O0FBQ0E7Ozs7Ozs7b0NBSUg7O29CQUFhLE9BQU87NENBQUE7O3FJQUVuQjs7Ozs7aUNBR0c7Z0JBQUk7NkJBRUE7d0JBQVEsS0FBSyxNQUNiO3lCQUFTLEtBQUssTUFFbEI7QUFKSSxhQURpQjttQ0FNakIsdUJBQUssV0FBVyw0QkFDWDthQURMLE9BQ1UsTUFBTTt5QkFEaEI7cUJBMkJQO0FBM0JPOzs7OztFQWJpQixnQkFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSG5DOzs7OzswRUFpQkE7K0JBQUE7c0VBQUE7c0JBQUE7aURBQUE7eUJBQ1E7QUFEUixpQ0FHSTs7cUNBQWEsUUFBUSxVQUFVOzt3Q0FIbkM7K0JBS3NCLGdDQUE4Qjs7eUJBQTFDO0FBTFY7d0NBQUE7K0JBTXVCLElBQUk7O3lCQUFqQjtBQU5WLHdDQU9RO0FBUFIsZ0NBT2dCLEtBQUssUUFFakI7O3FDQUFhLFFBQVEsU0FBUzs7eUJBVGxDO3lCQUFBO3dDQUFBOztBQUFBO29CQUFBOzs7b0JBQWU7Ozs7O0FBZmYsU0FBUyxlQUNMO1FBQUksTUFDSjtRQUFJLE9BQ0o7UUFBSSxNQUNKO1FBQUksTUFBTSxDQUFDLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FFckw7O1NBQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLEtBQ25CO2NBQU0sS0FBSyxNQUFNLEtBQUssWUFBWSxJQUFJLFNBQ3RDO2VBQU8sSUFDVjtBQUVEOztXQUFPLElBQUksVUFBVSxHQUFHLEtBQUssTUFBTSxJQUFJLFVBQVUsR0FBRyxNQUFNLE1BQU0sSUFBSSxVQUFVLElBQUksTUFBTSxNQUFNLElBQUksVUFBVSxJQUFHLE1BQU0sTUFBTSxJQUFJLFVBQVUsSUFDekk7V0FDSDtBQWNEOztrQkFBZSxPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0JSOzs7O0FBQ0E7Ozs7QUFDUDs7QUFDTzs7OztBQUNBOzs7O0FBQ1k7Ozs7QUFDRzs7OztBQUNIOzs7Ozs7Ozs7Ozs7Ozs7OztpQ0FRUDtzQ0FBTSxhQUFhLFFBQ25CO3dDQUFRLGFBQWEsUUFFekI7O0FBQ0E7O29DQUFJLE9BQU8sUUFBUSxTQUFTLE1BQ3hCO0FBQ0E7MENBQU0sYUFBYSxRQUNuQjs0Q0FBUSxhQUFhLFFBQ3hCOzs7O3VDQUVlLCtCQUE2QixLQUFLLE1BQU0sZUFBVSxrQkFBYTs7aUNBQTNFOzs7dUNBQ2EsSUFBSTs7aUNBQWpCOzs7c0NBRUEsS0FBSyxVQUFVOzs7QUFDZjs7QUFDQTtBQUNBO3NDQUFNLGFBQWEsUUFDbkI7d0NBQVEsYUFBYSxRQUVyQjs7Ozt1Q0FDWSwrQkFBNkIsS0FBSyxNQUFNLGVBQVUsa0JBQWE7O2lDQUEzRTs7O3VDQUNhLElBQUk7O2lDQUFqQjs7O2lDQUdKOztxQ0FBSyxTQUFTLEVBQUMsS0FBSyxLQUVwQjs7b0NBQUcsY0FBSSxlQUNDO0FBRGMsNENBQ04sU0FBUyxjQUNqQjtBQUZjLDBDQUdsQjs7d0NBQUksV0FBVyxLQUFLLE1BQ3BCO3dDQUFJLFlBQ0o7d0NBQUksR0FBRyxjQUFJLE9BQU8saUJBQWdCLFlBQ2hDOzhDQUNEO0FBQ0o7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkF2Q29DLFdBQVQsTUFBUzs7Ozs7a0VBQzlCLEVBQUMsSUFBSTs7Ozs7Ozs7Ozs7Ozs7O0FBeUNoQjs7O29CQUFhLE9BQU87NENBQUE7OzBJQUVoQjs7Y0FBSyxRQUFRLEVBQUMsS0FBSztlQUN0Qjs7Ozs7aUNBR0c7bUNBQ0ksdUJBQUssV0FBVSxxQkFDWDthQURKLGtCQUNLLDhCQUNHOzRCQUFBO0FBQUEsZUFDQSxxREFBTSxTQUFRLHFCQUNkO3dEQUFNLEtBQUksY0FBYSxNQUFLLGtDQUdoQztpQ0FBQyxnQ0FDRCw4Q0FBSyxXQUFVLG9CQUNYOytCQUFDLHFDQUFVLE1BQ1AsaURBQU8sV0FBVSxvQkFBakI7O3lCQVZaO3FCQW9DUDtBQXBDTzs7Ozs7RUFsRGlCLGdCQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ1RuQyx5QkFBYSxTQUEyRCxtQkFBbUIsZ0RBQWdELGFBQWEsS0FBSyxNQUFNLGdDQUFnQyxTQUFTLHFDQUFxQyxTQUFTLG1DQUFtQyxPQUFPLEtBQUssT0FBTyxhQUFhLGFBQWEsMEJBQTBCLDBCQUEwQixnQkFBZ0IsVUFBVSxVQUFVLDBDQUEwQyw4QkFBd0Isb0JBQW9CLDhDQUE4QyxrQ0FBa0MsWUFBWSxZQUFZLG1DQUFtQyxpQkFBaUIsZ0JBQWdCLHNCQUFzQixvQkFBb0IsMENBQTBDLFlBQVksV0FBVyxZQUFZLFNBQVMsR0FBRztBQUN2eUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0gsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7QUFDQSxpQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpREFBaUQ7QUFDakY7QUFDQSw0RkFBNEYsNEJBQTRCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQsK0NBQStDO0FBQzNHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtDQUErQyxpQkFBaUIsR0FBRyxlQUFlLEdBQUcscUJBQXFCLEdBQUcsbUJBQW1CO0FBQ2hJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxNQUFNLEdBQUcsYUFBYSxHQUFHLGdCQUFnQixHQUFHLHFDQUFxQyxHQUFHLFVBQVU7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHdIQUF3SDtBQUN6SztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakY7QUFDQTtBQUNBLGlFQUFpRSwwQkFBMEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHFFQUFxRTtBQUM1SCw0REFBNEQsY0FBYztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsOEJBQThCLHNFQUFzRTtBQUNwRztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx1Q0FBdUM7QUFDdkc7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNEhBQTRIO0FBQ3JMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNkpBQTZKO0FBQ3ROO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDRIQUE0SDtBQUNyTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwwR0FBMEc7QUFDbkssbUJBQW1CO0FBQ25CO0FBQ0EseURBQXlELHdHQUF3RztBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UscURBQXFEO0FBQ3pIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUMsRUFBRSx3RUFBd0U7QUFDM0U7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SixpREFBaUQsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRTlPLDBDQUEwQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUgsRUFBRTtBQUM5ZTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxhQUFhO0FBQ3RFO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDLEVBQUUsd0JBQXdCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosaURBQWlELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUU5TywwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVILEVBQUU7QUFDOWU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHlCQUF5Qjs7QUFFM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsc0NBQXNDO0FBQ3pHO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsWUFBWTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLG9DQUFvQztBQUN6RztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDLEVBQUUsd0JBQXdCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELG9HQUFvRyxtQkFBbUIsRUFBRSxtQkFBbUIsOEhBQThIOztBQUUxUSxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLGlEQUFpRCxhQUFhLHVGQUF1RixFQUFFLHVGQUF1Rjs7QUFFOU8sMENBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SCxFQUFFO0FBQzllO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4Qzs7QUFFOUMsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsdUVBQXVFLDRCQUE0QjtBQUNuRyxlQUFlO0FBQ2Y7QUFDQTtBQUNBLHVFQUF1RSw2QkFBNkI7QUFDcEcsZUFBZTtBQUNmLGFBQWE7O0FBRWI7QUFDQSxXQUFXO0FBQ1g7QUFDQSx3RUFBd0UsNkJBQTZCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUMsRUFBRSx3Q0FBd0M7QUFDM0M7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtDQUFrQztBQUNwRTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdko7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw0Q0FBNEMsMkhBQTJIO0FBQ3ZLO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUMsRUFBRSx3Q0FBd0M7QUFDM0M7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFELGtCQUFrQjtBQUN2RTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUUsR0FBRztBQUNwakI7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZELG9CQUFvQixHQUFHLFlBQVksR0FBRyxnQkFBZ0IsR0FBRyxzQkFBc0I7QUFDNUksdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjLEdBQUcsWUFBWSx3Q0FBd0MsR0FBRyxHQUFHLGNBQWM7QUFDMUg7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxFQUFFLHdCQUF3QjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7QUFDcGpCO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG1LQUFtSztBQUMxTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUMsRUFBRSxnQkFBZ0I7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0FBQ3BqQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSx1RUFBdUUsU0FBUyx1Q0FBdUMsRUFBRTtBQUN6SDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBEQUEwRCxHQUFHLDJEQUEyRCxHQUFHLG1FQUFtRTs7QUFFeE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHNKQUFzSjtBQUMxTTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxFQUFFLGdFQUFnRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYTtBQUNuRztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwRkFBMEYsZUFBZTtBQUN6RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLENBQUMsRUFBRSw4QkFBOEI7QUFDakM7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLGFBQWE7QUFDckc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEZBQTRGLGVBQWU7QUFDM0c7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msb0lBQW9JLDRFQUE0RSxFQUFFO0FBQ2pRO0FBQ0EsdUJBQXVCLG9GQUFvRjtBQUMzRyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbVVBQW1VO0FBQzFWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDLEVBQUUsb0RBQW9EO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUUsR0FBRztBQUNwakI7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGdDQUFnQyx1Q0FBdUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixPQUFPO0FBQ1AsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0IsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CLGtDQUFrQztBQUNsQyxrQkFBa0I7QUFDbEIsNkJBQTZCO0FBQzdCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTztBQUNQLG9CQUFvQjtBQUNwQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxFQUFFLFFBQVE7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7QUFDcGpCO0FBQ0E7OztBQUdBOztBQUVBLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUSxHQUFHLE9BQU87O0FBRW5FO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxFQUFFLFFBQVE7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7QUFDcGpCO0FBQ0E7QUFDQSxVQUFVLE9BQU87OztBQUdqQjs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdko7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx5RUFBeUUsZ0NBQWdDO0FBQ3pHO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQ0FBbUM7QUFDN0Q7QUFDQSxtQ0FBbUM7QUFDbkMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUMsRUFBRSxRQUFRO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0FBQ3BqQjtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQ0FBcUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0NBQXNDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxFQUFFLFFBQVE7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7QUFDcGpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlEQUF5RCxvSkFBb0o7QUFDN007QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrRUFBK0UsMENBQTBDO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYyx1Q0FBdUMsdUJBQXVCO0FBQzVFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx1SEFBdUg7QUFDOUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RCxvQkFBb0IsR0FBRyxZQUFZLEdBQUcsZ0JBQWdCLEdBQUcsc0JBQXNCO0FBQzVJLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFDQUFxQztBQUMvRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxFQUFFLGdEQUFnRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELCtCQUErQjtBQUNsRjtBQUNBLHFEQUFxRCwrQkFBK0I7QUFDcEY7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxnREFBZ0QsK0JBQStCO0FBQy9FO0FBQ0Esa0RBQWtELCtCQUErQjtBQUNqRjtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLHVEQUF1RCwrQkFBK0I7QUFDdEY7QUFDQSx5REFBeUQsK0JBQStCO0FBQ3hGO0FBQ0EsaURBQWlELHFDQUFxQztBQUN0RjtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0Esb0RBQW9ELHFDQUFxQztBQUN6RjtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsb0dBQW9HLG1CQUFtQixFQUFFLG1CQUFtQiw4SEFBOEg7O0FBRTFRLGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUUsR0FBRztBQUNwakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdGQUF3RixhQUFhO0FBQ3JHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrREFBa0QsK0hBQStIO0FBQ2pMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDLEVBQUUsd0JBQXdCO0FBQzNCOztBQUVBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixVQUFVO0FBQ2xHO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxtREFBbUQsNEdBQTRHO0FBQy9KO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLDJEQUEyRCxxRUFBcUUsZ0NBQWdDO0FBQ2hLO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0Esc0RBQXNELHNCQUFzQjtBQUM1RTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLDBEQUEwRCw4REFBOEQsZ0NBQWdDO0FBQ3hKO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsNkRBQTZELGlFQUFpRSxnQ0FBZ0M7QUFDOUo7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSwyREFBMkQsMEJBQTBCO0FBQ3JGO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EseURBQXlELDhEQUE4RDtBQUN2SDtBQUNBLDREQUE0RCxrREFBa0QsZ0JBQWdCO0FBQzlIO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsNkZBQTZGLGtEQUFrRCxxREFBcUQ7QUFDcE07QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsNERBQTRELHlEQUF5RDtBQUNySDtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDLHlCQUF5QixtREFBbUQ7QUFDNUU7QUFDQTtBQUNBLE9BQU87QUFDUCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxzQkFBc0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUUsR0FBRztBQUNwakI7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLG9CQUFvQixHQUFHLGtCQUFrQjs7QUFFMUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxFQUFFLFFBQVE7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SUFBNkk7QUFDN0k7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsYUFBYTtBQUNyRztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0RkFBNEYsZUFBZTtBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGVBQWU7QUFDckU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsV0FBVztBQUNsRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEs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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0IsNERBQTREO0FBQzVELHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7O0FBRUEsR0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsUUFBUSxHQUFHLFFBQVEsR0FBRyxRQUFRLEdBQUcsd0NBQXdDO0FBQ3ZMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0Esc0JBQXNCLDRDQUE0QztBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZTtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLEVBQUUsUUFBUTtBQUNYOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLHVCQUF1QjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHVDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQiwwQkFBMEIsZUFBZTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6ImJ1bmRsZXNcXHBhZ2VzXFxtb3ZpZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcclxuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHZhciBjb250YWluZXJDbGFzcyA9IGNsYXNzTmFtZXMoe1xyXG4gICAgICAgICAgICAnY29udGFpbmVyJzogdHJ1ZSxcclxuICAgICAgICAgICAgJ2ZsZXgnOiB0aGlzLnByb3BzLmZsZXgsXHJcbiAgICAgICAgICAgICdzbWFsbCc6IHRoaXMucHJvcHMuc21hbGxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y29udGFpbmVyQ2xhc3N9PlxyXG4gICAgICAgICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICA8c3R5bGUganN4PntgXHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbnRhaW5lci5zbWFsbCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDUwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC5jb250YWluZXIge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMCBhdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAuY29udGFpbmVyLmZsZXgge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4taGVpZ2h0OiA2MzBweCkgYW5kIChtaW4td2lkdGg6IDEyOTRweCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29udGFpbmVyIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDY2cHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi1oZWlnaHQ6IDg3MHB4KSBhbmQgKG1pbi13aWR0aDogMTMyMHB4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb250YWluZXIge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEyODBweDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGB9PC9zdHlsZT5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250YWluZXIuanMiLCJpbXBvcnQgJ2lzb21vcnBoaWMtZmV0Y2gnXHJcblxyXG5mdW5jdGlvbiByYW5kb21Vc2VyaWQoKSB7XHJcbiAgICBsZXQgc3RyID0gXCJcIjtcclxuICAgIGxldCBzdHIyID0gXCJcIjtcclxuICAgIGxldCBwb3MgPSAnJztcclxuICAgIGxldCBhcnIgPSBbJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJ107XHJcbiAgICBcclxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKXtcclxuICAgICAgICBwb3MgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAoYXJyLmxlbmd0aC0xKSk7XHJcbiAgICAgICAgc3RyICs9IGFycltwb3NdO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBzdHIyID0gc3RyLnN1YnN0cmluZygwLCA4KSArICctJyArIHN0ci5zdWJzdHJpbmcoOCwgMTIpICsgJy0nICsgc3RyLnN1YnN0cmluZygxMiwgMTYpICsgJy0nICsgc3RyLnN1YnN0cmluZygxNiwyMCkgKyAnLScgKyBzdHIuc3Vic3RyaW5nKDIwLDMyKTtcclxuICAgIHJldHVybiBzdHIyO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnkoKSB7XHJcbiAgICBsZXQgdXNlcmlkID0gcmFuZG9tVXNlcmlkKCk7XHJcblxyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2VyaWRcIiwgdXNlcmlkKTtcclxuXHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgaHR0cDovL2xvbGkudmMvbG9naW4vJHt1c2VyaWR9YCk7XHJcbiAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcclxuICAgIGxldCB0b2tlbiA9IGpzb24uTWVzc2FnZS5Ub2tlbjtcclxuXHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInRva2VuXCIsIHRva2VuKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgdmVyaWZ5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi90b29sLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnXHJcbmltcG9ydCAnaXNvbW9ycGhpYy1mZXRjaCdcclxuaW1wb3J0IEhscyBmcm9tICdobHMuanMnXHJcbmltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCdcclxuaW1wb3J0IEhlYWRlciBmcm9tICcuLi9jb21wb25lbnRzL2hlYWRlcidcclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi9jb21wb25lbnRzL2NvbnRhaW5lcidcclxuaW1wb3J0IHZlcmlmeSBmcm9tICcuLi9saWIvdG9vbCdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIHN0YXRpYyBhc3luYyBnZXRJbml0aWFsUHJvcHMgKHsgcXVlcnk6IHsgaWQgfSB9KSB7XHJcbiAgICAgICAgcmV0dXJuIHtpZDogaWR9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgY29tcG9uZW50V2lsbE1vdW50KCkge1xyXG4gICAgICAgIGxldCB1aWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInVzZXJpZFwiKTtcclxuICAgICAgICBsZXQgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VuXCIpO1xyXG5cclxuICAgICAgICAvLyDnm7TmjqXku44gdXJsIOi/m+WFpee7hOS7tlxyXG4gICAgICAgIGlmICh1aWQgPT0gbnVsbCB8fCB0b2tlbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZlcmlmeSgpO1xyXG4gICAgICAgICAgICB1aWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInVzZXJpZFwiKTtcclxuICAgICAgICAgICAgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9saS52Yy9wbGF5LyR7dGhpcy5wcm9wcy5pZH0/dWlkPSR7dWlkfSZ0b2tlbj0ke3Rva2VufWApO1xyXG4gICAgICAgIGxldCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcclxuXHJcbiAgICAgICAgaWYgKGRhdGEuUmVzdWx0ID09IDApIHtcclxuICAgICAgICAgICAgLy8g6K6k6K+B5bey6L+H5pyfLCDpnIDopoHph43mlrDorqTor4FcclxuICAgICAgICAgICAgdmVyaWZ5KCk7XHJcbiAgICAgICAgICAgIHVpZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidXNlcmlkXCIpO1xyXG4gICAgICAgICAgICB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidG9rZW5cIik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyDph43mlrDorqTor4HlkI7lj5Hor7fmsYJcclxuICAgICAgICAgICAgcmVzID0gYXdhaXQgZmV0Y2goYGh0dHA6Ly9sb2xpLnZjL3BsYXkvJHt0aGlzLnByb3BzLmlkfT91aWQ9JHt1aWR9JnRva2VuPSR7dG9rZW59YCk7XHJcbiAgICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dXJsOiBkYXRhLk1lc3NhZ2V9KTtcclxuXHJcbiAgICAgICAgaWYoSGxzLmlzU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICAgICAgdmFyIHZpZGVvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRlc3QnKTtcclxuICAgICAgICAgICAgdmFyIGhscyA9IG5ldyBIbHMoKTtcclxuICAgICAgICAgICAgaGxzLmxvYWRTb3VyY2UodGhpcy5zdGF0ZS51cmwpO1xyXG4gICAgICAgICAgICBobHMuYXR0YWNoTWVkaWEodmlkZW8pO1xyXG4gICAgICAgICAgICBobHMub24oSGxzLkV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgdmlkZW8ucGxheSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IgKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7dXJsOiBcIlwifTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb3ZpZVwiPlxyXG4gICAgICAgICAgICAgICAgPEhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRpdGxlPmxvbGkgMy4wPC90aXRsZT5cclxuICAgICAgICAgICAgICAgICAgICA8bWV0YSBjaGFyU2V0PSd1dGYtOCcgLz5cclxuICAgICAgICAgICAgICAgICAgICA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgaHJlZj1cIi9zdGF0aWMvZ2xvYmFsLmNzc1wiIC8+XHJcbiAgICAgICAgICAgICAgICA8L0hlYWQ+XHJcblxyXG4gICAgICAgICAgICAgICAgPEhlYWRlci8+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1hc2tcIj5cclxuICAgICAgICAgICAgICAgICAgICA8Q29udGFpbmVyIGZsZXg9e3RydWV9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dmlkZW8gY2xhc3NOYW1lPVwidGVzdFwiPjwvdmlkZW8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Db250YWluZXI+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgPHN0eWxlIGpzeD57YFxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXN0IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXNrIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogIzAwMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi1oZWlnaHQ6IDYzMHB4KSBhbmQgKG1pbi13aWR0aDogMTI5NHB4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXNrIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogNDgwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi1oZWlnaHQ6IDg3MHB4KSBhbmQgKG1pbi13aWR0aDogMTMyMHB4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXNrIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogNzIwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBgfTwvc3R5bGU+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhZ2VzL21vdmllLmpzP2VudHJ5IiwiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuSGxzID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG59LHt9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cclxuKGZ1bmN0aW9uKHJvb3QpIHsgXHJcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXHJcblxyXG4gIHZhciBIQVNIX1NQTElUID0gL14oW14jXSopKC4qKSQvO1xyXG4gIHZhciBRVUVSWV9TUExJVCA9IC9eKFteXFw/XSopKC4qKSQvO1xyXG4gIHZhciBET01BSU5fU1BMSVQgPSAvXigoW2Etel0rOlxcL1xcLyk/W146XFwvXSsoPzo6WzAtOV0rKT8pPyhcXC8/LiopJC9pO1xyXG5cclxuICB2YXIgVVJMVG9vbGtpdCA9IHtcclxuICAgIC8vIGJ1aWxkIGFuIGFic29sdXRlIFVSTCBmcm9tIGEgcmVsYXRpdmUgb25lIHVzaW5nIHRoZSBwcm92aWRlZCBiYXNlVVJMXHJcbiAgICAvLyBpZiByZWxhdGl2ZVVSTCBpcyBhbiBhYnNvbHV0ZSBVUkwgaXQgd2lsbCBiZSByZXR1cm5lZCBhcyBpcy5cclxuICAgIGJ1aWxkQWJzb2x1dGVVUkw6IGZ1bmN0aW9uKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XHJcbiAgICAgIC8vIHJlbW92ZSBhbnkgcmVtYWluaW5nIHNwYWNlIGFuZCBDUkxGXHJcbiAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xyXG4gICAgICBpZiAoL15bYS16XSs6L2kudGVzdChyZWxhdGl2ZVVSTCkpIHtcclxuICAgICAgICAvLyBjb21wbGV0ZSB1cmwsIG5vdCByZWxhdGl2ZVxyXG4gICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlbGF0aXZlVVJMUXVlcnkgPSBudWxsO1xyXG4gICAgICB2YXIgcmVsYXRpdmVVUkxIYXNoID0gbnVsbDtcclxuXHJcbiAgICAgIHZhciByZWxhdGl2ZVVSTEhhc2hTcGxpdCA9IEhBU0hfU1BMSVQuZXhlYyhyZWxhdGl2ZVVSTCk7XHJcbiAgICAgIGlmIChyZWxhdGl2ZVVSTEhhc2hTcGxpdCkge1xyXG4gICAgICAgIHJlbGF0aXZlVVJMSGFzaCA9IHJlbGF0aXZlVVJMSGFzaFNwbGl0WzJdO1xyXG4gICAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkxIYXNoU3BsaXRbMV07XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlbGF0aXZlVVJMUXVlcnlTcGxpdCA9IFFVRVJZX1NQTElULmV4ZWMocmVsYXRpdmVVUkwpO1xyXG4gICAgICBpZiAocmVsYXRpdmVVUkxRdWVyeVNwbGl0KSB7XHJcbiAgICAgICAgcmVsYXRpdmVVUkxRdWVyeSA9IHJlbGF0aXZlVVJMUXVlcnlTcGxpdFsyXTtcclxuICAgICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMUXVlcnlTcGxpdFsxXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGJhc2VVUkxIYXNoU3BsaXQgPSBIQVNIX1NQTElULmV4ZWMoYmFzZVVSTCk7XHJcbiAgICAgIGlmIChiYXNlVVJMSGFzaFNwbGl0KSB7XHJcbiAgICAgICAgYmFzZVVSTCA9IGJhc2VVUkxIYXNoU3BsaXRbMV07XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGJhc2VVUkxRdWVyeVNwbGl0ID0gUVVFUllfU1BMSVQuZXhlYyhiYXNlVVJMKTtcclxuICAgICAgaWYgKGJhc2VVUkxRdWVyeVNwbGl0KSB7XHJcbiAgICAgICAgYmFzZVVSTCA9IGJhc2VVUkxRdWVyeVNwbGl0WzFdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgYmFzZVVSTERvbWFpblNwbGl0ID0gRE9NQUlOX1NQTElULmV4ZWMoYmFzZVVSTCk7XHJcbiAgICAgIGlmICghYmFzZVVSTERvbWFpblNwbGl0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIGUuZy4gJ2h0dHA6Ly8nLCAnaHR0cHM6Ly8nLCAnJ1xyXG4gICAgICB2YXIgYmFzZVVSTFByb3RvY29sID0gYmFzZVVSTERvbWFpblNwbGl0WzJdIHx8ICcnO1xyXG4gICAgICAvLyBlLmcuICdodHRwOi8vZXhhbXBsZS5jb20nLCAnLy9leGFtcGxlLmNvbScsICdleGFtcGxlLmNvbScsICcnXHJcbiAgICAgIHZhciBiYXNlVVJMUHJvdG9jb2xEb21haW4gPSBiYXNlVVJMRG9tYWluU3BsaXRbMV0gfHwgJyc7XHJcbiAgICAgIC8vIGUuZy4gJy9hL2IvYy9wbGF5bGlzdC5tM3U4JywgJ2EvYi9jL3BsYXlsaXN0Lm0zdTgnXHJcbiAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VVUkxEb21haW5TcGxpdFszXTtcclxuICAgICAgaWYgKGJhc2VVUkxQYXRoLmluZGV4T2YoJy8nKSAhPT0gMCAmJiBiYXNlVVJMUHJvdG9jb2xEb21haW4gIT09ICcnKSB7XHJcbiAgICAgICAgLy8gdGhpcyBoYW5kbGVzIGEgYmFzZSB1cmwgb2YgaHR0cDovL2V4YW1wbGUuY29tIChtaXNzaW5nIGxhc3Qgc2xhc2gpXHJcbiAgICAgICAgYmFzZVVSTFBhdGggPSAnLycrYmFzZVVSTFBhdGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBidWlsdFVSTCA9IG51bGw7XHJcbiAgICAgIGlmICgvXlxcL1xcLy8udGVzdChyZWxhdGl2ZVVSTCkpIHtcclxuICAgICAgICAvLyByZWxhdGl2ZSB1cmwgc3RhcnRzIHd0aCAnLy8nIHNvIGNvcHkgcHJvdG9jb2wgKHdoaWNoIG1heSBiZSAnJyBpZiBiYXNlVXJsIGRpZG4ndCBwcm92aWRlIG9uZSlcclxuICAgICAgICBidWlsdFVSTCA9IGJhc2VVUkxQcm90b2NvbCtVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVQYXRoKCcnLCByZWxhdGl2ZVVSTC5zdWJzdHJpbmcoMikpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKC9eXFwvLy50ZXN0KHJlbGF0aXZlVVJMKSkge1xyXG4gICAgICAgIC8vIHJlbGF0aXZlIHVybCBzdGFydHMgd2l0aCAnLycgc28gc3RhcnQgZnJvbSByb290IG9mIGRvbWFpblxyXG4gICAgICAgIGJ1aWx0VVJMID0gYmFzZVVSTFByb3RvY29sRG9tYWluKycvJytVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVQYXRoKCcnLCByZWxhdGl2ZVVSTC5zdWJzdHJpbmcoMSkpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGJ1aWx0VVJMID0gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlUGF0aChiYXNlVVJMUHJvdG9jb2xEb21haW4rYmFzZVVSTFBhdGgsIHJlbGF0aXZlVVJMKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcHV0IHRoZSBxdWVyeSBhbmQgaGFzaCBwYXJ0cyBiYWNrXHJcbiAgICAgIGlmIChyZWxhdGl2ZVVSTFF1ZXJ5KSB7XHJcbiAgICAgICAgYnVpbHRVUkwgKz0gcmVsYXRpdmVVUkxRdWVyeTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocmVsYXRpdmVVUkxIYXNoKSB7XHJcbiAgICAgICAgYnVpbHRVUkwgKz0gcmVsYXRpdmVVUkxIYXNoO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBidWlsdFVSTDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gYnVpbGQgYW4gYWJzb2x1dGUgcGF0aCB1c2luZyB0aGUgcHJvdmlkZWQgYmFzZVBhdGhcclxuICAgIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvZG9jdW1lbnQvY29va2llI1VzaW5nX3JlbGF0aXZlX1VSTHNfaW5fdGhlX3BhdGhfcGFyYW1ldGVyXHJcbiAgICAvLyB0aGlzIGRvZXMgbm90IGhhbmRsZSB0aGUgY2FzZSB3aGVyZSByZWxhdGl2ZVBhdGggaXMgXCIvXCIgb3IgXCIvL1wiLiBUaGVzZSBjYXNlcyBzaG91bGQgYmUgaGFuZGxlZCBvdXRzaWRlIHRoaXMuXHJcbiAgICBidWlsZEFic29sdXRlUGF0aDogZnVuY3Rpb24oYmFzZVBhdGgsIHJlbGF0aXZlUGF0aCkge1xyXG4gICAgICB2YXIgc1JlbFBhdGggPSByZWxhdGl2ZVBhdGg7XHJcbiAgICAgIHZhciBuVXBMbiwgc0RpciA9ICcnLCBzUGF0aCA9IGJhc2VQYXRoLnJlcGxhY2UoL1teXFwvXSokLywgc1JlbFBhdGgucmVwbGFjZSgvKFxcL3xeKSg/OlxcLj9cXC8rKSsvZywgJyQxJykpO1xyXG4gICAgICBmb3IgKHZhciBuRW5kLCBuU3RhcnQgPSAwOyBuRW5kID0gc1BhdGguaW5kZXhPZignLy4uLycsIG5TdGFydCksIG5FbmQgPiAtMTsgblN0YXJ0ID0gbkVuZCArIG5VcExuKSB7XHJcbiAgICAgICAgblVwTG4gPSAvXlxcLyg/OlxcLlxcLlxcLykqLy5leGVjKHNQYXRoLnNsaWNlKG5FbmQpKVswXS5sZW5ndGg7XHJcbiAgICAgICAgc0RpciA9IChzRGlyICsgc1BhdGguc3Vic3RyaW5nKG5TdGFydCwgbkVuZCkpLnJlcGxhY2UobmV3IFJlZ0V4cCgnKD86XFxcXFxcLytbXlxcXFxcXC9dKil7MCwnICsgKChuVXBMbiAtIDEpIC8gMykgKyAnfSQnKSwgJy8nKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc0RpciArIHNQYXRoLnN1YnN0cihuU3RhcnQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXHJcbiAgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBVUkxUb29sa2l0O1xyXG4gIGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxyXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIFVSTFRvb2xraXQ7IH0pO1xyXG4gIGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxyXG4gICAgZXhwb3J0c1tcIlVSTFRvb2xraXRcIl0gPSBVUkxUb29sa2l0O1xyXG4gIGVsc2VcclxuICAgIHJvb3RbXCJVUkxUb29sa2l0XCJdID0gVVJMVG9vbGtpdDtcclxufSkodGhpcyk7XHJcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXHJcblxufSx7fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgYnVuZGxlRm4gPSBhcmd1bWVudHNbM107XG52YXIgc291cmNlcyA9IGFyZ3VtZW50c1s0XTtcbnZhciBjYWNoZSA9IGFyZ3VtZW50c1s1XTtcblxudmFyIHN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIHZhciB3a2V5O1xuICAgIHZhciBjYWNoZUtleXMgPSBPYmplY3Qua2V5cyhjYWNoZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhY2hlS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGNhY2hlS2V5c1tpXTtcbiAgICAgICAgdmFyIGV4cCA9IGNhY2hlW2tleV0uZXhwb3J0cztcbiAgICAgICAgLy8gVXNpbmcgYmFiZWwgYXMgYSB0cmFuc3BpbGVyIHRvIHVzZSBlc21vZHVsZSwgdGhlIGV4cG9ydCB3aWxsIGFsd2F5c1xuICAgICAgICAvLyBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZGVmYXVsdCBleHBvcnQgYXMgYSBwcm9wZXJ0eSBvZiBpdC4gVG8gZW5zdXJlXG4gICAgICAgIC8vIHRoZSBleGlzdGluZyBhcGkgYW5kIGJhYmVsIGVzbW9kdWxlIGV4cG9ydHMgYXJlIGJvdGggc3VwcG9ydGVkIHdlXG4gICAgICAgIC8vIGNoZWNrIGZvciBib3RoXG4gICAgICAgIGlmIChleHAgPT09IGZuIHx8IGV4cCAmJiBleHAuZGVmYXVsdCA9PT0gZm4pIHtcbiAgICAgICAgICAgIHdrZXkgPSBrZXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghd2tleSkge1xuICAgICAgICB3a2V5ID0gTWF0aC5mbG9vcihNYXRoLnBvdygxNiwgOCkgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygxNik7XG4gICAgICAgIHZhciB3Y2FjaGUgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWNoZUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXlzW2ldO1xuICAgICAgICAgICAgd2NhY2hlW2tleV0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlc1t3a2V5XSA9IFtcbiAgICAgICAgICAgIEZ1bmN0aW9uKFsncmVxdWlyZScsJ21vZHVsZScsJ2V4cG9ydHMnXSwgJygnICsgZm4gKyAnKShzZWxmKScpLFxuICAgICAgICAgICAgd2NhY2hlXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZhciBza2V5ID0gTWF0aC5mbG9vcihNYXRoLnBvdygxNiwgOCkgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygxNik7XG5cbiAgICB2YXIgc2NhY2hlID0ge307IHNjYWNoZVt3a2V5XSA9IHdrZXk7XG4gICAgc291cmNlc1tza2V5XSA9IFtcbiAgICAgICAgRnVuY3Rpb24oWydyZXF1aXJlJ10sIChcbiAgICAgICAgICAgIC8vIHRyeSB0byBjYWxsIGRlZmF1bHQgaWYgZGVmaW5lZCB0byBhbHNvIHN1cHBvcnQgYmFiZWwgZXNtb2R1bGVcbiAgICAgICAgICAgIC8vIGV4cG9ydHNcbiAgICAgICAgICAgICd2YXIgZiA9IHJlcXVpcmUoJyArIHN0cmluZ2lmeSh3a2V5KSArICcpOycgK1xuICAgICAgICAgICAgJyhmLmRlZmF1bHQgPyBmLmRlZmF1bHQgOiBmKShzZWxmKTsnXG4gICAgICAgICkpLFxuICAgICAgICBzY2FjaGVcbiAgICBdO1xuXG4gICAgdmFyIHdvcmtlclNvdXJjZXMgPSB7fTtcbiAgICByZXNvbHZlU291cmNlcyhza2V5KTtcblxuICAgIGZ1bmN0aW9uIHJlc29sdmVTb3VyY2VzKGtleSkge1xuICAgICAgICB3b3JrZXJTb3VyY2VzW2tleV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGRlcFBhdGggaW4gc291cmNlc1trZXldWzFdKSB7XG4gICAgICAgICAgICB2YXIgZGVwS2V5ID0gc291cmNlc1trZXldWzFdW2RlcFBhdGhdO1xuICAgICAgICAgICAgaWYgKCF3b3JrZXJTb3VyY2VzW2RlcEtleV0pIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlU291cmNlcyhkZXBLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNyYyA9ICcoJyArIGJ1bmRsZUZuICsgJykoeydcbiAgICAgICAgKyBPYmplY3Qua2V5cyh3b3JrZXJTb3VyY2VzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShrZXkpICsgJzpbJ1xuICAgICAgICAgICAgICAgICsgc291cmNlc1trZXldWzBdXG4gICAgICAgICAgICAgICAgKyAnLCcgKyBzdHJpbmdpZnkoc291cmNlc1trZXldWzFdKSArICddJ1xuICAgICAgICAgICAgO1xuICAgICAgICB9KS5qb2luKCcsJylcbiAgICAgICAgKyAnfSx7fSxbJyArIHN0cmluZ2lmeShza2V5KSArICddKSdcbiAgICA7XG5cbiAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMO1xuXG4gICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbc3JjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmJhcmUpIHsgcmV0dXJuIGJsb2I7IH1cbiAgICB2YXIgd29ya2VyVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVcmwpO1xuICAgIHdvcmtlci5vYmplY3RVUkwgPSB3b3JrZXJVcmw7XG4gICAgcmV0dXJuIHdvcmtlcjtcbn07XG5cbn0se31dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBITFMgY29uZmlnXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmhsc0RlZmF1bHRDb25maWcgPSB1bmRlZmluZWQ7XG5cbnZhciBfYWJyQ29udHJvbGxlciA9IF9kZXJlcV8oNSk7XG5cbnZhciBfYWJyQ29udHJvbGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hYnJDb250cm9sbGVyKTtcblxudmFyIF9idWZmZXJDb250cm9sbGVyID0gX2RlcmVxXyg4KTtcblxudmFyIF9idWZmZXJDb250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1ZmZlckNvbnRyb2xsZXIpO1xuXG52YXIgX2NhcExldmVsQ29udHJvbGxlciA9IF9kZXJlcV8oOSk7XG5cbnZhciBfY2FwTGV2ZWxDb250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NhcExldmVsQ29udHJvbGxlcik7XG5cbnZhciBfZnBzQ29udHJvbGxlciA9IF9kZXJlcV8oMTEpO1xuXG52YXIgX2Zwc0NvbnRyb2xsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnBzQ29udHJvbGxlcik7XG5cbnZhciBfeGhyTG9hZGVyID0gX2RlcmVxXyg1NSk7XG5cbnZhciBfeGhyTG9hZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3hockxvYWRlcik7XG5cbnZhciBfYXVkaW9UcmFja0NvbnRyb2xsZXIgPSBfZGVyZXFfKDcpO1xuXG52YXIgX2F1ZGlvVHJhY2tDb250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F1ZGlvVHJhY2tDb250cm9sbGVyKTtcblxudmFyIF9hdWRpb1N0cmVhbUNvbnRyb2xsZXIgPSBfZGVyZXFfKDYpO1xuXG52YXIgX2F1ZGlvU3RyZWFtQ29udHJvbGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hdWRpb1N0cmVhbUNvbnRyb2xsZXIpO1xuXG52YXIgX2N1ZXMgPSBfZGVyZXFfKDQ4KTtcblxudmFyIF9jdWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2N1ZXMpO1xuXG52YXIgX3RpbWVsaW5lQ29udHJvbGxlciA9IF9kZXJlcV8oMTYpO1xuXG52YXIgX3RpbWVsaW5lQ29udHJvbGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW1lbGluZUNvbnRyb2xsZXIpO1xuXG52YXIgX3N1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gX2RlcmVxXygxNSk7XG5cbnZhciBfc3VidGl0bGVUcmFja0NvbnRyb2xsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpO1xuXG52YXIgX3N1YnRpdGxlU3RyZWFtQ29udHJvbGxlciA9IF9kZXJlcV8oMTQpO1xuXG52YXIgX3N1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyNlbmRpZlxuXG4vLyNlbmRpZlxuXG4vLyNpZiBzdWJ0aXRsZVxuXG4vL2ltcG9ydCBGZXRjaExvYWRlciBmcm9tICcuL3V0aWxzL2ZldGNoLWxvYWRlcic7XG4vLyNpZiBhbHRhdWRpb1xudmFyIGhsc0RlZmF1bHRDb25maWcgPSBleHBvcnRzLmhsc0RlZmF1bHRDb25maWcgPSB7XG4gICAgICBhdXRvU3RhcnRMb2FkOiB0cnVlLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBzdGFydFBvc2l0aW9uOiAtMSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgZGVmYXVsdEF1ZGlvQ29kZWM6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgZGVidWc6IGZhbHNlLCAvLyB1c2VkIGJ5IGxvZ2dlclxuICAgICAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLCAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gICAgICBjYXBMZXZlbFRvUGxheWVyU2l6ZTogZmFsc2UsIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgICAgIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplOiAxLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBtYXhCdWZmZXJMZW5ndGg6IDMwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBtYXhCdWZmZXJTaXplOiA2MCAqIDEwMDAgKiAxMDAwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBtYXhCdWZmZXJIb2xlOiAwLjUsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIG1heFNlZWtIb2xlOiAyLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBsb3dCdWZmZXJXYXRjaGRvZ1BlcmlvZDogMC41LCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBoaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2Q6IDMsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIG51ZGdlT2Zmc2V0OiAwLjEsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIG51ZGdlTWF4UmV0cnk6IDMsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IDAuMiwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50OiAzLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IEluZmluaXR5LCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBsaXZlU3luY0R1cmF0aW9uOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIGxpdmVNYXhMYXRlbmN5RHVyYXRpb246IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgbWF4TWF4QnVmZmVyTGVuZ3RoOiA2MDAsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIGVuYWJsZVdvcmtlcjogdHJ1ZSwgLy8gdXNlZCBieSBkZW11eGVyXG4gICAgICBlbmFibGVTb2Z0d2FyZUFFUzogdHJ1ZSwgLy8gdXNlZCBieSBkZWNyeXB0ZXJcbiAgICAgIG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6IDEwMDAwLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICAgICAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk6IDEsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gICAgICBtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICAgICAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgICAgIHN0YXJ0TGV2ZWw6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBsZXZlbC1jb250cm9sbGVyXG4gICAgICBsZXZlbExvYWRpbmdUaW1lT3V0OiAxMDAwMCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgICAgIGxldmVsTG9hZGluZ01heFJldHJ5OiA0LCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICAgICAgbGV2ZWxMb2FkaW5nUmV0cnlEZWxheTogMTAwMCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgICAgIGxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gICAgICBmcmFnTG9hZGluZ1RpbWVPdXQ6IDIwMDAwLCAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICAgICAgZnJhZ0xvYWRpbmdNYXhSZXRyeTogNiwgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgICAgIGZyYWdMb2FkaW5nUmV0cnlEZWxheTogMTAwMCwgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgICAgIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCwgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgICAgIGZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDogMywgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgc3RhcnRGcmFnUHJlZmV0Y2g6IGZhbHNlLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBmcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZDogNTAwMCwgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICAgICAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IDAuMiwgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICAgICAgYXBwZW5kRXJyb3JNYXhSZXRyeTogMywgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICAgICAgbG9hZGVyOiBfeGhyTG9hZGVyMi5kZWZhdWx0LFxuICAgICAgLy9sb2FkZXI6IEZldGNoTG9hZGVyLFxuICAgICAgZkxvYWRlcjogdW5kZWZpbmVkLFxuICAgICAgcExvYWRlcjogdW5kZWZpbmVkLFxuICAgICAgeGhyU2V0dXA6IHVuZGVmaW5lZCxcbiAgICAgIGZldGNoU2V0dXA6IHVuZGVmaW5lZCxcbiAgICAgIGFickNvbnRyb2xsZXI6IF9hYnJDb250cm9sbGVyMi5kZWZhdWx0LFxuICAgICAgYnVmZmVyQ29udHJvbGxlcjogX2J1ZmZlckNvbnRyb2xsZXIyLmRlZmF1bHQsXG4gICAgICBjYXBMZXZlbENvbnRyb2xsZXI6IF9jYXBMZXZlbENvbnRyb2xsZXIyLmRlZmF1bHQsXG4gICAgICBmcHNDb250cm9sbGVyOiBfZnBzQ29udHJvbGxlcjIuZGVmYXVsdCxcbiAgICAgIC8vI2lmIGFsdGF1ZGlvXG4gICAgICBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IF9hdWRpb1N0cmVhbUNvbnRyb2xsZXIyLmRlZmF1bHQsXG4gICAgICBhdWRpb1RyYWNrQ29udHJvbGxlcjogX2F1ZGlvVHJhY2tDb250cm9sbGVyMi5kZWZhdWx0LFxuICAgICAgLy8jZW5kaWZcbiAgICAgIC8vI2lmIHN1YnRpdGxlXG4gICAgICBzdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI6IF9zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIyLmRlZmF1bHQsXG4gICAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjogX3N1YnRpdGxlVHJhY2tDb250cm9sbGVyMi5kZWZhdWx0LFxuICAgICAgdGltZWxpbmVDb250cm9sbGVyOiBfdGltZWxpbmVDb250cm9sbGVyMi5kZWZhdWx0LFxuICAgICAgY3VlSGFuZGxlcjogX2N1ZXMyLmRlZmF1bHQsXG4gICAgICBlbmFibGVDRUE3MDhDYXB0aW9uczogdHJ1ZSwgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgICBlbmFibGVXZWJWVFQ6IHRydWUsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgICAgLy8jZW5kaWZcbiAgICAgIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6IGZhbHNlLCAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gICAgICBmb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5OiB0cnVlLCAvLyB1c2VkIGJ5IHRzLWRlbXV4ZXJcbiAgICAgIGFickV3bWFGYXN0TGl2ZTogMywgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgICAgYWJyRXdtYVNsb3dMaXZlOiA5LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gICAgICBhYnJFd21hRmFzdFZvRDogMywgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgICAgYWJyRXdtYVNsb3dWb0Q6IDksIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIGFickV3bWFEZWZhdWx0RXN0aW1hdGU6IDVlNSwgLy8gNTAwIGticHMgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIGFickJhbmRXaWR0aEZhY3RvcjogMC45NSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgICAgYWJyQmFuZFdpZHRoVXBGYWN0b3I6IDAuNywgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgICAgYWJyTWF4V2l0aFJlYWxCaXRyYXRlOiBmYWxzZSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgICAgbWF4U3RhcnZhdGlvbkRlbGF5OiA0LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gICAgICBtYXhMb2FkaW5nRGVsYXk6IDQsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIG1pbkF1dG9CaXRyYXRlOiAwIC8vIHVzZWQgYnkgaGxzXG59O1xuXG59LHtcIjExXCI6MTEsXCIxNFwiOjE0LFwiMTVcIjoxNSxcIjE2XCI6MTYsXCI0OFwiOjQ4LFwiNVwiOjUsXCI1NVwiOjU1LFwiNlwiOjYsXCI3XCI6NyxcIjhcIjo4LFwiOVwiOjl9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ldmVudHMgPSBfZGVyZXFfKDMzKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9ldmVudEhhbmRsZXIgPSBfZGVyZXFfKDMyKTtcblxudmFyIF9ldmVudEhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRIYW5kbGVyKTtcblxudmFyIF9idWZmZXJIZWxwZXIgPSBfZGVyZXFfKDM1KTtcblxudmFyIF9idWZmZXJIZWxwZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnVmZmVySGVscGVyKTtcblxudmFyIF9lcnJvcnMgPSBfZGVyZXFfKDMxKTtcblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxudmFyIF9ld21hQmFuZHdpZHRoRXN0aW1hdG9yID0gX2RlcmVxXygxMCk7XG5cbnZhciBfZXdtYUJhbmR3aWR0aEVzdGltYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ld21hQmFuZHdpZHRoRXN0aW1hdG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc2ltcGxlIEFCUiBDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgLSBjb21wdXRlIG5leHQgbGV2ZWwgYmFzZWQgb24gbGFzdCBmcmFnbWVudCBidyBoZXVyaXN0aWNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgLSBpbXBsZW1lbnQgYW4gYWJhbmRvbiBydWxlcyB0cmlnZ2VyZWQgaWYgd2UgaGF2ZSBsZXNzIHRoYW4gMiBmcmFnIGJ1ZmZlcmVkIGFuZCBpZiBjb21wdXRlZCBidyBzaG93cyB0aGF0IHdlIHJpc2sgYnVmZmVyIHN0YWxsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIEFickNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0V2ZW50SGFuZGxlcikge1xuICBfaW5oZXJpdHMoQWJyQ29udHJvbGxlciwgX0V2ZW50SGFuZGxlcik7XG5cbiAgZnVuY3Rpb24gQWJyQ29udHJvbGxlcihobHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJyQ29udHJvbGxlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQWJyQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEFickNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIGhscywgX2V2ZW50czIuZGVmYXVsdC5GUkFHX0xPQURJTkcsIF9ldmVudHMyLmRlZmF1bHQuRlJBR19MT0FERUQsIF9ldmVudHMyLmRlZmF1bHQuRlJBR19CVUZGRVJFRCwgX2V2ZW50czIuZGVmYXVsdC5FUlJPUikpO1xuXG4gICAgX3RoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IDA7XG4gICAgX3RoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICBfdGhpcy5obHMgPSBobHM7XG4gICAgX3RoaXMub25DaGVjayA9IF90aGlzLl9hYmFuZG9uUnVsZXNDaGVjay5iaW5kKF90aGlzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQWJyQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgX2V2ZW50SGFuZGxlcjIuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRnJhZ0xvYWRpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZyYWdMb2FkaW5nKGRhdGEpIHtcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9uQ2hlY2ssIDEwMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGF6eSBpbml0IG9mIGJ3IEVzdGltYXRvciwgcmF0aW9uYWxlIGlzIHRoYXQgd2UgdXNlIGRpZmZlcmVudCBwYXJhbXMgZm9yIExpdmUvVm9EXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gd2FpdCBmb3Igc3RyZWFtIG1hbmlmZXN0IC8gcGxheWxpc3QgdHlwZSB0byBpbnN0YW50aWF0ZSBpdC5cbiAgICAgICAgaWYgKCF0aGlzLl9id0VzdGltYXRvcikge1xuICAgICAgICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgICAgICAgbGV2ZWwgPSBkYXRhLmZyYWcubGV2ZWwsXG4gICAgICAgICAgICAgIGlzTGl2ZSA9IGhscy5sZXZlbHNbbGV2ZWxdLmRldGFpbHMubGl2ZSxcbiAgICAgICAgICAgICAgY29uZmlnID0gaGxzLmNvbmZpZyxcbiAgICAgICAgICAgICAgZXdtYUZhc3QgPSB2b2lkIDAsXG4gICAgICAgICAgICAgIGV3bWFTbG93ID0gdm9pZCAwO1xuXG4gICAgICAgICAgaWYgKGlzTGl2ZSkge1xuICAgICAgICAgICAgZXdtYUZhc3QgPSBjb25maWcuYWJyRXdtYUZhc3RMaXZlO1xuICAgICAgICAgICAgZXdtYVNsb3cgPSBjb25maWcuYWJyRXdtYVNsb3dMaXZlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBld21hRmFzdCA9IGNvbmZpZy5hYnJFd21hRmFzdFZvRDtcbiAgICAgICAgICAgIGV3bWFTbG93ID0gY29uZmlnLmFickV3bWFTbG93Vm9EO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9id0VzdGltYXRvciA9IG5ldyBfZXdtYUJhbmR3aWR0aEVzdGltYXRvcjIuZGVmYXVsdChobHMsIGV3bWFTbG93LCBld21hRmFzdCwgY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19hYmFuZG9uUnVsZXNDaGVjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hYmFuZG9uUnVsZXNDaGVjaygpIHtcbiAgICAgIC8qXG4gICAgICAgIG1vbml0b3IgZnJhZ21lbnQgcmV0cmlldmFsIHRpbWUuLi5cbiAgICAgICAgd2UgY29tcHV0ZSBleHBlY3RlZCB0aW1lIG9mIGFycml2YWwgb2YgdGhlIGNvbXBsZXRlIGZyYWdtZW50LlxuICAgICAgICB3ZSBjb21wYXJlIGl0IHRvIGV4cGVjdGVkIHRpbWUgb2YgYnVmZmVyIHN0YXJ2YXRpb25cbiAgICAgICovXG4gICAgICB2YXIgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgdiA9IGhscy5tZWRpYSxcbiAgICAgICAgICBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgICBsb2FkZXIgPSBmcmFnLmxvYWRlcixcbiAgICAgICAgICBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xuXG4gICAgICAvLyBpZiBsb2FkZXIgaGFzIGJlZW4gZGVzdHJveWVkIG9yIGxvYWRpbmcgaGFzIGJlZW4gYWJvcnRlZCwgc3RvcCB0aW1lciBhbmQgcmV0dXJuXG4gICAgICBpZiAoIWxvYWRlciB8fCBsb2FkZXIuc3RhdHMgJiYgbG9hZGVyLnN0YXRzLmFib3J0ZWQpIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignZnJhZyBsb2FkZXIgZGVzdHJveSBvciBhYm9ydGVkLCBkaXNhcm0gYWJhbmRvblJ1bGVzJyk7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc3RhdHMgPSBsb2FkZXIuc3RhdHM7XG4gICAgICAvKiBvbmx5IG1vbml0b3IgZnJhZyByZXRyaWV2YWwgdGltZSBpZlxuICAgICAgKHZpZGVvIG5vdCBwYXVzZWQgT1IgZmlyc3QgZnJhZ21lbnQgYmVpbmcgbG9hZGVkKHJlYWR5IHN0YXRlID09PSBIQVZFX05PVEhJTkcgPSAwKSkgQU5EIGF1dG9zd2l0Y2hpbmcgZW5hYmxlZCBBTkQgbm90IGxvd2VzdCBsZXZlbCAoPT4gbWVhbnMgdGhhdCB3ZSBoYXZlIHNldmVyYWwgbGV2ZWxzKSAqL1xuICAgICAgaWYgKHYgJiYgKCF2LnBhdXNlZCAmJiB2LnBsYXliYWNrUmF0ZSAhPT0gMCB8fCAhdi5yZWFkeVN0YXRlKSAmJiBmcmFnLmF1dG9MZXZlbCAmJiBmcmFnLmxldmVsKSB7XG4gICAgICAgIHZhciByZXF1ZXN0RGVsYXkgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXRzLnRyZXF1ZXN0LFxuICAgICAgICAgICAgcGxheWJhY2tSYXRlID0gTWF0aC5hYnModi5wbGF5YmFja1JhdGUpO1xuICAgICAgICAvLyBtb25pdG9yIGZyYWdtZW50IGxvYWQgcHJvZ3Jlc3MgYWZ0ZXIgaGFsZiBvZiBleHBlY3RlZCBmcmFnbWVudCBkdXJhdGlvbix0byBzdGFiaWxpemUgYml0cmF0ZVxuICAgICAgICBpZiAocmVxdWVzdERlbGF5ID4gNTAwICogZnJhZy5kdXJhdGlvbiAvIHBsYXliYWNrUmF0ZSkge1xuICAgICAgICAgIHZhciBsZXZlbHMgPSBobHMubGV2ZWxzLFxuICAgICAgICAgICAgICBsb2FkUmF0ZSA9IE1hdGgubWF4KDEsIHN0YXRzLmJ3ID8gc3RhdHMuYncgLyA4IDogc3RhdHMubG9hZGVkICogMTAwMCAvIHJlcXVlc3REZWxheSksXG4gICAgICAgICAgICAgIC8vIGJ5dGUvczsgYXQgbGVhc3QgMSBieXRlL3MgdG8gYXZvaWQgZGl2aXNpb24gYnkgemVyb1xuICAgICAgICAgIC8vIGNvbXB1dGUgZXhwZWN0ZWQgZnJhZ21lbnQgbGVuZ3RoIHVzaW5nIGZyYWcgZHVyYXRpb24gYW5kIGxldmVsIGJpdHJhdGUuIGFsc28gZW5zdXJlIHRoYXQgZXhwZWN0ZWQgbGVuIGlzIGd0ZSB0aGFuIGFscmVhZHkgbG9hZGVkIHNpemVcbiAgICAgICAgICBsZXZlbCA9IGxldmVsc1tmcmFnLmxldmVsXSxcbiAgICAgICAgICAgICAgbGV2ZWxCaXRyYXRlID0gbGV2ZWwucmVhbEJpdHJhdGUgPyBNYXRoLm1heChsZXZlbC5yZWFsQml0cmF0ZSwgbGV2ZWwuYml0cmF0ZSkgOiBsZXZlbC5iaXRyYXRlLFxuICAgICAgICAgICAgICBleHBlY3RlZExlbiA9IHN0YXRzLnRvdGFsID8gc3RhdHMudG90YWwgOiBNYXRoLm1heChzdGF0cy5sb2FkZWQsIE1hdGgucm91bmQoZnJhZy5kdXJhdGlvbiAqIGxldmVsQml0cmF0ZSAvIDgpKSxcbiAgICAgICAgICAgICAgcG9zID0gdi5jdXJyZW50VGltZSxcbiAgICAgICAgICAgICAgZnJhZ0xvYWRlZERlbGF5ID0gKGV4cGVjdGVkTGVuIC0gc3RhdHMubG9hZGVkKSAvIGxvYWRSYXRlLFxuICAgICAgICAgICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoX2J1ZmZlckhlbHBlcjIuZGVmYXVsdC5idWZmZXJJbmZvKHYsIHBvcywgaGxzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKS5lbmQgLSBwb3MpIC8gcGxheWJhY2tSYXRlO1xuICAgICAgICAgIC8vIGNvbnNpZGVyIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbmx5IGlmIHdlIGhhdmUgbGVzcyB0aGFuIDIgZnJhZyBidWZmZXJlZCBBTkRcbiAgICAgICAgICAvLyB0aW1lIHRvIGZpbmlzaCBsb2FkaW5nIGN1cnJlbnQgZnJhZ21lbnQgaXMgYmlnZ2VyIHRoYW4gYnVmZmVyIHN0YXJ2YXRpb24gZGVsYXlcbiAgICAgICAgICAvLyBpZSBpZiB3ZSByaXNrIGJ1ZmZlciBzdGFydmF0aW9uIGlmIGJ3IGRvZXMgbm90IGluY3JlYXNlIHF1aWNrbHlcbiAgICAgICAgICBpZiAoYnVmZmVyU3RhcnZhdGlvbkRlbGF5IDwgMiAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUgJiYgZnJhZ0xvYWRlZERlbGF5ID4gYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAgICAgICB2YXIgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIG5leHRMb2FkTGV2ZWwgPSB2b2lkIDA7XG4gICAgICAgICAgICAvLyBsZXRzIGl0ZXJhdGUgdGhyb3VnaCBsb3dlciBsZXZlbCBhbmQgdHJ5IHRvIGZpbmQgdGhlIGJpZ2dlc3Qgb25lIHRoYXQgY291bGQgYXZvaWQgcmVidWZmZXJpbmdcbiAgICAgICAgICAgIC8vIHdlIHN0YXJ0IGZyb20gY3VycmVudCBsZXZlbCAtIDEgYW5kIHdlIHN0ZXAgZG93biAsIHVudGlsIHdlIGZpbmQgYSBtYXRjaGluZyBsZXZlbFxuICAgICAgICAgICAgZm9yIChuZXh0TG9hZExldmVsID0gZnJhZy5sZXZlbCAtIDE7IG5leHRMb2FkTGV2ZWwgPiBtaW5BdXRvTGV2ZWw7IG5leHRMb2FkTGV2ZWwtLSkge1xuICAgICAgICAgICAgICAvLyBjb21wdXRlIHRpbWUgdG8gbG9hZCBuZXh0IGZyYWdtZW50IGF0IGxvd2VyIGxldmVsXG4gICAgICAgICAgICAgIC8vIDAuOCA6IGNvbnNpZGVyIG9ubHkgODAlIG9mIGN1cnJlbnQgYncgdG8gYmUgY29uc2VydmF0aXZlXG4gICAgICAgICAgICAgIC8vIDggPSBiaXRzIHBlciBieXRlIChicHMvQnBzKVxuICAgICAgICAgICAgICB2YXIgbGV2ZWxOZXh0Qml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsc1tuZXh0TG9hZExldmVsXS5yZWFsQml0cmF0ZSwgbGV2ZWxzW25leHRMb2FkTGV2ZWxdLmJpdHJhdGUpIDogbGV2ZWxzW25leHRMb2FkTGV2ZWxdLmJpdHJhdGU7XG4gICAgICAgICAgICAgIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IGZyYWcuZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlIC8gKDggKiAwLjggKiBsb2FkUmF0ZSk7XG4gICAgICAgICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPCBidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBmb3VuZCBhIGxvd2VyIGxldmVsIHRoYXQgYmUgcmVidWZmZXJpbmcgZnJlZSB3aXRoIGN1cnJlbnQgZXN0aW1hdGVkIGJ3ICFcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb25seSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgaXQgdGFrZXMgbGVzcyB0aW1lIHRvIGxvYWQgbmV3IGZyYWdtZW50IGF0IGxvd2VzdCBsZXZlbCBpbnN0ZWFkXG4gICAgICAgICAgICAvLyBvZiBmaW5pc2hpbmcgbG9hZGluZyBjdXJyZW50IG9uZSAuLi5cbiAgICAgICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPCBmcmFnTG9hZGVkRGVsYXkpIHtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignbG9hZGluZyB0b28gc2xvdywgYWJvcnQgZnJhZ21lbnQgbG9hZGluZyBhbmQgc3dpdGNoIHRvIGxldmVsICcgKyBuZXh0TG9hZExldmVsICsgJzpmcmFnTG9hZGVkRGVsYXlbJyArIG5leHRMb2FkTGV2ZWwgKyAnXTxmcmFnTG9hZGVkRGVsYXlbJyArIChmcmFnLmxldmVsIC0gMSkgKyAnXTtidWZmZXJTdGFydmF0aW9uRGVsYXk6JyArIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheS50b0ZpeGVkKDEpICsgJzwnICsgZnJhZ0xvYWRlZERlbGF5LnRvRml4ZWQoMSkgKyAnOicgKyBidWZmZXJTdGFydmF0aW9uRGVsYXkudG9GaXhlZCgxKSk7XG4gICAgICAgICAgICAgIC8vIGZvcmNlIG5leHQgbG9hZCBsZXZlbCBpbiBhdXRvIG1vZGVcbiAgICAgICAgICAgICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBuZXh0TG9hZExldmVsO1xuICAgICAgICAgICAgICAvLyB1cGRhdGUgYncgZXN0aW1hdGUgZm9yIHRoaXMgZnJhZ21lbnQgYmVmb3JlIGNhbmNlbGxpbmcgbG9hZCAodGhpcyB3aWxsIGhlbHAgcmVkdWNpbmcgdGhlIGJ3KVxuICAgICAgICAgICAgICB0aGlzLl9id0VzdGltYXRvci5zYW1wbGUocmVxdWVzdERlbGF5LCBzdGF0cy5sb2FkZWQpO1xuICAgICAgICAgICAgICAvL2Fib3J0IGZyYWdtZW50IGxvYWRpbmdcbiAgICAgICAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgIC8vIHN0b3AgYWJhbmRvbiBydWxlcyB0aW1lclxuICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHsgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRnJhZ0xvYWRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRnJhZ0xvYWRlZChkYXRhKSB7XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJyAmJiAhaXNOYU4oZnJhZy5zbikpIHtcbiAgICAgICAgLy8gc3RvcCBtb25pdG9yaW5nIGJ3IG9uY2UgZnJhZyBsb2FkZWRcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIC8vIHN0b3JlIGxldmVsIGlkIGFmdGVyIHN1Y2Nlc3NmdWwgZnJhZ21lbnQgbG9hZFxuICAgICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSBmcmFnLmxldmVsO1xuICAgICAgICAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuICAgICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG5cbiAgICAgICAgLy8gY29tcHV0ZSBsZXZlbCBhdmVyYWdlIGJpdHJhdGVcbiAgICAgICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5hYnJNYXhXaXRoUmVhbEJpdHJhdGUpIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICAgICAgdmFyIGxvYWRlZEJ5dGVzID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5ieXRlcyA6IDApICsgZGF0YS5zdGF0cy5sb2FkZWQ7XG4gICAgICAgICAgdmFyIGxvYWRlZER1cmF0aW9uID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZGF0YS5mcmFnLmR1cmF0aW9uO1xuICAgICAgICAgIGxldmVsLmxvYWRlZCA9IHsgYnl0ZXM6IGxvYWRlZEJ5dGVzLCBkdXJhdGlvbjogbG9hZGVkRHVyYXRpb24gfTtcbiAgICAgICAgICBsZXZlbC5yZWFsQml0cmF0ZSA9IE1hdGgucm91bmQoOCAqIGxvYWRlZEJ5dGVzIC8gbG9hZGVkRHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGZyYWdtZW50IGhhcyBiZWVuIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0LFxuICAgICAgICBpZiAoZGF0YS5mcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgICAgdmFyIHN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gc3RhdHMudGxvYWQ7XG4gICAgICAgICAgdGhpcy5vbkZyYWdCdWZmZXJlZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRnJhZ0J1ZmZlcmVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GcmFnQnVmZmVyZWQoZGF0YSkge1xuICAgICAgdmFyIHN0YXRzID0gZGF0YS5zdGF0cyxcbiAgICAgICAgICBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgLy8gb25seSB1cGRhdGUgc3RhdHMgb24gZmlyc3QgZnJhZyBidWZmZXJpbmdcbiAgICAgIC8vIGlmIHNhbWUgZnJhZyBpcyBsb2FkZWQgbXVsdGlwbGUgdGltZXMsIGl0IG1pZ2h0IGJlIGluIGJyb3dzZXIgY2FjaGUsIGFuZCBsb2FkZWQgcXVpY2tseVxuICAgICAgLy8gYW5kIGxlYWRpbmcgdG8gd3JvbmcgYncgZXN0aW1hdGlvblxuICAgICAgLy8gb24gYml0cmF0ZSB0ZXN0LCBhbHNvIG9ubHkgdXBkYXRlIHN0YXRzIG9uY2UgKGlmIHRsb2FkID0gdGJ1ZmZlcmVkID09IG9uIEZSQUdfTE9BREVEKVxuICAgICAgaWYgKHN0YXRzLmFib3J0ZWQgIT09IHRydWUgJiYgZnJhZy5sb2FkQ291bnRlciA9PT0gMSAmJiBmcmFnLnR5cGUgPT09ICdtYWluJyAmJiAhaXNOYU4oZnJhZy5zbikgJiYgKCFmcmFnLmJpdHJhdGVUZXN0IHx8IHN0YXRzLnRsb2FkID09PSBzdGF0cy50YnVmZmVyZWQpKSB7XG4gICAgICAgIC8vIHVzZSB0cGFyc2VkLXRyZXF1ZXN0IGluc3RlYWQgb2YgdGJ1ZmZlcmVkLXRyZXF1ZXN0IHRvIGNvbXB1dGUgZnJhZ0xvYWRpbmdQcm9jZXNzaW5nOyByYXRpb25hbGUgaXMgdGhhdCAgYnVmZmVyIGFwcGVuZGluZyBvbmx5IGhhcHBlbnMgb25jZSBtZWRpYSBpcyBhdHRhY2hlZFxuICAgICAgICAvLyBpbiBjYXNlIHdlIHVzZSBjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2ggd2hpbGUgbWVkaWEgaXMgbm90IGF0dGFjaGVkIHlldCwgZnJhZ21lbnQgbWlnaHQgYmUgcGFyc2VkIHdoaWxlIG1lZGlhIG5vdCBhdHRhY2hlZCB5ZXQsIGJ1dCBpdCB3aWxsIG9ubHkgYmUgYnVmZmVyZWQgb24gbWVkaWEgYXR0YWNoZWRcbiAgICAgICAgLy8gYXMgYSBjb25zZXF1ZW5jZSBpdCBjb3VsZCBoYXBwZW4gcmVhbGx5IGxhdGUgaW4gdGhlIHByb2Nlc3MuIG1lYW5pbmcgdGhhdCBhcHBlbmRpbmcgZHVyYXRpb24gbWlnaHQgYXBwZWFycyBodWdlIC4uLiBsZWFkaW5nIHRvIHVuZGVyZXN0aW1hdGVkIHRocm91Z2hwdXQgZXN0aW1hdGlvblxuICAgICAgICB2YXIgZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMgPSBzdGF0cy50cGFyc2VkIC0gc3RhdHMudHJlcXVlc3Q7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbGF0ZW5jeS9sb2FkaW5nL3BhcnNpbmcvYXBwZW5kL2ticHM6JyArIE1hdGgucm91bmQoc3RhdHMudGZpcnN0IC0gc3RhdHMudHJlcXVlc3QpICsgJy8nICsgTWF0aC5yb3VuZChzdGF0cy50bG9hZCAtIHN0YXRzLnRmaXJzdCkgKyAnLycgKyBNYXRoLnJvdW5kKHN0YXRzLnRwYXJzZWQgLSBzdGF0cy50bG9hZCkgKyAnLycgKyBNYXRoLnJvdW5kKHN0YXRzLnRidWZmZXJlZCAtIHN0YXRzLnRwYXJzZWQpICsgJy8nICsgTWF0aC5yb3VuZCg4ICogc3RhdHMubG9hZGVkIC8gKHN0YXRzLnRidWZmZXJlZCAtIHN0YXRzLnRyZXF1ZXN0KSkpO1xuICAgICAgICB0aGlzLl9id0VzdGltYXRvci5zYW1wbGUoZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMsIHN0YXRzLmxvYWRlZCk7XG4gICAgICAgIC8vIGlmIGZyYWdtZW50IGhhcyBiZWVuIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0LCAoaGxzLnN0YXJ0TGV2ZWwgPSAtMSksIHN0b3JlIGJpdHJhdGUgdGVzdCBkZWxheSBkdXJhdGlvblxuICAgICAgICBpZiAoZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zIC8gMTAwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25FcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRXJyb3IoZGF0YSkge1xuICAgICAgLy8gc3RvcCB0aW1lciBpbiBjYXNlIG9mIGZyYWcgbG9hZGluZyBlcnJvclxuICAgICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICAgIGNhc2UgX2Vycm9ycy5FcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2xlYXJUaW1lcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyVGltZXIoKSB7XG4gICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gbmV4dCBhdXRvIGxldmVsXG5cbiAgfSwge1xuICAgIGtleTogJ19maW5kQmVzdExldmVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCZXN0TGV2ZWwoY3VycmVudExldmVsLCBjdXJyZW50RnJhZ0R1cmF0aW9uLCBjdXJyZW50QncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBtYXhGZXRjaER1cmF0aW9uLCBid0ZhY3RvciwgYndVcEZhY3RvciwgbGV2ZWxzKSB7XG4gICAgICBmb3IgKHZhciBpID0gbWF4QXV0b0xldmVsOyBpID49IG1pbkF1dG9MZXZlbDsgaS0tKSB7XG4gICAgICAgIHZhciBsZXZlbEluZm8gPSBsZXZlbHNbaV0sXG4gICAgICAgICAgICBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscyxcbiAgICAgICAgICAgIGF2Z0R1cmF0aW9uID0gbGV2ZWxEZXRhaWxzID8gbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb24gLyBsZXZlbERldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA6IGN1cnJlbnRGcmFnRHVyYXRpb24sXG4gICAgICAgICAgICBsaXZlID0gbGV2ZWxEZXRhaWxzID8gbGV2ZWxEZXRhaWxzLmxpdmUgOiBmYWxzZSxcbiAgICAgICAgICAgIGFkanVzdGVkYncgPSB2b2lkIDA7XG4gICAgICAgIC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XG4gICAgICAgIC8vIGh0dHBzOi8vYW5kcm9pZC5nb29nbGVzb3VyY2UuY29tL3BsYXRmb3JtL2ZyYW1ld29ya3MvYXYvKy9tYXN0ZXIvbWVkaWEvbGlic3RhZ2VmcmlnaHQvaHR0cGxpdmUvTGl2ZVNlc3Npb24uY3BwXG4gICAgICAgIC8vIFBpY2sgdGhlIGhpZ2hlc3QgYmFuZHdpZHRoIHN0cmVhbSBiZWxvdyBvciBlcXVhbCB0byBlc3RpbWF0ZWQgYmFuZHdpZHRoLlxuICAgICAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXG4gICAgICAgIC8vIGJlIGV2ZW4gbW9yZSBjb25zZXJ2YXRpdmUgKDcwJSkgdG8gYXZvaWQgb3ZlcmVzdGltYXRpbmcgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAgIC8vIHN3aXRjaGluZyBiYWNrLlxuICAgICAgICBpZiAoaSA8PSBjdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgICBhZGp1c3RlZGJ3ID0gYndGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRqdXN0ZWRidyA9IGJ3VXBGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJpdHJhdGUgPSBsZXZlbHNbaV0ucmVhbEJpdHJhdGUgPyBNYXRoLm1heChsZXZlbHNbaV0ucmVhbEJpdHJhdGUsIGxldmVsc1tpXS5iaXRyYXRlKSA6IGxldmVsc1tpXS5iaXRyYXRlLFxuICAgICAgICAgICAgZmV0Y2hEdXJhdGlvbiA9IGJpdHJhdGUgKiBhdmdEdXJhdGlvbiAvIGFkanVzdGVkYnc7XG5cbiAgICAgICAgX2xvZ2dlci5sb2dnZXIudHJhY2UoJ2xldmVsL2FkanVzdGVkYncvYml0cmF0ZS9hdmdEdXJhdGlvbi9tYXhGZXRjaER1cmF0aW9uL2ZldGNoRHVyYXRpb246ICcgKyBpICsgJy8nICsgTWF0aC5yb3VuZChhZGp1c3RlZGJ3KSArICcvJyArIGJpdHJhdGUgKyAnLycgKyBhdmdEdXJhdGlvbiArICcvJyArIG1heEZldGNoRHVyYXRpb24gKyAnLycgKyBmZXRjaER1cmF0aW9uKTtcbiAgICAgICAgLy8gaWYgYWRqdXN0ZWQgYncgaXMgZ3JlYXRlciB0aGFuIGxldmVsIGJpdHJhdGUgQU5EXG4gICAgICAgIGlmIChhZGp1c3RlZGJ3ID4gYml0cmF0ZSAmJiAoXG4gICAgICAgIC8vIGZyYWdtZW50IGZldGNoRHVyYXRpb24gdW5rbm93biBPUiBsaXZlIHN0cmVhbSBPUiBmcmFnbWVudCBmZXRjaER1cmF0aW9uIGxlc3MgdGhhbiBtYXggYWxsb3dlZCBmZXRjaCBkdXJhdGlvbiwgdGhlbiB0aGlzIGxldmVsIG1hdGNoZXNcbiAgICAgICAgLy8gd2UgZG9uJ3QgYWNjb3VudCBmb3IgbWF4IEZldGNoIER1cmF0aW9uIGZvciBsaXZlIHN0cmVhbXMsIHRoaXMgaXMgdG8gYXZvaWQgc3dpdGNoaW5nIGRvd24gd2hlbiBuZWFyIHRoZSBlZGdlIG9mIGxpdmUgc2xpZGluZyB3aW5kb3cgLi4uXG4gICAgICAgICFmZXRjaER1cmF0aW9uIHx8IGxpdmUgfHwgZmV0Y2hEdXJhdGlvbiA8IG1heEZldGNoRHVyYXRpb24pKSB7XG4gICAgICAgICAgLy8gYXMgd2UgYXJlIGxvb3BpbmcgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCwgdGhpcyB3aWxsIHJldHVybiB0aGUgYmVzdCBhY2hpZXZhYmxlIHF1YWxpdHkgbGV2ZWxcblxuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBub3QgZW5vdWdoIHRpbWUgYnVkZ2V0IGV2ZW4gd2l0aCBxdWFsaXR5IGxldmVsIDAgLi4uIHJlYnVmZmVyaW5nIG1pZ2h0IGhhcHBlblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25leHRBdXRvTGV2ZWwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGZvcmNlZEF1dG9MZXZlbCA9IHRoaXMuX25leHRBdXRvTGV2ZWw7XG4gICAgICB2YXIgYndFc3RpbWF0b3IgPSB0aGlzLl9id0VzdGltYXRvcjtcbiAgICAgIC8vIGluIGNhc2UgbmV4dCBhdXRvIGxldmVsIGhhcyBiZWVuIGZvcmNlZCwgYW5kIGJ3IG5vdCBhdmFpbGFibGUgb3Igbm90IHJlbGlhYmxlLCByZXR1cm4gZm9yY2VkIHZhbHVlXG4gICAgICBpZiAoZm9yY2VkQXV0b0xldmVsICE9PSAtMSAmJiAoIWJ3RXN0aW1hdG9yIHx8ICFid0VzdGltYXRvci5jYW5Fc3RpbWF0ZSgpKSkge1xuICAgICAgICByZXR1cm4gZm9yY2VkQXV0b0xldmVsO1xuICAgICAgfVxuICAgICAgLy8gY29tcHV0ZSBuZXh0IGxldmVsIHVzaW5nIEFCUiBsb2dpY1xuICAgICAgdmFyIG5leHRBQlJBdXRvTGV2ZWwgPSB0aGlzLl9uZXh0QUJSQXV0b0xldmVsO1xuICAgICAgLy8gaWYgZm9yY2VkIGF1dG8gbGV2ZWwgaGFzIGJlZW4gZGVmaW5lZCwgdXNlIGl0IHRvIGNhcCBBQlIgY29tcHV0ZWQgcXVhbGl0eSBsZXZlbFxuICAgICAgaWYgKGZvcmNlZEF1dG9MZXZlbCAhPT0gLTEpIHtcbiAgICAgICAgbmV4dEFCUkF1dG9MZXZlbCA9IE1hdGgubWluKGZvcmNlZEF1dG9MZXZlbCwgbmV4dEFCUkF1dG9MZXZlbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dEFCUkF1dG9MZXZlbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5leHRMZXZlbCkge1xuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfbmV4dEFCUkF1dG9MZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgbWF4QXV0b0xldmVsID0gaGxzLm1heEF1dG9MZXZlbCxcbiAgICAgICAgICBsZXZlbHMgPSBobHMubGV2ZWxzLFxuICAgICAgICAgIGNvbmZpZyA9IGhscy5jb25maWcsXG4gICAgICAgICAgbWluQXV0b0xldmVsID0gaGxzLm1pbkF1dG9MZXZlbDtcbiAgICAgIHZhciB2ID0gaGxzLm1lZGlhLFxuICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCxcbiAgICAgICAgICBjdXJyZW50RnJhZ0R1cmF0aW9uID0gdGhpcy5mcmFnQ3VycmVudCA/IHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gOiAwLFxuICAgICAgICAgIHBvcyA9IHYgPyB2LmN1cnJlbnRUaW1lIDogMCxcblxuICAgICAgLy8gcGxheWJhY2tSYXRlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgcGxheWJhY2sgcmF0ZTsgaWYgdi5wbGF5YmFja1JhdGUgaXMgMCwgd2UgdXNlIDEgdG8gbG9hZCBhc1xuICAgICAgLy8gaWYgd2UncmUgcGxheWluZyBiYWNrIGF0IHRoZSBub3JtYWwgcmF0ZS5cbiAgICAgIHBsYXliYWNrUmF0ZSA9IHYgJiYgdi5wbGF5YmFja1JhdGUgIT09IDAgPyBNYXRoLmFicyh2LnBsYXliYWNrUmF0ZSkgOiAxLjAsXG4gICAgICAgICAgYXZnYncgPSB0aGlzLl9id0VzdGltYXRvciA/IHRoaXMuX2J3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSxcblxuICAgICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIHRoZSB3YWxsLWNsb2NrIHRpbWUgbGVmdCB1bnRpbCB0aGUgcGxheWJhY2sgYnVmZmVyIGlzIGV4aGF1c3RlZC5cbiAgICAgIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IChfYnVmZmVySGVscGVyMi5kZWZhdWx0LmJ1ZmZlckluZm8odiwgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSkuZW5kIC0gcG9zKSAvIHBsYXliYWNrUmF0ZTtcblxuICAgICAgLy8gRmlyc3QsIGxvb2sgdG8gc2VlIGlmIHdlIGNhbiBmaW5kIGEgbGV2ZWwgbWF0Y2hpbmcgd2l0aCBvdXIgYXZnIGJhbmR3aWR0aCBBTkQgdGhhdCBjb3VsZCBhbHNvIGd1YXJhbnRlZSBubyByZWJ1ZmZlcmluZyBhdCBhbGxcbiAgICAgIHZhciBiZXN0TGV2ZWwgPSB0aGlzLl9maW5kQmVzdExldmVsKGN1cnJlbnRMZXZlbCwgY3VycmVudEZyYWdEdXJhdGlvbiwgYXZnYncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXksIGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IsIGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvciwgbGV2ZWxzKTtcbiAgICAgIGlmIChiZXN0TGV2ZWwgPj0gMCkge1xuICAgICAgICByZXR1cm4gYmVzdExldmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIudHJhY2UoJ3JlYnVmZmVyaW5nIGV4cGVjdGVkIHRvIGhhcHBlbiwgbGV0cyB0cnkgdG8gZmluZCBhIHF1YWxpdHkgbGV2ZWwgbWluaW1pemluZyB0aGUgcmVidWZmZXJpbmcnKTtcbiAgICAgICAgLy8gbm90IHBvc3NpYmxlIHRvIGdldCByaWQgb2YgcmVidWZmZXJpbmcgLi4uIGxldCdzIHRyeSB0byBmaW5kIGxldmVsIHRoYXQgd2lsbCBndWFyYW50ZWUgbGVzcyB0aGFuIG1heFN0YXJ2YXRpb25EZWxheSBvZiByZWJ1ZmZlcmluZ1xuICAgICAgICAvLyBpZiBubyBtYXRjaGluZyBsZXZlbCBmb3VuZCwgbG9naWMgd2lsbCByZXR1cm4gMFxuICAgICAgICB2YXIgbWF4U3RhcnZhdGlvbkRlbGF5ID0gY3VycmVudEZyYWdEdXJhdGlvbiA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXkpIDogY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheSxcbiAgICAgICAgICAgIGJ3RmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aEZhY3RvcixcbiAgICAgICAgICAgIGJ3VXBGYWN0b3IgPSBjb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3I7XG4gICAgICAgIGlmIChidWZmZXJTdGFydmF0aW9uRGVsYXkgPT09IDApIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIGJ1ZmZlciBpcyBlbXB0eSwgbGV0J3MgY2hlY2sgaWYgcHJldmlvdXMgZnJhZ21lbnQgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0XG4gICAgICAgICAgdmFyIGJpdHJhdGVUZXN0RGVsYXkgPSB0aGlzLmJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgICAgaWYgKGJpdHJhdGVUZXN0RGVsYXkpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIHRoZSBjYXNlLCB0aGVuIHdlIG5lZWQgdG8gYWRqdXN0IG91ciBtYXggc3RhcnZhdGlvbiBkZWxheSB1c2luZyBtYXhMb2FkaW5nRGVsYXkgY29uZmlnIHZhbHVlXG4gICAgICAgICAgICAvLyBtYXggdmlkZW8gbG9hZGluZyBkZWxheSB1c2VkIGluICBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uIDpcbiAgICAgICAgICAgIC8vIGluIHRoYXQgbW9kZSBBQlIgY29udHJvbGxlciB3aWxsIGVuc3VyZSB0aGF0IHZpZGVvIGxvYWRpbmcgdGltZSAoaWUgdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZpcnN0IGZyYWdtZW50IGF0IGxvd2VzdCBxdWFsaXR5IGxldmVsICtcbiAgICAgICAgICAgIC8vIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmcmFnbWVudCBhdCB0aGUgYXBwcm9wcmlhdGUgcXVhbGl0eSBsZXZlbCBpcyBsZXNzIHRoYW4gYGBgbWF4TG9hZGluZ0RlbGF5YGBgIClcbiAgICAgICAgICAgIC8vIGNhcCBtYXhMb2FkaW5nRGVsYXkgYW5kIGVuc3VyZSBpdCBpcyBub3QgYmlnZ2VyICd0aGFuIGJpdHJhdGUgdGVzdCcgZnJhZyBkdXJhdGlvblxuICAgICAgICAgICAgdmFyIG1heExvYWRpbmdEZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4TG9hZGluZ0RlbGF5KSA6IGNvbmZpZy5tYXhMb2FkaW5nRGVsYXk7XG4gICAgICAgICAgICBtYXhTdGFydmF0aW9uRGVsYXkgPSBtYXhMb2FkaW5nRGVsYXkgLSBiaXRyYXRlVGVzdERlbGF5O1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIudHJhY2UoJ2JpdHJhdGUgdGVzdCB0b29rICcgKyBNYXRoLnJvdW5kKDEwMDAgKiBiaXRyYXRlVGVzdERlbGF5KSArICdtcywgc2V0IGZpcnN0IGZyYWdtZW50IG1heCBmZXRjaER1cmF0aW9uIHRvICcgKyBNYXRoLnJvdW5kKDEwMDAgKiBtYXhTdGFydmF0aW9uRGVsYXkpICsgJyBtcycpO1xuICAgICAgICAgICAgLy8gZG9uJ3QgdXNlIGNvbnNlcnZhdGl2ZSBmYWN0b3Igb24gYml0cmF0ZSB0ZXN0XG4gICAgICAgICAgICBid0ZhY3RvciA9IGJ3VXBGYWN0b3IgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiZXN0TGV2ZWwgPSB0aGlzLl9maW5kQmVzdExldmVsKGN1cnJlbnRMZXZlbCwgY3VycmVudEZyYWdEdXJhdGlvbiwgYXZnYncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXkgKyBtYXhTdGFydmF0aW9uRGVsYXksIGJ3RmFjdG9yLCBid1VwRmFjdG9yLCBsZXZlbHMpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoYmVzdExldmVsLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWJyQ29udHJvbGxlcjtcbn0oX2V2ZW50SGFuZGxlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFickNvbnRyb2xsZXI7XG5cbn0se1wiMTBcIjoxMCxcIjMxXCI6MzEsXCIzMlwiOjMyLFwiMzNcIjozMyxcIjM1XCI6MzUsXCI1MFwiOjUwfV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9iaW5hcnlTZWFyY2ggPSBfZGVyZXFfKDQ2KTtcblxudmFyIF9iaW5hcnlTZWFyY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmluYXJ5U2VhcmNoKTtcblxudmFyIF9idWZmZXJIZWxwZXIgPSBfZGVyZXFfKDM1KTtcblxudmFyIF9idWZmZXJIZWxwZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnVmZmVySGVscGVyKTtcblxudmFyIF9kZW11eGVyID0gX2RlcmVxXygyNSk7XG5cbnZhciBfZGVtdXhlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZW11eGVyKTtcblxudmFyIF9ldmVudHMgPSBfZGVyZXFfKDMzKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9ldmVudEhhbmRsZXIgPSBfZGVyZXFfKDMyKTtcblxudmFyIF9ldmVudEhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRIYW5kbGVyKTtcblxudmFyIF9sZXZlbEhlbHBlciA9IF9kZXJlcV8oMzYpO1xuXG52YXIgX2xldmVsSGVscGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xldmVsSGVscGVyKTtcblxudmFyIF90aW1lUmFuZ2VzID0gX2RlcmVxXyg1MSk7XG5cbnZhciBfdGltZVJhbmdlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW1lUmFuZ2VzKTtcblxudmFyIF9lcnJvcnMgPSBfZGVyZXFfKDMxKTtcblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQXVkaW8gU3RyZWFtIENvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBTdGF0ZSA9IHtcbiAgU1RPUFBFRDogJ1NUT1BQRUQnLFxuICBTVEFSVElORzogJ1NUQVJUSU5HJyxcbiAgSURMRTogJ0lETEUnLFxuICBQQVVTRUQ6ICdQQVVTRUQnLFxuICBLRVlfTE9BRElORzogJ0tFWV9MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HOiAnRlJBR19MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6ICdGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWScsXG4gIFdBSVRJTkdfVFJBQ0s6ICdXQUlUSU5HX1RSQUNLJyxcbiAgUEFSU0lORzogJ1BBUlNJTkcnLFxuICBQQVJTRUQ6ICdQQVJTRUQnLFxuICBCVUZGRVJfRkxVU0hJTkc6ICdCVUZGRVJfRkxVU0hJTkcnLFxuICBFTkRFRDogJ0VOREVEJyxcbiAgRVJST1I6ICdFUlJPUicsXG4gIFdBSVRJTkdfSU5JVF9QVFM6ICdXQUlUSU5HX0lOSVRfUFRTJ1xufTtcblxudmFyIEF1ZGlvU3RyZWFtQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfRXZlbnRIYW5kbGVyKSB7XG4gIF9pbmhlcml0cyhBdWRpb1N0cmVhbUNvbnRyb2xsZXIsIF9FdmVudEhhbmRsZXIpO1xuXG4gIGZ1bmN0aW9uIEF1ZGlvU3RyZWFtQ29udHJvbGxlcihobHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9TdHJlYW1Db250cm9sbGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChBdWRpb1N0cmVhbUNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihBdWRpb1N0cmVhbUNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIGhscywgX2V2ZW50czIuZGVmYXVsdC5NRURJQV9BVFRBQ0hFRCwgX2V2ZW50czIuZGVmYXVsdC5NRURJQV9ERVRBQ0hJTkcsIF9ldmVudHMyLmRlZmF1bHQuQVVESU9fVFJBQ0tTX1VQREFURUQsIF9ldmVudHMyLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENISU5HLCBfZXZlbnRzMi5kZWZhdWx0LkFVRElPX1RSQUNLX0xPQURFRCwgX2V2ZW50czIuZGVmYXVsdC5LRVlfTE9BREVELCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfTE9BREVELCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTSU5HX0RBVEEsIF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTRUQsIF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0NSRUFURUQsIF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0FQUEVOREVELCBfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9GTFVTSEVELCBfZXZlbnRzMi5kZWZhdWx0LklOSVRfUFRTX0ZPVU5EKSk7XG5cbiAgICBfdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIF90aGlzLmF1ZGlvQ29kZWNTd2FwID0gZmFsc2U7XG4gICAgX3RoaXMudGlja3MgPSAwO1xuICAgIF90aGlzLl9zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgX3RoaXMub250aWNrID0gX3RoaXMudGljay5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5pbml0UFRTID0gW107XG4gICAgX3RoaXMud2FpdGluZ0ZyYWdtZW50ID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQXVkaW9TdHJlYW1Db250cm9sbGVyLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICBfZXZlbnRIYW5kbGVyMi5kZWZhdWx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG5cbiAgICAvL1NpZ25hbCB0aGF0IHZpZGVvIFBUUyB3YXMgZm91bmRcblxuICB9LCB7XG4gICAga2V5OiAnb25Jbml0UHRzRm91bmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkluaXRQdHNGb3VuZChkYXRhKSB7XG4gICAgICB2YXIgZGVtdXhlcklkID0gZGF0YS5pZCxcbiAgICAgICAgICBjYyA9IGRhdGEuZnJhZy5jYyxcbiAgICAgICAgICBpbml0UFRTID0gZGF0YS5pbml0UFRTO1xuICAgICAgaWYgKGRlbXV4ZXJJZCA9PT0gJ21haW4nKSB7XG4gICAgICAgIC8vQWx3YXlzIHVwZGF0ZSB0aGUgbmV3IElOSVQgUFRTXG4gICAgICAgIC8vQ2FuIGNoYW5nZSBkdWUgbGV2ZWwgc3dpdGNoXG4gICAgICAgIHRoaXMuaW5pdFBUU1tjY10gPSBpbml0UFRTO1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ0luaXRQVFMgZm9yIGNjOicgKyBjYyArICcgZm91bmQgZnJvbSB2aWRlbyB0cmFjazonICsgaW5pdFBUUyk7XG5cbiAgICAgICAgLy9JZiB3ZSBhcmUgd2FpdGluZyB3ZSBuZWVkIHRvIGRlbXV4L3JlbXV4IHRoZSB3YWl0aW5nIGZyYWdcbiAgICAgICAgLy9XaXRoIHRoZSBuZXcgaW5pdFBUU1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19JTklUX1BUUykge1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc2VuZGluZyBwZW5kaW5nIGF1ZGlvIGZyYWcgdG8gZGVtdXhlcicpO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgLy9XZSBoYXZlIGF1ZGlvIGZyYWcgd2FpdGluZyBvciB2aWRlbyBwdHNcbiAgICAgICAgICAvL0xldCBwcm9jZXNzIGl0XG4gICAgICAgICAgdGhpcy5vbkZyYWdMb2FkZWQodGhpcy53YWl0aW5nRnJhZ21lbnQpO1xuICAgICAgICAgIC8vTGV0cyBjbGVhbiB0aGUgd2FpdGluZyBmcmFnXG4gICAgICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RhcnRMb2FkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICAgIGlmICh0aGlzLnRyYWNrcykge1xuICAgICAgICB2YXIgbGFzdEN1cnJlbnRUaW1lID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICAgIGlmIChsYXN0Q3VycmVudFRpbWUgPiAwICYmIHN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdhdWRpbzpvdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAnICsgbGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMykpO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uID8gdGhpcy5zdGFydFBvc2l0aW9uIDogc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RBUlRJTkc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RvcExvYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wTG9hZCgpIHtcbiAgICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIGlmIChmcmFnLmxvYWRlcikge1xuICAgICAgICAgIGZyYWcubG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0aWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGljaygpIHtcbiAgICAgIHRoaXMudGlja3MrKztcbiAgICAgIGlmICh0aGlzLnRpY2tzID09PSAxKSB7XG4gICAgICAgIHRoaXMuZG9UaWNrKCk7XG4gICAgICAgIGlmICh0aGlzLnRpY2tzID4gMSkge1xuICAgICAgICAgIHNldFRpbWVvdXQodGhpcy50aWNrLCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpY2tzID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkb1RpY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb1RpY2soKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHBvcyxcbiAgICAgICAgICB0cmFjayxcbiAgICAgICAgICB0cmFja0RldGFpbHMsXG4gICAgICAgICAgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAgIC8vbG9nZ2VyLmxvZygnYXVkaW9TdHJlYW06JyArIHRoaXMuc3RhdGUpO1xuICAgICAgdmFyIG5vdztcbiAgICAgIHZhciByZXRyeURhdGU7XG4gICAgICB2YXIgaXNTZWVraW5nO1xuXG4gICAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoIChfdGhpczIuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlIFN0YXRlLkVSUk9SOlxuICAgICAgICAgIC8vZG9uJ3QgZG8gYW55dGhpbmcgaW4gZXJyb3Igc3RhdGUgdG8gYXZvaWQgYnJlYWtpbmcgZnVydGhlciAuLi5cbiAgICAgICAgICBjYXNlIFN0YXRlLlBBVVNFRDpcbiAgICAgICAgICAvL2Rvbid0IGRvIGFueXRoaW5nIGluIHBhdXNlZCBzdGF0ZSBlaXRoZXIgLi4uXG4gICAgICAgICAgY2FzZSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFN0YXRlLlNUQVJUSU5HOlxuICAgICAgICAgICAgX3RoaXMyLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgICAgICAgIF90aGlzMi5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBTdGF0ZS5JRExFOlxuICAgICAgICAgICAgdmFyIHRyYWNrcyA9IF90aGlzMi50cmFja3M7XG4gICAgICAgICAgICAvLyBhdWRpbyB0cmFja3Mgbm90IHJlY2VpdmVkID0+IGV4aXQgbG9vcFxuICAgICAgICAgICAgaWYgKCF0cmFja3MpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EXG4gICAgICAgICAgICAvLyBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIGRpc2FibGVcbiAgICAgICAgICAgIC8vIGV4aXQgbG9vcFxuICAgICAgICAgICAgLy8gPT4gaWYgbWVkaWEgbm90IGF0dGFjaGVkIGJ1dCBzdGFydCBmcmFnIHByZWZldGNoIGlzIGVuYWJsZWQgYW5kIHN0YXJ0IGZyYWcgbm90IHJlcXVlc3RlZCB5ZXQsIHdlIHdpbGwgbm90IGV4aXQgbG9vcFxuICAgICAgICAgICAgaWYgKCFfdGhpczIubWVkaWEgJiYgKF90aGlzMi5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgbmV4dCBjYW5kaWRhdGUgZnJhZ21lbnQgdG8gYmUgbG9hZGVkLCBiYXNlZCBvbiBjdXJyZW50IHBvc2l0aW9uIGFuZFxuICAgICAgICAgICAgLy8gIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChfdGhpczIubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgcG9zID0gX3RoaXMyLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zID0gX3RoaXMyLm5leHRMb2FkUG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWVkaWEgPSBfdGhpczIubWVkaWFCdWZmZXIgPyBfdGhpczIubWVkaWFCdWZmZXIgOiBfdGhpczIubWVkaWEsXG4gICAgICAgICAgICAgICAgYnVmZmVySW5mbyA9IF9idWZmZXJIZWxwZXIyLmRlZmF1bHQuYnVmZmVySW5mbyhtZWRpYSwgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSksXG4gICAgICAgICAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW4sXG4gICAgICAgICAgICAgICAgYnVmZmVyRW5kID0gYnVmZmVySW5mby5lbmQsXG4gICAgICAgICAgICAgICAgZnJhZ1ByZXZpb3VzID0gX3RoaXMyLmZyYWdQcmV2aW91cyxcbiAgICAgICAgICAgICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoLFxuICAgICAgICAgICAgICAgIGF1ZGlvU3dpdGNoID0gX3RoaXMyLmF1ZGlvU3dpdGNoLFxuICAgICAgICAgICAgICAgIHRyYWNrSWQgPSBfdGhpczIudHJhY2tJZDtcblxuICAgICAgICAgICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50XG4gICAgICAgICAgICBpZiAoYnVmZmVyTGVuIDwgbWF4QnVmTGVuICYmIHRyYWNrSWQgPCB0cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRyYWNrRGV0YWlscyA9IHRyYWNrc1t0cmFja0lkXS5kZXRhaWxzO1xuICAgICAgICAgICAgICAvLyBpZiB0cmFjayBpbmZvIG5vdCByZXRyaWV2ZWQgeWV0LCBzd2l0Y2ggc3RhdGUgYW5kIHdhaXQgZm9yIHRyYWNrIHJldHJpZXZhbFxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyYWNrRGV0YWlscyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBfdGhpczIuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX1RSQUNLO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gd2UganVzdCBnb3QgZG9uZSBsb2FkaW5nIHRoZSBmaW5hbCBmcmFnbWVudCwgY2hlY2sgaWYgd2UgbmVlZCB0byBmaW5hbGl6ZSBtZWRpYSBzdHJlYW1cbiAgICAgICAgICAgICAgaWYgKCFhdWRpb1N3aXRjaCAmJiAhdHJhY2tEZXRhaWxzLmxpdmUgJiYgZnJhZ1ByZXZpb3VzICYmIGZyYWdQcmV2aW91cy5zbiA9PT0gdHJhY2tEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBzZWVraW5nIG9yIGlmIHdlIGFyZSBzZWVraW5nIGJ1dCBldmVyeXRoaW5nIChhbG1vc3QpIHRpbCB0aGUgZW5kIGlzIGJ1ZmZlcmVkLCBsZXQncyBzaWduYWwgZW9zXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgY29tcGFyZSBleGFjdGx5IG1lZGlhLmR1cmF0aW9uID09PSBidWZmZXJJbmZvLmVuZCBhcyB0aGVyZSBjb3VsZCBiZSBzb21lIHN1YnRsZSBtZWRpYSBkdXJhdGlvbiBkaWZmZXJlbmNlIHdoZW4gc3dpdGNoaW5nXG4gICAgICAgICAgICAgICAgLy8gYmV0d2VlbiBkaWZmZXJlbnQgcmVuZGl0aW9ucy4gdXNpbmcgaGFsZiBmcmFnIGR1cmF0aW9uIHNob3VsZCBoZWxwIGNvcGUgd2l0aCB0aGVzZSBjYXNlcy5cbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzMi5tZWRpYS5zZWVraW5nIHx8IF90aGlzMi5tZWRpYS5kdXJhdGlvbiAtIGJ1ZmZlckVuZCA8IGZyYWdQcmV2aW91cy5kdXJhdGlvbiAvIDIpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEZpbmFsaXplIHRoZSBtZWRpYSBzdHJlYW1cbiAgICAgICAgICAgICAgICAgIF90aGlzMi5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9FT1MsIHsgdHlwZTogJ2F1ZGlvJyB9KTtcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgICAgICAgICAgdmFyIGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgICAgICAgICAgICBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICBmcmFnID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgIC8vIFdoZW4gc3dpdGNoaW5nIGF1ZGlvIHRyYWNrLCByZWxvYWQgYXVkaW8gYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gY3VycmVudFRpbWVcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5saXZlICYmICF0cmFja0RldGFpbHMuUFRTS25vd24pIHtcbiAgICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc3dpdGNoaW5nIGF1ZGlvdHJhY2ssIGxpdmUgc3RyZWFtLCB1bmtub3duIFBUUyxsb2FkIGZpcnN0IGZyYWdtZW50Jyk7XG4gICAgICAgICAgICAgICAgICBidWZmZXJFbmQgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBidWZmZXJFbmQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAvLyBpZiBjdXJyZW50VGltZSAocG9zKSBpcyBsZXNzIHRoYW4gYWx0IGF1ZGlvIHBsYXlsaXN0IHN0YXJ0IHRpbWUsIGl0IG1lYW5zIHRoYXQgYWx0IGF1ZGlvIGlzIGFoZWFkIG9mIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgICBpZiAodHJhY2tEZXRhaWxzLlBUU0tub3duICYmIHBvcyA8IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGV2ZXJ5dGhpbmcgaXMgYnVmZmVyZWQgZnJvbSBwb3MgdG8gc3RhcnQgb3IgaWYgYXVkaW8gYnVmZmVyIHVwZnJvbnQsIGxldCdzIHNlZWsgdG8gc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlckluZm8uZW5kID4gc3RhcnQgfHwgYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2FsdCBhdWRpbyB0cmFjayBhaGVhZCBvZiBtYWluIHRyYWNrLCBzZWVrIHRvIHN0YXJ0IG9mIGFsdCBhdWRpbyB0cmFjaycpO1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5tZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0ICsgMC4wNTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdjogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHJhY2tEZXRhaWxzLmluaXRTZWdtZW50ICYmICF0cmFja0RldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSkge1xuICAgICAgICAgICAgICAgIGZyYWcgPSB0cmFja0RldGFpbHMuaW5pdFNlZ21lbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gaWYgYnVmZmVyRW5kIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgICAgICAgICBlbHNlIGlmIChidWZmZXJFbmQgPD0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgICAgICAgICBpZiAodHJhY2tEZXRhaWxzLmxpdmUgJiYgZnJhZy5sb2FkSWR4ICYmIGZyYWcubG9hZElkeCA9PT0gX3RoaXMyLmZyYWdMb2FkSWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGp1c3QgbG9hZGVkIHRoaXMgZmlyc3QgZnJhZ21lbnQsIGFuZCB3ZSBhcmUgc3RpbGwgbGFnZ2luZyBiZWhpbmQgdGhlIHN0YXJ0IG9mIHRoZSBsaXZlIHBsYXlsaXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIGZvcmNlIHNlZWsgdG8gc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRCdWZmZXJlZCA9IGJ1ZmZlckluZm8ubmV4dFN0YXJ0ID8gYnVmZmVySW5mby5uZXh0U3RhcnQgOiBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdubyBhbHQgYXVkaW8gYXZhaWxhYmxlIEBjdXJyZW50VGltZTonICsgX3RoaXMyLm1lZGlhLmN1cnJlbnRUaW1lICsgJywgc2Vla2luZyBAJyArIChuZXh0QnVmZmVyZWQgKyAwLjA1KSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMi5tZWRpYS5jdXJyZW50VGltZSA9IG5leHRCdWZmZXJlZCArIDAuMDU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdjogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZEZyYWcgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFnTmV4dCA9IGZyYWdQcmV2aW91cyA/IGZyYWdtZW50c1tmcmFnUHJldmlvdXMuc24gLSBmcmFnbWVudHNbMF0uc24gKyAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCA9IGZ1bmN0aW9uIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQgc2hvdWxkIGJlIHdpdGhpbiBmcmFnbWVudCBib3VuZGFyeSAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgICAgICAgICAgICAgICAgICAgICAvLyBmcmFnW8OYXSA6IFswLDEwXVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGZyYWdbMV0gOiBbMTAsMjBdXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICBmcmFnIHN0YXJ0ICAgICAgICAgICAgICAgZnJhZyBzdGFydCtkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAgICAgICAgICAgICAgICAgICAgIC8vICAuLi4tLS0tLS0tLT48LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+PC0tLS0tLS0tLS4uLi5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcbiAgICAgICAgICAgICAgICAgICAgICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgbGV2ZWwvc24vc3RhcnQvZW5kL2J1ZkVuZDoke2xldmVsfS8ke2NhbmRpZGF0ZS5zbn0vJHtjYW5kaWRhdGUuc3RhcnR9LyR7KGNhbmRpZGF0ZS5zdGFydCtjYW5kaWRhdGUuZHVyYXRpb24pfS8ke2J1ZmZlckVuZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPD0gYnVmZmVyRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICB9IC8vIGlmIG1heEZyYWdMb29rVXBUb2xlcmFuY2Ugd2lsbCBoYXZlIG5lZ2F0aXZlIHZhbHVlIHRoZW4gZG9uJ3QgcmV0dXJuIC0xIGZvciBmaXJzdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXJFbmQgPiBlbmQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgLy8gUHJlZmVyIHRoZSBuZXh0IGZyYWdtZW50IGlmIGl0J3Mgd2l0aGluIHRvbGVyYW5jZVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnTmV4dCAmJiAhZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGZyYWdOZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnID0gZnJhZ05leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZyA9IF9iaW5hcnlTZWFyY2gyLmRlZmF1bHQuc2VhcmNoKGZyYWdtZW50cywgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRGcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IGZvdW5kRnJhZztcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGZvdW5kRnJhZy5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coJ2ZpbmQgU04gbWF0Y2hpbmcgd2l0aCBwb3M6JyArICBidWZmZXJFbmQgKyAnOicgKyBmcmFnLnNuKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbCAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLnNuIDwgdHJhY2tEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbZnJhZy5zbiArIDEgLSB0cmFja0RldGFpbHMuc3RhcnRTTl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnU04ganVzdCBsb2FkZWQsIGxvYWQgbmV4dCBvbmU6ICcgKyBmcmFnLnNuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICAgICAgLy9sb2dnZXIubG9nKCcgICAgICBsb2FkaW5nIGZyYWcgJyArIGkgKycscG9zL2J1ZkVuZDonICsgcG9zLnRvRml4ZWQoMykgKyAnLycgKyBidWZmZXJFbmQudG9GaXhlZCgzKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyYWcuZGVjcnlwdGRhdGEgJiYgZnJhZy5kZWNyeXB0ZGF0YS51cmkgIT0gbnVsbCAmJiBmcmFnLmRlY3J5cHRkYXRhLmtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ0xvYWRpbmcga2V5IGZvciAnICsgZnJhZy5zbiArICcgb2YgWycgKyB0cmFja0RldGFpbHMuc3RhcnRTTiArICcgLCcgKyB0cmFja0RldGFpbHMuZW5kU04gKyAnXSx0cmFjayAnICsgdHJhY2tJZCk7XG4gICAgICAgICAgICAgICAgICBfdGhpczIuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuS0VZX0xPQURJTkcsIHsgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdMb2FkaW5nICcgKyBmcmFnLnNuICsgJyBvZiBbJyArIHRyYWNrRGV0YWlscy5zdGFydFNOICsgJyAsJyArIHRyYWNrRGV0YWlscy5lbmRTTiArICddLHRyYWNrICcgKyB0cmFja0lkICsgJywgY3VycmVudFRpbWU6JyArIHBvcyArICcsYnVmZmVyRW5kOicgKyBidWZmZXJFbmQudG9GaXhlZCgzKSk7XG4gICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB3ZSBhcmUgbm90IHJlbG9hZGluZyB0aGUgc2FtZSBmcmFnbWVudHMgaW4gbG9vcCAuLi5cbiAgICAgICAgICAgICAgICAgIGlmIChfdGhpczIuZnJhZ0xvYWRJZHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIuZnJhZ0xvYWRJZHgrKztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMi5mcmFnTG9hZElkeCA9IDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZnJhZy5sb2FkQ291bnRlcikge1xuICAgICAgICAgICAgICAgICAgICBmcmFnLmxvYWRDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhUaHJlc2hvbGQgPSBjb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGZyYWcgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQgMyB0aW1lcywgYW5kIGlmIGl0IGhhcyBiZWVuIHJlbG9hZGVkIHJlY2VudGx5XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmxvYWRDb3VudGVyID4gbWF4VGhyZXNob2xkICYmIE1hdGguYWJzKF90aGlzMi5mcmFnTG9hZElkeCAtIGZyYWcubG9hZElkeCkgPCBtYXhUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdjogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlciA9IDE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmcmFnLmxvYWRJZHggPSBfdGhpczIuZnJhZ0xvYWRJZHg7XG4gICAgICAgICAgICAgICAgICBfdGhpczIuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgICAgICAgICAgICAgX3RoaXMyLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGZyYWcuc24pKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMi5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfTE9BRElORywgeyBmcmFnOiBmcmFnIH0pO1xuICAgICAgICAgICAgICAgICAgX3RoaXMyLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX1RSQUNLOlxuICAgICAgICAgICAgdHJhY2sgPSBfdGhpczIudHJhY2tzW190aGlzMi50cmFja0lkXTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgICAgICBpZiAodHJhY2sgJiYgdHJhY2suZGV0YWlscykge1xuICAgICAgICAgICAgICBfdGhpczIuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgICAgICAgIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgcmV0cnlEYXRlID0gX3RoaXMyLnJldHJ5RGF0ZTtcblxuICAgICAgICAgICAgbWVkaWEgPSBfdGhpczIubWVkaWE7XG4gICAgICAgICAgICBpc1NlZWtpbmcgPSBtZWRpYSAmJiBtZWRpYS5zZWVraW5nO1xuICAgICAgICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcblxuICAgICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgbm93ID49IHJldHJ5RGF0ZSB8fCBpc1NlZWtpbmcpIHtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IHJldHJ5RGF0ZSByZWFjaGVkLCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlJyk7XG4gICAgICAgICAgICAgIF90aGlzMi5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFN0YXRlLldBSVRJTkdfSU5JVF9QVFM6XG4gICAgICAgICAgY2FzZSBTdGF0ZS5TVE9QUEVEOlxuICAgICAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxuICAgICAgICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcbiAgICAgICAgICBjYXNlIFN0YXRlLlBBUlNFRDpcbiAgICAgICAgICBjYXNlIFN0YXRlLkVOREVEOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KCk7XG5cbiAgICAgIGlmICgodHlwZW9mIF9yZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKF9yZXQpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1lZGlhQXR0YWNoZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoZWQoZGF0YSkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xuICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyk7XG4gICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICBpZiAodGhpcy50cmFja3MgJiYgY29uZmlnLmF1dG9TdGFydExvYWQpIHtcbiAgICAgICAgdGhpcy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWVkaWFEZXRhY2hpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5lbmRlZCkge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzZXQgZnJhZ21lbnQgbG9hZGluZyBjb3VudGVyIG9uIE1TRSBkZXRhY2hpbmcgdG8gYXZvaWQgcmVwb3J0aW5nIEZSQUdfTE9PUF9MT0FESU5HX0VSUk9SIGFmdGVyIGVycm9yIHJlY292ZXJ5XG4gICAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgICBpZiAodHJhY2tzKSB7XG4gICAgICAgIC8vIHJlc2V0IGZyYWdtZW50IGxvYWQgY291bnRlclxuICAgICAgICB0cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICBpZiAodHJhY2suZGV0YWlscykge1xuICAgICAgICAgICAgdHJhY2suZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgZnJhZ21lbnQubG9hZENvdW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9udnNlZWtlZCA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWVkaWFTZWVraW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZWRpYVNlZWtpbmcoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gY2hlY2sgZm9yIHBvdGVudGlhbCBuZXcgZnJhZ21lbnRcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMubWVkaWEuY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICAvLyBhdm9pZCByZXBvcnRpbmcgZnJhZ21lbnQgbG9vcCBsb2FkaW5nIGVycm9yIGluIGNhc2UgdXNlciBpcyBzZWVraW5nIHNldmVyYWwgdGltZXMgb24gc2FtZSBwb3NpdGlvblxuICAgICAgaWYgKHRoaXMuZnJhZ0xvYWRJZHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIHByb2Nlc3NpbmdcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWVkaWFFbmRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVkaWFFbmRlZCgpIHtcbiAgICAgIC8vIHJlc2V0IHN0YXJ0UG9zaXRpb24gYW5kIGxhc3RDdXJyZW50VGltZSB0byByZXN0YXJ0IHBsYXliYWNrIEAgc3RyZWFtIGJlZ2lubmluZ1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQXVkaW9UcmFja3NVcGRhdGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25BdWRpb1RyYWNrc1VwZGF0ZWQoZGF0YSkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdhdWRpbyB0cmFja3MgdXBkYXRlZCcpO1xuICAgICAgdGhpcy50cmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQXVkaW9UcmFja1N3aXRjaGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQXVkaW9UcmFja1N3aXRjaGluZyhkYXRhKSB7XG4gICAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgICB2YXIgYWx0QXVkaW8gPSAhIWRhdGEudXJsO1xuICAgICAgdGhpcy50cmFja0lkID0gZGF0YS5pZDtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuXG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVVTRUQ7XG4gICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XG4gICAgICAvLyBkZXN0cm95IHVzZWxlc3MgZGVtdXhlciB3aGVuIHN3aXRjaGluZyBhdWRpbyB0byBtYWluXG4gICAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN3aXRjaGluZyB0byBhdWRpbyB0cmFjaywgc3RhcnQgdGltZXIgaWYgbm90IGFscmVhZHkgc3RhcnRlZFxuICAgICAgICBpZiAoIXRoaXMudGltZXIpIHtcbiAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbnRpY2ssIDEwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9zaG91bGQgd2Ugc3dpdGNoIHRyYWNrcyA/XG4gICAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IHRydWU7XG4gICAgICAgIC8vbWFpbiBhdWRpbyB0cmFjayBhcmUgaGFuZGxlZCBieSBzdHJlYW0tY29udHJvbGxlciwganVzdCBkbyBzb21ldGhpbmcgaWYgc3dpdGNoaW5nIHRvIGFsdCBhdWRpbyB0cmFja1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcbiAgICAgICAgaWYgKHRoaXMuZnJhZ0xvYWRJZHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25BdWRpb1RyYWNrTG9hZGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25BdWRpb1RyYWNrTG9hZGVkKGRhdGEpIHtcbiAgICAgIHZhciBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzLFxuICAgICAgICAgIHRyYWNrSWQgPSBkYXRhLmlkLFxuICAgICAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tJZF0sXG4gICAgICAgICAgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24sXG4gICAgICAgICAgc2xpZGluZyA9IDA7XG5cbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygndHJhY2sgJyArIHRyYWNrSWQgKyAnIGxvYWRlZCBbJyArIG5ld0RldGFpbHMuc3RhcnRTTiArICcsJyArIG5ld0RldGFpbHMuZW5kU04gKyAnXSxkdXJhdGlvbjonICsgZHVyYXRpb24pO1xuXG4gICAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICAgIHZhciBjdXJEZXRhaWxzID0gdHJhY2suZGV0YWlscztcbiAgICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIHdlIGFscmVhZHkgaGF2ZSBkZXRhaWxzIGZvciB0aGF0IGxldmVsLCBtZXJnZSB0aGVtXG4gICAgICAgICAgX2xldmVsSGVscGVyMi5kZWZhdWx0Lm1lcmdlRGV0YWlscyhjdXJEZXRhaWxzLCBuZXdEZXRhaWxzKTtcbiAgICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgIC8vdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGN1ckRldGFpbHMpO1xuICAgICAgICAgIGlmIChuZXdEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3Qgc2xpZGluZzonICsgc2xpZGluZy50b0ZpeGVkKDMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdsaXZlIGF1ZGlvIHBsYXlsaXN0IC0gb3V0ZGF0ZWQgUFRTLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbGl2ZSBhdWRpbyBwbGF5bGlzdCAtIGZpcnN0IGxvYWQsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0cmFjay5kZXRhaWxzID0gbmV3RGV0YWlscztcblxuICAgICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvblxuICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHNldCB0byAtMS4gdXNlIGl0IHN0cmFpZ2h0IGF3YXkgaWYgdmFsdWUgaXMgZGVmaW5lZFxuICAgICAgICBpZiAodGhpcy5zdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgICAgICB2YXIgc3RhcnRUaW1lT2Zmc2V0ID0gbmV3RGV0YWlscy5zdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgaWYgKCFpc05hTihzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3N0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAnICsgc3RhcnRUaW1lT2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgLy8gb25seSBzd2l0Y2ggYmF0Y2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIHRyYWNrIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19UUkFDSykge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25LZXlMb2FkZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbktleUxvYWRlZCgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5LRVlfTE9BRElORykge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GcmFnTG9hZGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GcmFnTG9hZGVkKGRhdGEpIHtcbiAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQsXG4gICAgICAgICAgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgJiYgZnJhZ0N1cnJlbnQgJiYgZnJhZ0xvYWRlZC50eXBlID09PSAnYXVkaW8nICYmIGZyYWdMb2FkZWQubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmIGZyYWdMb2FkZWQuc24gPT09IGZyYWdDdXJyZW50LnNuKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF0sXG4gICAgICAgICAgICBkZXRhaWxzID0gdHJhY2suZGV0YWlscyxcbiAgICAgICAgICAgIGR1cmF0aW9uID0gZGV0YWlscy50b3RhbGR1cmF0aW9uLFxuICAgICAgICAgICAgdHJhY2tJZCA9IGZyYWdDdXJyZW50LmxldmVsLFxuICAgICAgICAgICAgc24gPSBmcmFnQ3VycmVudC5zbixcbiAgICAgICAgICAgIGNjID0gZnJhZ0N1cnJlbnQuY2MsXG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgdHJhY2suYXVkaW9Db2RlYyB8fCAnbXA0YS40MC4yJyxcbiAgICAgICAgICAgIHN0YXRzID0gdGhpcy5zdGF0cyA9IGRhdGEuc3RhdHM7XG4gICAgICAgIGlmIChzbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuXG4gICAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA9IGRhdGEucGF5bG9hZDtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlJBR19CVUZGRVJFRCwgeyBzdGF0czogc3RhdHMsIGZyYWc6IGZyYWdDdXJyZW50LCBpZDogJ2F1ZGlvJyB9KTtcbiAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgICAgICAvLyB0cmFuc211eCB0aGUgTVBFRy1UUyBkYXRhIHRvIElTTy1CTUZGIHNlZ21lbnRzXG4gICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmICghdGhpcy5kZW11eGVyKSB7XG4gICAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgX2RlbXV4ZXIyLmRlZmF1bHQodGhpcy5obHMsICdhdWRpbycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL0NoZWNrIGlmIHdlIGhhdmUgdmlkZW8gaW5pdFBUU1xuICAgICAgICAgIC8vIElmIG5vdCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0XG4gICAgICAgICAgdmFyIGluaXRQVFMgPSB0aGlzLmluaXRQVFNbY2NdO1xuICAgICAgICAgIHZhciBpbml0U2VnbWVudERhdGEgPSBkZXRhaWxzLmluaXRTZWdtZW50ID8gZGV0YWlscy5pbml0U2VnbWVudC5kYXRhIDogW107XG4gICAgICAgICAgaWYgKGluaXRTZWdtZW50RGF0YSB8fCBpbml0UFRTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ0RlbXV4aW5nICcgKyBzbiArICcgb2YgWycgKyBkZXRhaWxzLnN0YXJ0U04gKyAnICwnICsgZGV0YWlscy5lbmRTTiArICddLHRyYWNrICcgKyB0cmFja0lkKTtcbiAgICAgICAgICAgIC8vIHRpbWUgT2Zmc2V0IGlzIGFjY3VyYXRlIGlmIGxldmVsIFBUUyBpcyBrbm93biwgb3IgaWYgcGxheWxpc3QgaXMgbm90IHNsaWRpbmcgKG5vdCBsaXZlKVxuICAgICAgICAgICAgdmFyIGFjY3VyYXRlVGltZU9mZnNldCA9IGZhbHNlOyAvL2RldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZTtcbiAgICAgICAgICAgIHRoaXMuZGVtdXhlci5wdXNoKGRhdGEucGF5bG9hZCwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCBudWxsLCBmcmFnQ3VycmVudCwgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgaW5pdFBUUyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygndW5rbm93biB2aWRlbyBQVFMgZm9yIGNvbnRpbnVpdHkgY291bnRlciAnICsgY2MgKyAnLCB3YWl0aW5nIGZvciB2aWRlbyBQVFMgYmVmb3JlIGRlbXV4aW5nIGF1ZGlvIGZyYWcgJyArIHNuICsgJyBvZiBbJyArIGRldGFpbHMuc3RhcnRTTiArICcgLCcgKyBkZXRhaWxzLmVuZFNOICsgJ10sdHJhY2sgJyArIHRyYWNrSWQpO1xuICAgICAgICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRnJhZ1BhcnNpbmdJbml0U2VnbWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRnJhZ1BhcnNpbmdJbml0U2VnbWVudChkYXRhKSB7XG4gICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgdmFyIGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZGF0YS5pZCA9PT0gJ2F1ZGlvJyAmJiBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJiBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgIHZhciB0cmFja3MgPSBkYXRhLnRyYWNrcyxcbiAgICAgICAgICAgIHRyYWNrID0gdm9pZCAwO1xuXG4gICAgICAgIC8vIGRlbGV0ZSBhbnkgdmlkZW8gdHJhY2sgZm91bmQgb24gYXVkaW8gZGVtdXhlclxuICAgICAgICBpZiAodHJhY2tzLnZpZGVvKSB7XG4gICAgICAgICAgZGVsZXRlIHRyYWNrcy52aWRlbztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgICAgIHRyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfQ09ERUNTLCB0cmFja3MpO1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnYXVkaW8gdHJhY2s6YXVkaW8sY29udGFpbmVyOicgKyB0cmFjay5jb250YWluZXIgKyAnLGNvZGVjc1tsZXZlbC9wYXJzZWRdPVsnICsgdHJhY2subGV2ZWxDb2RlYyArICcvJyArIHRyYWNrLmNvZGVjICsgJ10nKTtcbiAgICAgICAgICB2YXIgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgICAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgICAgICAgIHZhciBhcHBlbmRPYmogPSB7IHR5cGU6ICdhdWRpbycsIGRhdGE6IGluaXRTZWdtZW50LCBwYXJlbnQ6ICdhdWRpbycsIGNvbnRlbnQ6ICdpbml0U2VnbWVudCcgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoKSB7XG4gICAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGEgPSBbYXBwZW5kT2JqXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBhcm0gcGVuZGluZyBCdWZmZXJpbmcgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIGEgc2VnbWVudFxuICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0FQUEVORElORywgYXBwZW5kT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZyYWdQYXJzaW5nRGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRnJhZ1BhcnNpbmdEYXRhKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgdmFyIGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZGF0YS5pZCA9PT0gJ2F1ZGlvJyAmJiBkYXRhLnR5cGUgPT09ICdhdWRpbycgJiYgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiYgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0cmFja0lkID0gX3RoaXMzLnRyYWNrSWQsXG4gICAgICAgICAgICAgIHRyYWNrID0gX3RoaXMzLnRyYWNrc1t0cmFja0lkXSxcbiAgICAgICAgICAgICAgaGxzID0gX3RoaXMzLmhscztcblxuICAgICAgICAgIGlmIChpc05hTihkYXRhLmVuZFBUUykpIHtcbiAgICAgICAgICAgIGRhdGEuZW5kUFRTID0gZGF0YS5zdGFydFBUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xuICAgICAgICAgICAgZGF0YS5lbmREVFMgPSBkYXRhLnN0YXJ0RFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdwYXJzZWQgJyArIGRhdGEudHlwZSArICcsUFRTOlsnICsgZGF0YS5zdGFydFBUUy50b0ZpeGVkKDMpICsgJywnICsgZGF0YS5lbmRQVFMudG9GaXhlZCgzKSArICddLERUUzpbJyArIGRhdGEuc3RhcnREVFMudG9GaXhlZCgzKSArICcvJyArIGRhdGEuZW5kRFRTLnRvRml4ZWQoMykgKyAnXSxuYjonICsgZGF0YS5uYik7XG4gICAgICAgICAgX2xldmVsSGVscGVyMi5kZWZhdWx0LnVwZGF0ZUZyYWdQVFNEVFModHJhY2suZGV0YWlscywgZnJhZ0N1cnJlbnQuc24sIGRhdGEuc3RhcnRQVFMsIGRhdGEuZW5kUFRTKTtcblxuICAgICAgICAgIHZhciBhdWRpb1N3aXRjaCA9IF90aGlzMy5hdWRpb1N3aXRjaCxcbiAgICAgICAgICAgICAgbWVkaWEgPSBfdGhpczMubWVkaWEsXG4gICAgICAgICAgICAgIGFwcGVuZE9uQnVmZmVyRmx1c2ggPSBmYWxzZTtcbiAgICAgICAgICAvL09ubHkgZmx1c2ggYXVkaW8gZnJvbSBvbGQgYXVkaW8gdHJhY2tzIHdoZW4gUFRTIGlzIGtub3duIG9uIG5ldyBhdWRpbyB0cmFja1xuICAgICAgICAgIGlmIChhdWRpb1N3aXRjaCAmJiBtZWRpYSkge1xuICAgICAgICAgICAgaWYgKG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc3dpdGNoaW5nIGF1ZGlvIHRyYWNrIDogY3VycmVudFRpbWU6JyArIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUaW1lID49IGRhdGEuc3RhcnRQVFMpIHtcbiAgICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGZsdXNoaW5nIGFsbCBhdWRpbycpO1xuICAgICAgICAgICAgICAgIF90aGlzMy5zdGF0ZSA9IFN0YXRlLkJVRkZFUl9GTFVTSElORztcbiAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9GTFVTSElORywgeyBzdGFydE9mZnNldDogMCwgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHR5cGU6ICdhdWRpbycgfSk7XG4gICAgICAgICAgICAgICAgYXBwZW5kT25CdWZmZXJGbHVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy9MZXRzIGFubm91bmNlIHRoYXQgdGhlIGluaXRpYWwgYXVkaW8gdHJhY2sgc3dpdGNoIGZsdXNoIG9jY3VyXG4gICAgICAgICAgICAgICAgX3RoaXMzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5BVURJT19UUkFDS19TV0lUQ0hFRCwgeyBpZDogdHJhY2tJZCB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy9MZXRzIGFubm91bmNlIHRoYXQgdGhlIGluaXRpYWwgYXVkaW8gdHJhY2sgc3dpdGNoIGZsdXNoIG9jY3VyXG4gICAgICAgICAgICAgIF90aGlzMy5hdWRpb1N3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7IGlkOiB0cmFja0lkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwZW5kaW5nRGF0YSA9IF90aGlzMy5wZW5kaW5nRGF0YTtcbiAgICAgICAgICBpZiAoIV90aGlzMy5hdWRpb1N3aXRjaCkge1xuICAgICAgICAgICAgW2RhdGEuZGF0YTEsIGRhdGEuZGF0YTJdLmZvckVhY2goZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nRGF0YS5wdXNoKHsgdHlwZTogZGF0YS50eXBlLCBkYXRhOiBidWZmZXIsIHBhcmVudDogJ2F1ZGlvJywgY29udGVudDogJ2RhdGEnIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghYXBwZW5kT25CdWZmZXJGbHVzaCAmJiBwZW5kaW5nRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcGVuZGluZ0RhdGEuZm9yRWFjaChmdW5jdGlvbiAoYXBwZW5kT2JqKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBhcHBlbmQgaW4gUEFSU0lORyBzdGF0ZSAocmF0aW9uYWxlIGlzIHRoYXQgYW4gYXBwZW5kaW5nIGVycm9yIGNvdWxkIGhhcHBlbiBzeW5jaHJvbm91c2x5IG9uIGZpcnN0IHNlZ21lbnQgYXBwZW5kaW5nKVxuICAgICAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBpdCBpcyB1c2VsZXNzIHRvIGFwcGVuZCBmb2xsb3dpbmcgc2VnbWVudHNcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgICAgICAgICAgICAvLyBhcm0gcGVuZGluZyBCdWZmZXJpbmcgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIGEgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgX3RoaXMzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgX3RoaXMzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0FQUEVORElORywgYXBwZW5kT2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBfdGhpczMucGVuZGluZ0RhdGEgPSBbXTtcbiAgICAgICAgICAgICAgX3RoaXMzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICAgICAgX3RoaXMzLnRpY2soKTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZyYWdQYXJzZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZyYWdQYXJzZWQoZGF0YSkge1xuICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIHZhciBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgICAgaWYgKGZyYWdDdXJyZW50ICYmIGRhdGEuaWQgPT09ICdhdWRpbycgJiYgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiYgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICB0aGlzLnN0YXRzLnRwYXJzZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQnVmZmVyQ3JlYXRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQnVmZmVyQ3JlYXRlZChkYXRhKSB7XG4gICAgICB2YXIgYXVkaW9UcmFjayA9IGRhdGEudHJhY2tzLmF1ZGlvO1xuICAgICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IGF1ZGlvVHJhY2suYnVmZmVyO1xuICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkJ1ZmZlckFwcGVuZGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25CdWZmZXJBcHBlbmRlZChkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8IHN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gYXBwZW5kZWRcbiAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSBkYXRhLnBlbmRpbmcgPiAwO1xuICAgICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19jaGVja0FwcGVuZGVkUGFyc2VkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrQXBwZW5kZWRQYXJzZWQoKSB7XG4gICAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQgJiYgKCF0aGlzLmFwcGVuZGVkIHx8ICF0aGlzLnBlbmRpbmdCdWZmZXJpbmcpKSB7XG4gICAgICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgICAgIHN0YXRzID0gdGhpcy5zdGF0cyxcbiAgICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgICAgICBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnLCBpZDogJ2F1ZGlvJyB9KTtcbiAgICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdhdWRpbyBidWZmZXJlZCA6ICcgKyBfdGltZVJhbmdlczIuZGVmYXVsdC50b1N0cmluZyhtZWRpYS5idWZmZXJlZCkpO1xuICAgICAgICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoICYmIHRoaXMuYXBwZW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHsgaWQ6IHRoaXMudHJhY2tJZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25FcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRXJyb3IoZGF0YSkge1xuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBhdWRpbyBmcmFnbWVudFxuICAgICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnYXVkaW8nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgX2Vycm9ycy5FcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICAgIGlmICghZGF0YS5mYXRhbCkge1xuICAgICAgICAgICAgdmFyIGxvYWRFcnJvciA9IHRoaXMuZnJhZ0xvYWRFcnJvcjtcbiAgICAgICAgICAgIGlmIChsb2FkRXJyb3IpIHtcbiAgICAgICAgICAgICAgbG9hZEVycm9yKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb2FkRXJyb3IgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgaWYgKGxvYWRFcnJvciA8PSBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSkge1xuICAgICAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSBsb2FkRXJyb3I7XG4gICAgICAgICAgICAgIC8vIHJlc2V0IGxvYWQgY291bnRlciB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvclxuICAgICAgICAgICAgICBmcmFnLmxvYWRDb3VudGVyID0gMDtcbiAgICAgICAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0XG4gICAgICAgICAgICAgIHZhciBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIGxvYWRFcnJvciAtIDEpICogY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSwgY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignYXVkaW9TdHJlYW1Db250cm9sbGVyOiBmcmFnIGxvYWRpbmcgZmFpbGVkLCByZXRyeSBpbiAnICsgZGVsYXkgKyAnIG1zJyk7XG4gICAgICAgICAgICAgIHRoaXMucmV0cnlEYXRlID0gcGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgICAgICAgICAgLy8gcmV0cnkgbG9hZGluZyBzdGF0ZVxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5lcnJvcignYXVkaW9TdHJlYW1Db250cm9sbGVyOiAnICsgZGF0YS5kZXRhaWxzICsgJyByZWFjaGVzIG1heCByZXRyeSwgcmVkaXNwYXRjaCBhcyBmYXRhbCAuLi4nKTtcbiAgICAgICAgICAgICAgLy8gcmVkaXNwYXRjaCBzYW1lIGVycm9yIGJ1dCB3aXRoIGZhdGFsIHNldCB0byB0cnVlXG4gICAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIGRhdGEpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SOlxuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I6XG4gICAgICAgIGNhc2UgX2Vycm9ycy5FcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgLy8gIHdoZW4gaW4gRVJST1Igc3RhdGUsIGRvbid0IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaW4gY2FzZSBhIG5vbi1mYXRhbCBlcnJvciBpcyByZWNlaXZlZFxuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICAgICAgLy8gaWYgZmF0YWwgZXJyb3IsIHN0b3AgcHJvY2Vzc2luZywgb3RoZXJ3aXNlIG1vdmUgdG8gSURMRSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gZGF0YS5mYXRhbCA/IFN0YXRlLkVSUk9SIDogU3RhdGUuSURMRTtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2F1ZGlvU3RyZWFtQ29udHJvbGxlcjogJyArIGRhdGEuZGV0YWlscyArICcgd2hpbGUgbG9hZGluZyBmcmFnLHN3aXRjaCB0byAnICsgdGhpcy5zdGF0ZSArICcgc3RhdGUgLi4uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICAgIC8vIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxuICAgICAgICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ2F1ZGlvJyAmJiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpKSB7XG4gICAgICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZSxcbiAgICAgICAgICAgICAgICBtZWRpYUJ1ZmZlcmVkID0gbWVkaWEgJiYgX2J1ZmZlckhlbHBlcjIuZGVmYXVsdC5pc0J1ZmZlcmVkKG1lZGlhLCBjdXJyZW50VGltZSkgJiYgX2J1ZmZlckhlbHBlcjIuZGVmYXVsdC5pc0J1ZmZlcmVkKG1lZGlhLCBjdXJyZW50VGltZSArIDAuNSk7XG4gICAgICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZFxuICAgICAgICAgICAgaWYgKG1lZGlhQnVmZmVyZWQpIHtcbiAgICAgICAgICAgICAgdmFyIF9jb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgICAgaWYgKF9jb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID49IF9jb25maWcubWF4QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIGFzIGl0IG1pZ2h0IGJlIHRvbyBoaWdoLiB3ZSBkbyB0aGlzIHRvIGF2b2lkIGxvb3AgZmx1c2hpbmcgLi4uXG4gICAgICAgICAgICAgICAgX2NvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggLz0gMjtcbiAgICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdhdWRpbzpyZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJyArIF9jb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoICsgJ3MnKTtcbiAgICAgICAgICAgICAgICAvLyBpbmNyZWFzZSBmcmFnbWVudCBsb2FkIEluZGV4IHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGFmdGVyIGJ1ZmZlciBmbHVzaFxuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIF9jb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vZGFpbHltb3Rpb24vaGxzLmpzL3B1bGwvNzA4XG4gICAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBmbHVzaCB0aGUgd2hvbGUgYXVkaW8gYnVmZmVyIHRvIHJlY292ZXJcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignYnVmZmVyIGZ1bGwgZXJyb3IgYWxzbyBtZWRpYS5jdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGZsdXNoIGF1ZGlvIGJ1ZmZlcicpO1xuICAgICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgLy8gZmx1c2ggZXZlcnl0aGluZ1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQlVGRkVSX0ZMVVNISU5HO1xuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0ZMVVNISU5HLCB7IHN0YXJ0T2Zmc2V0OiAwLCBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdHlwZTogJ2F1ZGlvJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25CdWZmZXJGbHVzaGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25CdWZmZXJGbHVzaGVkKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBwZW5kaW5nRGF0YSA9IHRoaXMucGVuZGluZ0RhdGE7XG4gICAgICBpZiAocGVuZGluZ0RhdGEgJiYgcGVuZGluZ0RhdGEubGVuZ3RoKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnYXBwZW5kaW5nIHBlbmRpbmcgYXVkaW8gZGF0YSBvbiBCdWZmZXIgRmx1c2hlZCcpO1xuICAgICAgICBwZW5kaW5nRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChhcHBlbmRPYmopIHtcbiAgICAgICAgICBfdGhpczQuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucGVuZGluZ0RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vdmUgdG8gSURMRSBvbmNlIGZsdXNoIGNvbXBsZXRlLiB0aGlzIHNob3VsZCB0cmlnZ2VyIG5ldyBmcmFnbWVudCBsb2FkaW5nXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gZnJhZ1xuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0YXRlJyxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXh0U3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBuZXh0U3RhdGUpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdhdWRpbyBzdHJlYW06JyArIHByZXZpb3VzU3RhdGUgKyAnLT4nICsgbmV4dFN0YXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG59KF9ldmVudEhhbmRsZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBBdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG5cbn0se1wiMjVcIjoyNSxcIjMxXCI6MzEsXCIzMlwiOjMyLFwiMzNcIjozMyxcIjM1XCI6MzUsXCIzNlwiOjM2LFwiNDZcIjo0NixcIjUwXCI6NTAsXCI1MVwiOjUxfV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZXZlbnRIYW5kbGVyID0gX2RlcmVxXygzMik7XG5cbnZhciBfZXZlbnRIYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50SGFuZGxlcik7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGF1ZGlvIHRyYWNrIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBBdWRpb1RyYWNrQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfRXZlbnRIYW5kbGVyKSB7XG4gIF9pbmhlcml0cyhBdWRpb1RyYWNrQ29udHJvbGxlciwgX0V2ZW50SGFuZGxlcik7XG5cbiAgZnVuY3Rpb24gQXVkaW9UcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvVHJhY2tDb250cm9sbGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChBdWRpb1RyYWNrQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEF1ZGlvVHJhY2tDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBobHMsIF9ldmVudHMyLmRlZmF1bHQuTUFOSUZFU1RfTE9BRElORywgX2V2ZW50czIuZGVmYXVsdC5NQU5JRkVTVF9MT0FERUQsIF9ldmVudHMyLmRlZmF1bHQuQVVESU9fVFJBQ0tfTE9BREVEKSk7XG5cbiAgICBfdGhpcy50aWNrcyA9IDA7XG4gICAgX3RoaXMub250aWNrID0gX3RoaXMudGljay5iaW5kKF90aGlzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQXVkaW9UcmFja0NvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBfZXZlbnRIYW5kbGVyMi5kZWZhdWx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICB0aGlzLnRpY2tzKys7XG4gICAgICBpZiAodGhpcy50aWNrcyA9PT0gMSkge1xuICAgICAgICB0aGlzLmRvVGljaygpO1xuICAgICAgICBpZiAodGhpcy50aWNrcyA+IDEpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMudGljaywgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aWNrcyA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZG9UaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9UaWNrKCkge1xuICAgICAgdGhpcy51cGRhdGVUcmFjayh0aGlzLnRyYWNrSWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWFuaWZlc3RMb2FkaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgICAvLyByZXNldCBhdWRpbyB0cmFja3Mgb24gbWFuaWZlc3QgbG9hZGluZ1xuICAgICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWFuaWZlc3RMb2FkZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGVkKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgdHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcyB8fCBbXTtcbiAgICAgIHZhciBkZWZhdWx0Rm91bmQgPSBmYWxzZTtcbiAgICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkFVRElPX1RSQUNLU19VUERBVEVELCB7IGF1ZGlvVHJhY2tzOiB0cmFja3MgfSk7XG4gICAgICAvLyBsb29wIHRocm91Z2ggYXZhaWxhYmxlIGF1ZGlvIHRyYWNrcyBhbmQgYXV0b3NlbGVjdCBkZWZhdWx0IGlmIG5lZWRlZFxuICAgICAgdmFyIGlkID0gMDtcbiAgICAgIHRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICBpZiAodHJhY2suZGVmYXVsdCkge1xuICAgICAgICAgIF90aGlzMi5hdWRpb1RyYWNrID0gaWQ7XG4gICAgICAgICAgZGVmYXVsdEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWQrKztcbiAgICAgIH0pO1xuICAgICAgaWYgKGRlZmF1bHRGb3VuZCA9PT0gZmFsc2UgJiYgdHJhY2tzLmxlbmd0aCkge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ25vIGRlZmF1bHQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgdXNlIGZpcnN0IGF1ZGlvIHRyYWNrIGFzIGRlZmF1bHQnKTtcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkF1ZGlvVHJhY2tMb2FkZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tMb2FkZWQoZGF0YSkge1xuICAgICAgaWYgKGRhdGEuaWQgPCB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdhdWRpb1RyYWNrICcgKyBkYXRhLmlkICsgJyBsb2FkZWQnKTtcbiAgICAgICAgdGhpcy50cmFja3NbZGF0YS5pZF0uZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgICAgLy8gY2hlY2sgaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3RcbiAgICAgICAgaWYgKGRhdGEuZGV0YWlscy5saXZlICYmICF0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCB3ZSB3aWxsIGhhdmUgdG8gcmVsb2FkIGl0IHBlcmlvZGljYWxseVxuICAgICAgICAgIC8vIHNldCByZWxvYWQgcGVyaW9kIHRvIHBsYXlsaXN0IHRhcmdldCBkdXJhdGlvblxuICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9udGljaywgMTAwMCAqIGRhdGEuZGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhLmRldGFpbHMubGl2ZSAmJiB0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgLy8gcGxheWxpc3QgaXMgbm90IGxpdmUgYW5kIHRpbWVyIGlzIGFybWVkIDogc3RvcHBpbmcgaXRcbiAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIGdldCBhbHRlcm5hdGUgYXVkaW8gdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0QXVkaW9UcmFja0ludGVybmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXVkaW9UcmFja0ludGVybmFsKG5ld0lkKSB7XG4gICAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICAgIGlmIChuZXdJZCA+PSAwICYmIG5ld0lkIDwgdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc3dpdGNoaW5nIHRvIGF1ZGlvVHJhY2sgJyArIG5ld0lkKTtcbiAgICAgICAgdmFyIGF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrc1tuZXdJZF0sXG4gICAgICAgICAgICBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgICAgIHR5cGUgPSBhdWRpb1RyYWNrLnR5cGUsXG4gICAgICAgICAgICB1cmwgPSBhdWRpb1RyYWNrLnVybCxcbiAgICAgICAgICAgIGV2ZW50T2JqID0geyBpZDogbmV3SWQsIHR5cGU6IHR5cGUsIHVybDogdXJsIH07XG4gICAgICAgIC8vIGtlZXAgQVVESU9fVFJBQ0tfU1dJVENIIGZvciBsZWdhY3kgcmVhc29uXG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENILCBldmVudE9iaik7XG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENISU5HLCBldmVudE9iaik7XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBhdWRpbyBUcmFja1xuICAgICAgICB2YXIgZGV0YWlscyA9IGF1ZGlvVHJhY2suZGV0YWlscztcbiAgICAgICAgaWYgKHVybCAmJiAoZGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGRldGFpbHMubGl2ZSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCcocmUpbG9hZGluZyBwbGF5bGlzdCBmb3IgYXVkaW9UcmFjayAnICsgbmV3SWQpO1xuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQVVESU9fVFJBQ0tfTE9BRElORywgeyB1cmw6IHVybCwgaWQ6IG5ld0lkIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlVHJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVUcmFjayhuZXdJZCkge1xuICAgICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgICBpZiAobmV3SWQgPj0gMCAmJiBuZXdJZCA8IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3VwZGF0aW5nIGF1ZGlvVHJhY2sgJyArIG5ld0lkKTtcbiAgICAgICAgdmFyIGF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrc1tuZXdJZF0sXG4gICAgICAgICAgICB1cmwgPSBhdWRpb1RyYWNrLnVybDtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGF1ZGlvIFRyYWNrXG4gICAgICAgIHZhciBkZXRhaWxzID0gYXVkaW9UcmFjay5kZXRhaWxzO1xuICAgICAgICBpZiAodXJsICYmIChkZXRhaWxzID09PSB1bmRlZmluZWQgfHwgZGV0YWlscy5saXZlID09PSB0cnVlKSkge1xuICAgICAgICAgIC8vIHRyYWNrIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJyhyZSlsb2FkaW5nIHBsYXlsaXN0IGZvciBhdWRpb1RyYWNrICcgKyBuZXdJZCk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkFVRElPX1RSQUNLX0xPQURJTkcsIHsgdXJsOiB1cmwsIGlkOiBuZXdJZCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2F1ZGlvVHJhY2tzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrcztcbiAgICB9XG5cbiAgICAvKiogZ2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBhdWRpbyB0cmFjayAoaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHMpICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhdWRpb1RyYWNrJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gICAgfVxuXG4gICAgLyoqIHNlbGVjdCBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKiovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGF1ZGlvVHJhY2tJZCkge1xuICAgICAgaWYgKHRoaXMudHJhY2tJZCAhPT0gYXVkaW9UcmFja0lkIHx8IHRoaXMudHJhY2tzW2F1ZGlvVHJhY2tJZF0uZGV0YWlscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2V0QXVkaW9UcmFja0ludGVybmFsKGF1ZGlvVHJhY2tJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2tDb250cm9sbGVyO1xufShfZXZlbnRIYW5kbGVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQXVkaW9UcmFja0NvbnRyb2xsZXI7XG5cbn0se1wiMzJcIjozMixcIjMzXCI6MzMsXCI1MFwiOjUwfV0sODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZXZlbnRIYW5kbGVyID0gX2RlcmVxXygzMik7XG5cbnZhciBfZXZlbnRIYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50SGFuZGxlcik7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbnZhciBfZXJyb3JzID0gX2RlcmVxXygzMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEJ1ZmZlciBDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgQnVmZmVyQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfRXZlbnRIYW5kbGVyKSB7XG4gIF9pbmhlcml0cyhCdWZmZXJDb250cm9sbGVyLCBfRXZlbnRIYW5kbGVyKTtcblxuICBmdW5jdGlvbiBCdWZmZXJDb250cm9sbGVyKGhscykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJDb250cm9sbGVyKTtcblxuICAgIC8vIHRoZSB2YWx1ZSB0aGF0IHdlIGhhdmUgc2V0IG1lZGlhc291cmNlLmR1cmF0aW9uIHRvXG4gICAgLy8gKHRoZSBhY3R1YWwgZHVyYXRpb24gbWF5IGJlIHR3ZWFrZWQgc2xpZ2hseSBieSB0aGUgYnJvd3NlcilcbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQnVmZmVyQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJ1ZmZlckNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIGhscywgX2V2ZW50czIuZGVmYXVsdC5NRURJQV9BVFRBQ0hJTkcsIF9ldmVudHMyLmRlZmF1bHQuTUVESUFfREVUQUNISU5HLCBfZXZlbnRzMi5kZWZhdWx0Lk1BTklGRVNUX1BBUlNFRCwgX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfUkVTRVQsIF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0FQUEVORElORywgX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfQ09ERUNTLCBfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9FT1MsIF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0ZMVVNISU5HLCBfZXZlbnRzMi5kZWZhdWx0LkxFVkVMX1BUU19VUERBVEVELCBfZXZlbnRzMi5kZWZhdWx0LkxFVkVMX1VQREFURUQpKTtcblxuICAgIF90aGlzLl9tc0R1cmF0aW9uID0gbnVsbDtcbiAgICAvLyB0aGUgdmFsdWUgdGhhdCB3ZSB3YW50IHRvIHNldCBtZWRpYVNvdXJjZS5kdXJhdGlvbiB0b1xuICAgIF90aGlzLl9sZXZlbER1cmF0aW9uID0gbnVsbDtcblxuICAgIC8vIFNvdXJjZSBCdWZmZXIgbGlzdGVuZXJzXG4gICAgX3RoaXMub25zYnVlID0gX3RoaXMub25TQlVwZGF0ZUVuZC5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5vbnNiZSA9IF90aGlzLm9uU0JVcGRhdGVFcnJvci5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgX3RoaXMudHJhY2tzID0ge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJ1ZmZlckNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBfZXZlbnRIYW5kbGVyMi5kZWZhdWx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25MZXZlbFB0c1VwZGF0ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkxldmVsUHRzVXBkYXRlZChkYXRhKSB7XG4gICAgICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgICAgIHZhciBhdWRpb1RyYWNrID0gdGhpcy50cmFja3MuYXVkaW87XG5cbiAgICAgIC8vIEFkanVzdGluZyBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGAgKGRlc2lyZWQgcG9pbnQgaW4gdGhlIHRpbWVsaW5lIHdoZXJlIHRoZSBuZXh0IGZyYW1lcyBzaG91bGQgYmUgYXBwZW5kZWQpXG4gICAgICAvLyBpbiBDaHJvbWUgYnJvd3NlciB3aGVuIHdlIGRldGVjdCBNUEVHIGF1ZGlvIGNvbnRhaW5lciBhbmQgdGltZSBkZWx0YSBiZXR3ZWVuIGxldmVsIFBUUyBhbmQgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgXG4gICAgICAvLyBpcyBncmVhdGVyIHRoYW4gMTAwbXMgKHRoaXMgaXMgZW5vdWdoIHRvIGhhbmRsZSBzZWVrIGZvciBWT0Qgb3IgbGV2ZWwgY2hhbmdlIGZvciBMSVZFIHZpZGVvcykuIEF0IHRoZSB0aW1lIG9mIGNoYW5nZSB3ZSBpc3N1ZVxuICAgICAgLy8gYFNvdXJjZUJ1ZmZlci5hYm9ydCgpYCBhbmQgYWRqdXN0aW5nIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YCBpZiBgU291cmNlQnVmZmVyLnVwZGF0aW5nYCBpcyBmYWxzZSBvciBhd2FpdGluZyBgdXBkYXRlZW5kYFxuICAgICAgLy8gZXZlbnQgaWYgU0IgaXMgaW4gdXBkYXRpbmcgc3RhdGUuXG4gICAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL2RhaWx5bW90aW9uL2hscy5qcy9pc3N1ZXMvMzMyI2lzc3VlY29tbWVudC0yNTc5ODY0ODZcblxuICAgICAgaWYgKHR5cGUgPT09ICdhdWRpbycgJiYgYXVkaW9UcmFjayAmJiBhdWRpb1RyYWNrLmNvbnRhaW5lciA9PT0gJ2F1ZGlvL21wZWcnKSB7XG4gICAgICAgIC8vIENocm9tZSBhdWRpbyBtcDMgdHJhY2tcbiAgICAgICAgdmFyIGF1ZGlvQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIuYXVkaW87XG4gICAgICAgIHZhciBkZWx0YSA9IE1hdGguYWJzKGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCAtIGRhdGEuc3RhcnQpO1xuXG4gICAgICAgIC8vIGFkanVzdCB0aW1lc3RhbXAgb2Zmc2V0IGlmIHRpbWUgZGVsdGEgaXMgZ3JlYXRlciB0aGFuIDEwMG1zXG4gICAgICAgIGlmIChkZWx0YSA+IDAuMSkge1xuICAgICAgICAgIHZhciB1cGRhdGluZyA9IGF1ZGlvQnVmZmVyLnVwZGF0aW5nO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF1ZGlvQnVmZmVyLmFib3J0KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB1cGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdjYW4gbm90IGFib3J0IGF1ZGlvIGJ1ZmZlcjogJyArIGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF1cGRhdGluZykge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignY2hhbmdlIG1wZWcgYXVkaW8gdGltZXN0YW1wIG9mZnNldCBmcm9tICcgKyBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgKyAnIHRvICcgKyBkYXRhLnN0YXJ0KTtcbiAgICAgICAgICAgIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCA9IGRhdGEuc3RhcnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQgPSBkYXRhLnN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWFuaWZlc3RQYXJzZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1hbmlmZXN0UGFyc2VkKGRhdGEpIHtcbiAgICAgIHZhciBhdWRpb0V4cGVjdGVkID0gZGF0YS5hdWRpbyxcbiAgICAgICAgICB2aWRlb0V4cGVjdGVkID0gZGF0YS52aWRlbyxcbiAgICAgICAgICBzb3VyY2VCdWZmZXJOYiA9IDA7XG4gICAgICAvLyBpbiBjYXNlIG9mIGFsdCBhdWRpbyAyIEJVRkZFUl9DT0RFQ1MgZXZlbnRzIHdpbGwgYmUgdHJpZ2dlcmVkLCBvbmUgcGVyIHN0cmVhbSBjb250cm9sbGVyXG4gICAgICAvLyBzb3VyY2VidWZmZXJzIHdpbGwgYmUgY3JlYXRlZCBhbGwgYXQgb25jZSB3aGVuIHRoZSBleHBlY3RlZCBuYiBvZiB0cmFja3Mgd2lsbCBiZSByZWFjaGVkXG4gICAgICAvLyBpbiBjYXNlIGFsdCBhdWRpbyBpcyBub3QgdXNlZCwgb25seSBvbmUgQlVGRkVSX0NPREVDIGV2ZW50IHdpbGwgYmUgZmlyZWQgZnJvbSBtYWluIHN0cmVhbSBjb250cm9sbGVyXG4gICAgICAvLyBpdCB3aWxsIGNvbnRhaW4gdGhlIGV4cGVjdGVkIG5iIG9mIHNvdXJjZSBidWZmZXJzLCBubyBuZWVkIHRvIGNvbXB1dGUgaXRcbiAgICAgIGlmIChkYXRhLmFsdEF1ZGlvICYmIChhdWRpb0V4cGVjdGVkIHx8IHZpZGVvRXhwZWN0ZWQpKSB7XG4gICAgICAgIHNvdXJjZUJ1ZmZlck5iID0gKGF1ZGlvRXhwZWN0ZWQgPyAxIDogMCkgKyAodmlkZW9FeHBlY3RlZCA/IDEgOiAwKTtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKHNvdXJjZUJ1ZmZlck5iICsgJyBzb3VyY2VCdWZmZXIocykgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc291cmNlQnVmZmVyTmIgPSBzb3VyY2VCdWZmZXJOYjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1lZGlhQXR0YWNoaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZWRpYUF0dGFjaGluZyhkYXRhKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAvLyBzZXR1cCB0aGUgbWVkaWEgc291cmNlXG4gICAgICAgIHZhciBtcyA9IHRoaXMubWVkaWFTb3VyY2UgPSBuZXcgTWVkaWFTb3VyY2UoKTtcbiAgICAgICAgLy9NZWRpYSBTb3VyY2UgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMub25tc28gPSB0aGlzLm9uTWVkaWFTb3VyY2VPcGVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25tc2UgPSB0aGlzLm9uTWVkaWFTb3VyY2VFbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9ubXNjID0gdGhpcy5vbk1lZGlhU291cmNlQ2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMub25tc2UpO1xuICAgICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMub25tc2MpO1xuICAgICAgICAvLyBsaW5rIHZpZGVvIGFuZCBtZWRpYSBTb3VyY2VcbiAgICAgICAgbWVkaWEuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChtcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYURldGFjaGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBkZXRhY2hpbmcnKTtcbiAgICAgIHZhciBtcyA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgICBpZiAobXMpIHtcbiAgICAgICAgaWYgKG1zLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBlbmRPZlN0cmVhbSBjb3VsZCB0cmlnZ2VyIGV4Y2VwdGlvbiBpZiBhbnkgc291cmNlYnVmZmVyIGlzIGluIHVwZGF0aW5nIHN0YXRlXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCByZWFsbHkgY2FyZSBhYm91dCBjaGVja2luZyBzb3VyY2VidWZmZXIgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGFzIHdlIGFyZSBhbnl3YXkgZGV0YWNoaW5nIHRoZSBNZWRpYVNvdXJjZVxuICAgICAgICAgICAgLy8gbGV0J3MganVzdCBhdm9pZCB0aGlzIGV4Y2VwdGlvbiB0byBwcm9wYWdhdGVcbiAgICAgICAgICAgIG1zLmVuZE9mU3RyZWFtKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdvbk1lZGlhRGV0YWNoaW5nOicgKyBlcnIubWVzc2FnZSArICcgd2hpbGUgY2FsbGluZyBlbmRPZlN0cmVhbScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XG4gICAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5vbm1zZSk7XG4gICAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5vbm1zYyk7XG5cbiAgICAgICAgLy8gRGV0YWNoIHByb3Blcmx5IHRoZSBNZWRpYVNvdXJjZSBmcm9tIHRoZSBIVE1MTWVkaWFFbGVtZW50IGFzXG4gICAgICAgIC8vIHN1Z2dlc3RlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vdzNjL21lZGlhLXNvdXJjZS9pc3N1ZXMvNTMuXG4gICAgICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLm1lZGlhLnNyYyk7XG4gICAgICAgICAgdGhpcy5tZWRpYS5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgIHRoaXMubWVkaWEubG9hZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICAgICAgdGhpcy50cmFja3MgPSB7fTtcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB7fTtcbiAgICAgICAgdGhpcy5mbHVzaFJhbmdlID0gW107XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5hcHBlbmRlZCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLm9ubXNvID0gdGhpcy5vbm1zZSA9IHRoaXMub25tc2MgPSBudWxsO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0Lk1FRElBX0RFVEFDSEVEKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1lZGlhU291cmNlT3BlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVkaWFTb3VyY2VPcGVuKCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdtZWRpYSBzb3VyY2Ugb3BlbmVkJyk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuTUVESUFfQVRUQUNIRUQsIHsgbWVkaWE6IHRoaXMubWVkaWEgfSk7XG4gICAgICB2YXIgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICAgIC8vIG9uY2UgcmVjZWl2ZWQsIGRvbid0IGxpc3RlbiBhbnltb3JlIHRvIHNvdXJjZW9wZW4gZXZlbnRcbiAgICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja1BlbmRpbmdUcmFja3MoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjaGVja1BlbmRpbmdUcmFja3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1BlbmRpbmdUcmFja3MoKSB7XG4gICAgICAvLyBpZiBhbnkgYnVmZmVyIGNvZGVjcyBwZW5kaW5nLCBjaGVjayBpZiB3ZSBoYXZlIGVub3VnaCB0byBjcmVhdGUgc291cmNlQnVmZmVyc1xuICAgICAgdmFyIHBlbmRpbmdUcmFja3MgPSB0aGlzLnBlbmRpbmdUcmFja3MsXG4gICAgICAgICAgcGVuZGluZ1RyYWNrc05iID0gT2JqZWN0LmtleXMocGVuZGluZ1RyYWNrcykubGVuZ3RoO1xuICAgICAgLy8gaWYgYW55IHBlbmRpbmcgdHJhY2tzIGFuZCAoaWYgbmIgb2YgcGVuZGluZyB0cmFja3MgZ3Qgb3IgZXF1YWwgdGhhbiBleHBlY3RlZCBuYiBvciBpZiB1bmtub3duIGV4cGVjdGVkIG5iKVxuICAgICAgaWYgKHBlbmRpbmdUcmFja3NOYiAmJiAodGhpcy5zb3VyY2VCdWZmZXJOYiA8PSBwZW5kaW5nVHJhY2tzTmIgfHwgdGhpcy5zb3VyY2VCdWZmZXJOYiA9PT0gMCkpIHtcbiAgICAgICAgLy8gb2ssIGxldCdzIGNyZWF0ZSB0aGVtIG5vdyAhXG4gICAgICAgIHRoaXMuY3JlYXRlU291cmNlQnVmZmVycyhwZW5kaW5nVHJhY2tzKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICAgIC8vIGFwcGVuZCBhbnkgcGVuZGluZyBzZWdtZW50cyBub3cgIVxuICAgICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYVNvdXJjZUNsb3NlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZWRpYVNvdXJjZUNsb3NlKCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgY2xvc2VkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYVNvdXJjZUVuZGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZWRpYVNvdXJjZUVuZGVkKCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgZW5kZWQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvblNCVXBkYXRlRW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TQlVwZGF0ZUVuZCgpIHtcbiAgICAgIC8vIHVwZGF0ZSB0aW1lc3RhbXBPZmZzZXRcbiAgICAgIGlmICh0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0KSB7XG4gICAgICAgIHZhciBhdWRpb0J1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLmF1ZGlvO1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdjaGFuZ2UgbXBlZyBhdWRpbyB0aW1lc3RhbXAgb2Zmc2V0IGZyb20gJyArIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCArICcgdG8gJyArIHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQpO1xuICAgICAgICBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgPSB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0O1xuICAgICAgICBkZWxldGUgdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX25lZWRzRmx1c2gpIHtcbiAgICAgICAgdGhpcy5kb0ZsdXNoKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9uZWVkc0Vvcykge1xuICAgICAgICB0aGlzLmNoZWNrRW9zKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZGluZyA9IGZhbHNlO1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgLy8gY291bnQgbmIgb2YgcGVuZGluZyBzZWdtZW50cyB3YWl0aW5nIGZvciBhcHBlbmRpbmcgb24gdGhpcyBzb3VyY2VidWZmZXJcbiAgICAgIHZhciBwZW5kaW5nID0gdGhpcy5zZWdtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50ZXIsIHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnQucGFyZW50ID09PSBwYXJlbnQgPyBjb3VudGVyICsgMSA6IGNvdW50ZXI7XG4gICAgICB9LCAwKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfQVBQRU5ERUQsIHsgcGFyZW50OiBwYXJlbnQsIHBlbmRpbmc6IHBlbmRpbmcgfSk7XG5cbiAgICAgIC8vIGRvbid0IGFwcGVuZCBpbiBmbHVzaGluZyBtb2RlXG4gICAgICBpZiAoIXRoaXMuX25lZWRzRmx1c2gpIHtcbiAgICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25TQlVwZGF0ZUVycm9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TQlVwZGF0ZUVycm9yKGV2ZW50KSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5lcnJvcignc291cmNlQnVmZmVyIGVycm9yOicgKyBldmVudCk7XG4gICAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyNzb3VyY2VidWZmZXItYXBwZW5kLWVycm9yXG4gICAgICAvLyB0aGlzIGVycm9yIG1pZ2h0IG5vdCBhbHdheXMgYmUgZmF0YWwgKGl0IGlzIGZhdGFsIGlmIGRlY29kZSBlcnJvciBpcyBzZXQsIGluIHRoYXQgY2FzZVxuICAgICAgLy8gaXQgd2lsbCBiZSBmb2xsb3dlZCBieSBhIG1lZGlhRWxlbWVudCBlcnJvciAuLi4pXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLCBmYXRhbDogZmFsc2UgfSk7XG4gICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGRvIG1vcmUgdGhhbiB0aGF0LCBhcyBhY2NvcmRpbiB0byB0aGUgc3BlYywgdXBkYXRlZW5kIHdpbGwgYmUgZmlyZWQganVzdCBhZnRlclxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQnVmZmVyUmVzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkJ1ZmZlclJlc2V0KCkge1xuICAgICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgICAgZm9yICh2YXIgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgdmFyIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMubWVkaWFTb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKHNiKTtcbiAgICAgICAgICBzYi5yZW1vdmVFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLm9uc2J1ZSk7XG4gICAgICAgICAgc2IucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uc2JlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgfVxuICAgICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB7fTtcbiAgICAgIHRoaXMuZmx1c2hSYW5nZSA9IFtdO1xuICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgdGhpcy5hcHBlbmRlZCA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25CdWZmZXJDb2RlY3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkJ1ZmZlckNvZGVjcyh0cmFja3MpIHtcbiAgICAgIC8vIGlmIHNvdXJjZSBidWZmZXIocykgbm90IGNyZWF0ZWQgeWV0LCBhcHBlbmRlZCBidWZmZXIgdHJhY2tzIGluIHRoaXMucGVuZGluZ1RyYWNrc1xuICAgICAgLy8gaWYgc291cmNlYnVmZmVycyBhbHJlYWR5IGNyZWF0ZWQsIGRvIG5vdGhpbmcgLi4uXG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciB0cmFja05hbWUgaW4gdHJhY2tzKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgICAgICBpZiAobWVkaWFTb3VyY2UgJiYgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBzb3VyY2VidWZmZXJzIGlmIG1lZGlhc291cmNlIG9wZW5lZFxuICAgICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVTb3VyY2VCdWZmZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU291cmNlQnVmZmVycyh0cmFja3MpIHtcbiAgICAgIHZhciBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcixcbiAgICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG5cbiAgICAgIGZvciAodmFyIHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgICAgaWYgKCFzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSkge1xuICAgICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICAgIC8vIHVzZSBsZXZlbENvZGVjIGFzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgICAgdmFyIGNvZGVjID0gdHJhY2subGV2ZWxDb2RlYyB8fCB0cmFjay5jb2RlYztcbiAgICAgICAgICB2YXIgbWltZVR5cGUgPSB0cmFjay5jb250YWluZXIgKyAnO2NvZGVjcz0nICsgY29kZWM7XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdjcmVhdGluZyBzb3VyY2VCdWZmZXIoJyArIG1pbWVUeXBlICsgJyknKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHNiID0gc291cmNlQnVmZmVyW3RyYWNrTmFtZV0gPSBtZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIobWltZVR5cGUpO1xuICAgICAgICAgICAgc2IuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgdGhpcy5vbnNidWUpO1xuICAgICAgICAgICAgc2IuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uc2JlKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tzW3RyYWNrTmFtZV0gPSB7IGNvZGVjOiBjb2RlYywgY29udGFpbmVyOiB0cmFjay5jb250YWluZXIgfTtcbiAgICAgICAgICAgIHRyYWNrLmJ1ZmZlciA9IHNiO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIuZXJyb3IoJ2Vycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOicgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SLCBmYXRhbDogZmFsc2UsIGVycjogZXJyLCBtaW1lVHlwZTogbWltZVR5cGUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0NSRUFURUQsIHsgdHJhY2tzOiB0cmFja3MgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25CdWZmZXJBcHBlbmRpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkJ1ZmZlckFwcGVuZGluZyhkYXRhKSB7XG4gICAgICBpZiAoIXRoaXMuX25lZWRzRmx1c2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlZ21lbnRzKSB7XG4gICAgICAgICAgdGhpcy5zZWdtZW50cyA9IFtkYXRhXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQnVmZmVyQXBwZW5kRmFpbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQnVmZmVyQXBwZW5kRmFpbChkYXRhKSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5lcnJvcignc291cmNlQnVmZmVyIGVycm9yOicsIGRhdGEuZXZlbnQpO1xuICAgICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxuICAgICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcbiAgICAgIC8vIGl0IHdpbGwgYmUgZm9sbG93ZWQgYnkgYSBtZWRpYUVsZW1lbnQgZXJyb3IgLi4uKVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUiwgZmF0YWw6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIC8vIG9uIEJVRkZFUl9FT1MgbWFyayBtYXRjaGluZyBzb3VyY2VidWZmZXIocykgYXMgZW5kZWQgYW5kIHRyaWdnZXIgY2hlY2tFb3MoKVxuXG4gIH0sIHtcbiAgICBrZXk6ICdvbkJ1ZmZlckVvcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQnVmZmVyRW9zKGRhdGEpIHtcbiAgICAgIHZhciBzYiA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgICAgdmFyIGRhdGFUeXBlID0gZGF0YS50eXBlO1xuICAgICAgZm9yICh2YXIgdHlwZSBpbiBzYikge1xuICAgICAgICBpZiAoIWRhdGFUeXBlIHx8IHR5cGUgPT09IGRhdGFUeXBlKSB7XG4gICAgICAgICAgaWYgKCFzYlt0eXBlXS5lbmRlZCkge1xuICAgICAgICAgICAgc2JbdHlwZV0uZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKHR5cGUgKyAnIHNvdXJjZUJ1ZmZlciBub3cgRU9TJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrRW9zKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgYWxsIHNvdXJjZSBidWZmZXJzIGFyZSBtYXJrZWQgYXMgZW5kZWQsIHNpZ25hbCBlbmRPZlN0cmVhbSgpIHRvIE1lZGlhU291cmNlLlxuXG4gIH0sIHtcbiAgICBrZXk6ICdjaGVja0VvcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRW9zKCkge1xuICAgICAgdmFyIHNiID0gdGhpcy5zb3VyY2VCdWZmZXIsXG4gICAgICAgICAgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgICAgaWYgKCFtZWRpYVNvdXJjZSB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgICAgdGhpcy5fbmVlZHNFb3MgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgdHlwZSBpbiBzYikge1xuICAgICAgICB2YXIgc2JvYmogPSBzYlt0eXBlXTtcbiAgICAgICAgaWYgKCFzYm9iai5lbmRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2JvYmoudXBkYXRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9uZWVkc0VvcyA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2FsbCBtZWRpYSBkYXRhIGF2YWlsYWJsZSwgc2lnbmFsIGVuZE9mU3RyZWFtKCkgdG8gTWVkaWFTb3VyY2UgYW5kIHN0b3AgbG9hZGluZyBmcmFnbWVudCcpO1xuICAgICAgLy9Ob3RpZnkgdGhlIG1lZGlhIGVsZW1lbnQgdGhhdCBpdCBub3cgaGFzIGFsbCBvZiB0aGUgbWVkaWEgZGF0YVxuICAgICAgdHJ5IHtcbiAgICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignZXhjZXB0aW9uIHdoaWxlIGNhbGxpbmcgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKScpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbmVlZHNFb3MgPSBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkJ1ZmZlckZsdXNoaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25CdWZmZXJGbHVzaGluZyhkYXRhKSB7XG4gICAgICB0aGlzLmZsdXNoUmFuZ2UucHVzaCh7IHN0YXJ0OiBkYXRhLnN0YXJ0T2Zmc2V0LCBlbmQ6IGRhdGEuZW5kT2Zmc2V0LCB0eXBlOiBkYXRhLnR5cGUgfSk7XG4gICAgICAvLyBhdHRlbXB0IGZsdXNoIGltbWVkaWF0bHlcbiAgICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyID0gMDtcbiAgICAgIHRoaXMuZG9GbHVzaCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTGV2ZWxVcGRhdGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25MZXZlbFVwZGF0ZWQoZXZlbnQpIHtcbiAgICAgIHZhciBkZXRhaWxzID0gZXZlbnQuZGV0YWlscztcbiAgICAgIGlmIChkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGV2ZWxEdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbiArIGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYWlseW1vdGlvbi9obHMuanMvaXNzdWVzLzM1NVxuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2UsXG4gICAgICAgICAgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsXG4gICAgICAgICAgbGV2ZWxEdXJhdGlvbiA9IHRoaXMuX2xldmVsRHVyYXRpb247XG4gICAgICBpZiAobGV2ZWxEdXJhdGlvbiA9PT0gbnVsbCB8fCAhbWVkaWEgfHwgIW1lZGlhU291cmNlIHx8ICFzb3VyY2VCdWZmZXIgfHwgbWVkaWEucmVhZHlTdGF0ZSA9PT0gMCB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgaWYgKHNvdXJjZUJ1ZmZlclt0eXBlXS51cGRhdGluZykge1xuICAgICAgICAgIC8vIGNhbid0IHNldCBkdXJhdGlvbiB3aGlsc3QgYSBidWZmZXIgaXMgdXBkYXRpbmdcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9tc0R1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgIC8vIGluaXRpYWxpc2UgdG8gdGhlIHZhbHVlIHRoYXQgdGhlIG1lZGlhIHNvdXJjZSBpcyByZXBvcnRpbmdcbiAgICAgICAgdGhpcy5fbXNEdXJhdGlvbiA9IG1lZGlhU291cmNlLmR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgdmFyIGR1cmF0aW9uID0gbWVkaWEuZHVyYXRpb247XG4gICAgICAvLyBsZXZlbER1cmF0aW9uIHdhcyB0aGUgbGFzdCB2YWx1ZSB3ZSBzZXQuXG4gICAgICAvLyBub3QgdXNpbmcgbWVkaWFTb3VyY2UuZHVyYXRpb24gYXMgdGhlIGJyb3dzZXIgbWF5IHR3ZWFrIHRoaXMgdmFsdWVcbiAgICAgIC8vIG9ubHkgdXBkYXRlIG1lZGlhc291cmNlIGR1cmF0aW9uIGlmIGl0cyB2YWx1ZSBpbmNyZWFzZSwgdGhpcyBpcyB0byBhdm9pZFxuICAgICAgLy8gZmx1c2hpbmcgYWxyZWFkeSBidWZmZXJlZCBwb3J0aW9uIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gcXVhbGl0eSBsZXZlbFxuICAgICAgaWYgKGxldmVsRHVyYXRpb24gPiB0aGlzLl9tc0R1cmF0aW9uICYmIGxldmVsRHVyYXRpb24gPiBkdXJhdGlvbiB8fCBkdXJhdGlvbiA9PT0gSW5maW5pdHkgfHwgaXNOYU4oZHVyYXRpb24pKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnVXBkYXRpbmcgbWVkaWFzb3VyY2UgZHVyYXRpb24gdG8gJyArIGxldmVsRHVyYXRpb24udG9GaXhlZCgzKSk7XG4gICAgICAgIHRoaXMuX21zRHVyYXRpb24gPSBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IGxldmVsRHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZG9GbHVzaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvRmx1c2goKSB7XG4gICAgICAvLyBsb29wIHRocm91Z2ggYWxsIGJ1ZmZlciByYW5nZXMgdG8gZmx1c2hcbiAgICAgIHdoaWxlICh0aGlzLmZsdXNoUmFuZ2UubGVuZ3RoKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZmx1c2hSYW5nZVswXTtcbiAgICAgICAgLy8gZmx1c2hCdWZmZXIgd2lsbCBhYm9ydCBhbnkgYnVmZmVyIGFwcGVuZCBpbiBwcm9ncmVzcyBhbmQgZmx1c2ggQXVkaW8vVmlkZW8gQnVmZmVyXG4gICAgICAgIGlmICh0aGlzLmZsdXNoQnVmZmVyKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIHJhbmdlLnR5cGUpKSB7XG4gICAgICAgICAgLy8gcmFuZ2UgZmx1c2hlZCwgcmVtb3ZlIGZyb20gZmx1c2ggYXJyYXlcbiAgICAgICAgICB0aGlzLmZsdXNoUmFuZ2Uuc2hpZnQoKTtcbiAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbmVlZHNGbHVzaCA9IHRydWU7XG4gICAgICAgICAgLy8gYXZvaWQgbG9vcGluZywgd2FpdCBmb3IgU0IgdXBkYXRlIGVuZCB0byByZXRyaWdnZXIgYSBmbHVzaFxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZmx1c2hSYW5nZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gZXZlcnl0aGluZyBmbHVzaGVkXG4gICAgICAgIHRoaXMuX25lZWRzRmx1c2ggPSBmYWxzZTtcblxuICAgICAgICAvLyBsZXQncyByZWNvbXB1dGUgdGhpcy5hcHBlbmRlZCwgd2hpY2ggaXMgdXNlZCB0byBhdm9pZCBmbHVzaCBsb29waW5nXG4gICAgICAgIHZhciBhcHBlbmRlZCA9IDA7XG4gICAgICAgIHZhciBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgICAgYXBwZW5kZWQgKz0gc291cmNlQnVmZmVyW3R5cGVdLmJ1ZmZlcmVkLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gZXJyb3IgY291bGQgYmUgdGhyb3duIHdoaWxlIGFjY2Vzc2luZyBidWZmZXJlZCwgaW4gY2FzZSBzb3VyY2VidWZmZXIgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIGZyb20gTWVkaWFTb3VyY2VcbiAgICAgICAgICAvLyB0aGlzIGlzIGhhcm1lc3MgYXQgdGhpcyBzdGFnZSwgY2F0Y2ggdGhpcyB0byBhdm9pZCByZXBvcnRpbmcgYW4gaW50ZXJuYWwgZXhjZXB0aW9uXG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIuZXJyb3IoJ2Vycm9yIHdoaWxlIGFjY2Vzc2luZyBzb3VyY2VCdWZmZXIuYnVmZmVyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZGVkID0gYXBwZW5kZWQ7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfRkxVU0hFRCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZG9BcHBlbmRpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb0FwcGVuZGluZygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgICBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcixcbiAgICAgICAgICBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoc291cmNlQnVmZmVyKS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMubWVkaWEuZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIuZXJyb3IoJ3RyeWluZyB0byBhcHBlbmQgYWx0aG91Z2ggYSBtZWRpYSBlcnJvciBvY2N1cmVkLCBmbHVzaCBzZWdtZW50IGFuZCBhYm9ydCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcHBlbmRpbmcpIHtcbiAgICAgICAgICAvL2xvZ2dlci5sb2coYHNiIGFwcGVuZGluZyBpbiBwcm9ncmVzc2ApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VnbWVudHMgJiYgc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHNlZ21lbnQudHlwZSxcbiAgICAgICAgICAgICAgICBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICAgIGlmIChzYikge1xuICAgICAgICAgICAgICBpZiAoIXNiLnVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgc291cmNlQnVmZmVyIGVuZGVkIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBzZWdtZW50XG4gICAgICAgICAgICAgICAgc2IuZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coYGFwcGVuZGluZyAke3NlZ21lbnQuY29udGVudH0gJHt0eXBlfSBTQiwgc2l6ZToke3NlZ21lbnQuZGF0YS5sZW5ndGh9LCAke3NlZ21lbnQucGFyZW50fWApO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gc2VnbWVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgc2IuYXBwZW5kQnVmZmVyKHNlZ21lbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRlZCsrO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy51bnNoaWZ0KHNlZ21lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBpbiBjYXNlIHdlIGRvbid0IGhhdmUgYW55IHNvdXJjZSBidWZmZXIgbWF0Y2hpbmcgd2l0aCB0aGlzIHNlZ21lbnQgdHlwZSxcbiAgICAgICAgICAgICAgLy8gaXQgbWVhbnMgdGhhdCBNZWRpYXNvdXJjZSBmYWlscyB0byBjcmVhdGUgc291cmNlYnVmZmVyXG4gICAgICAgICAgICAgIC8vIGRpc2NhcmQgdGhpcyBzZWdtZW50LCBhbmQgdHJpZ2dlciB1cGRhdGUgZW5kXG4gICAgICAgICAgICAgIHRoaXMub25TQlVwZGF0ZUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSBhbnkgZXJyb3Igb2NjdXJlZCB3aGlsZSBhcHBlbmRpbmcsIHB1dCBiYWNrIHNlZ21lbnQgaW4gc2VnbWVudHMgdGFibGVcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmVycm9yKCdlcnJvciB3aGlsZSB0cnlpbmcgdG8gYXBwZW5kIGJ1ZmZlcjonICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgc2VnbWVudHMudW5zaGlmdChzZWdtZW50KTtcbiAgICAgICAgICAgIHZhciBldmVudCA9IHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBwYXJlbnQ6IHNlZ21lbnQucGFyZW50IH07XG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09IDIyKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcisrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBfZXJyb3JzLkVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SO1xuICAgICAgICAgICAgICAvKiB3aXRoIFVIRCBjb250ZW50LCB3ZSBjb3VsZCBnZXQgbG9vcCBvZiBxdW90YSBleGNlZWRlZCBlcnJvciB1bnRpbFxuICAgICAgICAgICAgICAgIGJyb3dzZXIgaXMgYWJsZSB0byBldmljdCBzb21lIGRhdGEgZnJvbSBzb3VyY2VidWZmZXIuIHJldHJ5aW5nIGhlbHAgcmVjb3ZlcmluZyB0aGlzXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZEVycm9yID4gaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5KSB7XG4gICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdmYWlsICcgKyBobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkgKyAnIHRpbWVzIHRvIGFwcGVuZCBzZWdtZW50IGluIHNvdXJjZUJ1ZmZlcicpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzID0gW107XG4gICAgICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCBldmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFF1b3RhRXhjZWVkZWRFcnJvcjogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNxdW90YWV4Y2VlZGVkZXJyb3JcbiAgICAgICAgICAgICAgLy8gbGV0J3Mgc3RvcCBhcHBlbmRpbmcgYW55IHNlZ21lbnRzLCBhbmQgcmVwb3J0IEJVRkZFUl9GVUxMX0VSUk9SIGVycm9yXG4gICAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgZXZlbnQuZGV0YWlscyA9IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SO1xuICAgICAgICAgICAgICBldmVudC5mYXRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCBldmVudCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAgZmx1c2ggc3BlY2lmaWVkIGJ1ZmZlcmVkIHJhbmdlLFxuICAgICAgcmV0dXJuIHRydWUgb25jZSByYW5nZSBoYXMgYmVlbiBmbHVzaGVkLlxuICAgICAgYXMgc291cmNlQnVmZmVyLnJlbW92ZSgpIGlzIGFzeW5jaHJvbm91cywgZmx1c2hCdWZmZXIgd2lsbCBiZSByZXRyaWdnZXJlZCBvbiBzb3VyY2VCdWZmZXIgdXBkYXRlIGVuZFxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZsdXNoQnVmZmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2hCdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZUluKSB7XG4gICAgICB2YXIgc2IsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBidWZTdGFydCxcbiAgICAgICAgICBidWZFbmQsXG4gICAgICAgICAgZmx1c2hTdGFydCxcbiAgICAgICAgICBmbHVzaEVuZCxcbiAgICAgICAgICBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpLmxlbmd0aCkge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2ZsdXNoQnVmZmVyLHBvcy9zdGFydC9lbmQ6ICcgKyB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lLnRvRml4ZWQoMykgKyAnLycgKyBzdGFydE9mZnNldCArICcvJyArIGVuZE9mZnNldCk7XG4gICAgICAgIC8vIHNhZmVndWFyZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIDogZG9uJ3QgdHJ5IHRvIGZsdXNoIG1vcmUgdGhhbiB0aGUgbmIgb2YgYXBwZW5kZWQgc2VnbWVudHNcbiAgICAgICAgaWYgKHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyIDwgdGhpcy5hcHBlbmRlZCkge1xuICAgICAgICAgIGZvciAodmFyIHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBzb3VyY2VidWZmZXIgdHlwZSBpcyBkZWZpbmVkICh0eXBlSW4pOiBpZiB5ZXMsIGxldCdzIG9ubHkgZmx1c2ggdGhpcyBvbmVcbiAgICAgICAgICAgIC8vIGlmIG5vLCBsZXQncyBmbHVzaCBhbGwgc291cmNlYnVmZmVyc1xuICAgICAgICAgICAgaWYgKHR5cGVJbiAmJiB0eXBlICE9PSB0eXBlSW4pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICAgIC8vIHdlIGFyZSBnb2luZyB0byBmbHVzaCBidWZmZXIsIG1hcmsgc291cmNlIGJ1ZmZlciBhcyAnbm90IGVuZGVkJ1xuICAgICAgICAgICAgc2IuZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghc2IudXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2IuYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGJ1ZlN0YXJ0ID0gc2IuYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgICAgICAgICAgICAgICBidWZFbmQgPSBzYi5idWZmZXJlZC5lbmQoaSk7XG4gICAgICAgICAgICAgICAgICAvLyB3b3JrYXJvdW5kIGZpcmVmb3ggbm90IGFibGUgdG8gcHJvcGVybHkgZmx1c2ggbXVsdGlwbGUgYnVmZmVyZWQgcmFuZ2UuXG4gICAgICAgICAgICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTEgJiYgZW5kT2Zmc2V0ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hTdGFydCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBmbHVzaEVuZCA9IGVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoU3RhcnQgPSBNYXRoLm1heChidWZTdGFydCwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBmbHVzaEVuZCA9IE1hdGgubWluKGJ1ZkVuZCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8qIHNvbWV0aW1lcyBzb3VyY2VidWZmZXIucmVtb3ZlKCkgZG9lcyBub3QgZmx1c2hcbiAgICAgICAgICAgICAgICAgICAgIHRoZSBleGFjdCBleHBlY3RlZCB0aW1lIHJhbmdlLlxuICAgICAgICAgICAgICAgICAgICAgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzL2luZmluaXRlIGxvb3AsXG4gICAgICAgICAgICAgICAgICAgICBvbmx5IGZsdXNoIGJ1ZmZlciByYW5nZSBvZiBsZW5ndGggZ3JlYXRlciB0aGFuIDUwMG1zLlxuICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgIGlmIChNYXRoLm1pbihmbHVzaEVuZCwgYnVmRW5kKSAtIGZsdXNoU3RhcnQgPiAwLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdmbHVzaCAnICsgdHlwZSArICcgWycgKyBmbHVzaFN0YXJ0ICsgJywnICsgZmx1c2hFbmQgKyAnXSwgb2YgWycgKyBidWZTdGFydCArICcsJyArIGJ1ZkVuZCArICddLCBwb3M6JyArIHRoaXMubWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBzYi5yZW1vdmUoZmx1c2hTdGFydCwgZmx1c2hFbmQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignZXhjZXB0aW9uIHdoaWxlIGFjY2Vzc2luZyBzb3VyY2VidWZmZXIsIGl0IG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gTWVkaWFTb3VyY2UnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdhYm9ydCAnICsgdHlwZSArICcgYXBwZW5kIGluIHByb2dyZXNzJyk7XG4gICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBhYm9ydCBhbnkgYXBwZW5kaW5nIGluIHByb2dyZXNzXG4gICAgICAgICAgICAgIC8vc2IuYWJvcnQoKTtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignY2Fubm90IGZsdXNoLCBzYiB1cGRhdGluZyBpbiBwcm9ncmVzcycpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2Fib3J0IGZsdXNoaW5nIHRvbyBtYW55IHJldHJpZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2J1ZmZlciBmbHVzaGVkJyk7XG4gICAgICB9XG4gICAgICAvLyBldmVyeXRoaW5nIGZsdXNoZWQgIVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJ1ZmZlckNvbnRyb2xsZXI7XG59KF9ldmVudEhhbmRsZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCdWZmZXJDb250cm9sbGVyO1xuXG59LHtcIjMxXCI6MzEsXCIzMlwiOjMyLFwiMzNcIjozMyxcIjUwXCI6NTB9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ldmVudHMgPSBfZGVyZXFfKDMzKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9ldmVudEhhbmRsZXIgPSBfZGVyZXFfKDMyKTtcblxudmFyIF9ldmVudEhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRIYW5kbGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogY2FwIHN0cmVhbSBsZXZlbCB0byBtZWRpYSBzaXplIGRpbWVuc2lvbiBjb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgQ2FwTGV2ZWxDb250cm9sbGVyID0gZnVuY3Rpb24gKF9FdmVudEhhbmRsZXIpIHtcbiAgX2luaGVyaXRzKENhcExldmVsQ29udHJvbGxlciwgX0V2ZW50SGFuZGxlcik7XG5cbiAgZnVuY3Rpb24gQ2FwTGV2ZWxDb250cm9sbGVyKGhscykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYXBMZXZlbENvbnRyb2xsZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDYXBMZXZlbENvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDYXBMZXZlbENvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIGhscywgX2V2ZW50czIuZGVmYXVsdC5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCBfZXZlbnRzMi5kZWZhdWx0Lk1FRElBX0FUVEFDSElORywgX2V2ZW50czIuZGVmYXVsdC5NQU5JRkVTVF9QQVJTRUQpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDYXBMZXZlbENvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy5obHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICAgIHRoaXMubWVkaWEgPSB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBudWxsO1xuICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgdGhpcy50aW1lciA9IGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZwc0Ryb3BMZXZlbENhcHBpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZwc0Ryb3BMZXZlbENhcHBpbmcoZGF0YSkge1xuICAgICAgaWYgKCF0aGlzLnJlc3RyaWN0ZWRMZXZlbHMpIHtcbiAgICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNMZXZlbFJlc3RyaWN0ZWQoZGF0YS5kcm9wcGVkTGV2ZWwpKSB7XG4gICAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscy5wdXNoKGRhdGEuZHJvcHBlZExldmVsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1lZGlhQXR0YWNoaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZWRpYUF0dGFjaGluZyhkYXRhKSB7XG4gICAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1hbmlmZXN0UGFyc2VkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChkYXRhKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gICAgICAgIGhscy5maXJzdExldmVsID0gdGhpcy5nZXRNYXhMZXZlbChkYXRhLmZpcnN0TGV2ZWwpO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5kZXRlY3RQbGF5ZXJTaXplLmJpbmQodGhpcyksIDEwMDApO1xuICAgICAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXRlY3RQbGF5ZXJTaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZWN0UGxheWVyU2l6ZSgpIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICAgIHZhciBsZXZlbHNMZW5ndGggPSB0aGlzLmxldmVscyA/IHRoaXMubGV2ZWxzLmxlbmd0aCA6IDA7XG4gICAgICAgIGlmIChsZXZlbHNMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSB0aGlzLmdldE1heExldmVsKGxldmVsc0xlbmd0aCAtIDEpO1xuICAgICAgICAgIGlmIChobHMuYXV0b0xldmVsQ2FwcGluZyA+IHRoaXMuYXV0b0xldmVsQ2FwcGluZykge1xuICAgICAgICAgICAgLy8gaWYgYXV0byBsZXZlbCBjYXBwaW5nIGhhcyBhIGhpZ2hlciB2YWx1ZSBmb3IgdGhlIHByZXZpb3VzIG9uZSwgZmx1c2ggdGhlIGJ1ZmZlciB1c2luZyBuZXh0TGV2ZWxTd2l0Y2hcbiAgICAgICAgICAgIC8vIHVzdWFsbHkgaGFwcGVuIHdoZW4gdGhlIHVzZXIgZ28gdG8gdGhlIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAgICAgICAgIGhscy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBobHMuYXV0b0xldmVsQ2FwcGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgKiByZXR1cm5zIGxldmVsIHNob3VsZCBiZSB0aGUgb25lIHdpdGggdGhlIGRpbWVuc2lvbnMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBtZWRpYSAocGxheWVyKSBkaW1lbnNpb25zIChzbyB0aGUgdmlkZW8gd2lsbCBiZSBkb3duc2NhbGVkKVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldE1heExldmVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF4TGV2ZWwoY2FwTGV2ZWxJbmRleCkge1xuICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgaSA9IHZvaWQgMCxcbiAgICAgICAgICBsZXZlbCA9IHZvaWQgMCxcbiAgICAgICAgICBtV2lkdGggPSB0aGlzLm1lZGlhV2lkdGgsXG4gICAgICAgICAgbUhlaWdodCA9IHRoaXMubWVkaWFIZWlnaHQsXG4gICAgICAgICAgbFdpZHRoID0gMCxcbiAgICAgICAgICBsSGVpZ2h0ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8PSBjYXBMZXZlbEluZGV4OyBpKyspIHtcbiAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsc1tpXTtcbiAgICAgICAgaWYgKHRoaXMuaXNMZXZlbFJlc3RyaWN0ZWQoaSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICBsV2lkdGggPSBsZXZlbC53aWR0aDtcbiAgICAgICAgbEhlaWdodCA9IGxldmVsLmhlaWdodDtcbiAgICAgICAgaWYgKG1XaWR0aCA8PSBsV2lkdGggfHwgbUhlaWdodCA8PSBsSGVpZ2h0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNMZXZlbFJlc3RyaWN0ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0xldmVsUmVzdHJpY3RlZChsZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVzdHJpY3RlZExldmVscyAmJiB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMuaW5kZXhPZihsZXZlbCkgIT09IC0xID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbnRlbnRTY2FsZUZhY3RvcicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IDE7XG4gICAgICB0cnkge1xuICAgICAgICBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgcmV0dXJuIHBpeGVsUmF0aW87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWVkaWFXaWR0aCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgd2lkdGggPSB2b2lkIDA7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHdpZHRoID0gbWVkaWEud2lkdGggfHwgbWVkaWEuY2xpZW50V2lkdGggfHwgbWVkaWEub2Zmc2V0V2lkdGg7XG4gICAgICAgIHdpZHRoICo9IHRoaXMuY29udGVudFNjYWxlRmFjdG9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21lZGlhSGVpZ2h0JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBoZWlnaHQgPSB2b2lkIDA7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGhlaWdodCA9IG1lZGlhLmhlaWdodCB8fCBtZWRpYS5jbGllbnRIZWlnaHQgfHwgbWVkaWEub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBoZWlnaHQgKj0gdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYXBMZXZlbENvbnRyb2xsZXI7XG59KF9ldmVudEhhbmRsZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYXBMZXZlbENvbnRyb2xsZXI7XG5cbn0se1wiMzJcIjozMixcIjMzXCI6MzN9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7IC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRVdNQSBCYW5kd2lkdGggRXN0aW1hdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRyYWNrcyBiYW5kd2lkdGggc2FtcGxlcyBhbmQgZXN0aW1hdGVzIGF2YWlsYWJsZSBiYW5kd2lkdGguXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQmFzZWQgb24gdGhlIG1pbmltdW0gb2YgdHdvIGV4cG9uZW50aWFsbHktd2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VzIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBkaWZmZXJlbnQgaGFsZi1saXZlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIF9ld21hID0gX2RlcmVxXyg0OSk7XG5cbnZhciBfZXdtYTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ld21hKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IoaGxzLCBzbG93LCBmYXN0LCBkZWZhdWx0RXN0aW1hdGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXdtYUJhbmRXaWR0aEVzdGltYXRvcik7XG5cbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSBkZWZhdWx0RXN0aW1hdGU7XG4gICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xuICAgIHRoaXMuc2xvd18gPSBuZXcgX2V3bWEyLmRlZmF1bHQoc2xvdyk7XG4gICAgdGhpcy5mYXN0XyA9IG5ldyBfZXdtYTIuZGVmYXVsdChmYXN0KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFd21hQmFuZFdpZHRoRXN0aW1hdG9yLCBbe1xuICAgIGtleTogJ3NhbXBsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhbXBsZShkdXJhdGlvbk1zLCBudW1CeXRlcykge1xuICAgICAgZHVyYXRpb25NcyA9IE1hdGgubWF4KGR1cmF0aW9uTXMsIHRoaXMubWluRGVsYXlNc18pO1xuICAgICAgdmFyIGJhbmR3aWR0aCA9IDgwMDAgKiBudW1CeXRlcyAvIGR1cmF0aW9uTXMsXG5cbiAgICAgIC8vY29uc29sZS5sb2coJ2luc3RhbnQgYnc6JysgTWF0aC5yb3VuZChiYW5kd2lkdGgpKTtcbiAgICAgIC8vIHdlIHdlaWdodCBzYW1wbGUgdXNpbmcgbG9hZGluZyBkdXJhdGlvbi4uLi5cbiAgICAgIHdlaWdodCA9IGR1cmF0aW9uTXMgLyAxMDAwO1xuICAgICAgdGhpcy5mYXN0Xy5zYW1wbGUod2VpZ2h0LCBiYW5kd2lkdGgpO1xuICAgICAgdGhpcy5zbG93Xy5zYW1wbGUod2VpZ2h0LCBiYW5kd2lkdGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbkVzdGltYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuRXN0aW1hdGUoKSB7XG4gICAgICB2YXIgZmFzdCA9IHRoaXMuZmFzdF87XG4gICAgICByZXR1cm4gZmFzdCAmJiBmYXN0LmdldFRvdGFsV2VpZ2h0KCkgPj0gdGhpcy5taW5XZWlnaHRfO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEVzdGltYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RXN0aW1hdGUoKSB7XG4gICAgICBpZiAodGhpcy5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3Nsb3cgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZmFzdCBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgICAvLyBUYWtlIHRoZSBtaW5pbXVtIG9mIHRoZXNlIHR3byBlc3RpbWF0ZXMuICBUaGlzIHNob3VsZCBoYXZlIHRoZSBlZmZlY3Qgb2ZcbiAgICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmZhc3RfLmdldEVzdGltYXRlKCksIHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBFd21hQmFuZFdpZHRoRXN0aW1hdG9yO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBFd21hQmFuZFdpZHRoRXN0aW1hdG9yO1xuXG59LHtcIjQ5XCI6NDl9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZXZlbnRIYW5kbGVyID0gX2RlcmVxXygzMik7XG5cbnZhciBfZXZlbnRIYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50SGFuZGxlcik7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEZQUyBDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgRlBTQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfRXZlbnRIYW5kbGVyKSB7XG4gIF9pbmhlcml0cyhGUFNDb250cm9sbGVyLCBfRXZlbnRIYW5kbGVyKTtcblxuICBmdW5jdGlvbiBGUFNDb250cm9sbGVyKGhscykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGUFNDb250cm9sbGVyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRlBTQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZQU0NvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIGhscywgX2V2ZW50czIuZGVmYXVsdC5NRURJQV9BVFRBQ0hJTkcpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGUFNDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWVkaWFBdHRhY2hpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoaW5nKGRhdGEpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgICBpZiAoY29uZmlnLmNhcExldmVsT25GUFNEcm9wKSB7XG4gICAgICAgIHZhciB2aWRlbyA9IHRoaXMudmlkZW8gPSBkYXRhLm1lZGlhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIHZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5jaGVja0ZQU0ludGVydmFsLmJpbmQodGhpcyksIGNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2hlY2tGUFMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0ZQUyh2aWRlbywgZGVjb2RlZEZyYW1lcywgZHJvcHBlZEZyYW1lcykge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBpZiAoZGVjb2RlZEZyYW1lcykge1xuICAgICAgICBpZiAodGhpcy5sYXN0VGltZSkge1xuICAgICAgICAgIHZhciBjdXJyZW50UGVyaW9kID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUaW1lLFxuICAgICAgICAgICAgICBjdXJyZW50RHJvcHBlZCA9IGRyb3BwZWRGcmFtZXMgLSB0aGlzLmxhc3REcm9wcGVkRnJhbWVzLFxuICAgICAgICAgICAgICBjdXJyZW50RGVjb2RlZCA9IGRlY29kZWRGcmFtZXMgLSB0aGlzLmxhc3REZWNvZGVkRnJhbWVzLFxuICAgICAgICAgICAgICBkcm9wcGVkRlBTID0gMTAwMCAqIGN1cnJlbnREcm9wcGVkIC8gY3VycmVudFBlcmlvZCxcbiAgICAgICAgICAgICAgaGxzID0gdGhpcy5obHM7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUFNfRFJPUCwgeyBjdXJyZW50RHJvcHBlZDogY3VycmVudERyb3BwZWQsIGN1cnJlbnREZWNvZGVkOiBjdXJyZW50RGVjb2RlZCwgdG90YWxEcm9wcGVkRnJhbWVzOiBkcm9wcGVkRnJhbWVzIH0pO1xuICAgICAgICAgIGlmIChkcm9wcGVkRlBTID4gMCkge1xuICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdjaGVja0ZQUyA6IGRyb3BwZWRGUFMvZGVjb2RlZEZQUzonICsgZHJvcHBlZEZQUy8oMTAwMCAqIGN1cnJlbnREZWNvZGVkIC8gY3VycmVudFBlcmlvZCkpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREcm9wcGVkID4gaGxzLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZCAqIGN1cnJlbnREZWNvZGVkKSB7XG4gICAgICAgICAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSBobHMuY3VycmVudExldmVsO1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdkcm9wIEZQUyByYXRpbyBncmVhdGVyIHRoYW4gbWF4IGFsbG93ZWQgdmFsdWUgZm9yIGN1cnJlbnRMZXZlbDogJyArIGN1cnJlbnRMZXZlbCk7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50TGV2ZWwgPiAwICYmIChobHMuYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgfHwgaGxzLmF1dG9MZXZlbENhcHBpbmcgPj0gY3VycmVudExldmVsKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCAtIDE7XG4gICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB7IGxldmVsOiBjdXJyZW50TGV2ZWwsIGRyb3BwZWRMZXZlbDogaGxzLmN1cnJlbnRMZXZlbCB9KTtcbiAgICAgICAgICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgICBobHMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSBkcm9wcGVkRnJhbWVzO1xuICAgICAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gZGVjb2RlZEZyYW1lcztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjaGVja0ZQU0ludGVydmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tGUFNJbnRlcnZhbCgpIHtcbiAgICAgIHZhciB2aWRlbyA9IHRoaXMudmlkZW87XG4gICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSkge1xuICAgICAgICAgIHZhciB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XG4gICAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW9QbGF5YmFja1F1YWxpdHkudG90YWxWaWRlb0ZyYW1lcywgdmlkZW9QbGF5YmFja1F1YWxpdHkuZHJvcHBlZFZpZGVvRnJhbWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNoZWNrRlBTKHZpZGVvLCB2aWRlby53ZWJraXREZWNvZGVkRnJhbWVDb3VudCwgdmlkZW8ud2Via2l0RHJvcHBlZEZyYW1lQ291bnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZQU0NvbnRyb2xsZXI7XG59KF9ldmVudEhhbmRsZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBGUFNDb250cm9sbGVyO1xuXG59LHtcIjMyXCI6MzIsXCIzM1wiOjMzLFwiNTBcIjo1MH1dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ldmVudHMgPSBfZGVyZXFfKDMzKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9ldmVudEhhbmRsZXIgPSBfZGVyZXFfKDMyKTtcblxudmFyIF9ldmVudEhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRIYW5kbGVyKTtcblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxudmFyIF9lcnJvcnMgPSBfZGVyZXFfKDMxKTtcblxudmFyIF9idWZmZXJIZWxwZXIgPSBfZGVyZXFfKDM1KTtcblxudmFyIF9idWZmZXJIZWxwZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnVmZmVySGVscGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTGV2ZWwgQ29udHJvbGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIExldmVsQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfRXZlbnRIYW5kbGVyKSB7XG4gIF9pbmhlcml0cyhMZXZlbENvbnRyb2xsZXIsIF9FdmVudEhhbmRsZXIpO1xuXG4gIGZ1bmN0aW9uIExldmVsQ29udHJvbGxlcihobHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGV2ZWxDb250cm9sbGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChMZXZlbENvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMZXZlbENvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIGhscywgX2V2ZW50czIuZGVmYXVsdC5NQU5JRkVTVF9MT0FERUQsIF9ldmVudHMyLmRlZmF1bHQuTEVWRUxfTE9BREVELCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfTE9BREVELCBfZXZlbnRzMi5kZWZhdWx0LkVSUk9SKSk7XG5cbiAgICBfdGhpcy5vbnRpY2sgPSBfdGhpcy50aWNrLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLl9tYW51YWxMZXZlbCA9IC0xO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMZXZlbENvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFudWFsTGV2ZWwgPSAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGFydExvYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydExvYWQoKSB7XG4gICAgICB0aGlzLmNhbmxvYWQgPSB0cnVlO1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICAgIC8vIGNsZWFuIHVwIGxpdmUgbGV2ZWwgZGV0YWlscyB0byBmb3JjZSByZWxvYWQgdGhlbSwgYW5kIHJlc2V0IGxvYWQgZXJyb3JzXG4gICAgICBpZiAobGV2ZWxzKSB7XG4gICAgICAgIGxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICAgICAgdmFyIGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgICAgICAgaWYgKGxldmVsRGV0YWlscyAmJiBsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgbGV2ZWwuZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gc3BlZWQgdXAgbGl2ZSBwbGF5bGlzdCByZWZyZXNoIGlmIHRpbWVyIGV4aXN0c1xuICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RvcExvYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wTG9hZCgpIHtcbiAgICAgIHRoaXMuY2FubG9hZCA9IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWFuaWZlc3RMb2FkZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGVkKGRhdGEpIHtcbiAgICAgIHZhciBsZXZlbHMwID0gW10sXG4gICAgICAgICAgbGV2ZWxzID0gW10sXG4gICAgICAgICAgYml0cmF0ZVN0YXJ0LFxuICAgICAgICAgIGJpdHJhdGVTZXQgPSB7fSxcbiAgICAgICAgICB2aWRlb0NvZGVjRm91bmQgPSBmYWxzZSxcbiAgICAgICAgICBhdWRpb0NvZGVjRm91bmQgPSBmYWxzZSxcbiAgICAgICAgICBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgICBicm9rZW5tcDRpbm1wMyA9IC9jaHJvbWV8ZmlyZWZveC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpLFxuICAgICAgICAgIGNoZWNrU3VwcG9ydGVkID0gZnVuY3Rpb24gY2hlY2tTdXBwb3J0ZWQodHlwZSwgY29kZWMpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCh0eXBlICsgJy9tcDQ7Y29kZWNzPScgKyBjb2RlYyk7XG4gICAgICB9O1xuXG4gICAgICAvLyByZWdyb3VwIHJlZHVuZGFudCBsZXZlbCB0b2dldGhlclxuICAgICAgZGF0YS5sZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgaWYgKGxldmVsLnZpZGVvQ29kZWMpIHtcbiAgICAgICAgICB2aWRlb0NvZGVjRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVyYXNlIGF1ZGlvIGNvZGVjIGluZm8gaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1wNGEuNDAuMzQuIGRlbXV4ZXIgd2lsbCBhdXRvZGV0ZWN0IGNvZGVjIGFuZCBmYWxsYmFjayB0byBtcGVnL2F1ZGlvXG4gICAgICAgIGlmIChicm9rZW5tcDRpbm1wMyAmJiBsZXZlbC5hdWRpb0NvZGVjICYmIGxldmVsLmF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4zNCcpICE9PSAtMSkge1xuICAgICAgICAgIGxldmVsLmF1ZGlvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxldmVsLmF1ZGlvQ29kZWMgfHwgbGV2ZWwuYXR0cnMgJiYgbGV2ZWwuYXR0cnMuQVVESU8pIHtcbiAgICAgICAgICBhdWRpb0NvZGVjRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWR1bmRhbnRMZXZlbElkID0gYml0cmF0ZVNldFtsZXZlbC5iaXRyYXRlXTtcbiAgICAgICAgaWYgKHJlZHVuZGFudExldmVsSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGJpdHJhdGVTZXRbbGV2ZWwuYml0cmF0ZV0gPSBsZXZlbHMwLmxlbmd0aDtcbiAgICAgICAgICBsZXZlbC51cmwgPSBbbGV2ZWwudXJsXTtcbiAgICAgICAgICBsZXZlbC51cmxJZCA9IDA7XG4gICAgICAgICAgbGV2ZWxzMC5wdXNoKGxldmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXZlbHMwW3JlZHVuZGFudExldmVsSWRdLnVybC5wdXNoKGxldmVsLnVybCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyByZW1vdmUgYXVkaW8tb25seSBsZXZlbCBpZiB3ZSBhbHNvIGhhdmUgbGV2ZWxzIHdpdGggYXVkaW8rdmlkZW8gY29kZWNzIHNpZ25hbGxlZFxuICAgICAgaWYgKHZpZGVvQ29kZWNGb3VuZCAmJiBhdWRpb0NvZGVjRm91bmQpIHtcbiAgICAgICAgbGV2ZWxzMC5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmIChsZXZlbC52aWRlb0NvZGVjKSB7XG4gICAgICAgICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVscyA9IGxldmVsczA7XG4gICAgICB9XG4gICAgICAvLyBvbmx5IGtlZXAgbGV2ZWwgd2l0aCBzdXBwb3J0ZWQgYXVkaW8vdmlkZW8gY29kZWNzXG4gICAgICBsZXZlbHMgPSBsZXZlbHMuZmlsdGVyKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICB2YXIgYXVkaW9Db2RlYyA9IGxldmVsLmF1ZGlvQ29kZWMsXG4gICAgICAgICAgICB2aWRlb0NvZGVjID0gbGV2ZWwudmlkZW9Db2RlYztcbiAgICAgICAgcmV0dXJuICghYXVkaW9Db2RlYyB8fCBjaGVja1N1cHBvcnRlZCgnYXVkaW8nLCBhdWRpb0NvZGVjKSkgJiYgKCF2aWRlb0NvZGVjIHx8IGNoZWNrU3VwcG9ydGVkKCd2aWRlbycsIHZpZGVvQ29kZWMpKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAvLyBzdGFydCBiaXRyYXRlIGlzIHRoZSBmaXJzdCBiaXRyYXRlIG9mIHRoZSBtYW5pZmVzdFxuICAgICAgICBiaXRyYXRlU3RhcnQgPSBsZXZlbHNbMF0uYml0cmF0ZTtcbiAgICAgICAgLy8gc29ydCBsZXZlbCBvbiBiaXRyYXRlXG4gICAgICAgIGxldmVscy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEuYml0cmF0ZSAtIGIuYml0cmF0ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgICAgICAgLy8gZmluZCBpbmRleCBvZiBmaXJzdCBsZXZlbCBpbiBzb3J0ZWQgbGV2ZWxzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGxldmVsc1tpXS5iaXRyYXRlID09PSBiaXRyYXRlU3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBpO1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdtYW5pZmVzdCBsb2FkZWQsJyArIGxldmVscy5sZW5ndGggKyAnIGxldmVsKHMpIGZvdW5kLCBmaXJzdCBiaXRyYXRlOicgKyBiaXRyYXRlU3RhcnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuTUFOSUZFU1RfUEFSU0VELCB7IGxldmVsczogbGV2ZWxzLCBmaXJzdExldmVsOiB0aGlzLl9maXJzdExldmVsLCBzdGF0czogZGF0YS5zdGF0cywgYXVkaW86IGF1ZGlvQ29kZWNGb3VuZCwgdmlkZW86IHZpZGVvQ29kZWNGb3VuZCwgYWx0QXVkaW86IGRhdGEuYXVkaW9UcmFja3MubGVuZ3RoID4gMCB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLCBmYXRhbDogdHJ1ZSwgdXJsOiBobHMudXJsLCByZWFzb246ICdubyBsZXZlbCB3aXRoIGNvbXBhdGlibGUgY29kZWNzIGZvdW5kIGluIG1hbmlmZXN0JyB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRMZXZlbEludGVybmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TGV2ZWxJbnRlcm5hbChuZXdMZXZlbCkge1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgICAgaWYgKG5ld0xldmVsID49IDAgJiYgbmV3TGV2ZWwgPCBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGV2ZWwgIT09IG5ld0xldmVsKSB7XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzd2l0Y2hpbmcgdG8gbGV2ZWwgJyArIG5ld0xldmVsKTtcbiAgICAgICAgICB0aGlzLl9sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICAgIHZhciBsZXZlbFByb3BlcnRpZXMgPSBsZXZlbHNbbmV3TGV2ZWxdO1xuICAgICAgICAgIGxldmVsUHJvcGVydGllcy5sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICAgIC8vIExFVkVMX1NXSVRDSCB0byBiZSBkZXByZWNhdGVkIGluIG5leHQgbWFqb3IgcmVsZWFzZVxuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuTEVWRUxfU1dJVENILCBsZXZlbFByb3BlcnRpZXMpO1xuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuTEVWRUxfU1dJVENISU5HLCBsZXZlbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tuZXdMZXZlbF0sXG4gICAgICAgICAgICBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGxvYWQgcGxheWxpc3QgZm9yIHRoaXMgbGV2ZWxcbiAgICAgICAgaWYgKCFsZXZlbERldGFpbHMgfHwgbGV2ZWxEZXRhaWxzLmxpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBsZXZlbCBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgICAgdmFyIHVybElkID0gbGV2ZWwudXJsSWQ7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5MRVZFTF9MT0FESU5HLCB7IHVybDogbGV2ZWwudXJsW3VybElkXSwgbGV2ZWw6IG5ld0xldmVsLCBpZDogdXJsSWQgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuT1RIRVJfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUiwgbGV2ZWw6IG5ld0xldmVsLCBmYXRhbDogZmFsc2UsIHJlYXNvbjogJ2ludmFsaWQgbGV2ZWwgaWR4JyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkVycm9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25FcnJvcihkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXRhaWxzID0gZGF0YS5kZXRhaWxzLFxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgIGxldmVsSWQgPSB2b2lkIDAsXG4gICAgICAgICAgbGV2ZWwgPSB2b2lkIDAsXG4gICAgICAgICAgbGV2ZWxFcnJvciA9IGZhbHNlO1xuICAgICAgLy8gdHJ5IHRvIHJlY292ZXIgbm90IGZhdGFsIGVycm9yc1xuICAgICAgc3dpdGNoIChkZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgX2Vycm9ycy5FcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SOlxuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgbGV2ZWxJZCA9IGRhdGEuZnJhZy5sZXZlbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgICAgICBsZXZlbElkID0gZGF0YS5jb250ZXh0LmxldmVsO1xuICAgICAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SOlxuICAgICAgICAgIGxldmVsSWQgPSBkYXRhLmxldmVsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogdHJ5IHRvIHN3aXRjaCB0byBhIHJlZHVuZGFudCBzdHJlYW0gaWYgYW55IGF2YWlsYWJsZS5cbiAgICAgICAqIGlmIG5vIHJlZHVuZGFudCBzdHJlYW0gYXZhaWxhYmxlLCBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gKGlmIGluIGF1dG8gbW9kZSBhbmQgY3VycmVudCBsZXZlbCBub3QgMClcbiAgICAgICAqIG90aGVyd2lzZSwgd2UgY2Fubm90IHJlY292ZXIgdGhpcyBuZXR3b3JrIGVycm9yIC4uLlxuICAgICAgICovXG4gICAgICBpZiAobGV2ZWxJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSWRdO1xuICAgICAgICBpZiAoIWxldmVsLmxvYWRFcnJvcikge1xuICAgICAgICAgIGxldmVsLmxvYWRFcnJvciA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV2ZWwubG9hZEVycm9yKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYW55IHJlZHVuZGFudCBzdHJlYW1zIGF2YWlsYWJsZSBhbmQgaWYgd2UgaGF2ZW4ndCB0cnkgdGhlbSBhbGwgKGxldmVsLmxvYWRFcnJvciBpcyByZXNldGVkIG9uIHN1Y2Nlc3NmdWwgZnJhZy9sZXZlbCBsb2FkLlxuICAgICAgICAvLyBpZiBsZXZlbC5sb2FkRXJyb3IgcmVhY2hlcyBuYlJlZHVuZGFudExldmVsIGl0IG1lYW5zIHRoYXQgd2UgdHJpZWQgdGhlbSBhbGwsIG5vIGhvcGUgID0+IGxldCdzIHN3aXRjaCBkb3duXG4gICAgICAgIHZhciBuYlJlZHVuZGFudExldmVsID0gbGV2ZWwudXJsLmxlbmd0aDtcbiAgICAgICAgaWYgKG5iUmVkdW5kYW50TGV2ZWwgPiAxICYmIGxldmVsLmxvYWRFcnJvciA8IG5iUmVkdW5kYW50TGV2ZWwpIHtcbiAgICAgICAgICBsZXZlbC51cmxJZCA9IChsZXZlbC51cmxJZCArIDEpICUgbmJSZWR1bmRhbnRMZXZlbDtcbiAgICAgICAgICBsZXZlbC5kZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2xldmVsIGNvbnRyb2xsZXIsJyArIGRldGFpbHMgKyAnIGZvciBsZXZlbCAnICsgbGV2ZWxJZCArICc6IHN3aXRjaGluZyB0byByZWR1bmRhbnQgc3RyZWFtIGlkICcgKyBsZXZlbC51cmxJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd2UgY291bGQgdHJ5IHRvIHJlY292ZXIgaWYgaW4gYXV0byBtb2RlIGFuZCBjdXJyZW50IGxldmVsIG5vdCBsb3dlc3QgbGV2ZWwgKDApXG4gICAgICAgICAgdmFyIHJlY292ZXJhYmxlID0gdGhpcy5fbWFudWFsTGV2ZWwgPT09IC0xICYmIGxldmVsSWQ7XG4gICAgICAgICAgaWYgKHJlY292ZXJhYmxlKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdsZXZlbCBjb250cm9sbGVyLCcgKyBkZXRhaWxzICsgJzogc3dpdGNoLWRvd24gZm9yIG5leHQgZnJhZ21lbnQnKTtcbiAgICAgICAgICAgIGhscy5uZXh0QXV0b0xldmVsID0gTWF0aC5tYXgoMCwgbGV2ZWxJZCAtIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGV2ZWwgJiYgbGV2ZWwuZGV0YWlscyAmJiBsZXZlbC5kZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2xldmVsIGNvbnRyb2xsZXIsJyArIGRldGFpbHMgKyAnIG9uIGxpdmUgc3RyZWFtLCBkaXNjYXJkJyk7XG4gICAgICAgICAgICBpZiAobGV2ZWxFcnJvcikge1xuICAgICAgICAgICAgICAvLyByZXNldCB0aGlzLl9sZXZlbCBzbyB0aGF0IGFub3RoZXIgY2FsbCB0byBzZXQgbGV2ZWwoKSB3aWxsIHJldHJpZ2dlciBhIGZyYWcgbG9hZFxuICAgICAgICAgICAgICB0aGlzLl9sZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG90aGVyIGVycm9ycyBhcmUgaGFuZGxlZCBieSBzdHJlYW0gY29udHJvbGxlclxuICAgICAgICAgIH0gZWxzZSBpZiAoZGV0YWlscyA9PT0gX2Vycm9ycy5FcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUiB8fCBkZXRhaWxzID09PSBfZXJyb3JzLkVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQpIHtcbiAgICAgICAgICAgIHZhciBtZWRpYSA9IGhscy5tZWRpYSxcblxuICAgICAgICAgICAgLy8gMC41IDogdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgZW5kXG4gICAgICAgICAgICBtZWRpYUJ1ZmZlcmVkID0gbWVkaWEgJiYgX2J1ZmZlckhlbHBlcjIuZGVmYXVsdC5pc0J1ZmZlcmVkKG1lZGlhLCBtZWRpYS5jdXJyZW50VGltZSkgJiYgX2J1ZmZlckhlbHBlcjIuZGVmYXVsdC5pc0J1ZmZlcmVkKG1lZGlhLCBtZWRpYS5jdXJyZW50VGltZSArIDAuNSk7XG4gICAgICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xuICAgICAgICAgICAgICB2YXIgcmV0cnlEZWxheSA9IGhscy5jb25maWcubGV2ZWxMb2FkaW5nUmV0cnlEZWxheTtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignbGV2ZWwgY29udHJvbGxlciwnICsgZGV0YWlscyArICcsIGJ1dCBtZWRpYSBidWZmZXJlZCwgcmV0cnkgaW4gJyArIHJldHJ5RGVsYXkgKyAnbXMnKTtcbiAgICAgICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5vbnRpY2ssIHJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIuZXJyb3IoJ2Nhbm5vdCByZWNvdmVyICcgKyBkZXRhaWxzICsgJyBlcnJvcicpO1xuICAgICAgICAgICAgICB0aGlzLl9sZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHJlZGlzcGF0Y2ggc2FtZSBlcnJvciBidXQgd2l0aCBmYXRhbCBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVzZXQgbGV2ZWwgbG9hZCBlcnJvciBjb3VudGVyIG9uIHN1Y2Nlc3NmdWwgZnJhZyBsb2FkZWRcblxuICB9LCB7XG4gICAga2V5OiAnb25GcmFnTG9hZGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GcmFnTG9hZGVkKGRhdGEpIHtcbiAgICAgIHZhciBmcmFnTG9hZGVkID0gZGF0YS5mcmFnO1xuICAgICAgaWYgKGZyYWdMb2FkZWQgJiYgZnJhZ0xvYWRlZC50eXBlID09PSAnbWFpbicpIHtcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW2ZyYWdMb2FkZWQubGV2ZWxdO1xuICAgICAgICBpZiAobGV2ZWwpIHtcbiAgICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25MZXZlbExvYWRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZGF0YSkge1xuICAgICAgdmFyIGxldmVsSWQgPSBkYXRhLmxldmVsO1xuICAgICAgLy8gb25seSBwcm9jZXNzIGxldmVsIGxvYWRlZCBldmVudHMgbWF0Y2hpbmcgd2l0aCBleHBlY3RlZCBsZXZlbFxuICAgICAgaWYgKGxldmVsSWQgPT09IHRoaXMuX2xldmVsKSB7XG4gICAgICAgIHZhciBjdXJMZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbElkXTtcbiAgICAgICAgLy8gcmVzZXQgbGV2ZWwgbG9hZCBlcnJvciBjb3VudGVyIG9uIHN1Y2Nlc3NmdWwgbGV2ZWwgbG9hZGVkXG4gICAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICAgIHZhciBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgICAgICAvLyBpZiBjdXJyZW50IHBsYXlsaXN0IGlzIGEgbGl2ZSBwbGF5bGlzdCwgYXJtIGEgdGltZXIgdG8gcmVsb2FkIGl0XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICB2YXIgcmVsb2FkSW50ZXJ2YWwgPSAxMDAwICogKG5ld0RldGFpbHMuYXZlcmFnZXRhcmdldGR1cmF0aW9uID8gbmV3RGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gOiBuZXdEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgY3VyRGV0YWlscyA9IGN1ckxldmVsLmRldGFpbHM7XG4gICAgICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5lbmRTTiA9PT0gY3VyRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgLy8gZm9sbG93IEhMUyBTcGVjLCBJZiB0aGUgY2xpZW50IHJlbG9hZHMgYSBQbGF5bGlzdCBmaWxlIGFuZCBmaW5kcyB0aGF0IGl0IGhhcyBub3RcbiAgICAgICAgICAgIC8vIGNoYW5nZWQgdGhlbiBpdCBNVVNUIHdhaXQgZm9yIGEgcGVyaW9kIG9mIG9uZS1oYWxmIHRoZSB0YXJnZXRcbiAgICAgICAgICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cbiAgICAgICAgICAgIHJlbG9hZEludGVydmFsIC89IDI7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3NhbWUgbGl2ZSBwbGF5bGlzdCwgcmVsb2FkIHR3aWNlIGZhc3RlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBkZWNyZW1lbnQgcmVsb2FkSW50ZXJ2YWwgd2l0aCBsZXZlbCBsb2FkaW5nIGRlbGF5XG4gICAgICAgICAgcmVsb2FkSW50ZXJ2YWwgLT0gcGVyZm9ybWFuY2Uubm93KCkgLSBkYXRhLnN0YXRzLnRyZXF1ZXN0O1xuICAgICAgICAgIC8vIGluIGFueSBjYXNlLCBkb24ndCByZWxvYWQgbW9yZSB0aGFuIGV2ZXJ5IHNlY29uZFxuICAgICAgICAgIHJlbG9hZEludGVydmFsID0gTWF0aC5tYXgoMTAwMCwgTWF0aC5yb3VuZChyZWxvYWRJbnRlcnZhbCkpO1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbGl2ZSBwbGF5bGlzdCwgcmVsb2FkIGluICcgKyByZWxvYWRJbnRlcnZhbCArICcgbXMnKTtcbiAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCh0aGlzLm9udGljaywgcmVsb2FkSW50ZXJ2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICB2YXIgbGV2ZWxJZCA9IHRoaXMuX2xldmVsO1xuICAgICAgaWYgKGxldmVsSWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNhbmxvYWQpIHtcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSWRdLFxuICAgICAgICAgICAgdXJsSWQgPSBsZXZlbC51cmxJZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkxFVkVMX0xPQURJTkcsIHsgdXJsOiBsZXZlbC51cmxbdXJsSWRdLCBsZXZlbDogbGV2ZWxJZCwgaWQ6IHVybElkIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xldmVscycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xldmVsJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuICAgICAgaWYgKGxldmVscyAmJiBsZXZlbHMubGVuZ3RoID4gbmV3TGV2ZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xldmVsICE9PSBuZXdMZXZlbCB8fCBsZXZlbHNbbmV3TGV2ZWxdLmRldGFpbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuc2V0TGV2ZWxJbnRlcm5hbChuZXdMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtYW51YWxMZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFudWFsTGV2ZWw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgdGhpcy5fbWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgICB0aGlzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmlyc3RMZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICB0aGlzLl9maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RhcnRMZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAvLyBobHMuc3RhcnRMZXZlbCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgY29uZmlnLnN0YXJ0TGV2ZWxcbiAgICAgIC8vIGlmIG5vbmUgb2YgdGhlc2UgdmFsdWVzIGFyZSBkZWZpbmVkLCBmYWxsYmFjayBvbiB0aGlzLl9maXJzdExldmVsIChmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiB2YXJpYW50IG1hbmlmZXN0KVxuICAgICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgY29uZmlnU3RhcnRMZXZlbCA9IHRoaXMuaGxzLmNvbmZpZy5zdGFydExldmVsO1xuICAgICAgICBpZiAoY29uZmlnU3RhcnRMZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbmZpZ1N0YXJ0TGV2ZWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydExldmVsO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduZXh0TG9hZExldmVsJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLl9tYW51YWxMZXZlbCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hbnVhbExldmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXh0TGV2ZWwpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgICBpZiAodGhpcy5fbWFudWFsTGV2ZWwgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExldmVsQ29udHJvbGxlcjtcbn0oX2V2ZW50SGFuZGxlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExldmVsQ29udHJvbGxlcjtcblxufSx7XCIzMVwiOjMxLFwiMzJcIjozMixcIjMzXCI6MzMsXCIzNVwiOjM1LFwiNTBcIjo1MH1dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9iaW5hcnlTZWFyY2ggPSBfZGVyZXFfKDQ2KTtcblxudmFyIF9iaW5hcnlTZWFyY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmluYXJ5U2VhcmNoKTtcblxudmFyIF9idWZmZXJIZWxwZXIgPSBfZGVyZXFfKDM1KTtcblxudmFyIF9idWZmZXJIZWxwZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnVmZmVySGVscGVyKTtcblxudmFyIF9kZW11eGVyID0gX2RlcmVxXygyNSk7XG5cbnZhciBfZGVtdXhlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZW11eGVyKTtcblxudmFyIF9ldmVudHMgPSBfZGVyZXFfKDMzKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9ldmVudEhhbmRsZXIgPSBfZGVyZXFfKDMyKTtcblxudmFyIF9ldmVudEhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRIYW5kbGVyKTtcblxudmFyIF9sZXZlbEhlbHBlciA9IF9kZXJlcV8oMzYpO1xuXG52YXIgX2xldmVsSGVscGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xldmVsSGVscGVyKTtcblxudmFyIF90aW1lUmFuZ2VzID0gX2RlcmVxXyg1MSk7XG5cbnZhciBfdGltZVJhbmdlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW1lUmFuZ2VzKTtcblxudmFyIF9lcnJvcnMgPSBfZGVyZXFfKDMxKTtcblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3RyZWFtIENvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBTdGF0ZSA9IHtcbiAgU1RPUFBFRDogJ1NUT1BQRUQnLFxuICBJRExFOiAnSURMRScsXG4gIEtFWV9MT0FESU5HOiAnS0VZX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkc6ICdGUkFHX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTogJ0ZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZJyxcbiAgV0FJVElOR19MRVZFTDogJ1dBSVRJTkdfTEVWRUwnLFxuICBQQVJTSU5HOiAnUEFSU0lORycsXG4gIFBBUlNFRDogJ1BBUlNFRCcsXG4gIEJVRkZFUl9GTFVTSElORzogJ0JVRkZFUl9GTFVTSElORycsXG4gIEVOREVEOiAnRU5ERUQnLFxuICBFUlJPUjogJ0VSUk9SJ1xufTtcblxudmFyIFN0cmVhbUNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0V2ZW50SGFuZGxlcikge1xuICBfaW5oZXJpdHMoU3RyZWFtQ29udHJvbGxlciwgX0V2ZW50SGFuZGxlcik7XG5cbiAgZnVuY3Rpb24gU3RyZWFtQ29udHJvbGxlcihobHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyZWFtQ29udHJvbGxlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3RyZWFtQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN0cmVhbUNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIGhscywgX2V2ZW50czIuZGVmYXVsdC5NRURJQV9BVFRBQ0hFRCwgX2V2ZW50czIuZGVmYXVsdC5NRURJQV9ERVRBQ0hJTkcsIF9ldmVudHMyLmRlZmF1bHQuTUFOSUZFU1RfTE9BRElORywgX2V2ZW50czIuZGVmYXVsdC5NQU5JRkVTVF9QQVJTRUQsIF9ldmVudHMyLmRlZmF1bHQuTEVWRUxfTE9BREVELCBfZXZlbnRzMi5kZWZhdWx0LktFWV9MT0FERUQsIF9ldmVudHMyLmRlZmF1bHQuRlJBR19MT0FERUQsIF9ldmVudHMyLmRlZmF1bHQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTSU5HX0RBVEEsIF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTRUQsIF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIF9ldmVudHMyLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENISU5HLCBfZXZlbnRzMi5kZWZhdWx0LkFVRElPX1RSQUNLX1NXSVRDSEVELCBfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9DUkVBVEVELCBfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9BUFBFTkRFRCwgX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfRkxVU0hFRCkpO1xuXG4gICAgX3RoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICBfdGhpcy5hdWRpb0NvZGVjU3dhcCA9IGZhbHNlO1xuICAgIF90aGlzLnRpY2tzID0gMDtcbiAgICBfdGhpcy5fc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIF90aGlzLm9udGljayA9IF90aGlzLnRpY2suYmluZChfdGhpcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0cmVhbUNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIF9ldmVudEhhbmRsZXIyLmRlZmF1bHQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0YXJ0TG9hZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7XG4gICAgICBpZiAodGhpcy5sZXZlbHMpIHtcbiAgICAgICAgdmFyIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGV2ZWwgPSAtMTtcbiAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgICAgIC8vIGRldGVybWluZSBsb2FkIGxldmVsXG4gICAgICAgICAgdmFyIHN0YXJ0TGV2ZWwgPSBobHMuc3RhcnRMZXZlbDtcbiAgICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIC0xIDogZ3Vlc3Mgc3RhcnQgTGV2ZWwgYnkgZG9pbmcgYSBiaXRyYXRlIHRlc3QgYnkgbG9hZGluZyBmaXJzdCBmcmFnbWVudCBvZiBsb3dlc3QgcXVhbGl0eSBsZXZlbFxuICAgICAgICAgICAgc3RhcnRMZXZlbCA9IDA7XG4gICAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc2V0IG5ldyBsZXZlbCB0byBwbGF5bGlzdCBsb2FkZXIgOiB0aGlzIHdpbGwgdHJpZ2dlciBzdGFydCBsZXZlbCBsb2FkXG4gICAgICAgICAgLy8gaGxzLm5leHRMb2FkTGV2ZWwgcmVtYWlucyB1bnRpbCBpdCBpcyBzZXQgdG8gYSBuZXcgdmFsdWUgb3IgdW50aWwgYSBuZXcgZnJhZyBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkXG4gICAgICAgICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gc3RhcnRMZXZlbDtcbiAgICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgc3RhcnRQb3NpdGlvbiB1bmRlZmluZWQgYnV0IGxhc3RDdXJyZW50VGltZSBzZXQsIHNldCBzdGFydFBvc2l0aW9uIHRvIGxhc3QgY3VycmVudFRpbWVcbiAgICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ292ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQCcgKyBsYXN0Q3VycmVudFRpbWUudG9GaXhlZCgzKSk7XG4gICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IGxhc3RDdXJyZW50VGltZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2Nhbm5vdCBzdGFydCBsb2FkaW5nIGFzIG1hbmlmZXN0IG5vdCBwYXJzZWQgeWV0Jyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0b3BMb2FkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcExvYWQoKSB7XG4gICAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICBpZiAoZnJhZy5sb2FkZXIpIHtcbiAgICAgICAgICBmcmFnLmxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICB0aGlzLnRpY2tzKys7XG4gICAgICBpZiAodGhpcy50aWNrcyA9PT0gMSkge1xuICAgICAgICB0aGlzLmRvVGljaygpO1xuICAgICAgICBpZiAodGhpcy50aWNrcyA+IDEpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMudGljaywgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aWNrcyA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZG9UaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9UaWNrKCkge1xuICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgU3RhdGUuRVJST1I6XG4gICAgICAgICAgLy9kb24ndCBkbyBhbnl0aGluZyBpbiBlcnJvciBzdGF0ZSB0byBhdm9pZCBicmVha2luZyBmdXJ0aGVyIC4uLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN0YXRlLkJVRkZFUl9GTFVTSElORzpcbiAgICAgICAgICAvLyBpbiBidWZmZXIgZmx1c2hpbmcgc3RhdGUsIHJlc2V0IGZyYWdMb2FkRXJyb3IgY291bnRlclxuICAgICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3RhdGUuSURMRTpcbiAgICAgICAgICAvLyB3aGVuIHRoaXMgcmV0dXJucyBmYWxzZSB0aGVyZSB3YXMgYW4gZXJyb3IgYW5kIHdlIHNoYWxsIHJldHVybiBpbW1lZGlhdGx5XG4gICAgICAgICAgLy8gZnJvbSBjdXJyZW50IHRpY2tcbiAgICAgICAgICBpZiAoIXRoaXMuX2RvVGlja0lkbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0xFVkVMOlxuICAgICAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdO1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgICAgaWYgKGxldmVsICYmIGxldmVsLmRldGFpbHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgbm93ID49IHJldHJ5RGF0ZSB8fCB0aGlzLm1lZGlhICYmIHRoaXMubWVkaWEuc2Vla2luZykge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdtZWRpYUNvbnRyb2xsZXI6IHJldHJ5RGF0ZSByZWFjaGVkLCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlJyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3RhdGUuRVJST1I6XG4gICAgICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcbiAgICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkc6XG4gICAgICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcbiAgICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICAgIGNhc2UgU3RhdGUuRU5ERUQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBjaGVjayBidWZmZXJcbiAgICAgIHRoaXMuX2NoZWNrQnVmZmVyKCk7XG4gICAgICAvLyBjaGVjay91cGRhdGUgY3VycmVudCBmcmFnbWVudFxuICAgICAgdGhpcy5fY2hlY2tGcmFnbWVudENoYW5nZWQoKTtcbiAgICB9XG5cbiAgICAvLyBJcm9uaWNhbGx5IHRoZSBcImlkbGVcIiBzdGF0ZSBpcyB0aGUgb24gd2UgZG8gdGhlIG1vc3QgbG9naWMgaW4gaXQgc2VlbXMgLi4uLlxuICAgIC8vIE5PVEU6IE1heWJlIHdlIGNvdWxkIHJhdGhlciBzY2hlZHVsZSBhIGNoZWNrIGZvciBidWZmZXIgbGVuZ3RoIGFmdGVyIGhhbGYgb2YgdGhlIGN1cnJlbnRseVxuICAgIC8vICAgICAgIHBsYXllZCBzZWdtZW50LCBvciBvbiBwYXVzZS9wbGF5L3NlZWsgaW5zdGVhZCBvZiBuYWl2ZWx5IGNoZWNraW5nIGV2ZXJ5IDEwMG1zP1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZG9UaWNrSWRsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kb1RpY2tJZGxlKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgIGNvbmZpZyA9IGhscy5jb25maWcsXG4gICAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EXG4gICAgICAvLyBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIGRpc2FibGVcbiAgICAgIC8vIGV4aXQgbG9vcFxuICAgICAgLy8gPT4gaWYgc3RhcnQgbGV2ZWwgbG9hZGVkIGFuZCBtZWRpYSBub3QgYXR0YWNoZWQgYnV0IHN0YXJ0IGZyYWcgcHJlZmV0Y2ggaXMgZW5hYmxlZCBhbmQgc3RhcnQgZnJhZyBub3QgcmVxdWVzdGVkIHlldCwgd2Ugd2lsbCBub3QgZXhpdCBsb29wXG4gICAgICBpZiAodGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IHVuZGVmaW5lZCAmJiAhbWVkaWEgJiYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBoYXZlIG5vdCB5ZXQgbG9hZGVkIGFueSBmcmFnbWVudCwgc3RhcnQgbG9hZGluZyBmcm9tIHN0YXJ0IHBvc2l0aW9uXG4gICAgICB2YXIgcG9zID0gdm9pZCAwO1xuICAgICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgcG9zID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSB0aGlzLm5leHRMb2FkUG9zaXRpb247XG4gICAgICB9XG4gICAgICAvLyBkZXRlcm1pbmUgbmV4dCBsb2FkIGxldmVsXG4gICAgICB2YXIgbGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCxcbiAgICAgICAgICBsZXZlbEluZm8gPSB0aGlzLmxldmVsc1tsZXZlbF0sXG4gICAgICAgICAgbGV2ZWxCaXRyYXRlID0gbGV2ZWxJbmZvLmJpdHJhdGUsXG4gICAgICAgICAgbWF4QnVmTGVuID0gdm9pZCAwO1xuXG4gICAgICAvLyBjb21wdXRlIG1heCBCdWZmZXIgTGVuZ3RoIHRoYXQgd2UgY291bGQgZ2V0IGZyb20gdGhpcyBsb2FkIGxldmVsLCBiYXNlZCBvbiBsZXZlbCBiaXRyYXRlLiBkb24ndCBidWZmZXIgbW9yZSB0aGFuIDYwIE1CIGFuZCBtb3JlIHRoYW4gMzBzXG4gICAgICBpZiAobGV2ZWxCaXRyYXRlKSB7XG4gICAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWF4KDggKiBjb25maWcubWF4QnVmZmVyU2l6ZSAvIGxldmVsQml0cmF0ZSwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgfVxuICAgICAgbWF4QnVmTGVuID0gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcblxuICAgICAgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmQgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgICAgLy8gZW5zdXJlIHVwIHRvIGBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoYCBvZiBidWZmZXIgdXBmcm9udFxuXG4gICAgICB2YXIgYnVmZmVySW5mbyA9IF9idWZmZXJIZWxwZXIyLmRlZmF1bHQuYnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IG1lZGlhLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKSxcbiAgICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbjtcbiAgICAgIC8vIFN0YXkgaWRsZSBpZiB3ZSBhcmUgc3RpbGwgd2l0aCBidWZmZXIgbWFyZ2luc1xuICAgICAgaWYgKGJ1ZmZlckxlbiA+PSBtYXhCdWZMZW4pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudCAuLi5cbiAgICAgIF9sb2dnZXIubG9nZ2VyLnRyYWNlKCdidWZmZXIgbGVuZ3RoIG9mICcgKyBidWZmZXJMZW4udG9GaXhlZCgzKSArICcgaXMgYmVsb3cgbWF4IG9mICcgKyBtYXhCdWZMZW4udG9GaXhlZCgzKSArICcuIGNoZWNraW5nIGZvciBtb3JlIHBheWxvYWQgLi4uJyk7XG5cbiAgICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXG4gICAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcblxuICAgICAgdmFyIGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuICAgICAgLy8gaWYgbGV2ZWwgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciBsZXZlbCByZXRyaWV2YWxcbiAgICAgIC8vIGlmIGxpdmUgcGxheWxpc3QsIGVuc3VyZSB0aGF0IG5ldyBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgdG8gYXZvaWQgbG9hZGluZy90cnkgdG8gbG9hZFxuICAgICAgLy8gYSB1c2VsZXNzIGFuZCBvdXRkYXRlZCBmcmFnbWVudCAodGhhdCBtaWdodCBldmVuIGludHJvZHVjZSBsb2FkIGVycm9yIGlmIGl0IGlzIGFscmVhZHkgb3V0IG9mIHRoZSBsaXZlIHBsYXlsaXN0KVxuICAgICAgaWYgKHR5cGVvZiBsZXZlbERldGFpbHMgPT09ICd1bmRlZmluZWQnIHx8IGxldmVsRGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBsZXZlbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGp1c3QgZ290IGRvbmUgbG9hZGluZyB0aGUgZmluYWwgZnJhZ21lbnQsIGNoZWNrIGlmIHdlIG5lZWQgdG8gZmluYWxpemUgbWVkaWEgc3RyZWFtXG4gICAgICB2YXIgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG4gICAgICBpZiAoIWxldmVsRGV0YWlscy5saXZlICYmIGZyYWdQcmV2aW91cyAmJiBmcmFnUHJldmlvdXMuc24gPT09IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAvLyBpZiBldmVyeXRoaW5nIChhbG1vc3QpIHRpbCB0aGUgZW5kIGlzIGJ1ZmZlcmVkLCBsZXQncyBzaWduYWwgZW9zXG4gICAgICAgIC8vIHdlIGRvbid0IGNvbXBhcmUgZXhhY3RseSBtZWRpYS5kdXJhdGlvbiA9PT0gYnVmZmVySW5mby5lbmQgYXMgdGhlcmUgY291bGQgYmUgc29tZSBzdWJ0bGUgbWVkaWEgZHVyYXRpb24gZGlmZmVyZW5jZVxuICAgICAgICAvLyB1c2luZyBoYWxmIGZyYWcgZHVyYXRpb24gc2hvdWxkIGhlbHAgY29wZSB3aXRoIHRoZXNlIGNhc2VzLlxuICAgICAgICAvLyBhbHNvIGNvcGUgd2l0aCBhbG1vc3QgemVybyBsYXN0IGZyYWcgZHVyYXRpb24gKG1heCBsYXN0IGZyYWcgZHVyYXRpb24gd2l0aCAyMDBtcykgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL2RhaWx5bW90aW9uL2hscy5qcy9wdWxsLzY1N1xuICAgICAgICBpZiAobWVkaWEuZHVyYXRpb24gLSBNYXRoLm1heChidWZmZXJJbmZvLmVuZCwgZnJhZ1ByZXZpb3VzLnN0YXJ0KSA8PSBNYXRoLm1heCgwLjIsIGZyYWdQcmV2aW91cy5kdXJhdGlvbiAvIDIpKSB7XG4gICAgICAgICAgLy8gRmluYWxpemUgdGhlIG1lZGlhIHN0cmVhbVxuICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgaWYgKHRoaXMuYWx0QXVkaW8pIHtcbiAgICAgICAgICAgIGRhdGEudHlwZSA9ICd2aWRlbyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfRU9TLCBkYXRhKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRU5ERUQ7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgd2UgaGF2ZSB0aGUgbGV2ZWxEZXRhaWxzIGZvciB0aGUgc2VsZWN0ZWQgdmFyaWFudCwgbGV0cyBjb250aW51ZSBlbnJpY2hlbiBvdXIgc3RyZWFtIChsb2FkIGtleXMvZnJhZ21lbnRzIG9yIHRyaWdnZXIgRU9TLCBldGMuLilcbiAgICAgIHJldHVybiB0aGlzLl9mZXRjaFBheWxvYWRPckVvcyhwb3MsIGJ1ZmZlckluZm8sIGxldmVsRGV0YWlscyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2ZldGNoUGF5bG9hZE9yRW9zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZldGNoUGF5bG9hZE9yRW9zKHBvcywgYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgICB2YXIgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXMsXG4gICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsLFxuICAgICAgICAgIGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgICAgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG5cbiAgICAgIC8vIGVtcHR5IHBsYXlsaXN0XG4gICAgICBpZiAoZnJhZ0xlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgICB2YXIgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQsXG4gICAgICAgICAgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uZHVyYXRpb24sXG4gICAgICAgICAgYnVmZmVyRW5kID0gYnVmZmVySW5mby5lbmQsXG4gICAgICAgICAgZnJhZyA9IHZvaWQgMDtcblxuICAgICAgaWYgKGxldmVsRGV0YWlscy5pbml0U2VnbWVudCAmJiAhbGV2ZWxEZXRhaWxzLmluaXRTZWdtZW50LmRhdGEpIHtcbiAgICAgICAgZnJhZyA9IGxldmVsRGV0YWlscy5pbml0U2VnbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluIGNhc2Ugb2YgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHJlcXVlc3RlZCBwb3NpdGlvbiBpcyBub3QgbG9jYXRlZCBiZWZvcmUgcGxheWxpc3Qgc3RhcnRcbiAgICAgICAgaWYgKGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgdmFyIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplID0gdGhpcy5jb25maWcuaW5pdGlhbExpdmVNYW5pZmVzdFNpemU7XG4gICAgICAgICAgaWYgKGZyYWdMZW4gPCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSkge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignQ2FuIG5vdCBzdGFydCBwbGF5YmFjayBvZiBhIGxldmVsLCByZWFzb246IG5vdCBlbm91Z2ggZnJhZ21lbnRzICcgKyBmcmFnTGVuICsgJyA8ICcgKyBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnJhZyA9IHRoaXMuX2Vuc3VyZUZyYWdtZW50QXRMaXZlUG9pbnQobGV2ZWxEZXRhaWxzLCBidWZmZXJFbmQsIHN0YXJ0LCBlbmQsIGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBmcmFnTGVuKTtcbiAgICAgICAgICAvLyBpZiBpdCBleHBsaWNpdGVseSByZXR1cm5zIG51bGwgZG9uJ3QgbG9hZCBhbnkgZnJhZ21lbnQgYW5kIGV4aXQgZnVuY3Rpb24gbm93XG4gICAgICAgICAgaWYgKGZyYWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVm9EIHBsYXlsaXN0OiBpZiBidWZmZXJFbmQgYmVmb3JlIHN0YXJ0IG9mIHBsYXlsaXN0LCBsb2FkIGZpcnN0IGZyYWdtZW50XG4gICAgICAgICAgaWYgKGJ1ZmZlckVuZCA8IHN0YXJ0KSB7XG4gICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIGZyYWcgPSB0aGlzLl9maW5kRnJhZ21lbnQoc3RhcnQsIGZyYWdQcmV2aW91cywgZnJhZ0xlbiwgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkRnJhZ21lbnRPcktleShmcmFnLCBsZXZlbCwgbGV2ZWxEZXRhaWxzLCBwb3MsIGJ1ZmZlckVuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfZW5zdXJlRnJhZ21lbnRBdExpdmVQb2ludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbnN1cmVGcmFnbWVudEF0TGl2ZVBvaW50KGxldmVsRGV0YWlscywgYnVmZmVyRW5kLCBzdGFydCwgZW5kLCBmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgZnJhZ0xlbikge1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZyxcbiAgICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICAgIHZhciBmcmFnID0gdm9pZCAwO1xuXG4gICAgICAvLyBjaGVjayBpZiByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgd2l0aGluIHNlZWthYmxlIGJvdW5kYXJpZXMgOlxuICAgICAgLy9sb2dnZXIubG9nKGBzdGFydC9wb3MvYnVmRW5kL3NlZWtpbmc6JHtzdGFydC50b0ZpeGVkKDMpfS8ke3Bvcy50b0ZpeGVkKDMpfS8ke2J1ZmZlckVuZC50b0ZpeGVkKDMpfS8ke3RoaXMubWVkaWEuc2Vla2luZ31gKTtcbiAgICAgIHZhciBtYXhMYXRlbmN5ID0gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDogY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcblxuICAgICAgaWYgKGJ1ZmZlckVuZCA8IE1hdGgubWF4KHN0YXJ0IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGVuZCAtIG1heExhdGVuY3kpKSB7XG4gICAgICAgIHZhciBsaXZlU3luY1Bvc2l0aW9uID0gdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHN0YXJ0LCBsZXZlbERldGFpbHMpO1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2J1ZmZlciBlbmQ6ICcgKyBidWZmZXJFbmQudG9GaXhlZCgzKSArICcgaXMgbG9jYXRlZCB0b28gZmFyIGZyb20gdGhlIGVuZCBvZiBsaXZlIHNsaWRpbmcgcGxheWxpc3QsIHJlc2V0IGN1cnJlbnRUaW1lIHRvIDogJyArIGxpdmVTeW5jUG9zaXRpb24udG9GaXhlZCgzKSk7XG4gICAgICAgIGJ1ZmZlckVuZCA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlICYmIG1lZGlhLmR1cmF0aW9uID4gbGl2ZVN5bmNQb3NpdGlvbikge1xuICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiBlbmQgb2YgYnVmZmVyIGdyZWF0ZXIgdGhhbiBsaXZlIGVkZ2UsIGRvbid0IGxvYWQgYW55IGZyYWdtZW50XG4gICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpZiBsaXZlIHBsYXlsaXN0IGludGVybWl0dGVudGx5IHNsaWRlcyBpbiB0aGUgcGFzdC5cbiAgICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjEsMTgyNTgwMTY3XVxuICAgICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MiwxODI1ODAxNjldXG4gICAgICAvLyBMb2FkaW5nIDE4MjU4MDE2OCBvZiBbMTgyNTgwMTYyICwxODI1ODAxNjldLGxldmVsIDEgLi5cbiAgICAgIC8vIExvYWRpbmcgMTgyNTgwMTY5IG9mIFsxODI1ODAxNjIgLDE4MjU4MDE2OV0sbGV2ZWwgMSAuLlxuICAgICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MiwxODI1ODAxNjhdIDw9PT09PT09PT09PT09IGhlcmUgd2Ugc2hvdWxkIGhhdmUgYnVmZmVyRW5kID4gZW5kLiBpbiB0aGF0IGNhc2UgYnJlYWsgdG8gYXZvaWQgcmVsb2FkaW5nIDE4MjU4MDE2OFxuICAgICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2NCwxODI1ODAxNzFdXG4gICAgICAvL1xuICAgICAgLy8gZG9uJ3QgcmV0dXJuIG51bGwgaW4gY2FzZSBtZWRpYSBub3QgbG9hZGVkIHlldCAocmVhZHlzdGF0ZSA9PT0gMClcbiAgICAgIGlmIChsZXZlbERldGFpbHMuUFRTS25vd24gJiYgYnVmZmVyRW5kID4gZW5kICYmIG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiAhbGV2ZWxEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgIC8qIHdlIGFyZSBzd2l0Y2hpbmcgbGV2ZWwgb24gbGl2ZSBwbGF5bGlzdCwgYnV0IHdlIGRvbid0IGhhdmUgYW55IFBUUyBpbmZvIGZvciB0aGF0IHF1YWxpdHkgbGV2ZWwgLi4uXG4gICAgICAgICAgIHRyeSB0byBsb2FkIGZyYWcgbWF0Y2hpbmcgd2l0aCBuZXh0IFNOLlxuICAgICAgICAgICBldmVuIGlmIFNOIGFyZSBub3Qgc3luY2hyb25pemVkIGJldHdlZW4gcGxheWxpc3RzLCBsb2FkaW5nIHRoaXMgZnJhZyB3aWxsIGhlbHAgdXNcbiAgICAgICAgICAgY29tcHV0ZSBwbGF5bGlzdCBzbGlkaW5nIGFuZCBmaW5kIHRoZSByaWdodCBvbmUgYWZ0ZXIgaW4gY2FzZSBpdCB3YXMgbm90IHRoZSByaWdodCBjb25zZWN1dGl2ZSBvbmUgKi9cbiAgICAgICAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgICAgICAgIHZhciB0YXJnZXRTTiA9IGZyYWdQcmV2aW91cy5zbiArIDE7XG4gICAgICAgICAgaWYgKHRhcmdldFNOID49IGxldmVsRGV0YWlscy5zdGFydFNOICYmIHRhcmdldFNOIDw9IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1t0YXJnZXRTTiAtIGxldmVsRGV0YWlscy5zdGFydFNOXTtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBuZXh0IFNOOiAnICsgZnJhZy5zbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZnJhZykge1xuICAgICAgICAgIC8qIHdlIGhhdmUgbm8gaWRlYSBhYm91dCB3aGljaCBmcmFnbWVudCBzaG91bGQgYmUgbG9hZGVkLlxuICAgICAgICAgICAgIHNvIGxldCdzIGxvYWQgbWlkIGZyYWdtZW50LiBpdCB3aWxsIGhlbHAgY29tcHV0aW5nIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGZpbmQgdGhlIHJpZ2h0IG9uZVxuICAgICAgICAgICovXG4gICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tNYXRoLm1pbihmcmFnTGVuIC0gMSwgTWF0aC5yb3VuZChmcmFnTGVuIC8gMikpXTtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgdW5rbm93biwgbG9hZCBtaWRkbGUgZnJhZyA6ICcgKyBmcmFnLnNuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2ZpbmRGcmFnbWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kRnJhZ21lbnQoc3RhcnQsIGZyYWdQcmV2aW91cywgZnJhZ0xlbiwgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgICAgdmFyIGZyYWcgPSB2b2lkIDA7XG4gICAgICB2YXIgZm91bmRGcmFnID0gdm9pZCAwO1xuICAgICAgdmFyIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgIHZhciBmcmFnTmV4dCA9IGZyYWdQcmV2aW91cyA/IGZyYWdtZW50c1tmcmFnUHJldmlvdXMuc24gLSBmcmFnbWVudHNbMF0uc24gKyAxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QgPSBmdW5jdGlvbiBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoY2FuZGlkYXRlKSB7XG4gICAgICAgIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgICAgICAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXG4gICAgICAgIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXG4gICAgICAgIC8vIGZyYWdbw5hdIDogWzAsMTBdXG4gICAgICAgIC8vIGZyYWdbMV0gOiBbMTAsMjBdXG4gICAgICAgIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcbiAgICAgICAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgICAgICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cbiAgICAgICAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAgICAgICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcbiAgICAgICAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgLy9sb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAgICAgICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xuICAgICAgICB2YXIgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uKTtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA8PSBidWZmZXJFbmQpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSAvLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxuICAgICAgICBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH07XG5cbiAgICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcbiAgICAgICAgaWYgKGJ1ZmZlckVuZCA+IGVuZCAtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXG4gICAgICAgIGlmIChmcmFnTmV4dCAmJiAhZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGZyYWdOZXh0KSkge1xuICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdOZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvdW5kRnJhZyA9IF9iaW5hcnlTZWFyY2gyLmRlZmF1bHQuc2VhcmNoKGZyYWdtZW50cywgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgICB9XG4gICAgICBpZiAoZm91bmRGcmFnKSB7XG4gICAgICAgIGZyYWcgPSBmb3VuZEZyYWc7XG4gICAgICAgIHZhciBjdXJTTklkeCA9IGZyYWcuc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgICAgdmFyIHNhbWVMZXZlbCA9IGZyYWdQcmV2aW91cyAmJiBmcmFnLmxldmVsID09PSBmcmFnUHJldmlvdXMubGV2ZWw7XG4gICAgICAgIHZhciBwcmV2RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCAtIDFdO1xuICAgICAgICB2YXIgbmV4dEZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHggKyAxXTtcbiAgICAgICAgLy9sb2dnZXIubG9nKCdmaW5kIFNOIG1hdGNoaW5nIHdpdGggcG9zOicgKyAgYnVmZmVyRW5kICsgJzonICsgZnJhZy5zbik7XG4gICAgICAgIGlmIChzYW1lTGV2ZWwgJiYgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuKSB7XG4gICAgICAgICAgaWYgKGZyYWcuc24gPCBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICAgIHZhciBkZWx0YVBUUyA9IGZyYWdQcmV2aW91cy5kZWx0YVBUUztcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc2lnbmlmaWNhbnQgZGVsdGEgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8sIGxhcmdlciB0aGFuIG1heCBhbGxvd2VkIGhvbGUsXG4gICAgICAgICAgICAvLyBhbmQgaWYgcHJldmlvdXMgcmVtdXhlZCBmcmFnbWVudCBkaWQgbm90IHN0YXJ0IHdpdGggYSBrZXlmcmFtZS4gKGZyYWdQcmV2aW91cy5kcm9wcGVkKVxuICAgICAgICAgICAgLy8gbGV0J3MgdHJ5IHRvIGxvYWQgcHJldmlvdXMgZnJhZ21lbnQgYWdhaW4gdG8gZ2V0IGxhc3Qga2V5ZnJhbWVcbiAgICAgICAgICAgIC8vIHRoZW4gd2Ugd2lsbCByZWxvYWQgYWdhaW4gY3VycmVudCBmcmFnbWVudCAodGhhdCB3YXkgd2Ugc2hvdWxkIGJlIGFibGUgdG8gZmlsbCB0aGUgYnVmZmVyIGhvbGUgLi4uKVxuICAgICAgICAgICAgaWYgKGRlbHRhUFRTICYmIGRlbHRhUFRTID4gY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgZnJhZ1ByZXZpb3VzLmRyb3BwZWQgJiYgY3VyU05JZHgpIHtcbiAgICAgICAgICAgICAgZnJhZyA9IHByZXZGcmFnO1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdTTiBqdXN0IGxvYWRlZCwgd2l0aCBsYXJnZSBQVFMgZ2FwIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBtYXliZSBmcmFnIGlzIG5vdCBzdGFydGluZyB3aXRoIGEga2V5ZnJhbWUgPyBsb2FkIHByZXZpb3VzIG9uZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpcycpO1xuICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgcHJldmlvdXMgZnJhZyBsb2FkIGNvdW50ZXIgdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3Igd2hlbiBuZXh0IGZyYWdtZW50IHdpbGwgZ2V0IHJlbG9hZGVkXG4gICAgICAgICAgICAgIGZyYWdQcmV2aW91cy5sb2FkQ291bnRlci0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ1NOIGp1c3QgbG9hZGVkLCBsb2FkIG5leHQgb25lOiAnICsgZnJhZy5zbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmcmFnLmRyb3BwZWQgJiYgIXNhbWVMZXZlbCkge1xuICAgICAgICAgIC8vIE9ubHkgYmFja3RyYWNrIGEgbWF4IG9mIDEgY29uc2VjdXRpdmUgZnJhZ21lbnQgdG8gcHJldmVudCBzbGlkaW5nIGJhY2sgdG9vIGZhciB3aGVuIGxpdHRsZSBvciBubyBmcmFncyBzdGFydCB3aXRoIGtleWZyYW1lc1xuICAgICAgICAgIGlmIChuZXh0RnJhZyAmJiBuZXh0RnJhZy5iYWNrdHJhY2tlZCkge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignQWxyZWFkeSBiYWNrdHJhY2tlZCBmcm9tIGZyYWdtZW50ICcgKyAoY3VyU05JZHggKyAxKSArICcsIHdpbGwgbm90IGJhY2t0cmFjayB0byBmcmFnbWVudCAnICsgY3VyU05JZHggKyAnLiBMb2FkaW5nIGZyYWdtZW50ICcgKyAoY3VyU05JZHggKyAxKSk7XG4gICAgICAgICAgICBmcmFnID0gbmV4dEZyYWc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGEgZnJhZ21lbnQgaGFzIGRyb3BwZWQgZnJhbWVzIGFuZCBpdCdzIGluIGEgZGlmZmVyZW50IGxldmVsL3NlcXVlbmNlLCBsb2FkIHRoZSBwcmV2aW91cyBmcmFnbWVudCB0byB0cnkgYW5kIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZHJvcHBlZCBjb3VudCBub3cgc2luY2UgaXQgd29uJ3QgYmUgcmVzZXQgdW50aWwgd2UgcGFyc2UgdGhlIGZyYWdtZW50IGFnYWluLCB3aGljaCBwcmV2ZW50cyBpbmZpbml0ZSBiYWNrdHJhY2tpbmcgb24gdGhlIHNhbWUgc2VnbWVudFxuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignTG9hZGVkIGZyYWdtZW50IHdpdGggZHJvcHBlZCBmcmFtZXMsIGJhY2t0cmFja2luZyAxIHNlZ21lbnQgdG8gZmluZCBhIGtleWZyYW1lJyk7XG4gICAgICAgICAgICBmcmFnLmRyb3BwZWQgPSAwO1xuICAgICAgICAgICAgaWYgKHByZXZGcmFnICYmIHByZXZGcmFnLmxvYWRDb3VudGVyKSB7XG4gICAgICAgICAgICAgIHByZXZGcmFnLmxvYWRDb3VudGVyLS07XG4gICAgICAgICAgICAgIGZyYWcgPSBwcmV2RnJhZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2xvYWRGcmFnbWVudE9yS2V5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRGcmFnbWVudE9yS2V5KGZyYWcsIGxldmVsLCBsZXZlbERldGFpbHMsIHBvcywgYnVmZmVyRW5kKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgY29uZmlnID0gaGxzLmNvbmZpZztcblxuICAgICAgLy9sb2dnZXIubG9nKCdsb2FkaW5nIGZyYWcgJyArIGkgKycscG9zL2J1ZkVuZDonICsgcG9zLnRvRml4ZWQoMykgKyAnLycgKyBidWZmZXJFbmQudG9GaXhlZCgzKSk7XG4gICAgICBpZiAoZnJhZy5kZWNyeXB0ZGF0YSAmJiBmcmFnLmRlY3J5cHRkYXRhLnVyaSAhPSBudWxsICYmIGZyYWcuZGVjcnlwdGRhdGEua2V5ID09IG51bGwpIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdMb2FkaW5nIGtleSBmb3IgJyArIGZyYWcuc24gKyAnIG9mIFsnICsgbGV2ZWxEZXRhaWxzLnN0YXJ0U04gKyAnICwnICsgbGV2ZWxEZXRhaWxzLmVuZFNOICsgJ10sbGV2ZWwgJyArIGxldmVsKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LktFWV9MT0FESU5HLCB7IGZyYWc6IGZyYWcgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ0xvYWRpbmcgJyArIGZyYWcuc24gKyAnIG9mIFsnICsgbGV2ZWxEZXRhaWxzLnN0YXJ0U04gKyAnICwnICsgbGV2ZWxEZXRhaWxzLmVuZFNOICsgJ10sbGV2ZWwgJyArIGxldmVsICsgJywgY3VycmVudFRpbWU6JyArIHBvcy50b0ZpeGVkKDMpICsgJyxidWZmZXJFbmQ6JyArIGJ1ZmZlckVuZC50b0ZpeGVkKDMpKTtcbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgd2UgYXJlIG5vdCByZWxvYWRpbmcgdGhlIHNhbWUgZnJhZ21lbnRzIGluIGxvb3AgLi4uXG4gICAgICAgIGlmICh0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmZyYWdMb2FkSWR4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5mcmFnTG9hZElkeCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWcubG9hZENvdW50ZXIpIHtcbiAgICAgICAgICBmcmFnLmxvYWRDb3VudGVyKys7XG4gICAgICAgICAgdmFyIG1heFRocmVzaG9sZCA9IGNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgICAgICAgLy8gaWYgdGhpcyBmcmFnIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkIDMgdGltZXMsIGFuZCBpZiBpdCBoYXMgYmVlbiByZWxvYWRlZCByZWNlbnRseVxuICAgICAgICAgIGlmIChmcmFnLmxvYWRDb3VudGVyID4gbWF4VGhyZXNob2xkICYmIE1hdGguYWJzKHRoaXMuZnJhZ0xvYWRJZHggLSBmcmFnLmxvYWRJZHgpIDwgbWF4VGhyZXNob2xkKSB7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZy5sb2FkQ291bnRlciA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZnJhZy5sb2FkSWR4ID0gdGhpcy5mcmFnTG9hZElkeDtcbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFpc05hTihmcmFnLnNuKSkge1xuICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGZyYWcuYXV0b0xldmVsID0gaGxzLmF1dG9MZXZlbEVuYWJsZWQ7XG4gICAgICAgIGZyYWcuYml0cmF0ZVRlc3QgPSB0aGlzLmJpdHJhdGVUZXN0O1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfTE9BRElORywgeyBmcmFnOiBmcmFnIH0pO1xuICAgICAgICAvLyBsYXp5IGRlbXV4ZXIgaW5pdCwgYXMgdGhpcyBjb3VsZCB0YWtlIHNvbWUgdGltZSAuLi4gZG8gaXQgZHVyaW5nIGZyYWcgbG9hZGluZ1xuICAgICAgICBpZiAoIXRoaXMuZGVtdXhlcikge1xuICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBfZGVtdXhlcjIuZGVmYXVsdChobHMsICdtYWluJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0QnVmZmVyUmFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCdWZmZXJSYW5nZShwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIF9iaW5hcnlTZWFyY2gyLmRlZmF1bHQuc2VhcmNoKHRoaXMuYnVmZmVyUmFuZ2UsIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICBpZiAocG9zaXRpb24gPCByYW5nZS5zdGFydCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA+IHJhbmdlLmVuZCkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9sbG93aW5nQnVmZmVyUmFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb2xsb3dpbmdCdWZmZXJSYW5nZShyYW5nZSkge1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIC8vIHRyeSB0byBnZXQgcmFuZ2Ugb2YgbmV4dCBmcmFnbWVudCAoNTAwbXMgYWZ0ZXIgdGhpcyByYW5nZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyUmFuZ2UocmFuZ2UuZW5kICsgMC41KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19jaGVja0ZyYWdtZW50Q2hhbmdlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0ZyYWdtZW50Q2hhbmdlZCgpIHtcbiAgICAgIHZhciByYW5nZUN1cnJlbnQsXG4gICAgICAgICAgY3VycmVudFRpbWUsXG4gICAgICAgICAgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgICAgaWYgKHZpZGVvICYmIHZpZGVvLnJlYWR5U3RhdGUgJiYgdmlkZW8uc2Vla2luZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3VycmVudFRpbWUgPSB2aWRlby5jdXJyZW50VGltZTtcbiAgICAgICAgLyogaWYgdmlkZW8gZWxlbWVudCBpcyBpbiBzZWVrZWQgc3RhdGUsIGN1cnJlbnRUaW1lIGNhbiBvbmx5IGluY3JlYXNlLlxuICAgICAgICAgIChhc3N1bWluZyB0aGF0IHBsYXliYWNrIHJhdGUgaXMgcG9zaXRpdmUgLi4uKVxuICAgICAgICAgIEFzIHNvbWV0aW1lcyBjdXJyZW50VGltZSBqdW1wcyBiYWNrIHRvIHplcm8gYWZ0ZXIgYVxuICAgICAgICAgIG1lZGlhIGRlY29kZSBlcnJvciwgY2hlY2sgdGhpcywgdG8gYXZvaWQgc2Vla2luZyBiYWNrIHRvXG4gICAgICAgICAgd3JvbmcgcG9zaXRpb24gYWZ0ZXIgYSBtZWRpYSBkZWNvZGUgZXJyb3JcbiAgICAgICAgKi9cbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lID4gdmlkZW8ucGxheWJhY2tSYXRlICogdGhpcy5sYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfYnVmZmVySGVscGVyMi5kZWZhdWx0LmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lKSkge1xuICAgICAgICAgIHJhbmdlQ3VycmVudCA9IHRoaXMuZ2V0QnVmZmVyUmFuZ2UoY3VycmVudFRpbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKF9idWZmZXJIZWxwZXIyLmRlZmF1bHQuaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUgKyAwLjEpKSB7XG4gICAgICAgICAgLyogZW5zdXJlIHRoYXQgRlJBR19DSEFOR0VEIGV2ZW50IGlzIHRyaWdnZXJlZCBhdCBzdGFydHVwLFxuICAgICAgICAgICAgd2hlbiBmaXJzdCB2aWRlbyBmcmFtZSBpcyBkaXNwbGF5ZWQgYW5kIHBsYXliYWNrIGlzIHBhdXNlZC5cbiAgICAgICAgICAgIGFkZCBhIHRvbGVyYW5jZSBvZiAxMDBtcywgaW4gY2FzZSBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCxcbiAgICAgICAgICAgIGNoZWNrIGlmIGN1cnJlbnQgcG9zKzEwMG1zIGlzIGJ1ZmZlcmVkIGFuZCB1c2UgdGhhdCBidWZmZXIgcmFuZ2VcbiAgICAgICAgICAgIGZvciBGUkFHX0NIQU5HRUQgZXZlbnQgcmVwb3J0aW5nICovXG4gICAgICAgICAgcmFuZ2VDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJSYW5nZShjdXJyZW50VGltZSArIDAuMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlQ3VycmVudCkge1xuICAgICAgICAgIHZhciBmcmFnUGxheWluZyA9IHJhbmdlQ3VycmVudC5mcmFnO1xuICAgICAgICAgIGlmIChmcmFnUGxheWluZyAhPT0gdGhpcy5mcmFnUGxheWluZykge1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfQ0hBTkdFRCwgeyBmcmFnOiBmcmFnUGxheWluZyB9KTtcbiAgICAgICAgICAgIHZhciBmcmFnUGxheWluZ0xldmVsID0gZnJhZ1BsYXlpbmcubGV2ZWw7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZnJhZ1BsYXlpbmcgfHwgdGhpcy5mcmFnUGxheWluZy5sZXZlbCAhPT0gZnJhZ1BsYXlpbmdMZXZlbCkge1xuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuTEVWRUxfU1dJVENIRUQsIHsgbGV2ZWw6IGZyYWdQbGF5aW5nTGV2ZWwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggOlxuICAgICAgIC0gcGF1c2UgcGxheWJhY2sgaWYgcGxheWluZ1xuICAgICAgIC0gY2FuY2VsIGFueSBwZW5kaW5nIGxvYWQgcmVxdWVzdFxuICAgICAgIC0gYW5kIHRyaWdnZXIgYSBidWZmZXIgZmx1c2hcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbW1lZGlhdGVMZXZlbFN3aXRjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGltbWVkaWF0ZUxldmVsU3dpdGNoKCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdpbW1lZGlhdGVMZXZlbFN3aXRjaCcpO1xuICAgICAgaWYgKCF0aGlzLmltbWVkaWF0ZVN3aXRjaCkge1xuICAgICAgICB0aGlzLmltbWVkaWF0ZVN3aXRjaCA9IHRydWU7XG4gICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgICAgICBwcmV2aW91c2x5UGF1c2VkID0gdm9pZCAwO1xuICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICBwcmV2aW91c2x5UGF1c2VkID0gbWVkaWEucGF1c2VkO1xuICAgICAgICAgIG1lZGlhLnBhdXNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZG9uJ3QgcmVzdGFydCBwbGF5YmFjayBhZnRlciBpbnN0YW50IGxldmVsIHN3aXRjaCBpbiBjYXNlIG1lZGlhIG5vdCBhdHRhY2hlZFxuICAgICAgICAgIHByZXZpb3VzbHlQYXVzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldmlvdXNseVBhdXNlZCA9IHByZXZpb3VzbHlQYXVzZWQ7XG4gICAgICB9XG4gICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcbiAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgICBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIGVuZCwgYWZ0ZXIgbmV3IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkIDpcbiAgICAgICAgLSBudWRnZSB2aWRlbyBkZWNvZGVyIGJ5IHNsaWdodGx5IGFkanVzdGluZyB2aWRlbyBjdXJyZW50VGltZSAoaWYgY3VycmVudFRpbWUgYnVmZmVyZWQpXG4gICAgICAgIC0gcmVzdW1lIHRoZSBwbGF5YmFjayBpZiBuZWVkZWRcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbW1lZGlhdGVMZXZlbFN3aXRjaEVuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGltbWVkaWF0ZUxldmVsU3dpdGNoRW5kKCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5idWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5pbW1lZGlhdGVTd2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKF9idWZmZXJIZWxwZXIyLmRlZmF1bHQuaXNCdWZmZXJlZChtZWRpYSwgbWVkaWEuY3VycmVudFRpbWUpKSB7XG4gICAgICAgICAgLy8gb25seSBudWRnZSBpZiBjdXJyZW50VGltZSBpcyBidWZmZXJlZFxuICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lIC09IDAuMDAwMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucHJldmlvdXNseVBhdXNlZCkge1xuICAgICAgICAgIG1lZGlhLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25leHRMZXZlbFN3aXRjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHRMZXZlbFN3aXRjaCgpIHtcbiAgICAgIC8qIHRyeSB0byBzd2l0Y2ggQVNBUCB3aXRob3V0IGJyZWFraW5nIHZpZGVvIHBsYXliYWNrIDpcbiAgICAgICAgIGluIG9yZGVyIHRvIGVuc3VyZSBzbW9vdGggYnV0IHF1aWNrIGxldmVsIHN3aXRjaGluZyxcbiAgICAgICAgd2UgbmVlZCB0byBmaW5kIHRoZSBuZXh0IGZsdXNoYWJsZSBidWZmZXIgcmFuZ2VcbiAgICAgICAgd2Ugc2hvdWxkIHRha2UgaW50byBhY2NvdW50IG5ldyBzZWdtZW50IGZldGNoIHRpbWVcbiAgICAgICovXG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgLy8gZW5zdXJlIHRoYXQgbWVkaWEgaXMgZGVmaW5lZCBhbmQgdGhhdCBtZXRhZGF0YSBhcmUgYXZhaWxhYmxlICh0byByZXRyaWV2ZSBjdXJyZW50VGltZSlcbiAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgIHZhciBmZXRjaGRlbGF5ID0gdm9pZCAwLFxuICAgICAgICAgICAgY3VycmVudFJhbmdlID0gdm9pZCAwLFxuICAgICAgICAgICAgbmV4dFJhbmdlID0gdm9pZCAwO1xuICAgICAgICAvLyBpbmNyZWFzZSBmcmFnbWVudCBsb2FkIEluZGV4IHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGFmdGVyIGJ1ZmZlciBmbHVzaFxuICAgICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgICAgIGN1cnJlbnRSYW5nZSA9IHRoaXMuZ2V0QnVmZmVyUmFuZ2UobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgICBpZiAoY3VycmVudFJhbmdlICYmIGN1cnJlbnRSYW5nZS5zdGFydCA+IDEpIHtcbiAgICAgICAgICAvLyBmbHVzaCBidWZmZXIgcHJlY2VkaW5nIGN1cnJlbnQgZnJhZ21lbnQgKGZsdXNoIHVudGlsIGN1cnJlbnQgZnJhZ21lbnQgc3RhcnQgb2Zmc2V0KVxuICAgICAgICAgIC8vIG1pbnVzIDFzIHRvIGF2b2lkIHZpZGVvIGZyZWV6aW5nLCB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSBmbHVzaCBrZXlmcmFtZSBvZiBjdXJyZW50IHZpZGVvIC4uLlxuICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIGN1cnJlbnRSYW5nZS5zdGFydCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVkaWEucGF1c2VkKSB7XG4gICAgICAgICAgLy8gYWRkIGEgc2FmZXR5IGRlbGF5IG9mIDFzXG4gICAgICAgICAgdmFyIG5leHRMZXZlbElkID0gdGhpcy5obHMubmV4dExvYWRMZXZlbCxcbiAgICAgICAgICAgICAgbmV4dExldmVsID0gdGhpcy5sZXZlbHNbbmV4dExldmVsSWRdLFxuICAgICAgICAgICAgICBmcmFnTGFzdEticHMgPSB0aGlzLmZyYWdMYXN0S2JwcztcbiAgICAgICAgICBpZiAoZnJhZ0xhc3RLYnBzICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICAgIGZldGNoZGVsYXkgPSB0aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uICogbmV4dExldmVsLmJpdHJhdGUgLyAoMTAwMCAqIGZyYWdMYXN0S2JwcykgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy9sb2dnZXIubG9nKCdmZXRjaGRlbGF5OicrZmV0Y2hkZWxheSk7XG4gICAgICAgIC8vIGZpbmQgYnVmZmVyIHJhbmdlIHRoYXQgd2lsbCBiZSByZWFjaGVkIG9uY2UgbmV3IGZyYWdtZW50IHdpbGwgYmUgZmV0Y2hlZFxuICAgICAgICBuZXh0UmFuZ2UgPSB0aGlzLmdldEJ1ZmZlclJhbmdlKG1lZGlhLmN1cnJlbnRUaW1lICsgZmV0Y2hkZWxheSk7XG4gICAgICAgIGlmIChuZXh0UmFuZ2UpIHtcbiAgICAgICAgICAvLyB3ZSBjYW4gZmx1c2ggYnVmZmVyIHJhbmdlIGZvbGxvd2luZyB0aGlzIG9uZSB3aXRob3V0IHN0YWxsaW5nIHBsYXliYWNrXG4gICAgICAgICAgbmV4dFJhbmdlID0gdGhpcy5mb2xsb3dpbmdCdWZmZXJSYW5nZShuZXh0UmFuZ2UpO1xuICAgICAgICAgIGlmIChuZXh0UmFuZ2UpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBoZXJlLCB3ZSBjYW4gYWxzbyBjYW5jZWwgYW55IGxvYWRpbmcvZGVtdXhpbmcgaW4gcHJvZ3Jlc3MsIGFzIHRoZXkgYXJlIHVzZWxlc3NcbiAgICAgICAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAvLyBmbHVzaCBwb3NpdGlvbiBpcyB0aGUgc3RhcnQgcG9zaXRpb24gb2YgdGhpcyBuZXcgYnVmZmVyXG4gICAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihuZXh0UmFuZ2Uuc3RhcnQsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmx1c2hNYWluQnVmZmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2hNYWluQnVmZmVyKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc7XG4gICAgICB2YXIgZmx1c2hTY29wZSA9IHsgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldCB9O1xuICAgICAgLy8gaWYgYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrcyBhcmUgdXNlZCwgb25seSBmbHVzaCB2aWRlbywgb3RoZXJ3aXNlIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICAgIGZsdXNoU2NvcGUudHlwZSA9ICd2aWRlbyc7XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0ZMVVNISU5HLCBmbHVzaFNjb3BlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1lZGlhQXR0YWNoZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoZWQoZGF0YSkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xuICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9uTWVkaWFTZWVrZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMub252ZW5kZWQgPSB0aGlzLm9uTWVkaWFFbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgaWYgKHRoaXMubGV2ZWxzICYmIGNvbmZpZy5hdXRvU3RhcnRMb2FkKSB7XG4gICAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYURldGFjaGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgaWYgKG1lZGlhICYmIG1lZGlhLmVuZGVkKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyByZXNldCBmcmFnbWVudCBsb2FkaW5nIGNvdW50ZXIgb24gTVNFIGRldGFjaGluZyB0byBhdm9pZCByZXBvcnRpbmcgRlJBR19MT09QX0xPQURJTkdfRVJST1IgYWZ0ZXIgZXJyb3IgcmVjb3ZlcnlcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICAgIGlmIChsZXZlbHMpIHtcbiAgICAgICAgLy8gcmVzZXQgZnJhZ21lbnQgbG9hZCBjb3VudGVyXG4gICAgICAgIGxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmIChsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgICBsZXZlbC5kZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICAgICAgICAgICAgICBmcmFnbWVudC5sb2FkQ291bnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgZnJhZ21lbnQuYmFja3RyYWNrZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252c2Vla2VkID0gdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYVNlZWtpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lZGlhU2Vla2luZygpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgICAgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdtZWRpYSBzZWVraW5nIHRvICcgKyBjdXJyZW50VGltZS50b0ZpeGVkKDMpKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcpIHtcbiAgICAgICAgdmFyIG1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiBtZWRpYTtcbiAgICAgICAgdmFyIGJ1ZmZlckluZm8gPSBfYnVmZmVySGVscGVyMi5kZWZhdWx0LmJ1ZmZlckluZm8obWVkaWFCdWZmZXIsIGN1cnJlbnRUaW1lLCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKSxcbiAgICAgICAgICAgIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIHNlZWtpbmcgdG8gYSB1bmJ1ZmZlcmVkIGFyZWEgQU5EIGlmIGZyYWcgbG9hZGluZyBpcyBpbiBwcm9ncmVzc1xuICAgICAgICBpZiAoYnVmZmVySW5mby5sZW4gPT09IDAgJiYgZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgdG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsXG4gICAgICAgICAgICAgIGZyYWdTdGFydE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0IC0gdG9sZXJhbmNlLFxuICAgICAgICAgICAgICBmcmFnRW5kT2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgKyBmcmFnQ3VycmVudC5kdXJhdGlvbiArIHRvbGVyYW5jZTtcbiAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBzZWVrIHBvc2l0aW9uIHdpbGwgYmUgb3V0IG9mIGN1cnJlbnRseSBsb2FkZWQgZnJhZyByYW5nZSA6IGlmIG91dCBjYW5jZWwgZnJhZyBsb2FkLCBpZiBpbiwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPCBmcmFnU3RhcnRPZmZzZXQgfHwgY3VycmVudFRpbWUgPiBmcmFnRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAoZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciB3aGlsZSBmcmFnbWVudCBsb2FkIGluIHByb2dyZXNzLCBjYW5jZWwgZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgYnV0IHdpdGhpbiBjdXJyZW50bHkgbG9hZGVkIGZyYWdtZW50IHJhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGNoZWNrIGZvciBwb3RlbnRpYWwgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICAvLyBhdm9pZCByZXBvcnRpbmcgZnJhZ21lbnQgbG9vcCBsb2FkaW5nIGVycm9yIGluIGNhc2UgdXNlciBpcyBzZWVraW5nIHNldmVyYWwgdGltZXMgb24gc2FtZSBwb3NpdGlvblxuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLkZSQUdfTE9BRElORyAmJiB0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAgIH1cbiAgICAgIC8vIGluIGNhc2Ugc2Vla2luZyBvY2N1cnMgYWx0aG91Z2ggbm8gbWVkaWEgYnVmZmVyZWQsIGFkanVzdCBzdGFydFBvc2l0aW9uIGFuZCBuZXh0TG9hZFBvc2l0aW9uIHRvIHNlZWsgdGFyZ2V0XG4gICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIHByb2Nlc3NpbmdcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWVkaWFTZWVrZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lZGlhU2Vla2VkKCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdtZWRpYSBzZWVrZWQgdG8gJyArIHRoaXMubWVkaWEuY3VycmVudFRpbWUudG9GaXhlZCgzKSk7XG4gICAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdNRU5UX1BMQVlJTkcgdHJpZ2dlcmluZ1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYUVuZGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZWRpYUVuZGVkKCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdtZWRpYSBlbmRlZCcpO1xuICAgICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NYW5pZmVzdExvYWRpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAgIC8vIHJlc2V0IGJ1ZmZlciBvbiBtYW5pZmVzdCBsb2FkaW5nXG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3RyaWdnZXIgQlVGRkVSX1JFU0VUJyk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX1JFU0VUKTtcbiAgICAgIHRoaXMuYnVmZmVyUmFuZ2UgPSBbXTtcbiAgICAgIHRoaXMuc3RhbGxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWFuaWZlc3RQYXJzZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1hbmlmZXN0UGFyc2VkKGRhdGEpIHtcbiAgICAgIHZhciBhYWMgPSBmYWxzZSxcbiAgICAgICAgICBoZWFhYyA9IGZhbHNlLFxuICAgICAgICAgIGNvZGVjO1xuICAgICAgZGF0YS5sZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgLy8gZGV0ZWN0IGlmIHdlIGhhdmUgZGlmZmVyZW50IGtpbmQgb2YgYXVkaW8gY29kZWNzIHVzZWQgYW1vbmdzdCBwbGF5bGlzdHNcbiAgICAgICAgY29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xKSB7XG4gICAgICAgICAgICBhYWMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgICBoZWFhYyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IGFhYyAmJiBoZWFhYztcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdib3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgICAgdGhpcy5zdGFydExldmVsTG9hZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgaWYgKGNvbmZpZy5hdXRvU3RhcnRMb2FkKSB7XG4gICAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25MZXZlbExvYWRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZGF0YSkge1xuICAgICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICAgICAgbmV3TGV2ZWxJZCA9IGRhdGEubGV2ZWwsXG4gICAgICAgICAgY3VyTGV2ZWwgPSB0aGlzLmxldmVsc1tuZXdMZXZlbElkXSxcbiAgICAgICAgICBkdXJhdGlvbiA9IG5ld0RldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgICBzbGlkaW5nID0gMDtcblxuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdsZXZlbCAnICsgbmV3TGV2ZWxJZCArICcgbG9hZGVkIFsnICsgbmV3RGV0YWlscy5zdGFydFNOICsgJywnICsgbmV3RGV0YWlscy5lbmRTTiArICddLGR1cmF0aW9uOicgKyBkdXJhdGlvbik7XG4gICAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IG5ld0xldmVsSWQ7XG5cbiAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgdmFyIGN1ckRldGFpbHMgPSBjdXJMZXZlbC5kZXRhaWxzO1xuICAgICAgICBpZiAoY3VyRGV0YWlscyAmJiBuZXdEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gd2UgYWxyZWFkeSBoYXZlIGRldGFpbHMgZm9yIHRoYXQgbGV2ZWwsIG1lcmdlIHRoZW1cbiAgICAgICAgICBfbGV2ZWxIZWxwZXIyLmRlZmF1bHQubWVyZ2VEZXRhaWxzKGN1ckRldGFpbHMsIG5ld0RldGFpbHMpO1xuICAgICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgICAgICB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgY3VyRGV0YWlscyk7XG4gICAgICAgICAgaWYgKG5ld0RldGFpbHMuUFRTS25vd24pIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbGl2ZSBwbGF5bGlzdCBzbGlkaW5nOicgKyBzbGlkaW5nLnRvRml4ZWQoMykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdsaXZlIHBsYXlsaXN0IC0gZmlyc3QgbG9hZCwgdW5rbm93biBzbGlkaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIG92ZXJyaWRlIGxldmVsIGluZm9cbiAgICAgIGN1ckxldmVsLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkxFVkVMX1VQREFURUQsIHsgZGV0YWlsczogbmV3RGV0YWlscywgbGV2ZWw6IG5ld0xldmVsSWQgfSk7XG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRQb3NpdGlvbiA9PT0gLTEgfHwgdGhpcy5sYXN0Q3VycmVudFRpbWUgPT09IC0xKSB7XG4gICAgICAgICAgLy8gZmlyc3QsIGNoZWNrIGlmIHN0YXJ0IHRpbWUgb2Zmc2V0IGhhcyBiZWVuIHNldCBpbiBwbGF5bGlzdCwgaWYgeWVzLCB1c2UgdGhpcyB2YWx1ZVxuICAgICAgICAgIHZhciBzdGFydFRpbWVPZmZzZXQgPSBuZXdEZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICBpZiAoIWlzTmFOKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbmVnYXRpdmUgc3RhcnQgdGltZSBvZmZzZXQgJyArIHN0YXJ0VGltZU9mZnNldCArICcsIGNvdW50IGZyb20gZW5kIG9mIGxhc3QgZnJhZ21lbnQnKTtcbiAgICAgICAgICAgICAgc3RhcnRUaW1lT2Zmc2V0ID0gc2xpZGluZyArIGR1cmF0aW9uICsgc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzdGFydCB0aW1lIG9mZnNldCBmb3VuZCBpbiBwbGF5bGlzdCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gdG8gJyArIHN0YXJ0VGltZU9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIGxpdmUgcGxheWxpc3QsIHNldCBzdGFydCBwb3NpdGlvbiB0byBiZSBmcmFnbWVudCBOLXRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCAodXN1YWxseSAzKVxuICAgICAgICAgICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgbmV3RGV0YWlscyk7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnY29uZmlndXJlIHN0YXJ0UG9zaXRpb24gdG8gJyArIHRoaXMuc3RhcnRQb3NpdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgICAvLyBvbmx5IHN3aXRjaCBiYXRjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgbGV2ZWwgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0xFVkVMKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbktleUxvYWRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uS2V5TG9hZGVkKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZyYWdMb2FkZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZyYWdMb2FkZWQoZGF0YSkge1xuICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgICBmcmFnTG9hZGVkID0gZGF0YS5mcmFnO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyAmJiBmcmFnQ3VycmVudCAmJiBmcmFnTG9hZGVkLnR5cGUgPT09ICdtYWluJyAmJiBmcmFnTG9hZGVkLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJiBmcmFnTG9hZGVkLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xuICAgICAgICB2YXIgc3RhdHMgPSBkYXRhLnN0YXRzLFxuICAgICAgICAgICAgY3VycmVudExldmVsID0gdGhpcy5sZXZlbHNbZnJhZ0N1cnJlbnQubGV2ZWxdLFxuICAgICAgICAgICAgZGV0YWlscyA9IGN1cnJlbnRMZXZlbC5kZXRhaWxzO1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ0xvYWRlZCAgJyArIGZyYWdDdXJyZW50LnNuICsgJyBvZiBbJyArIGRldGFpbHMuc3RhcnRTTiArICcgLCcgKyBkZXRhaWxzLmVuZFNOICsgJ10sbGV2ZWwgJyArIGZyYWdDdXJyZW50LmxldmVsKTtcbiAgICAgICAgLy8gcmVzZXQgZnJhZyBiaXRyYXRlIHRlc3QgaW4gYW55IGNhc2UgYWZ0ZXIgZnJhZyBsb2FkZWQgZXZlbnRcbiAgICAgICAgdGhpcy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRzID0gc3RhdHM7XG4gICAgICAgIC8vIGlmIHRoaXMgZnJhZyB3YXMgbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3QgQU5EIGlmIGhscy5uZXh0TG9hZExldmVsIGlzIGdyZWF0ZXIgdGhhbiAwXG4gICAgICAgIC8vIHRoZW4gdGhpcyBtZWFucyB0aGF0IHdlIHNob3VsZCBiZSBhYmxlIHRvIGxvYWQgYSBmcmFnbWVudCBhdCBhIGhpZ2hlciBxdWFsaXR5IGxldmVsXG4gICAgICAgIGlmIChmcmFnTG9hZGVkLmJpdHJhdGVUZXN0ID09PSB0cnVlICYmIHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwpIHtcbiAgICAgICAgICAvLyBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIC4uLiB3ZSBqdXN0IGxvYWRlZCBhIGZyYWdtZW50IHRvIGRldGVybWluZSBhZGVxdWF0ZSBzdGFydCBiaXRyYXRlIGFuZCBpbml0aWFsaXplIGF1dG9zd2l0Y2ggYWxnb1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZ0N1cnJlbnQsIGlkOiAnbWFpbicgfSk7XG4gICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZnJhZ0xvYWRlZC5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgPSBkYXRhLnBheWxvYWQ7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnQ3VycmVudCwgaWQ6ICdtYWluJyB9KTtcbiAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgICAgICAvLyB0cmFuc211eCB0aGUgTVBFRy1UUyBkYXRhIHRvIElTTy1CTUZGIHNlZ21lbnRzXG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gZGV0YWlscy50b3RhbGR1cmF0aW9uLFxuICAgICAgICAgICAgICBsZXZlbCA9IGZyYWdDdXJyZW50LmxldmVsLFxuICAgICAgICAgICAgICBzbiA9IGZyYWdDdXJyZW50LnNuLFxuICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3YXApIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc3dhcHBpbmcgcGxheWxpc3QgYXVkaW8gY29kZWMnKTtcbiAgICAgICAgICAgIGlmIChhdWRpb0NvZGVjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9IHRoaXMubGFzdEF1ZGlvQ29kZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXVkaW9Db2RlYykge1xuICAgICAgICAgICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IGZhbHNlO1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnUGFyc2luZyAnICsgc24gKyAnIG9mIFsnICsgZGV0YWlscy5zdGFydFNOICsgJyAsJyArIGRldGFpbHMuZW5kU04gKyAnXSxsZXZlbCAnICsgbGV2ZWwgKyAnLCBjYyAnICsgZnJhZ0N1cnJlbnQuY2MpO1xuICAgICAgICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgICAgIGlmICghZGVtdXhlcikge1xuICAgICAgICAgICAgZGVtdXhlciA9IHRoaXMuZGVtdXhlciA9IG5ldyBfZGVtdXhlcjIuZGVmYXVsdCh0aGlzLmhscywgJ21haW4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpIGFuZCBpZiBtZWRpYSBpcyBub3Qgc2Vla2luZyAodGhpcyBpcyB0byBvdmVyY29tZSBwb3RlbnRpYWwgdGltZXN0YW1wIGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0cyBhbmQgZnJhZ21lbnRzKVxuICAgICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgICAgdmFyIG1lZGlhU2Vla2luZyA9IG1lZGlhICYmIG1lZGlhLnNlZWtpbmc7XG4gICAgICAgICAgdmFyIGFjY3VyYXRlVGltZU9mZnNldCA9ICFtZWRpYVNlZWtpbmcgJiYgKGRldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZSk7XG4gICAgICAgICAgdmFyIGluaXRTZWdtZW50RGF0YSA9IGRldGFpbHMuaW5pdFNlZ21lbnQgPyBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgOiBbXTtcbiAgICAgICAgICBkZW11eGVyLnB1c2goZGF0YS5wYXlsb2FkLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjLCBmcmFnQ3VycmVudCwgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQoZGF0YSkge1xuICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIHZhciBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgICAgaWYgKGZyYWdDdXJyZW50ICYmIGRhdGEuaWQgPT09ICdtYWluJyAmJiBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJiBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgIHZhciB0cmFja3MgPSBkYXRhLnRyYWNrcyxcbiAgICAgICAgICAgIHRyYWNrTmFtZSxcbiAgICAgICAgICAgIHRyYWNrO1xuXG4gICAgICAgIC8vIGlmIGF1ZGlvIHRyYWNrIGlzIGV4cGVjdGVkIHRvIGNvbWUgZnJvbSBhdWRpbyBzdHJlYW0gY29udHJvbGxlciwgZGlzY2FyZCBhbnkgY29taW5nIGZyb20gbWFpblxuICAgICAgICBpZiAodHJhY2tzLmF1ZGlvICYmIHRoaXMuYWx0QXVkaW8pIHtcbiAgICAgICAgICBkZWxldGUgdHJhY2tzLmF1ZGlvO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgICAgIHRyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLmF1ZGlvQ29kZWMsXG4gICAgICAgICAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChhdWRpb0NvZGVjICYmIHRoaXMuYXVkaW9Db2RlY1N3YXApIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc3dhcHBpbmcgcGxheWxpc3QgYXVkaW8gY29kZWMnKTtcbiAgICAgICAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGluIGNhc2UgQUFDIGFuZCBIRS1BQUMgYXVkaW8gY29kZWNzIGFyZSBzaWduYWxsZWQgaW4gbWFuaWZlc3RcbiAgICAgICAgICAvLyBmb3JjZSBIRS1BQUMgLCBhcyBpdCBzZWVtcyB0aGF0IG1vc3QgYnJvd3NlcnMgcHJlZmVycyB0aGF0IHdheSxcbiAgICAgICAgICAvLyBleGNlcHQgZm9yIG1vbm8gc3RyZWFtcyBPUiBvbiBGRlxuICAgICAgICAgIC8vIHRoZXNlIGNvbmRpdGlvbnMgbWlnaHQgbmVlZCB0byBiZSByZXZpZXdlZCAuLi5cbiAgICAgICAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgbW9ubyBzdHJlYW1cbiAgICAgICAgICAgIGlmICh0cmFjay5tZXRhZGF0YS5jaGFubmVsQ291bnQgIT09IDEgJiZcbiAgICAgICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBmaXJlZm94XG4gICAgICAgICAgICB1YS5pbmRleE9mKCdmaXJlZm94JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSEUtQUFDIGlzIGJyb2tlbiBvbiBBbmRyb2lkLCBhbHdheXMgc2lnbmFsIGF1ZGlvIGNvZGVjIGFzIEFBQyBldmVuIGlmIHZhcmlhbnQgbWFuaWZlc3Qgc3RhdGVzIG90aGVyd2lzZVxuICAgICAgICAgIGlmICh1YS5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xICYmIHRyYWNrLmNvbnRhaW5lciAhPT0gJ2F1ZGlvL21wZWcnKSB7XG4gICAgICAgICAgICAvLyBFeGNsdWRlIG1wZWcgYXVkaW9cbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnQW5kcm9pZDogZm9yY2UgYXVkaW8gY29kZWMgdG8gJyArIGF1ZGlvQ29kZWMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2sgPSB0cmFja3MudmlkZW87XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXS52aWRlb0NvZGVjO1xuICAgICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHJlbXV4ZXIgc3BlY2lmeSB0aGF0IGEgdW5pcXVlIHRyYWNrIG5lZWRzIHRvIGdlbmVyYXRlZCxcbiAgICAgICAgLy8gbGV0J3MgbWVyZ2UgYWxsIHRyYWNrcyB0b2dldGhlclxuICAgICAgICBpZiAoZGF0YS51bmlxdWUpIHtcbiAgICAgICAgICB2YXIgbWVyZ2VkVHJhY2sgPSB7XG4gICAgICAgICAgICBjb2RlYzogJycsXG4gICAgICAgICAgICBsZXZlbENvZGVjOiAnJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgZm9yICh0cmFja05hbWUgaW4gZGF0YS50cmFja3MpIHtcbiAgICAgICAgICAgIHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgICAgICBtZXJnZWRUcmFjay5jb250YWluZXIgPSB0cmFjay5jb250YWluZXI7XG4gICAgICAgICAgICBpZiAobWVyZ2VkVHJhY2suY29kZWMpIHtcbiAgICAgICAgICAgICAgbWVyZ2VkVHJhY2suY29kZWMgKz0gJywnO1xuICAgICAgICAgICAgICBtZXJnZWRUcmFjay5sZXZlbENvZGVjICs9ICcsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFjay5jb2RlYykge1xuICAgICAgICAgICAgICBtZXJnZWRUcmFjay5jb2RlYyArPSB0cmFjay5jb2RlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFjay5sZXZlbENvZGVjKSB7XG4gICAgICAgICAgICAgIG1lcmdlZFRyYWNrLmxldmVsQ29kZWMgKz0gdHJhY2subGV2ZWxDb2RlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhY2tzID0geyBhdWRpb3ZpZGVvOiBtZXJnZWRUcmFjayB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfQ09ERUNTLCB0cmFja3MpO1xuICAgICAgICAvLyBsb29wIHRocm91Z2ggdHJhY2tzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIHByb3ZpZGVkIHRvIGJ1ZmZlckNvbnRyb2xsZXJcbiAgICAgICAgZm9yICh0cmFja05hbWUgaW4gdHJhY2tzKSB7XG4gICAgICAgICAgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ21haW4gdHJhY2s6JyArIHRyYWNrTmFtZSArICcsY29udGFpbmVyOicgKyB0cmFjay5jb250YWluZXIgKyAnLGNvZGVjc1tsZXZlbC9wYXJzZWRdPVsnICsgdHJhY2subGV2ZWxDb2RlYyArICcvJyArIHRyYWNrLmNvZGVjICsgJ10nKTtcbiAgICAgICAgICB2YXIgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgICAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0FQUEVORElORywgeyB0eXBlOiB0cmFja05hbWUsIGRhdGE6IGluaXRTZWdtZW50LCBwYXJlbnQ6ICdtYWluJywgY29udGVudDogJ2luaXRTZWdtZW50JyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRnJhZ1BhcnNpbmdEYXRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GcmFnUGFyc2luZ0RhdGEoZGF0YSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICB2YXIgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICAgIGlmIChmcmFnQ3VycmVudCAmJiBkYXRhLmlkID09PSAnbWFpbicgJiYgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiYgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiYgIShkYXRhLnR5cGUgPT09ICdhdWRpbycgJiYgdGhpcy5hbHRBdWRpbykgJiYgLy8gZmlsdGVyIG91dCBtYWluIGF1ZGlvIGlmIGF1ZGlvIHRyYWNrIGlzIGxvYWRlZCB0aHJvdWdoIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyXG4gICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLFxuICAgICAgICAgICAgZnJhZyA9IGZyYWdDdXJyZW50O1xuICAgICAgICBpZiAoaXNOYU4oZGF0YS5lbmRQVFMpKSB7XG4gICAgICAgICAgZGF0YS5lbmRQVFMgPSBkYXRhLnN0YXJ0UFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XG4gICAgICAgICAgZGF0YS5lbmREVFMgPSBkYXRhLnN0YXJ0RFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ1BhcnNlZCAnICsgZGF0YS50eXBlICsgJyxQVFM6WycgKyBkYXRhLnN0YXJ0UFRTLnRvRml4ZWQoMykgKyAnLCcgKyBkYXRhLmVuZFBUUy50b0ZpeGVkKDMpICsgJ10sRFRTOlsnICsgZGF0YS5zdGFydERUUy50b0ZpeGVkKDMpICsgJy8nICsgZGF0YS5lbmREVFMudG9GaXhlZCgzKSArICddLG5iOicgKyBkYXRhLm5iICsgJyxkcm9wcGVkOicgKyAoZGF0YS5kcm9wcGVkIHx8IDApKTtcblxuICAgICAgICAvLyBEZXRlY3QgZ2FwcyBpbiBhIGZyYWdtZW50ICBhbmQgdHJ5IHRvIGZpeCBpdCBieSBmaW5kaW5nIGEga2V5ZnJhbWUgaW4gdGhlIHByZXZpb3VzIGZyYWdtZW50IChzZWUgX2ZpbmRGcmFnbWVudHMpXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICBmcmFnLmRyb3BwZWQgPSBkYXRhLmRyb3BwZWQ7XG4gICAgICAgICAgaWYgKGZyYWcuZHJvcHBlZCkge1xuICAgICAgICAgICAgaWYgKCFmcmFnLmJhY2t0cmFja2VkKSB7XG4gICAgICAgICAgICAgIC8vIFJldHVybiBiYWNrIHRvIHRoZSBJRExFIHN0YXRlIHdpdGhvdXQgYXBwZW5kaW5nIHRvIGJ1ZmZlclxuICAgICAgICAgICAgICAvLyBDYXVzZXMgZmluZEZyYWdtZW50cyB0byBiYWNrdHJhY2sgYSBzZWdtZW50IGFuZCBmaW5kIHRoZSBrZXlmcmFtZVxuICAgICAgICAgICAgICAvLyBBdWRpbyBmcmFnbWVudHMgYXJyaXZpbmcgYmVmb3JlIHZpZGVvIHNldHMgdGhlIG5leHRMb2FkUG9zaXRpb24sIGNhdXNpbmcgX2ZpbmRGcmFnbWVudHMgdG8gc2tpcCB0aGUgYmFja3RyYWNrZWQgZnJhZ21lbnRcbiAgICAgICAgICAgICAgZnJhZy5iYWNrdHJhY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGRhdGEuc3RhcnRQVFM7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignQWxyZWFkeSBiYWNrdHJhY2tlZCBvbiB0aGlzIGZyYWdtZW50LCBhcHBlbmRpbmcgd2l0aCB0aGUgZ2FwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9ubHkgcmVzZXQgdGhlIGJhY2t0cmFja2VkIGZsYWcgaWYgd2UndmUgbG9hZGVkIHRoZSBmcmFnIHdpdGhvdXQgYW55IGRyb3BwZWQgZnJhbWVzXG4gICAgICAgICAgICBmcmFnLmJhY2t0cmFja2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyaWZ0ID0gX2xldmVsSGVscGVyMi5kZWZhdWx0LnVwZGF0ZUZyYWdQVFNEVFMobGV2ZWwuZGV0YWlscywgZnJhZy5zbiwgZGF0YS5zdGFydFBUUywgZGF0YS5lbmRQVFMsIGRhdGEuc3RhcnREVFMsIGRhdGEuZW5kRFRTKSxcbiAgICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkxFVkVMX1BUU19VUERBVEVELCB7IGRldGFpbHM6IGxldmVsLmRldGFpbHMsIGxldmVsOiB0aGlzLmxldmVsLCBkcmlmdDogZHJpZnQsIHR5cGU6IGRhdGEudHlwZSwgc3RhcnQ6IGRhdGEuc3RhcnRQVFMsIGVuZDogZGF0YS5lbmRQVFMgfSk7XG5cbiAgICAgICAgLy8gaGFzIHJlbXV4ZXIgZHJvcHBlZCB2aWRlbyBmcmFtZXMgbG9jYXRlZCBiZWZvcmUgZmlyc3Qga2V5ZnJhbWUgP1xuICAgICAgICBbZGF0YS5kYXRhMSwgZGF0YS5kYXRhMl0uZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgLy8gb25seSBhcHBlbmQgaW4gUEFSU0lORyBzdGF0ZSAocmF0aW9uYWxlIGlzIHRoYXQgYW4gYXBwZW5kaW5nIGVycm9yIGNvdWxkIGhhcHBlbiBzeW5jaHJvbm91c2x5IG9uIGZpcnN0IHNlZ21lbnQgYXBwZW5kaW5nKVxuICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBpdCBpcyB1c2VsZXNzIHRvIGFwcGVuZCBmb2xsb3dpbmcgc2VnbWVudHNcbiAgICAgICAgICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGggJiYgX3RoaXMyLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgICAgICBfdGhpczIuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICAgIF90aGlzMi5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0FQUEVORElORywgeyB0eXBlOiBkYXRhLnR5cGUsIGRhdGE6IGJ1ZmZlciwgcGFyZW50OiAnbWFpbicsIGNvbnRlbnQ6ICdkYXRhJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GcmFnUGFyc2VkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GcmFnUGFyc2VkKGRhdGEpIHtcbiAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICB2YXIgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICAgIGlmIChmcmFnQ3VycmVudCAmJiBkYXRhLmlkID09PSAnbWFpbicgJiYgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiYgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICB0aGlzLnN0YXRzLnRwYXJzZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQXVkaW9UcmFja1N3aXRjaGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQXVkaW9UcmFja1N3aXRjaGluZyhkYXRhKSB7XG4gICAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgICB2YXIgYWx0QXVkaW8gPSAhIWRhdGEudXJsLFxuICAgICAgICAgIHRyYWNrSWQgPSBkYXRhLmlkO1xuICAgICAgLy8gaWYgd2Ugc3dpdGNoIG9uIG1haW4gYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCBtZWRpYS5idWZmZXJlZFxuICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaWYgd2Ugc3dpdGNoIHRvIGFsdCBhdWRpbzogYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIgaXMgaGFuZGxpbmcgaXQuXG4gICAgICAvLyB3ZSB3aWxsIGp1c3QgaGF2ZSB0byBjaGFuZ2UgYnVmZmVyIHNjaGVkdWxpbmcgb24gYXVkaW9UcmFja1N3aXRjaGVkXG4gICAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICAgIGlmICh0aGlzLm1lZGlhQnVmZmVyICE9PSB0aGlzLm1lZGlhKSB7XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzd2l0Y2hpbmcgb24gbWFpbiBhdWRpbywgdXNlIG1lZGlhLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgICAgLy8gd2UgbmVlZCB0byByZWZpbGwgYXVkaW8gYnVmZmVyIGZyb20gbWFpbjogY2FuY2VsIGFueSBmcmFnIGxvYWRpbmcgdG8gc3BlZWQgdXAgYXVkaW8gc3dpdGNoXG4gICAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbyB0cmFjaywgY2FuY2VsIG1haW4gZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAvLyBkZXN0cm95IGRlbXV4ZXIgdG8gZm9yY2UgaW5pdCBzZWdtZW50IGdlbmVyYXRpb24gKGZvbGxvd2luZyBhdWRpbyBzd2l0Y2gpXG4gICAgICAgICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICAvLyBzd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbywgZmx1c2ggYWxsIGF1ZGlvIGFuZCB0cmlnZ2VyIHRyYWNrIHN3aXRjaGVkXG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0ZMVVNISU5HLCB7IHN0YXJ0T2Zmc2V0OiAwLCBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdHlwZTogJ2F1ZGlvJyB9KTtcbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5BVURJT19UUkFDS19TV0lUQ0hFRCwgeyBpZDogdHJhY2tJZCB9KTtcbiAgICAgICAgdGhpcy5hbHRBdWRpbyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQXVkaW9UcmFja1N3aXRjaGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25BdWRpb1RyYWNrU3dpdGNoZWQoZGF0YSkge1xuICAgICAgdmFyIHRyYWNrSWQgPSBkYXRhLmlkLFxuICAgICAgICAgIGFsdEF1ZGlvID0gISF0aGlzLmhscy5hdWRpb1RyYWNrc1t0cmFja0lkXS51cmw7XG4gICAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgICAgdmFyIHZpZGVvQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlcjtcbiAgICAgICAgLy8gaWYgd2Ugc3dpdGNoZWQgb24gYWx0ZXJuYXRlIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggdmlkZW8gc291cmNlYnVmZmVyIGJ1ZmZlcmVkXG4gICAgICAgIGlmICh2aWRlb0J1ZmZlciAmJiB0aGlzLm1lZGlhQnVmZmVyICE9PSB2aWRlb0J1ZmZlcikge1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc3dpdGNoaW5nIG9uIGFsdGVybmF0ZSBhdWRpbywgdXNlIHZpZGVvLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB2aWRlb0J1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hbHRBdWRpbyA9IGFsdEF1ZGlvO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25CdWZmZXJDcmVhdGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25CdWZmZXJDcmVhdGVkKGRhdGEpIHtcbiAgICAgIHZhciB0cmFja3MgPSBkYXRhLnRyYWNrcyxcbiAgICAgICAgICBtZWRpYVRyYWNrID0gdm9pZCAwLFxuICAgICAgICAgIG5hbWUgPSB2b2lkIDAsXG4gICAgICAgICAgYWx0ZXJuYXRlID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciB0eXBlIGluIHRyYWNrcykge1xuICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbdHlwZV07XG4gICAgICAgIGlmICh0cmFjay5pZCA9PT0gJ21haW4nKSB7XG4gICAgICAgICAgbmFtZSA9IHR5cGU7XG4gICAgICAgICAgbWVkaWFUcmFjayA9IHRyYWNrO1xuICAgICAgICAgIC8vIGtlZXAgdmlkZW8gc291cmNlIGJ1ZmZlciByZWZlcmVuY2VcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHRyYWNrc1t0eXBlXS5idWZmZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsdGVybmF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbHRlcm5hdGUgJiYgbWVkaWFUcmFjaykge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2FsdGVybmF0ZSB0cmFjayBmb3VuZCwgdXNlICcgKyBuYW1lICsgJy5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG1lZGlhVHJhY2suYnVmZmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25CdWZmZXJBcHBlbmRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQnVmZmVyQXBwZW5kZWQoZGF0YSkge1xuICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnbWFpbicpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8IHN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gYXBwZW5kZWRcbiAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSBkYXRhLnBlbmRpbmcgPiAwO1xuICAgICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19jaGVja0FwcGVuZGVkUGFyc2VkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrQXBwZW5kZWRQYXJzZWQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEICYmICghdGhpcy5hcHBlbmRlZCB8fCAhdGhpcy5wZW5kaW5nQnVmZmVyaW5nKSkge1xuICAgICAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZWRpYSA9IF90aGlzMy5tZWRpYUJ1ZmZlciA/IF90aGlzMy5tZWRpYUJ1ZmZlciA6IF90aGlzMy5tZWRpYTtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbWFpbiBidWZmZXJlZCA6ICcgKyBfdGltZVJhbmdlczIuZGVmYXVsdC50b1N0cmluZyhtZWRpYS5idWZmZXJlZCkpO1xuICAgICAgICAgICAgLy8gZmlsdGVyIHBvdGVudGlhbGx5IGV2aWN0ZWQgYnVmZmVyUmFuZ2UuIHRoaXMgaXMgdG8gYXZvaWQgbWVtbGVhayBvbiBsaXZlIHN0cmVhbXNcbiAgICAgICAgICAgIHZhciBidWZmZXJSYW5nZSA9IF90aGlzMy5idWZmZXJSYW5nZS5maWx0ZXIoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfYnVmZmVySGVscGVyMi5kZWZhdWx0LmlzQnVmZmVyZWQobWVkaWEsIChyYW5nZS5zdGFydCArIHJhbmdlLmVuZCkgLyAyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gcHVzaCBuZXcgcmFuZ2VcbiAgICAgICAgICAgIGJ1ZmZlclJhbmdlLnB1c2goeyB0eXBlOiBmcmFnLnR5cGUsIHN0YXJ0OiBmcmFnLnN0YXJ0UFRTLCBlbmQ6IGZyYWcuZW5kUFRTLCBmcmFnOiBmcmFnIH0pO1xuICAgICAgICAgICAgLy8gc29ydCwgYXMgd2UgdXNlIEJpbmFyeVNlYXJjaCBmb3IgbG9va3VwIGluIGdldEJ1ZmZlclJhbmdlIC4uLlxuICAgICAgICAgICAgX3RoaXMzLmJ1ZmZlclJhbmdlID0gYnVmZmVyUmFuZ2Uuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzMy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICAgICAgdmFyIHN0YXRzID0gX3RoaXMzLnN0YXRzO1xuICAgICAgICAgICAgc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgZ2V0IHJpZCBvZiB0aGlzLmZyYWdMYXN0S2Jwc1xuICAgICAgICAgICAgX3RoaXMzLmZyYWdMYXN0S2JwcyA9IE1hdGgucm91bmQoOCAqIHN0YXRzLnRvdGFsIC8gKHN0YXRzLnRidWZmZXJlZCAtIHN0YXRzLnRmaXJzdCkpO1xuICAgICAgICAgICAgX3RoaXMzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlJBR19CVUZGRVJFRCwgeyBzdGF0czogc3RhdHMsIGZyYWc6IGZyYWcsIGlkOiAnbWFpbicgfSk7XG4gICAgICAgICAgICBfdGhpczMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25FcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRXJyb3IoZGF0YSkge1xuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcgfHwgdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIC8vIGRvbid0IGhhbmRsZSBmcmFnIGVycm9yIG5vdCByZWxhdGVkIHRvIG1haW4gZnJhZ21lbnRcbiAgICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gJ21haW4nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG5cbiAgICAgIC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxuICAgICAgbWVkaWFCdWZmZXJlZCA9IG1lZGlhICYmIF9idWZmZXJIZWxwZXIyLmRlZmF1bHQuaXNCdWZmZXJlZChtZWRpYSwgbWVkaWEuY3VycmVudFRpbWUpICYmIF9idWZmZXJIZWxwZXIyLmRlZmF1bHQuaXNCdWZmZXJlZChtZWRpYSwgbWVkaWEuY3VycmVudFRpbWUgKyAwLjUpO1xuICAgICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICAgIGNhc2UgX2Vycm9ycy5FcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGNhc2UgX2Vycm9ycy5FcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICAgIGNhc2UgX2Vycm9ycy5FcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgICBpZiAoIWRhdGEuZmF0YWwpIHtcbiAgICAgICAgICAgIHZhciBsb2FkRXJyb3IgPSB0aGlzLmZyYWdMb2FkRXJyb3I7XG4gICAgICAgICAgICBpZiAobG9hZEVycm9yKSB7XG4gICAgICAgICAgICAgIGxvYWRFcnJvcisrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9hZEVycm9yID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIC8vIGtlZXAgcmV0cnlpbmcgLyBkb24ndCByYWlzZSBmYXRhbCBuZXR3b3JrIGVycm9yIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWQgb3IgaWYgaW4gYXV0b21vZGUgd2l0aCBjdXJyZW50IGxldmVsIG5vdCAwXG4gICAgICAgICAgICBpZiAobG9hZEVycm9yIDw9IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5IHx8IG1lZGlhQnVmZmVyZWQgfHwgZnJhZy5hdXRvTGV2ZWwgJiYgZnJhZy5sZXZlbCkge1xuICAgICAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSBsb2FkRXJyb3I7XG4gICAgICAgICAgICAgIC8vIHJlc2V0IGxvYWQgY291bnRlciB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvclxuICAgICAgICAgICAgICBmcmFnLmxvYWRDb3VudGVyID0gMDtcbiAgICAgICAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0XG4gICAgICAgICAgICAgIHZhciBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIGxvYWRFcnJvciAtIDEpICogY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSwgY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignbWVkaWFDb250cm9sbGVyOiBmcmFnIGxvYWRpbmcgZmFpbGVkLCByZXRyeSBpbiAnICsgZGVsYXkgKyAnIG1zJyk7XG4gICAgICAgICAgICAgIHRoaXMucmV0cnlEYXRlID0gcGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgICAgICAgICAgLy8gcmV0cnkgbG9hZGluZyBzdGF0ZVxuICAgICAgICAgICAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXG4gICAgICAgICAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmVycm9yKCdtZWRpYUNvbnRyb2xsZXI6ICcgKyBkYXRhLmRldGFpbHMgKyAnIHJlYWNoZXMgbWF4IHJldHJ5LCByZWRpc3BhdGNoIGFzIGZhdGFsIC4uLicpO1xuICAgICAgICAgICAgICAvLyByZWRpc3BhdGNoIHNhbWUgZXJyb3IgYnV0IHdpdGggZmF0YWwgc2V0IHRvIHRydWVcbiAgICAgICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgZGF0YSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX2Vycm9ycy5FcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1I6XG4gICAgICAgICAgaWYgKCFkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgICAvLyBpZiBidWZmZXIgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xuICAgICAgICAgICAgICAvLyB0cnkgdG8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIDogcmF0aW9uYWxlIGlzIHRoYXQgd2UgY291bGQgZ2V0XG4gICAgICAgICAgICAgIC8vIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGJlY2F1c2Ugb2YgYnVmZmVyIGV2aWN0aW9uXG4gICAgICAgICAgICAgIHRoaXMuX3JlZHVjZU1heEJ1ZmZlckxlbmd0aChmcmFnLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBidWZmZXIgZW1wdHkuIHJlcG9ydCBhcyBmYXRhbCBpZiBpbiBtYW51YWwgbW9kZSBvciBpZiBsb3dlc3QgbGV2ZWwuXG4gICAgICAgICAgICAgIC8vIGxldmVsIGNvbnRyb2xsZXIgdGFrZXMgY2FyZSBvZiBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gbG9naWNcbiAgICAgICAgICAgICAgaWYgKCFmcmFnLmF1dG9MZXZlbCB8fCBmcmFnLmxldmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVkaXNwYXRjaCBzYW1lIGVycm9yIGJ1dCB3aXRoIGZhdGFsIHNldCB0byB0cnVlXG4gICAgICAgICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX2Vycm9ycy5FcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2Fybignc3RyZWFtQ29udHJvbGxlcjogJyArIGRhdGEuZGV0YWlscyArICcsc3dpdGNoIHRvICcgKyB0aGlzLnN0YXRlICsgJyBzdGF0ZSAuLi4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGluIGNhcyBvZiBub24gZmF0YWwgZXJyb3Igd2hpbGUgd2FpdGluZyBsZXZlbCBsb2FkIHRvIGJlIGNvbXBsZXRlZCwgc3dpdGNoIGJhY2sgdG8gSURMRVxuICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICAgIC8vIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxuICAgICAgICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ21haW4nICYmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkpIHtcbiAgICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG4gICAgICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xuICAgICAgICAgICAgICB0aGlzLl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGgodGhpcy5jb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCwgYnV0IGJyb3dzZXIgaXMgc3RpbGwgY29tcGxhaW5pbmcgYWJvdXQgYnVmZmVyIGZ1bGwgZXJyb3JcbiAgICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9kYWlseW1vdGlvbi9obHMuanMvcHVsbC83MDhcbiAgICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdidWZmZXIgZnVsbCBlcnJvciBhbHNvIG1lZGlhLmN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgZmx1c2ggZXZlcnl0aGluZycpO1xuICAgICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgLy8gZmx1c2ggZXZlcnl0aGluZ1xuICAgICAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfcmVkdWNlTWF4QnVmZmVyTGVuZ3RoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZHVjZU1heEJ1ZmZlckxlbmd0aChtaW5MZW5ndGgpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIGlmIChjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID49IG1pbkxlbmd0aCkge1xuICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggYXMgaXQgbWlnaHQgYmUgdG9vIGhpZ2guIHdlIGRvIHRoaXMgdG8gYXZvaWQgbG9vcCBmbHVzaGluZyAuLi5cbiAgICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCAvPSAyO1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdtYWluOnJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byAnICsgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCArICdzJyk7XG4gICAgICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXG4gICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIGNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2NoZWNrQnVmZmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrQnVmZmVyKCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIC8vIGlmIHJlYWR5IHN0YXRlIGRpZmZlcmVudCBmcm9tIEhBVkVfTk9USElORyAobnVtZXJpYyB2YWx1ZSAwKSwgd2UgYXJlIGFsbG93ZWQgdG8gc2Vla1xuICAgICAgaWYgKG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWUsXG4gICAgICAgICAgICBtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogbWVkaWEsXG4gICAgICAgICAgICBidWZmZXJlZCA9IG1lZGlhQnVmZmVyLmJ1ZmZlcmVkO1xuICAgICAgICAvLyBhZGp1c3QgY3VycmVudFRpbWUgdG8gc3RhcnQgcG9zaXRpb24gb24gbG9hZGVkIG1ldGFkYXRhXG4gICAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBidWZmZXJlZC5sZW5ndGggJiYgIW1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgICAvLyBvbmx5IGFkanVzdCBjdXJyZW50VGltZSBpZiBkaWZmZXJlbnQgZnJvbSBzdGFydFBvc2l0aW9uIG9yIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkXG4gICAgICAgICAgLy8gYXQgdGhhdCBzdGFnZSwgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJ1ZmZlcmVkIHJhbmdlLCBhcyB3ZSByZWFjaCB0aGF0IGNvZGUgYWZ0ZXIgZmlyc3QgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWRcbiAgICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbixcbiAgICAgICAgICAgICAgc3RhcnRQb3NpdGlvbkJ1ZmZlcmVkID0gX2J1ZmZlckhlbHBlcjIuZGVmYXVsdC5pc0J1ZmZlcmVkKG1lZGlhQnVmZmVyLCBzdGFydFBvc2l0aW9uKTtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50VGltZSBub3QgbWF0Y2hpbmcgd2l0aCBleHBlY3RlZCBzdGFydFBvc2l0aW9uIG9yIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkXG4gICAgICAgICAgaWYgKGN1cnJlbnRUaW1lICE9PSBzdGFydFBvc2l0aW9uIHx8ICFzdGFydFBvc2l0aW9uQnVmZmVyZWQpIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygndGFyZ2V0IHN0YXJ0IHBvc2l0aW9uOicgKyBzdGFydFBvc2l0aW9uKTtcbiAgICAgICAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkLCBsZXQncyBzZWVrIHRvIGJ1ZmZlcmVkLnN0YXJ0KDApXG4gICAgICAgICAgICBpZiAoIXN0YXJ0UG9zaXRpb25CdWZmZXJlZCkge1xuICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uID0gYnVmZmVyZWQuc3RhcnQoMCk7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygndGFyZ2V0IHN0YXJ0IHBvc2l0aW9uIG5vdCBidWZmZXJlZCwgc2VlayB0byBidWZmZXJlZC5zdGFydCgwKSAnICsgc3RhcnRQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2FkanVzdCBjdXJyZW50VGltZSBmcm9tICcgKyBjdXJyZW50VGltZSArICcgdG8gJyArIHN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmltbWVkaWF0ZVN3aXRjaCkge1xuICAgICAgICAgIHRoaXMuaW1tZWRpYXRlTGV2ZWxTd2l0Y2hFbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYnVmZmVySW5mbyA9IF9idWZmZXJIZWxwZXIyLmRlZmF1bHQuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApLFxuICAgICAgICAgICAgICBleHBlY3RlZFBsYXlpbmcgPSAhKG1lZGlhLnBhdXNlZCB8fCAvLyBub3QgcGxheWluZyB3aGVuIG1lZGlhIGlzIHBhdXNlZFxuICAgICAgICAgIG1lZGlhLmVuZGVkIHx8IC8vIG5vdCBwbGF5aW5nIHdoZW4gbWVkaWEgaXMgZW5kZWRcbiAgICAgICAgICBtZWRpYS5idWZmZXJlZC5sZW5ndGggPT09IDApLFxuICAgICAgICAgICAgICAvLyBub3QgcGxheWluZyBpZiBub3RoaW5nIGJ1ZmZlcmVkXG4gICAgICAgICAganVtcFRocmVzaG9sZCA9IDAuNSxcbiAgICAgICAgICAgICAgLy8gdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgcmFuZ2UgZW5kXG4gICAgICAgICAgcGxheWhlYWRNb3ZpbmcgPSBjdXJyZW50VGltZSAhPT0gdGhpcy5sYXN0Q3VycmVudFRpbWUsXG4gICAgICAgICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgICAgaWYgKHBsYXloZWFkTW92aW5nKSB7XG4gICAgICAgICAgICAvLyBwbGF5ZWQgbW92aW5nLCBidXQgd2FzIHByZXZpb3VzbHkgc3RhbGxlZCA9PiBub3cgbm90IHN0dWNrIGFueW1vcmVcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWxsUmVwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybigncGxheWJhY2sgbm90IHN0dWNrIGFueW1vcmUgQCcgKyBjdXJyZW50VGltZSArICcsIGFmdGVyICcgKyBNYXRoLnJvdW5kKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFsbGVkKSArICdtcycpO1xuICAgICAgICAgICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBsYXloZWFkIG5vdCBtb3ZpbmdcbiAgICAgICAgICAgIGlmIChleHBlY3RlZFBsYXlpbmcpIHtcbiAgICAgICAgICAgICAgLy8gcGxheWhlYWQgbm90IG1vdmluZyBCVVQgbWVkaWEgZXhwZWN0ZWQgdG8gcGxheVxuICAgICAgICAgICAgICB2YXIgdG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5zdGFsbGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhbGwganVzdCBkZXRlY3RlZCwgc3RvcmUgY3VycmVudCB0aW1lXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFsbGVkID0gdG5vdztcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBwbGF5YmFjayBhbHJlYWR5IHN0YWxsZWQsIGNoZWNrIHN0YWxsaW5nIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgLy8gaWYgc3RhbGxpbmcgZm9yIG1vcmUgdGhhbiBhIGdpdmVuIHRocmVzaG9sZCwgbGV0J3MgdHJ5IHRvIHJlY292ZXJcbiAgICAgICAgICAgICAgICB2YXIgc3RhbGxlZER1cmF0aW9uID0gdG5vdyAtIHRoaXMuc3RhbGxlZDtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG4gICAgICAgICAgICAgICAgdmFyIG51ZGdlUmV0cnkgPSB0aGlzLm51ZGdlUmV0cnkgfHwgMDtcbiAgICAgICAgICAgICAgICAvLyBoYXZlIHdlIHJlYWNoZWQgc3RhbGwgZGVhZGxpbmUgP1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXJMZW4gPD0ganVtcFRocmVzaG9sZCAmJiBzdGFsbGVkRHVyYXRpb24gPiBjb25maWcubG93QnVmZmVyV2F0Y2hkb2dQZXJpb2QgKiAxMDAwKSB7XG4gICAgICAgICAgICAgICAgICAvLyByZXBvcnQgc3RhbGxlZCBlcnJvciBvbmNlXG4gICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdwbGF5YmFjayBzdGFsbGluZyBpbiBsb3cgYnVmZmVyIEAnICsgY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnVmZmVyOiBidWZmZXJMZW4gfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBpZiBidWZmZXIgbGVuIGlzIGJlbG93IHRocmVzaG9sZCwgdHJ5IHRvIGp1bXAgdG8gc3RhcnQgb2YgbmV4dCBidWZmZXIgcmFuZ2UgaWYgY2xvc2VcbiAgICAgICAgICAgICAgICAgIC8vIG5vIGJ1ZmZlciBhdmFpbGFibGUgQCBjdXJyZW50VGltZSwgY2hlY2sgaWYgbmV4dCBidWZmZXIgaXMgY2xvc2UgKHdpdGhpbiBhIGNvbmZpZy5tYXhTZWVrSG9sZSBzZWNvbmQgcmFuZ2UpXG4gICAgICAgICAgICAgICAgICB2YXIgbmV4dEJ1ZmZlclN0YXJ0ID0gYnVmZmVySW5mby5uZXh0U3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSBuZXh0QnVmZmVyU3RhcnQgLSBjdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICAgIGlmIChuZXh0QnVmZmVyU3RhcnQgJiYgZGVsdGEgPCBjb25maWcubWF4U2Vla0hvbGUgJiYgZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9ICsrbnVkZ2VSZXRyeTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51ZGdlT2Zmc2V0ID0gbnVkZ2VSZXRyeSAqIGNvbmZpZy5udWRnZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBidWZmZXIgaXMgY2xvc2UgISBhZGp1c3QgY3VycmVudFRpbWUgdG8gbmV4dEJ1ZmZlclN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBlbnN1cmUgZWZmZWN0aXZlIHZpZGVvIGRlY29kaW5nXG4gICAgICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnYWRqdXN0IGN1cnJlbnRUaW1lIGZyb20gJyArIG1lZGlhLmN1cnJlbnRUaW1lICsgJyB0byBuZXh0IGJ1ZmZlcmVkIEAgJyArIG5leHRCdWZmZXJTdGFydCArICcgKyBudWRnZSAnICsgbnVkZ2VPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IG5leHRCdWZmZXJTdGFydCArIG51ZGdlT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAvLyByZXNldCBzdGFsbGVkIHNvIHRvIHJlYXJtIHdhdGNoZG9nIHRpbWVyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkJVRkZFUl9TRUVLX09WRVJfSE9MRSwgZmF0YWw6IGZhbHNlLCBob2xlOiBuZXh0QnVmZmVyU3RhcnQgKyBudWRnZU9mZnNldCAtIGN1cnJlbnRUaW1lIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyTGVuID4ganVtcFRocmVzaG9sZCAmJiBzdGFsbGVkRHVyYXRpb24gPiBjb25maWcuaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kICogMTAwMCkge1xuICAgICAgICAgICAgICAgICAgLy8gcmVwb3J0IHN0YWxsZWQgZXJyb3Igb25jZVxuICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YWxsUmVwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybigncGxheWJhY2sgc3RhbGxpbmcgaW4gaGlnaCBidWZmZXIgQCcgKyBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUiwgZmF0YWw6IGZhbHNlLCBidWZmZXI6IGJ1ZmZlckxlbiB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IHN0YWxsZWQgc28gdG8gcmVhcm0gd2F0Y2hkb2cgdGltZXJcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9ICsrbnVkZ2VSZXRyeTtcbiAgICAgICAgICAgICAgICAgIGlmIChudWRnZVJldHJ5IDwgY29uZmlnLm51ZGdlTWF4UmV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VGltZSA9IF9jdXJyZW50VGltZSArIG51ZGdlUmV0cnkgKiBjb25maWcubnVkZ2VPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnYWRqdXN0IGN1cnJlbnRUaW1lIGZyb20gJyArIF9jdXJyZW50VGltZSArICcgdG8gJyArIHRhcmdldFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBwbGF5YmFjayBzdGFsbGVkIGluIGJ1ZmZlcmVkIGFyZWEgLi4uIGxldCdzIG51ZGdlIGN1cnJlbnRUaW1lIHRvIHRyeSB0byBvdmVyY29tZSB0aGlzXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gdGFyZ2V0VGltZTtcbiAgICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkJVRkZFUl9OVURHRV9PTl9TVEFMTCwgZmF0YWw6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIuZXJyb3IoJ3N0aWxsIHN0dWNrIGluIGhpZ2ggYnVmZmVyIEAnICsgY3VycmVudFRpbWUgKyAnIGFmdGVyICcgKyBjb25maWcubnVkZ2VNYXhSZXRyeSArICcsIHJhaXNlIGZhdGFsIGVycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUiwgZmF0YWw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCgpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcbiAgICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkJ1ZmZlckZsdXNoZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoZWQoKSB7XG4gICAgICAvKiBhZnRlciBzdWNjZXNzZnVsIGJ1ZmZlciBmbHVzaGluZywgZmlsdGVyIGZsdXNoZWQgZnJhZ21lbnRzIGZyb20gYnVmZmVyUmFuZ2VcbiAgICAgICAgdXNlIG1lZGlhQnVmZmVyZWQgaW5zdGVhZCBvZiBtZWRpYSAoc28gdGhhdCB3ZSB3aWxsIGNoZWNrIGFnYWluc3QgdmlkZW8uYnVmZmVyZWQgcmFuZ2VzIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIHRyYWNrKVxuICAgICAgKi9cbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICAgIHRoaXMuYnVmZmVyUmFuZ2UgPSB0aGlzLmJ1ZmZlclJhbmdlLmZpbHRlcihmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9idWZmZXJIZWxwZXIyLmRlZmF1bHQuaXNCdWZmZXJlZChtZWRpYSwgKHJhbmdlLnN0YXJ0ICsgcmFuZ2UuZW5kKSAvIDIpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXG4gICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gZnJhZ1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N3YXBBdWRpb0NvZGVjJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gIXRoaXMuYXVkaW9Db2RlY1N3YXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcHV0ZUxpdmVQb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgICB2YXIgdGFyZ2V0TGF0ZW5jeSA9IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gOiB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICByZXR1cm4gc2xpZGluZyArIE1hdGgubWF4KDAsIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uIC0gdGFyZ2V0TGF0ZW5jeSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RhdGUnLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5leHRTdGF0ZSkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ21haW4gc3RyZWFtOicgKyBwcmV2aW91c1N0YXRlICsgJy0+JyArIG5leHRTdGF0ZSk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5TVFJFQU1fU1RBVEVfVFJBTlNJVElPTiwgeyBwcmV2aW91c1N0YXRlOiBwcmV2aW91c1N0YXRlLCBuZXh0U3RhdGU6IG5leHRTdGF0ZSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2N1cnJlbnRMZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0QnVmZmVyUmFuZ2UobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gcmFuZ2UuZnJhZy5sZXZlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25leHRCdWZmZXJSYW5nZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIC8vIGZpcnN0IGdldCBlbmQgcmFuZ2Ugb2YgY3VycmVudCBmcmFnbWVudFxuICAgICAgICByZXR1cm4gdGhpcy5mb2xsb3dpbmdCdWZmZXJSYW5nZSh0aGlzLmdldEJ1ZmZlclJhbmdlKG1lZGlhLmN1cnJlbnRUaW1lKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduZXh0TGV2ZWwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5uZXh0QnVmZmVyUmFuZ2U7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLmZyYWcubGV2ZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGl2ZVN5bmNQb3NpdGlvbicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl9saXZlU3luY1Bvc2l0aW9uID0gdmFsdWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0cmVhbUNvbnRyb2xsZXI7XG59KF9ldmVudEhhbmRsZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTdHJlYW1Db250cm9sbGVyO1xuXG59LHtcIjI1XCI6MjUsXCIzMVwiOjMxLFwiMzJcIjozMixcIjMzXCI6MzMsXCIzNVwiOjM1LFwiMzZcIjozNixcIjQ2XCI6NDYsXCI1MFwiOjUwLFwiNTFcIjo1MX1dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ldmVudHMgPSBfZGVyZXFfKDMzKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9ldmVudEhhbmRsZXIgPSBfZGVyZXFfKDMyKTtcblxudmFyIF9ldmVudEhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRIYW5kbGVyKTtcblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3VidGl0bGUgU3RyZWFtIENvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0V2ZW50SGFuZGxlcikge1xuICBfaW5oZXJpdHMoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBfRXZlbnRIYW5kbGVyKTtcblxuICBmdW5jdGlvbiBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIoaGxzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyKSkuY2FsbCh0aGlzLCBobHMsIF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIF9ldmVudHMyLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIF9ldmVudHMyLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tfU1dJVENILCBfZXZlbnRzMi5kZWZhdWx0LlNVQlRJVExFX1RSQUNLX0xPQURFRCwgX2V2ZW50czIuZGVmYXVsdC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCkpO1xuXG4gICAgX3RoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICBfdGhpcy52dHRGcmFnU05zUHJvY2Vzc2VkID0ge307XG4gICAgX3RoaXMudnR0RnJhZ1F1ZXVlcyA9IHVuZGVmaW5lZDtcbiAgICBfdGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nID0gbnVsbDtcbiAgICBfdGhpcy5jdXJyZW50VHJhY2tJZCA9IC0xO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBfZXZlbnRIYW5kbGVyMi5kZWZhdWx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBxdWV1ZWQgaXRlbXMgYW5kIGNyZWF0ZSBhIG5ldywgZW1wdHkgcXVldWUgZm9yIGVhY2ggdHJhY2suXG5cbiAgfSwge1xuICAgIGtleTogJ2NsZWFyVnR0RnJhZ1F1ZXVlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyVnR0RnJhZ1F1ZXVlcygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnZ0dEZyYWdRdWV1ZXMgPSB7fTtcbiAgICAgIHRoaXMudHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIF90aGlzMi52dHRGcmFnUXVldWVzW3RyYWNrLmlkXSA9IFtdO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gZnJhZyBpcyBiZWluZyBwcm9jZXNzZWQgYW5kIHF1ZXVlIGlzbid0IGVtcHR5LCBpbml0aWF0ZSBwcm9jZXNzaW5nIG9mIG5leHQgZnJhZyBpbiBsaW5lLlxuXG4gIH0sIHtcbiAgICBrZXk6ICduZXh0RnJhZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHRGcmFnKCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA9PT0gbnVsbCAmJiB0aGlzLmN1cnJlbnRUcmFja0lkID4gLTEgJiYgdGhpcy52dHRGcmFnUXVldWVzW3RoaXMuY3VycmVudFRyYWNrSWRdLmxlbmd0aCkge1xuICAgICAgICB2YXIgZnJhZyA9IHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA9IHRoaXMudnR0RnJhZ1F1ZXVlc1t0aGlzLmN1cnJlbnRUcmFja0lkXS5zaGlmdCgpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlJBR19MT0FESU5HLCB7IGZyYWc6IGZyYWcgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2hlbiBmcmFnbWVudCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZywgYWRkIHNuIHRvIGxpc3Qgb2YgY29tcGxldGVkIGlmIHN1Y2Nlc3NmdWwuXG5cbiAgfSwge1xuICAgIGtleTogJ29uU3VidGl0bGVGcmFnUHJvY2Vzc2VkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQoZGF0YSkge1xuICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICB0aGlzLnZ0dEZyYWdTTnNQcm9jZXNzZWRbZGF0YS5mcmFnLnRyYWNrSWRdLnB1c2goZGF0YS5mcmFnLnNuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA9IG51bGw7XG4gICAgICB0aGlzLm5leHRGcmFnKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgc29tZXRoaW5nIGdvZXMgd3JvbmcsIHByb2NlZGUgdG8gbmV4dCBmcmFnLCBpZiB3ZSB3ZXJlIHByb2Nlc3Npbmcgb25lLlxuXG4gIH0sIHtcbiAgICBrZXk6ICdvbkVycm9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25FcnJvcihkYXRhKSB7XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgIC8vIGRvbid0IGhhbmRsZSBmcmFnIGVycm9yIG5vdCByZWxhdGVkIHRvIHN1YnRpdGxlIGZyYWdtZW50XG4gICAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdzdWJ0aXRsZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZykge1xuICAgICAgICB0aGlzLmN1cnJlbnRseVByb2Nlc3NpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRGcmFnKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR290IGFsbCBuZXcgc3VidGl0bGUgdHJhY2tzLlxuXG4gIH0sIHtcbiAgICBrZXk6ICdvblN1YnRpdGxlVHJhY2tzVXBkYXRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3N1YnRpdGxlIHRyYWNrcyB1cGRhdGVkJyk7XG4gICAgICB0aGlzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3M7XG4gICAgICB0aGlzLmNsZWFyVnR0RnJhZ1F1ZXVlcygpO1xuICAgICAgdGhpcy52dHRGcmFnU05zUHJvY2Vzc2VkID0ge307XG4gICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICBfdGhpczMudnR0RnJhZ1NOc1Byb2Nlc3NlZFt0cmFjay5pZF0gPSBbXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uU3VidGl0bGVUcmFja1N3aXRjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3VidGl0bGVUcmFja1N3aXRjaChkYXRhKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gZGF0YS5pZDtcbiAgICAgIHRoaXMuY2xlYXJWdHRGcmFnUXVldWVzKCk7XG4gICAgfVxuXG4gICAgLy8gR290IGEgbmV3IHNldCBvZiBzdWJ0aXRsZSBmcmFnbWVudHMuXG5cbiAgfSwge1xuICAgIGtleTogJ29uU3VidGl0bGVUcmFja0xvYWRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3VidGl0bGVUcmFja0xvYWRlZChkYXRhKSB7XG4gICAgICB2YXIgcHJvY2Vzc2VkRnJhZ1NOcyA9IHRoaXMudnR0RnJhZ1NOc1Byb2Nlc3NlZFtkYXRhLmlkXSxcbiAgICAgICAgICBmcmFnUXVldWUgPSB0aGlzLnZ0dEZyYWdRdWV1ZXNbZGF0YS5pZF0sXG4gICAgICAgICAgY3VycmVudEZyYWdTTiA9ICEhdGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nID8gdGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nLnNuIDogLTE7XG5cbiAgICAgIHZhciBhbHJlYWR5UHJvY2Vzc2VkID0gZnVuY3Rpb24gYWxyZWFkeVByb2Nlc3NlZChmcmFnKSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRGcmFnU05zLmluZGV4T2YoZnJhZy5zbikgPiAtMTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBhbHJlYWR5SW5RdWV1ZSA9IGZ1bmN0aW9uIGFscmVhZHlJblF1ZXVlKGZyYWcpIHtcbiAgICAgICAgcmV0dXJuIGZyYWdRdWV1ZS5zb21lKGZ1bmN0aW9uIChmcmFnSW5RdWV1ZSkge1xuICAgICAgICAgIHJldHVybiBmcmFnSW5RdWV1ZS5zbiA9PT0gZnJhZy5zbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBBZGQgYWxsIGZyYWdtZW50cyB0aGF0IGhhdmVuJ3QgYmVlbiwgYXJlbid0IGN1cnJlbnRseSBiZWluZyBhbmQgYXJlbid0IHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkLCB0byBxdWV1ZS5cbiAgICAgIGRhdGEuZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICBpZiAoIShhbHJlYWR5UHJvY2Vzc2VkKGZyYWcpIHx8IGZyYWcuc24gPT09IGN1cnJlbnRGcmFnU04gfHwgYWxyZWFkeUluUXVldWUoZnJhZykpKSB7XG4gICAgICAgICAgLy8gRnJhZ3MgZG9uJ3Qga25vdyB0aGVpciBzdWJ0aXRsZSB0cmFjayBJRCwgc28gbGV0J3MganVzdCBhZGQgdGhhdC4uLlxuICAgICAgICAgIGZyYWcudHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgICAgICAgZnJhZ1F1ZXVlLnB1c2goZnJhZyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm5leHRGcmFnKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjtcbn0oX2V2ZW50SGFuZGxlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjtcblxufSx7XCIzMlwiOjMyLFwiMzNcIjozMyxcIjUwXCI6NTB9XSwxNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZXZlbnRIYW5kbGVyID0gX2RlcmVxXygzMik7XG5cbnZhciBfZXZlbnRIYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50SGFuZGxlcik7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGF1ZGlvIHRyYWNrIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfRXZlbnRIYW5kbGVyKSB7XG4gIF9pbmhlcml0cyhTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciwgX0V2ZW50SGFuZGxlcik7XG5cbiAgZnVuY3Rpb24gU3VidGl0bGVUcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBobHMsIF9ldmVudHMyLmRlZmF1bHQuTUVESUFfQVRUQUNIRUQsIF9ldmVudHMyLmRlZmF1bHQuTUVESUFfREVUQUNISU5HLCBfZXZlbnRzMi5kZWZhdWx0Lk1BTklGRVNUX0xPQURJTkcsIF9ldmVudHMyLmRlZmF1bHQuTUFOSUZFU1RfTE9BREVELCBfZXZlbnRzMi5kZWZhdWx0LlNVQlRJVExFX1RSQUNLX0xPQURFRCkpO1xuXG4gICAgX3RoaXMudHJhY2tzID0gW107XG4gICAgX3RoaXMudHJhY2tJZCA9IC0xO1xuICAgIF90aGlzLm1lZGlhID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIF9ldmVudEhhbmRsZXIyLmRlZmF1bHQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHN1YnRpdGxlIHRyYWNrIGNoYW5nZSwgdGhlbiBleHRyYWN0IHRoZSBjdXJyZW50IHRyYWNrIElELlxuXG4gIH0sIHtcbiAgICBrZXk6ICdvbk1lZGlhQXR0YWNoZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoZWQoZGF0YSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTWVkaWEgaXMgdW5kZWZpbmVkIHdoZW4gc3dpdGNoaW5nIHN0cmVhbXMgdmlhIGxvYWRTb3VyY2UoKVxuICAgICAgICBpZiAoIV90aGlzMi5tZWRpYSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0cmFja0lkID0gLTE7XG4gICAgICAgIHZhciB0cmFja3MgPSBfdGhpczIubWVkaWEudGV4dFRyYWNrcztcbiAgICAgICAgZm9yICh2YXIgaWQgPSAwOyBpZCA8IHRyYWNrcy5sZW5ndGg7IGlkKyspIHtcbiAgICAgICAgICBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICAgIHRyYWNrSWQgPSBpZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0dGluZyBjdXJyZW50IHN1YnRpdGxlVHJhY2sgd2lsbCBpbnZva2UgY29kZS5cbiAgICAgICAgX3RoaXMyLnN1YnRpdGxlVHJhY2sgPSB0cmFja0lkO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYURldGFjaGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgICAvLyBUT0RPOiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgdGhpcy5tZWRpYSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBzdWJ0aXRsZSB0cmFja3Mgb24gbWFuaWZlc3QgbG9hZGluZ1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvbk1hbmlmZXN0TG9hZGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIH1cblxuICAgIC8vIEZpcmVkIHdoZW5ldmVyIGEgbmV3IG1hbmlmZXN0IGlzIGxvYWRlZC5cblxuICB9LCB7XG4gICAga2V5OiAnb25NYW5pZmVzdExvYWRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkZWQoZGF0YSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB0cmFja3MgPSBkYXRhLnN1YnRpdGxlcyB8fCBbXTtcbiAgICAgIHZhciBkZWZhdWx0Rm91bmQgPSBmYWxzZTtcbiAgICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHsgc3VidGl0bGVUcmFja3M6IHRyYWNrcyB9KTtcblxuICAgICAgLy8gbG9vcCB0aHJvdWdoIGF2YWlsYWJsZSBzdWJ0aXRsZSB0cmFja3MgYW5kIGF1dG9zZWxlY3QgZGVmYXVsdCBpZiBuZWVkZWRcbiAgICAgIC8vIFRPRE86IGltcHJvdmUgc2VsZWN0aW9uIGxvZ2ljIHRvIGhhbmRsZSBmb3JjZWQsIGV0Y1xuICAgICAgdHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIGlmICh0cmFjay5kZWZhdWx0KSB7XG4gICAgICAgICAgX3RoaXMzLnN1YnRpdGxlVHJhY2sgPSB0cmFjay5pZDtcbiAgICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBUcmlnZ2VyIHN1YnRpdGxlIHRyYWNrIHBsYXlsaXN0IHJlbG9hZC5cblxuICB9LCB7XG4gICAga2V5OiAnb25UaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25UaWNrKCkge1xuICAgICAgdmFyIHRyYWNrSWQgPSB0aGlzLnRyYWNrSWQ7XG4gICAgICB2YXIgc3VidGl0bGVUcmFjayA9IHRoaXMudHJhY2tzW3RyYWNrSWRdO1xuICAgICAgaWYgKCFzdWJ0aXRsZVRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRldGFpbHMgPSBzdWJ0aXRsZVRyYWNrLmRldGFpbHM7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGxvYWQgcGxheWxpc3QgZm9yIHRoaXMgc3VidGl0bGUgVHJhY2tcbiAgICAgIGlmIChkZXRhaWxzID09PSB1bmRlZmluZWQgfHwgZGV0YWlscy5saXZlID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHRyYWNrIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCcocmUpbG9hZGluZyBwbGF5bGlzdCBmb3Igc3VidGl0bGUgdHJhY2sgJyArIHRyYWNrSWQpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tfTE9BRElORywgeyB1cmw6IHN1YnRpdGxlVHJhY2sudXJsLCBpZDogdHJhY2tJZCB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvblN1YnRpdGxlVHJhY2tMb2FkZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tMb2FkZWQoZGF0YSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGlmIChkYXRhLmlkIDwgdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc3VidGl0bGUgdHJhY2sgJyArIGRhdGEuaWQgKyAnIGxvYWRlZCcpO1xuICAgICAgICB0aGlzLnRyYWNrc1tkYXRhLmlkXS5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgICAgICAvLyBjaGVjayBpZiBjdXJyZW50IHBsYXlsaXN0IGlzIGEgbGl2ZSBwbGF5bGlzdFxuICAgICAgICBpZiAoZGF0YS5kZXRhaWxzLmxpdmUgJiYgIXRoaXMudGltZXIpIHtcbiAgICAgICAgICAvLyBpZiBsaXZlIHBsYXlsaXN0IHdlIHdpbGwgaGF2ZSB0byByZWxvYWQgaXQgcGVyaW9kaWNhbGx5XG4gICAgICAgICAgLy8gc2V0IHJlbG9hZCBwZXJpb2QgdG8gcGxheWxpc3QgdGFyZ2V0IGR1cmF0aW9uXG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNC5vblRpY2soKTtcbiAgICAgICAgICB9LCAxMDAwICogZGF0YS5kZXRhaWxzLnRhcmdldGR1cmF0aW9uLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEuZGV0YWlscy5saXZlICYmIHRoaXMudGltZXIpIHtcbiAgICAgICAgICAvLyBwbGF5bGlzdCBpcyBub3QgbGl2ZSBhbmQgdGltZXIgaXMgYXJtZWQgOiBzdG9wcGluZyBpdFxuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRTdWJ0aXRsZVRyYWNrSW50ZXJuYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdWJ0aXRsZVRyYWNrSW50ZXJuYWwobmV3SWQpIHtcbiAgICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgICAgaWYgKG5ld0lkID49IDAgJiYgbmV3SWQgPCB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrSWQgPSBuZXdJZDtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzd2l0Y2hpbmcgdG8gc3VidGl0bGUgdHJhY2sgJyArIG5ld0lkKTtcbiAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2sgPSB0aGlzLnRyYWNrc1tuZXdJZF07XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHsgaWQ6IG5ld0lkIH0pO1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGxvYWQgcGxheWxpc3QgZm9yIHRoaXMgc3VidGl0bGUgVHJhY2tcbiAgICAgICAgdmFyIGRldGFpbHMgPSBzdWJ0aXRsZVRyYWNrLmRldGFpbHM7XG4gICAgICAgIGlmIChkZXRhaWxzID09PSB1bmRlZmluZWQgfHwgZGV0YWlscy5saXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnKHJlKWxvYWRpbmcgcGxheWxpc3QgZm9yIHN1YnRpdGxlIHRyYWNrICcgKyBuZXdJZCk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHsgdXJsOiBzdWJ0aXRsZVRyYWNrLnVybCwgaWQ6IG5ld0lkIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3VidGl0bGVUcmFja3MnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICAgIH1cblxuICAgIC8qKiBnZXQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cykgKiovXG5cbiAgfSwge1xuICAgIGtleTogJ3N1YnRpdGxlVHJhY2snLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2tJZDtcbiAgICB9XG5cbiAgICAvKiogc2VsZWN0IGEgc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cyoqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICAgIGlmICh0aGlzLnRyYWNrSWQgIT09IHN1YnRpdGxlVHJhY2tJZCkge1xuICAgICAgICAvLyB8fCB0aGlzLnRyYWNrc1tzdWJ0aXRsZVRyYWNrSWRdLmRldGFpbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2tJbnRlcm5hbChzdWJ0aXRsZVRyYWNrSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbn0oX2V2ZW50SGFuZGxlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuXG59LHtcIjMyXCI6MzIsXCIzM1wiOjMzLFwiNTBcIjo1MH1dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V2ZW50cyA9IF9kZXJlcV8oMzMpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX2V2ZW50SGFuZGxlciA9IF9kZXJlcV8oMzIpO1xuXG52YXIgX2V2ZW50SGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudEhhbmRsZXIpO1xuXG52YXIgX2NlYTYwOFBhcnNlciA9IF9kZXJlcV8oNDcpO1xuXG52YXIgX2NlYTYwOFBhcnNlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jZWE2MDhQYXJzZXIpO1xuXG52YXIgX3dlYnZ0dFBhcnNlciA9IF9kZXJlcV8oNTQpO1xuXG52YXIgX3dlYnZ0dFBhcnNlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93ZWJ2dHRQYXJzZXIpO1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaW1lbGluZSBDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5mdW5jdGlvbiBjbGVhckN1cnJlbnRDdWVzKHRyYWNrKSB7XG4gIGlmICh0cmFjayAmJiB0cmFjay5jdWVzKSB7XG4gICAgd2hpbGUgKHRyYWNrLmN1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdHJhY2sucmVtb3ZlQ3VlKHRyYWNrLmN1ZXNbMF0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrLCBtYW5pZmVzdFRyYWNrKSB7XG4gIHJldHVybiBpblVzZVRyYWNrICYmIGluVXNlVHJhY2subGFiZWwgPT09IG1hbmlmZXN0VHJhY2submFtZSAmJiAhKGluVXNlVHJhY2sudGV4dFRyYWNrMSB8fCBpblVzZVRyYWNrLnRleHRUcmFjazIpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oeDEsIHgyLCB5MSwgeTIpIHtcbiAgcmV0dXJuIE1hdGgubWluKHgyLCB5MikgLSBNYXRoLm1heCh4MSwgeTEpO1xufVxuXG52YXIgVGltZWxpbmVDb250cm9sbGVyID0gZnVuY3Rpb24gKF9FdmVudEhhbmRsZXIpIHtcbiAgX2luaGVyaXRzKFRpbWVsaW5lQ29udHJvbGxlciwgX0V2ZW50SGFuZGxlcik7XG5cbiAgZnVuY3Rpb24gVGltZWxpbmVDb250cm9sbGVyKGhscykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lbGluZUNvbnRyb2xsZXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFRpbWVsaW5lQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbWVsaW5lQ29udHJvbGxlcikpLmNhbGwodGhpcywgaGxzLCBfZXZlbnRzMi5kZWZhdWx0Lk1FRElBX0FUVEFDSElORywgX2V2ZW50czIuZGVmYXVsdC5NRURJQV9ERVRBQ0hJTkcsIF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCBfZXZlbnRzMi5kZWZhdWx0Lk1BTklGRVNUX0xPQURJTkcsIF9ldmVudHMyLmRlZmF1bHQuTUFOSUZFU1RfTE9BREVELCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfTE9BREVELCBfZXZlbnRzMi5kZWZhdWx0LkxFVkVMX1NXSVRDSElORywgX2V2ZW50czIuZGVmYXVsdC5JTklUX1BUU19GT1VORCkpO1xuXG4gICAgX3RoaXMuaGxzID0gaGxzO1xuICAgIF90aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgX3RoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgX3RoaXMuQ3VlcyA9IGhscy5jb25maWcuY3VlSGFuZGxlcjtcbiAgICBfdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgX3RoaXMudHJhY2tzID0gW107XG4gICAgX3RoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgIF90aGlzLmluaXRQVFMgPSB1bmRlZmluZWQ7XG4gICAgX3RoaXMuY3VlUmFuZ2VzID0gW107XG5cbiAgICBpZiAoX3RoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKSB7XG4gICAgICB2YXIgc2VsZiA9IF90aGlzO1xuICAgICAgdmFyIHNlbmRBZGRUcmFja0V2ZW50ID0gZnVuY3Rpb24gc2VuZEFkZFRyYWNrRXZlbnQodHJhY2ssIG1lZGlhKSB7XG4gICAgICAgIHZhciBlID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlID0gbmV3IHdpbmRvdy5FdmVudCgnYWRkdHJhY2snKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy9mb3IgSUUxMVxuICAgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgICBlLmluaXRFdmVudCgnYWRkdHJhY2snLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGUudHJhY2sgPSB0cmFjaztcbiAgICAgICAgbWVkaWEuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGFubmVsMSA9IHtcbiAgICAgICAgJ25ld0N1ZSc6IGZ1bmN0aW9uIG5ld0N1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbikge1xuICAgICAgICAgIGlmICghc2VsZi50ZXh0VHJhY2sxKSB7XG4gICAgICAgICAgICAvL0VuYWJsZSByZXVzZSBvZiBleGlzdGluZyB0ZXh0IHRyYWNrLlxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVHJhY2sxID0gc2VsZi5nZXRFeGlzdGluZ1RyYWNrKCcxJyk7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nVHJhY2sxKSB7XG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMSA9IHNlbGYuY3JlYXRlVGV4dFRyYWNrKCdjYXB0aW9ucycsICdFbmdsaXNoJywgJ2VuJyk7XG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMS50ZXh0VHJhY2sxID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMSA9IGV4aXN0aW5nVHJhY2sxO1xuICAgICAgICAgICAgICBzZWxmLmNsZWFyQ3VycmVudEN1ZXMoc2VsZi50ZXh0VHJhY2sxKTtcblxuICAgICAgICAgICAgICBzZW5kQWRkVHJhY2tFdmVudChzZWxmLnRleHRUcmFjazEsIHNlbGYubWVkaWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmFkZEN1ZXMoJ3RleHRUcmFjazEnLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGFubmVsMiA9IHtcbiAgICAgICAgJ25ld0N1ZSc6IGZ1bmN0aW9uIG5ld0N1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbikge1xuICAgICAgICAgIGlmICghc2VsZi50ZXh0VHJhY2syKSB7XG4gICAgICAgICAgICAvL0VuYWJsZSByZXVzZSBvZiBleGlzdGluZyB0ZXh0IHRyYWNrLlxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVHJhY2syID0gc2VsZi5nZXRFeGlzdGluZ1RyYWNrKCcyJyk7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nVHJhY2syKSB7XG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMiA9IHNlbGYuY3JlYXRlVGV4dFRyYWNrKCdjYXB0aW9ucycsICdTcGFuaXNoJywgJ2VzJyk7XG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMi50ZXh0VHJhY2syID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMiA9IGV4aXN0aW5nVHJhY2syO1xuXG4gICAgICAgICAgICAgIHNlbmRBZGRUcmFja0V2ZW50KHNlbGYudGV4dFRyYWNrMiwgc2VsZi5tZWRpYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuYWRkQ3VlcygndGV4dFRyYWNrMicsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3RoaXMuY2VhNjA4UGFyc2VyID0gbmV3IF9jZWE2MDhQYXJzZXIyLmRlZmF1bHQoMCwgY2hhbm5lbDEsIGNoYW5uZWwyKTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRpbWVsaW5lQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdhZGRDdWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ3VlcyhjaGFubmVsLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbikge1xuICAgICAgLy8gc2tpcCBjdWVzIHdoaWNoIG92ZXJsYXAgbW9yZSB0aGFuIDUwJSB3aXRoIHByZXZpb3VzbHkgcGFyc2VkIHRpbWUgcmFuZ2VzXG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5jdWVSYW5nZXM7XG4gICAgICB2YXIgbWVyZ2VkID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gcmFuZ2VzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICB2YXIgY3VlUmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgIHZhciBvdmVybGFwID0gaW50ZXJzZWN0aW9uKGN1ZVJhbmdlWzBdLCBjdWVSYW5nZVsxXSwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcbiAgICAgICAgaWYgKG92ZXJsYXAgPj0gMCkge1xuICAgICAgICAgIGN1ZVJhbmdlWzBdID0gTWF0aC5taW4oY3VlUmFuZ2VbMF0sIHN0YXJ0VGltZSk7XG4gICAgICAgICAgY3VlUmFuZ2VbMV0gPSBNYXRoLm1heChjdWVSYW5nZVsxXSwgZW5kVGltZSk7XG4gICAgICAgICAgbWVyZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAob3ZlcmxhcCAvIChlbmRUaW1lIC0gc3RhcnRUaW1lKSA+IDAuNSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFtZXJnZWQpIHtcbiAgICAgICAgcmFuZ2VzLnB1c2goW3N0YXJ0VGltZSwgZW5kVGltZV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5DdWVzLm5ld0N1ZSh0aGlzW2NoYW5uZWxdLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgfVxuXG4gICAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gaW5pdGlhbCBQVFMgaXMgZm91bmQ7IHVzZWQgZm9yIHN5bmNocm9uaXNhdGlvbiBvZiBXZWJWVFQuXG5cbiAgfSwge1xuICAgIGtleTogJ29uSW5pdFB0c0ZvdW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Jbml0UHRzRm91bmQoZGF0YSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5pbml0UFRTID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmluaXRQVFMgPSBkYXRhLmluaXRQVFM7XG4gICAgICB9XG5cbiAgICAgIC8vIER1ZSB0byBhc3luY2hyb255LCBpbml0aWFsIFBUUyBtYXkgYXJyaXZlIGxhdGVyIHRoYW4gdGhlIGZpcnN0IFZUVCBmcmFnbWVudHMgYXJlIGxvYWRlZC5cbiAgICAgIC8vIFBhcnNlIGFueSB1bnBhcnNlZCBmcmFnbWVudHMgdXBvbiByZWNlaXZpbmcgdGhlIGluaXRpYWwgUFRTLlxuICAgICAgaWYgKHRoaXMudW5wYXJzZWRWdHRGcmFncy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzLmZvckVhY2goZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgICBfdGhpczIub25GcmFnTG9hZGVkKGZyYWcpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0RXhpc3RpbmdUcmFjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEV4aXN0aW5nVHJhY2soY2hhbm5lbE51bWJlcikge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhLnRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdGV4dFRyYWNrID0gbWVkaWEudGV4dFRyYWNrc1tpXTtcbiAgICAgICAgICB2YXIgcHJvcE5hbWUgPSAndGV4dFRyYWNrJyArIGNoYW5uZWxOdW1iZXI7XG4gICAgICAgICAgaWYgKHRleHRUcmFja1twcm9wTmFtZV0gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVUZXh0VHJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBfZXZlbnRIYW5kbGVyMi5kZWZhdWx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYUF0dGFjaGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hpbmcoZGF0YSkge1xuICAgICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYURldGFjaGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgICBjbGVhckN1cnJlbnRDdWVzKHRoaXMudGV4dFRyYWNrMSk7XG4gICAgICBjbGVhckN1cnJlbnRDdWVzKHRoaXMudGV4dFRyYWNrMik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NYW5pZmVzdExvYWRpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAgIHRoaXMubGFzdFNuID0gLTE7IC8vIERldGVjdCBkaXNjb250aWd1aXR5IGluIGZyYWdtZW50IHBhcnNpbmdcbiAgICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgICB0aGlzLnZ0dENDcyA9IHsgY2NPZmZzZXQ6IDAsIHByZXNlbnRhdGlvbk9mZnNldDogMCB9OyAvLyBEZXRlY3QgZGlzY29udGludWl0eSBpbiBzdWJ0aXRsZSBtYW5pZmVzdHNcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1hbmlmZXN0TG9hZGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NYW5pZmVzdExvYWRlZChkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgfHwgW107XG4gICAgICB0aGlzLmluaXRQVFMgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlV2ViVlRUKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVzIHx8IFtdO1xuICAgICAgICAgIHZhciBpblVzZVRyYWNrcyA9IF90aGlzMy5tZWRpYSA/IF90aGlzMy5tZWRpYS50ZXh0VHJhY2tzIDogW107XG5cbiAgICAgICAgICBfdGhpczMudHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHRleHRUcmFjayA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBpblVzZVRyYWNrID0gaW5Vc2VUcmFja3NbaW5kZXhdO1xuICAgICAgICAgICAgLy8gUmV1c2UgdHJhY2tzIHdpdGggdGhlIHNhbWUgbGFiZWwsIGJ1dCBkbyBub3QgcmV1c2UgNjA4LzcwOCB0cmFja3NcbiAgICAgICAgICAgIGlmIChyZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrLCB0cmFjaykpIHtcbiAgICAgICAgICAgICAgdGV4dFRyYWNrID0gaW5Vc2VUcmFjaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRleHRUcmFjayA9IF90aGlzMy5jcmVhdGVUZXh0VHJhY2soJ3N1YnRpdGxlcycsIHRyYWNrLm5hbWUsIHRyYWNrLmxhbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dFRyYWNrLm1vZGUgPSB0cmFjay5kZWZhdWx0ID8gJ3Nob3dpbmcnIDogJ2hpZGRlbic7XG4gICAgICAgICAgICBfdGhpczMudGV4dFRyYWNrcy5wdXNoKHRleHRUcmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25MZXZlbFN3aXRjaGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTGV2ZWxTd2l0Y2hpbmcoKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLmhscy5jdXJyZW50TGV2ZWwuY2xvc2VkQ2FwdGlvbnMgIT09ICdOT05FJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZyYWdMb2FkZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZyYWdMb2FkZWQoZGF0YSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICAgIHBheWxvYWQgPSBkYXRhLnBheWxvYWQ7XG4gICAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgICAgdmFyIHNuID0gZnJhZy5zbjtcbiAgICAgICAgLy8gaWYgdGhpcyBmcmFnIGlzbid0IGNvbnRpZ3VvdXMsIGNsZWFyIHRoZSBwYXJzZXIgc28gY3VlcyB3aXRoIGJhZCBzdGFydC9lbmQgdGltZXMgYXJlbid0IGFkZGVkIHRvIHRoZSB0ZXh0VHJhY2tcbiAgICAgICAgaWYgKHNuICE9PSB0aGlzLmxhc3RTbiArIDEpIHtcbiAgICAgICAgICB0aGlzLmNlYTYwOFBhcnNlci5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFNuID0gc247XG4gICAgICB9XG4gICAgICAvLyBJZiBmcmFnbWVudCBpcyBzdWJ0aXRsZSB0eXBlLCBwYXJzZSBhcyBXZWJWVFQuXG4gICAgICBlbHNlIGlmIChmcmFnLnR5cGUgPT09ICdzdWJ0aXRsZScpIHtcbiAgICAgICAgICBpZiAocGF5bG9hZC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgX3JldDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIG5lZWQgYW4gaW5pdGlhbCBzeW5jaHJvbmlzYXRpb24gUFRTLiBTdG9yZSBmcmFnbWVudHMgYXMgbG9uZyBhcyBub25lIGhhcyBhcnJpdmVkLlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzNC5pbml0UFRTID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIF90aGlzNC51bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHY6IHZvaWQgMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHZ0dENDcyA9IF90aGlzNC52dHRDQ3M7XG4gICAgICAgICAgICAgIGlmICghdnR0Q0NzW2ZyYWcuY2NdKSB7XG4gICAgICAgICAgICAgICAgdnR0Q0NzW2ZyYWcuY2NdID0geyBzdGFydDogZnJhZy5zdGFydCwgcHJldkNDOiBfdGhpczQucHJldkNDLCBuZXc6IHRydWUgfTtcbiAgICAgICAgICAgICAgICBfdGhpczQucHJldkNDID0gZnJhZy5jYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgdGV4dFRyYWNrcyA9IF90aGlzNC50ZXh0VHJhY2tzLFxuICAgICAgICAgICAgICAgICAgaGxzID0gX3RoaXM0LmhscztcblxuICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgV2ViVlRUIGZpbGUgY29udGVudHMuXG4gICAgICAgICAgICAgIF93ZWJ2dHRQYXJzZXIyLmRlZmF1bHQucGFyc2UocGF5bG9hZCwgX3RoaXM0LmluaXRQVFMsIHZ0dENDcywgZnJhZy5jYywgZnVuY3Rpb24gKGN1ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgY3VlcyBhbmQgdHJpZ2dlciBldmVudCB3aXRoIHN1Y2Nlc3MgdHJ1ZS5cbiAgICAgICAgICAgICAgICBjdWVzLmZvckVhY2goZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgICAgICAgICAgICAgdGV4dFRyYWNrc1tmcmFnLnRyYWNrSWRdLmFkZEN1ZShjdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHsgc3VjY2VzczogdHJ1ZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBwYXJzaW5nLiBUcmlnZ2VyIGV2ZW50IHdpdGggc3VjY2VzcyBmYWxzZS5cbiAgICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ0ZhaWxlZCB0byBwYXJzZSBWVFQgY3VlOiAnICsgZSk7XG4gICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgIGlmICgodHlwZW9mIF9yZXQyID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihfcmV0MikpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldDIudjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBubyBwYXlsb2FkLCBmaW5pc2ggdW5zdWNjZXNzZnVsbHkuXG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHsgc3VjY2VzczogZmFsc2UsIGZyYWc6IGZyYWcgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GcmFnUGFyc2luZ1VzZXJkYXRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GcmFnUGFyc2luZ1VzZXJkYXRhKGRhdGEpIHtcbiAgICAgIC8vIHB1c2ggYWxsIG9mIHRoZSBDRUEtNzA4IG1lc3NhZ2VzIGludG8gdGhlIGludGVycHJldGVyXG4gICAgICAvLyBpbW1lZGlhdGVseS4gSXQgd2lsbCBjcmVhdGUgdGhlIHByb3BlciB0aW1lc3RhbXBzIGJhc2VkIG9uIG91ciBQVFMgdmFsdWVcbiAgICAgIGlmICh0aGlzLmVuYWJsZWQgJiYgdGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2NkYXRhcyA9IHRoaXMuZXh0cmFjdENlYTYwOERhdGEoZGF0YS5zYW1wbGVzW2ldLmJ5dGVzKTtcbiAgICAgICAgICB0aGlzLmNlYTYwOFBhcnNlci5hZGREYXRhKGRhdGEuc2FtcGxlc1tpXS5wdHMsIGNjZGF0YXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZXh0cmFjdENlYTYwOERhdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0Q2VhNjA4RGF0YShieXRlQXJyYXkpIHtcbiAgICAgIHZhciBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDMxO1xuICAgICAgdmFyIHBvc2l0aW9uID0gMjtcbiAgICAgIHZhciB0bXBCeXRlLCBjY2J5dGUxLCBjY2J5dGUyLCBjY1ZhbGlkLCBjY1R5cGU7XG4gICAgICB2YXIgYWN0dWFsQ0NCeXRlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgdG1wQnl0ZSA9IGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgICAgY2NieXRlMSA9IDB4N0YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICAgIGNjYnl0ZTIgPSAweDdGICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgICBjY1ZhbGlkID0gKDQgJiB0bXBCeXRlKSAhPT0gMDtcbiAgICAgICAgY2NUeXBlID0gMyAmIHRtcEJ5dGU7XG5cbiAgICAgICAgaWYgKGNjYnl0ZTEgPT09IDAgJiYgY2NieXRlMiA9PT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNjVmFsaWQpIHtcbiAgICAgICAgICBpZiAoY2NUeXBlID09PSAwKSAvLyB8fCBjY1R5cGUgPT09IDFcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYWN0dWFsQ0NCeXRlcy5wdXNoKGNjYnl0ZTEpO1xuICAgICAgICAgICAgICBhY3R1YWxDQ0J5dGVzLnB1c2goY2NieXRlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3R1YWxDQ0J5dGVzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUaW1lbGluZUNvbnRyb2xsZXI7XG59KF9ldmVudEhhbmRsZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUaW1lbGluZUNvbnRyb2xsZXI7XG5cbn0se1wiMzJcIjozMixcIjMzXCI6MzMsXCI0N1wiOjQ3LFwiNTBcIjo1MCxcIjU0XCI6NTR9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBBRVNDcnlwdG8gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFFU0NyeXB0byhzdWJ0bGUsIGl2KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFFU0NyeXB0byk7XG5cbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmFlc0lWID0gaXY7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQUVTQ3J5cHRvLCBbe1xuICAgIGtleTogJ2RlY3J5cHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0KGRhdGEsIGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3VidGxlLmRlY3J5cHQoeyBuYW1lOiAnQUVTLUNCQycsIGl2OiB0aGlzLmFlc0lWIH0sIGtleSwgZGF0YSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFFU0NyeXB0bztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQUVTQ3J5cHRvO1xuXG59LHt9XSwxODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBBRVNEZWNyeXB0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFFU0RlY3J5cHRvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQUVTRGVjcnlwdG9yKTtcblxuICAgIC8vIFN0YXRpYyBhZnRlciBydW5uaW5nIGluaXRUYWJsZVxuICAgIHRoaXMucmNvbiA9IFsweDAsIDB4MSwgMHgyLCAweDQsIDB4OCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG5cbiAgICB0aGlzLnN1Yk1peCA9IFtdO1xuICAgIHRoaXMuc3ViTWl4WzBdID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5zdWJNaXhbMV0gPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLnN1Yk1peFsyXSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMuc3ViTWl4WzNdID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG5cbiAgICB0aGlzLmludlN1Yk1peCA9IFtdO1xuICAgIHRoaXMuaW52U3ViTWl4WzBdID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5pbnZTdWJNaXhbMV0gPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLmludlN1Yk1peFsyXSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMuaW52U3ViTWl4WzNdID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG5cbiAgICB0aGlzLnNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLmludlNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcblxuICAgIC8vIENoYW5nZXMgZHVyaW5nIHJ1bnRpbWVcbiAgICB0aGlzLmtleSA9IG5ldyBVaW50MzJBcnJheSgwKTtcblxuICAgIHRoaXMuaW5pdFRhYmxlKCk7XG4gIH1cblxuICAvLyBVc2luZyB2aWV3LmdldFVpbnQzMigpIGFsc28gc3dhcHMgdGhlIGJ5dGUgb3JkZXIuXG5cblxuICBfY3JlYXRlQ2xhc3MoQUVTRGVjcnlwdG9yLCBbe1xuICAgIGtleTogJ3VpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgICAgdmFyIG5ld0FycmF5ID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdBcnJheVtpXSA9IHZpZXcuZ2V0VWludDMyKGkgKiA0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbml0VGFibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0VGFibGUoKSB7XG4gICAgICB2YXIgc0JveCA9IHRoaXMuc0JveDtcbiAgICAgIHZhciBpbnZTQm94ID0gdGhpcy5pbnZTQm94O1xuICAgICAgdmFyIHN1Yk1peDAgPSB0aGlzLnN1Yk1peFswXTtcbiAgICAgIHZhciBzdWJNaXgxID0gdGhpcy5zdWJNaXhbMV07XG4gICAgICB2YXIgc3ViTWl4MiA9IHRoaXMuc3ViTWl4WzJdO1xuICAgICAgdmFyIHN1Yk1peDMgPSB0aGlzLnN1Yk1peFszXTtcbiAgICAgIHZhciBpbnZTdWJNaXgwID0gdGhpcy5pbnZTdWJNaXhbMF07XG4gICAgICB2YXIgaW52U3ViTWl4MSA9IHRoaXMuaW52U3ViTWl4WzFdO1xuICAgICAgdmFyIGludlN1Yk1peDIgPSB0aGlzLmludlN1Yk1peFsyXTtcbiAgICAgIHZhciBpbnZTdWJNaXgzID0gdGhpcy5pbnZTdWJNaXhbM107XG5cbiAgICAgIHZhciBkID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgICB2YXIgeCA9IDA7XG4gICAgICB2YXIgeGkgPSAwO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgICAgZFtpXSA9IGkgPDwgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkW2ldID0gaSA8PCAxIF4gMHgxMWI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIHZhciBzeCA9IHhpIF4geGkgPDwgMSBeIHhpIDw8IDIgXiB4aSA8PCAzIF4geGkgPDwgNDtcbiAgICAgICAgc3ggPSBzeCA+Pj4gOCBeIHN4ICYgMHhmZiBeIDB4NjM7XG4gICAgICAgIHNCb3hbeF0gPSBzeDtcbiAgICAgICAgaW52U0JveFtzeF0gPSB4O1xuXG4gICAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cbiAgICAgICAgdmFyIHgyID0gZFt4XTtcbiAgICAgICAgdmFyIHg0ID0gZFt4Ml07XG4gICAgICAgIHZhciB4OCA9IGRbeDRdO1xuXG4gICAgICAgIC8vIENvbXB1dGUgc3ViL2ludlN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICAgIHZhciB0ID0gZFtzeF0gKiAweDEwMSBeIHN4ICogMHgxMDEwMTAwO1xuICAgICAgICBzdWJNaXgwW3hdID0gdCA8PCAyNCB8IHQgPj4+IDg7XG4gICAgICAgIHN1Yk1peDFbeF0gPSB0IDw8IDE2IHwgdCA+Pj4gMTY7XG4gICAgICAgIHN1Yk1peDJbeF0gPSB0IDw8IDggfCB0ID4+PiAyNDtcbiAgICAgICAgc3ViTWl4M1t4XSA9IHQ7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICAgIHQgPSB4OCAqIDB4MTAxMDEwMSBeIHg0ICogMHgxMDAwMSBeIHgyICogMHgxMDEgXiB4ICogMHgxMDEwMTAwO1xuICAgICAgICBpbnZTdWJNaXgwW3N4XSA9IHQgPDwgMjQgfCB0ID4+PiA4O1xuICAgICAgICBpbnZTdWJNaXgxW3N4XSA9IHQgPDwgMTYgfCB0ID4+PiAxNjtcbiAgICAgICAgaW52U3ViTWl4MltzeF0gPSB0IDw8IDggfCB0ID4+PiAyNDtcbiAgICAgICAgaW52U3ViTWl4M1tzeF0gPSB0O1xuXG4gICAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG4gICAgICAgIGlmICgheCkge1xuICAgICAgICAgIHggPSB4aSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcbiAgICAgICAgICB4aSBePSBkW2RbeGldXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2V4cGFuZEtleScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4cGFuZEtleShrZXlCdWZmZXIpIHtcbiAgICAgIC8vIGNvbnZlcnQga2V5QnVmZmVyIHRvIFVpbnQzMkFycmF5XG4gICAgICB2YXIga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcbiAgICAgIHZhciBzYW1lS2V5ID0gdHJ1ZTtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICB3aGlsZSAob2Zmc2V0IDwga2V5Lmxlbmd0aCAmJiBzYW1lS2V5KSB7XG4gICAgICAgIHNhbWVLZXkgPSBrZXlbb2Zmc2V0XSA9PT0gdGhpcy5rZXlbb2Zmc2V0XTtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG5cbiAgICAgIGlmIChzYW1lS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB2YXIga2V5U2l6ZSA9IHRoaXMua2V5U2l6ZSA9IGtleS5sZW5ndGg7XG5cbiAgICAgIGlmIChrZXlTaXplICE9PSA0ICYmIGtleVNpemUgIT09IDYgJiYga2V5U2l6ZSAhPT0gOCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWVzIGtleSBzaXplPScgKyBrZXlTaXplKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtzUm93cyA9IHRoaXMua3NSb3dzID0gKGtleVNpemUgKyA2ICsgMSkgKiA0O1xuICAgICAgdmFyIGtzUm93ID0gdm9pZCAwO1xuICAgICAgdmFyIGludktzUm93ID0gdm9pZCAwO1xuXG4gICAgICB2YXIga2V5U2NoZWR1bGUgPSB0aGlzLmtleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KHRoaXMua3NSb3dzKTtcbiAgICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkodGhpcy5rc1Jvd3MpO1xuICAgICAgdmFyIHNib3ggPSB0aGlzLnNCb3g7XG4gICAgICB2YXIgcmNvbiA9IHRoaXMucmNvbjtcblxuICAgICAgdmFyIGludlN1Yk1peDAgPSB0aGlzLmludlN1Yk1peFswXTtcbiAgICAgIHZhciBpbnZTdWJNaXgxID0gdGhpcy5pbnZTdWJNaXhbMV07XG4gICAgICB2YXIgaW52U3ViTWl4MiA9IHRoaXMuaW52U3ViTWl4WzJdO1xuICAgICAgdmFyIGludlN1Yk1peDMgPSB0aGlzLmludlN1Yk1peFszXTtcblxuICAgICAgdmFyIHByZXYgPSB2b2lkIDA7XG4gICAgICB2YXIgdCA9IHZvaWQgMDtcblxuICAgICAgZm9yIChrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcbiAgICAgICAgICBwcmV2ID0ga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5W2tzUm93XTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ID0gcHJldjtcblxuICAgICAgICBpZiAoa3NSb3cgJSBrZXlTaXplID09PSAwKSB7XG4gICAgICAgICAgLy8gUm90IHdvcmRcbiAgICAgICAgICB0ID0gdCA8PCA4IHwgdCA+Pj4gMjQ7XG5cbiAgICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICAgIHQgPSBzYm94W3QgPj4+IDI0XSA8PCAyNCB8IHNib3hbdCA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IHNib3hbdCA+Pj4gOCAmIDB4ZmZdIDw8IDggfCBzYm94W3QgJiAweGZmXTtcblxuICAgICAgICAgIC8vIE1peCBSY29uXG4gICAgICAgICAgdCBePSByY29uW2tzUm93IC8ga2V5U2l6ZSB8IDBdIDw8IDI0O1xuICAgICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PT0gNCkge1xuICAgICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgICAgdCA9IHNib3hbdCA+Pj4gMjRdIDw8IDI0IHwgc2JveFt0ID4+PiAxNiAmIDB4ZmZdIDw8IDE2IHwgc2JveFt0ID4+PiA4ICYgMHhmZl0gPDwgOCB8IHNib3hbdCAmIDB4ZmZdO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0gcHJldiA9IChrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdCkgPj4+IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgICAgICBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuICAgICAgICBpZiAoaW52S3NSb3cgJiAzKSB7XG4gICAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52U3ViTWl4MFtzYm94W3QgPj4+IDI0XV0gXiBpbnZTdWJNaXgxW3Nib3hbdCA+Pj4gMTYgJiAweGZmXV0gXiBpbnZTdWJNaXgyW3Nib3hbdCA+Pj4gOCAmIDB4ZmZdXSBeIGludlN1Yk1peDNbc2JveFt0ICYgMHhmZl1dO1xuICAgICAgICB9XG5cbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID4+PiAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZGluZyB0aGlzIGFzIGEgbWV0aG9kIGdyZWF0bHkgaW1wcm92ZXMgcGVyZm9ybWFuY2UuXG5cbiAgfSwge1xuICAgIGtleTogJ25ldHdvcmtUb0hvc3RPcmRlclN3YXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKHdvcmQpIHtcbiAgICAgIHJldHVybiB3b3JkIDw8IDI0IHwgKHdvcmQgJiAweGZmMDApIDw8IDggfCAod29yZCAmIDB4ZmYwMDAwKSA+PiA4IHwgd29yZCA+Pj4gMjQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVjcnlwdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3J5cHQoaW5wdXRBcnJheUJ1ZmZlciwgb2Zmc2V0LCBhZXNJVikge1xuICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLmtleVNpemUgKyA2O1xuICAgICAgdmFyIGludktleVNjaGVkdWxlID0gdGhpcy5pbnZLZXlTY2hlZHVsZTtcbiAgICAgIHZhciBpbnZTQk9YID0gdGhpcy5pbnZTQm94O1xuXG4gICAgICB2YXIgaW52U3ViTWl4MCA9IHRoaXMuaW52U3ViTWl4WzBdO1xuICAgICAgdmFyIGludlN1Yk1peDEgPSB0aGlzLmludlN1Yk1peFsxXTtcbiAgICAgIHZhciBpbnZTdWJNaXgyID0gdGhpcy5pbnZTdWJNaXhbMl07XG4gICAgICB2YXIgaW52U3ViTWl4MyA9IHRoaXMuaW52U3ViTWl4WzNdO1xuXG4gICAgICB2YXIgaW5pdFZlY3RvciA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGFlc0lWKTtcbiAgICAgIHZhciBpbml0VmVjdG9yMCA9IGluaXRWZWN0b3JbMF07XG4gICAgICB2YXIgaW5pdFZlY3RvcjEgPSBpbml0VmVjdG9yWzFdO1xuICAgICAgdmFyIGluaXRWZWN0b3IyID0gaW5pdFZlY3RvclsyXTtcbiAgICAgIHZhciBpbml0VmVjdG9yMyA9IGluaXRWZWN0b3JbM107XG5cbiAgICAgIHZhciBpbnB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRBcnJheUJ1ZmZlcik7XG4gICAgICB2YXIgb3V0cHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEludDMyLmxlbmd0aCk7XG5cbiAgICAgIHZhciB0MCA9IHZvaWQgMCxcbiAgICAgICAgICB0MSA9IHZvaWQgMCxcbiAgICAgICAgICB0MiA9IHZvaWQgMCxcbiAgICAgICAgICB0MyA9IHZvaWQgMDtcbiAgICAgIHZhciBzMCA9IHZvaWQgMCxcbiAgICAgICAgICBzMSA9IHZvaWQgMCxcbiAgICAgICAgICBzMiA9IHZvaWQgMCxcbiAgICAgICAgICBzMyA9IHZvaWQgMDtcbiAgICAgIHZhciBpbnB1dFdvcmRzMCA9IHZvaWQgMCxcbiAgICAgICAgICBpbnB1dFdvcmRzMSA9IHZvaWQgMCxcbiAgICAgICAgICBpbnB1dFdvcmRzMiA9IHZvaWQgMCxcbiAgICAgICAgICBpbnB1dFdvcmRzMyA9IHZvaWQgMDtcblxuICAgICAgdmFyIGtzUm93LCBpO1xuXG4gICAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXRJbnQzMi5sZW5ndGgpIHtcbiAgICAgICAgaW5wdXRXb3JkczAgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXAoaW5wdXRJbnQzMltvZmZzZXRdKTtcbiAgICAgICAgaW5wdXRXb3JkczEgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXAoaW5wdXRJbnQzMltvZmZzZXQgKyAxXSk7XG4gICAgICAgIGlucHV0V29yZHMyID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKGlucHV0SW50MzJbb2Zmc2V0ICsgMl0pO1xuICAgICAgICBpbnB1dFdvcmRzMyA9IHRoaXMubmV0d29ya1RvSG9zdE9yZGVyU3dhcChpbnB1dEludDMyW29mZnNldCArIDNdKTtcblxuICAgICAgICBzMCA9IGlucHV0V29yZHMwIF4gaW52S2V5U2NoZWR1bGVbMF07XG4gICAgICAgIHMxID0gaW5wdXRXb3JkczMgXiBpbnZLZXlTY2hlZHVsZVsxXTtcbiAgICAgICAgczIgPSBpbnB1dFdvcmRzMiBeIGludktleVNjaGVkdWxlWzJdO1xuICAgICAgICBzMyA9IGlucHV0V29yZHMxIF4gaW52S2V5U2NoZWR1bGVbM107XG5cbiAgICAgICAga3NSb3cgPSA0O1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcm91bmRzIG9mIGRlY3J5cHRpb25cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG5Sb3VuZHM7IGkrKykge1xuICAgICAgICAgIHQwID0gaW52U3ViTWl4MFtzMCA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMSA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMiA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgICAgdDEgPSBpbnZTdWJNaXgwW3MxID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MyID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MzID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczAgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICAgICAgdDIgPSBpbnZTdWJNaXgwW3MyID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MzID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MwID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICAgICAgdDMgPSBpbnZTdWJNaXgwW3MzID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MwID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MxID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107XG4gICAgICAgICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgICAgICAgczAgPSB0MDtcbiAgICAgICAgICBzMSA9IHQxO1xuICAgICAgICAgIHMyID0gdDI7XG4gICAgICAgICAgczMgPSB0MztcblxuICAgICAgICAgIGtzUm93ID0ga3NSb3cgKyA0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG4gICAgICAgIHQwID0gaW52U0JPWFtzMCA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMSA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMiA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczMgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgdDEgPSBpbnZTQk9YW3MxID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MyID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MzID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgICAgdDIgPSBpbnZTQk9YW3MyID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MzID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MwID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgICAgdDMgPSBpbnZTQk9YW3MzID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MwID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MxID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMiAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcbiAgICAgICAga3NSb3cgPSBrc1JvdyArIDM7XG5cbiAgICAgICAgLy8gV3JpdGVcbiAgICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0XSA9IHRoaXMubmV0d29ya1RvSG9zdE9yZGVyU3dhcCh0MCBeIGluaXRWZWN0b3IwKTtcbiAgICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgMV0gPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXAodDMgXiBpbml0VmVjdG9yMSk7XG4gICAgICAgIG91dHB1dEludDMyW29mZnNldCArIDJdID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKHQyIF4gaW5pdFZlY3RvcjIpO1xuICAgICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAzXSA9IHRoaXMubmV0d29ya1RvSG9zdE9yZGVyU3dhcCh0MSBeIGluaXRWZWN0b3IzKTtcblxuICAgICAgICAvLyByZXNldCBpbml0VmVjdG9yIHRvIGxhc3QgNCB1bnNpZ25lZCBpbnRcbiAgICAgICAgaW5pdFZlY3RvcjAgPSBpbnB1dFdvcmRzMDtcbiAgICAgICAgaW5pdFZlY3RvcjEgPSBpbnB1dFdvcmRzMTtcbiAgICAgICAgaW5pdFZlY3RvcjIgPSBpbnB1dFdvcmRzMjtcbiAgICAgICAgaW5pdFZlY3RvcjMgPSBpbnB1dFdvcmRzMztcblxuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyA0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0SW50MzIuYnVmZmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5rZXkgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmtleVNpemUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmtzUm93cyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5zQm94ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbnZTQm94ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5zdWJNaXggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmludlN1Yk1peCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMua2V5U2NoZWR1bGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmludktleVNjaGVkdWxlID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnJjb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFFU0RlY3J5cHRvcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQUVTRGVjcnlwdG9yO1xuXG59LHt9XSwxOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfYWVzQ3J5cHRvID0gX2RlcmVxXygxNyk7XG5cbnZhciBfYWVzQ3J5cHRvMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Flc0NyeXB0byk7XG5cbnZhciBfZmFzdEFlc0tleSA9IF9kZXJlcV8oMjApO1xuXG52YXIgX2Zhc3RBZXNLZXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmFzdEFlc0tleSk7XG5cbnZhciBfYWVzRGVjcnlwdG9yID0gX2RlcmVxXygxOCk7XG5cbnZhciBfYWVzRGVjcnlwdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Flc0RlY3J5cHRvcik7XG5cbnZhciBfZXJyb3JzID0gX2RlcmVxXygzMSk7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qZ2xvYmFscyBzZWxmOiBmYWxzZSAqL1xuXG52YXIgRGVjcnlwdGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEZWNyeXB0ZXIob2JzZXJ2ZXIsIGNvbmZpZykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZWNyeXB0ZXIpO1xuXG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBicm93c2VyQ3J5cHRvID0gY3J5cHRvID8gY3J5cHRvIDogc2VsZi5jcnlwdG87XG4gICAgICB0aGlzLnN1YnRsZSA9IGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8IGJyb3dzZXJDcnlwdG8ud2Via2l0U3VidGxlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdGhpcy5kaXNhYmxlV2ViQ3J5cHRvID0gIXRoaXMuc3VidGxlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERlY3J5cHRlciwgW3tcbiAgICBrZXk6ICdpc1N5bmMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N5bmMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXNhYmxlV2ViQ3J5cHRvICYmIHRoaXMuY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlY3J5cHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0KGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5kaXNhYmxlV2ViQ3J5cHRvICYmIHRoaXMuY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTKSB7XG4gICAgICAgIGlmICh0aGlzLmxvZ0VuYWJsZWQpIHtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ0pTIEFFUyBkZWNyeXB0Jyk7XG4gICAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlY3J5cHRvciA9IHRoaXMuZGVjcnlwdG9yO1xuICAgICAgICBpZiAoIWRlY3J5cHRvcikge1xuICAgICAgICAgIHRoaXMuZGVjcnlwdG9yID0gZGVjcnlwdG9yID0gbmV3IF9hZXNEZWNyeXB0b3IyLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNyeXB0b3IuZXhwYW5kS2V5KGtleSk7XG4gICAgICAgIGNhbGxiYWNrKGRlY3J5cHRvci5kZWNyeXB0KGRhdGEsIDAsIGl2KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5sb2dFbmFibGVkKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ1dlYkNyeXB0byBBRVMgZGVjcnlwdCcpO1xuICAgICAgICAgICAgX3RoaXMubG9nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3VidGxlID0gX3RoaXMuc3VidGxlO1xuICAgICAgICAgIGlmIChfdGhpcy5rZXkgIT09IGtleSkge1xuICAgICAgICAgICAgX3RoaXMua2V5ID0ga2V5O1xuICAgICAgICAgICAgX3RoaXMuZmFzdEFlc0tleSA9IG5ldyBfZmFzdEFlc0tleTIuZGVmYXVsdChzdWJ0bGUsIGtleSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuZmFzdEFlc0tleS5leHBhbmRLZXkoKS50aGVuKGZ1bmN0aW9uIChhZXNLZXkpIHtcbiAgICAgICAgICAgIC8vIGRlY3J5cHQgdXNpbmcgd2ViIGNyeXB0b1xuICAgICAgICAgICAgdmFyIGNyeXB0byA9IG5ldyBfYWVzQ3J5cHRvMi5kZWZhdWx0KHN1YnRsZSwgaXYpO1xuICAgICAgICAgICAgY3J5cHRvLmRlY3J5cHQoZGF0YSwgYWVzS2V5KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIF90aGlzLm9uV2ViQ3J5cHRvRXJyb3IoZXJyLCBkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIF90aGlzLm9uV2ViQ3J5cHRvRXJyb3IoZXJyLCBkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25XZWJDcnlwdG9FcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uV2ViQ3J5cHRvRXJyb3IoZXJyLCBkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnV2ViQ3J5cHRvIEVycm9yLCBkaXNhYmxlIFdlYkNyeXB0byBBUEknKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlV2ViQ3J5cHRvID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWNyeXB0KGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmVycm9yKCdkZWNyeXB0aW5nIGVycm9yIDogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiBlcnIubWVzc2FnZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBkZWNyeXB0b3IgPSB0aGlzLmRlY3J5cHRvcjtcbiAgICAgIGlmIChkZWNyeXB0b3IpIHtcbiAgICAgICAgZGVjcnlwdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kZWNyeXB0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERlY3J5cHRlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRGVjcnlwdGVyO1xuXG59LHtcIjE3XCI6MTcsXCIxOFwiOjE4LFwiMjBcIjoyMCxcIjMxXCI6MzEsXCI1MFwiOjUwfV0sMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgRmFzdEFFU0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmFzdEFFU0tleShzdWJ0bGUsIGtleSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGYXN0QUVTS2V5KTtcblxuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZhc3RBRVNLZXksIFt7XG4gICAga2V5OiAnZXhwYW5kS2V5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhwYW5kS2V5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3VidGxlLmltcG9ydEtleSgncmF3JywgdGhpcy5rZXksIHsgbmFtZTogJ0FFUy1DQkMnIH0sIGZhbHNlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmFzdEFFU0tleTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRmFzdEFFU0tleTtcblxufSx7fV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpOyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBBQUMgZGVtdXhlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbnZhciBfYWR0cyA9IF9kZXJlcV8oMjIpO1xuXG52YXIgX2FkdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWR0cyk7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbnZhciBfaWQgPSBfZGVyZXFfKDI3KTtcblxudmFyIF9pZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBBQUNEZW11eGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBQUNEZW11eGVyKG9ic2VydmVyLCByZW11eGVyLCBjb25maWcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQUFDRGVtdXhlcik7XG5cbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5yZW11eGVyID0gcmVtdXhlcjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBQUNEZW11eGVyLCBbe1xuICAgIGtleTogJ3Jlc2V0SW5pdFNlZ21lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xuICAgICAgdGhpcy5fYWFjVHJhY2sgPSB7IGNvbnRhaW5lcjogJ2F1ZGlvL2FkdHMnLCB0eXBlOiAnYXVkaW8nLCBpZDogLTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBpc0FBQzogdHJ1ZSwgc2FtcGxlczogW10sIGxlbjogMCwgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYywgZHVyYXRpb246IGR1cmF0aW9uIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVzZXRUaW1lU3RhbXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFRpbWVTdGFtcCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdhcHBlbmQnLFxuXG5cbiAgICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICAgIHZhciB0cmFjayxcbiAgICAgICAgICBpZDMgPSBuZXcgX2lkMi5kZWZhdWx0KGRhdGEpLFxuICAgICAgICAgIHB0cyA9IDkwICogaWQzLnRpbWVTdGFtcCxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgZnJhbWVMZW5ndGgsXG4gICAgICAgICAgZnJhbWVEdXJhdGlvbixcbiAgICAgICAgICBmcmFtZUluZGV4LFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICBoZWFkZXJMZW5ndGgsXG4gICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgbGVuLFxuICAgICAgICAgIGFhY1NhbXBsZTtcblxuICAgICAgdHJhY2sgPSB0aGlzLl9hYWNUcmFjaztcblxuICAgICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICAgIGZvciAob2Zmc2V0ID0gaWQzLmxlbmd0aCwgbGVuID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGYwKSA9PT0gMHhmMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdHJhY2suYXVkaW9zYW1wbGVyYXRlKSB7XG4gICAgICAgIGNvbmZpZyA9IF9hZHRzMi5kZWZhdWx0LmdldEF1ZGlvQ29uZmlnKHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdHJhY2subWFuaWZlc3RDb2RlYyk7XG4gICAgICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgICAgIHRyYWNrLmF1ZGlvc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgICAgICB0cmFjay5jaGFubmVsQ291bnQgPSBjb25maWcuY2hhbm5lbENvdW50O1xuICAgICAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlYztcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdwYXJzZWQgY29kZWM6JyArIHRyYWNrLmNvZGVjICsgJyxyYXRlOicgKyBjb25maWcuc2FtcGxlcmF0ZSArICcsbmIgY2hhbm5lbDonICsgY29uZmlnLmNoYW5uZWxDb3VudCk7XG4gICAgICB9XG4gICAgICBmcmFtZUluZGV4ID0gMDtcbiAgICAgIGZyYW1lRHVyYXRpb24gPSAxMDI0ICogOTAwMDAgLyB0cmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgICB3aGlsZSAob2Zmc2V0ICsgNSA8IGxlbikge1xuICAgICAgICAvLyBUaGUgcHJvdGVjdGlvbiBza2lwIGJpdCB0ZWxscyB1cyBpZiB3ZSBoYXZlIDIgYnl0ZXMgb2YgQ1JDIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgQURUUyBoZWFkZXJcbiAgICAgICAgaGVhZGVyTGVuZ3RoID0gISEoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDEpID8gNyA6IDk7XG4gICAgICAgIC8vIHJldHJpZXZlIGZyYW1lIHNpemVcbiAgICAgICAgZnJhbWVMZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MDMpIDw8IDExIHwgZGF0YVtvZmZzZXQgKyA0XSA8PCAzIHwgKGRhdGFbb2Zmc2V0ICsgNV0gJiAweEUwKSA+Pj4gNTtcbiAgICAgICAgZnJhbWVMZW5ndGggLT0gaGVhZGVyTGVuZ3RoO1xuICAgICAgICAvL3N0YW1wID0gcGVzLnB0cztcblxuICAgICAgICBpZiAoZnJhbWVMZW5ndGggPiAwICYmIG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoIDw9IGxlbikge1xuICAgICAgICAgIHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgICAgICAgLy9sb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9LyR7KHN0YW1wLzkwKS50b0ZpeGVkKDApfWApO1xuICAgICAgICAgIGFhY1NhbXBsZSA9IHsgdW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoKSwgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcCB9O1xuICAgICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNTYW1wbGUpO1xuICAgICAgICAgIHRyYWNrLmxlbiArPSBmcmFtZUxlbmd0aDtcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWVMZW5ndGggKyBoZWFkZXJMZW5ndGg7XG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgICAgICAgZm9yICg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhmMCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnJlbXV4ZXIucmVtdXgodHJhY2ssIHsgc2FtcGxlczogW10gfSwgeyBzYW1wbGVzOiBbeyBwdHM6IHB0cywgZHRzOiBwdHMsIHVuaXQ6IGlkMy5wYXlsb2FkIH1dIH0sIHsgc2FtcGxlczogW10gfSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHt9XG4gIH1dLCBbe1xuICAgIGtleTogJ3Byb2JlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvYmUoZGF0YSkge1xuICAgICAgLy8gY2hlY2sgaWYgZGF0YSBjb250YWlucyBJRDMgdGltZXN0YW1wIGFuZCBBRFRTIHN5bmMgd29yY1xuICAgICAgdmFyIGlkMyA9IG5ldyBfaWQyLmRlZmF1bHQoZGF0YSksXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIGxlbjtcbiAgICAgIGlmIChpZDMuaGFzVGltZVN0YW1wKSB7XG4gICAgICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgICAgIGZvciAob2Zmc2V0ID0gaWQzLmxlbmd0aCwgbGVuID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjApID09PSAweGYwKSB7XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coJ0FEVFMgc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBQUNEZW11eGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBBQUNEZW11eGVyO1xuXG59LHtcIjIyXCI6MjIsXCIyN1wiOjI3LFwiNTBcIjo1MH1dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEFEVFMgcGFyc2VyIGhlbHBlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbnZhciBfZXJyb3JzID0gX2RlcmVxXygzMSk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBBRFRTID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBRFRTKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBRFRTKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBRFRTLCBudWxsLCBbe1xuICAgIGtleTogJ2dldEF1ZGlvQ29uZmlnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXVkaW9Db25maWcob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYykge1xuICAgICAgdmFyIGFkdHNPYmplY3RUeXBlLFxuICAgICAgICAgIC8vIDppbnRcbiAgICAgIGFkdHNTYW1wbGVpbmdJbmRleCxcbiAgICAgICAgICAvLyA6aW50XG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXgsXG4gICAgICAgICAgLy8gOmludFxuICAgICAgYWR0c0NoYW5lbENvbmZpZyxcbiAgICAgICAgICAvLyA6aW50XG4gICAgICBjb25maWcsXG4gICAgICAgICAgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIG1hbmlmZXN0Q29kZWMgPSBhdWRpb0NvZGVjLFxuICAgICAgICAgIGFkdHNTYW1wbGVpbmdSYXRlcyA9IFs5NjAwMCwgODgyMDAsIDY0MDAwLCA0ODAwMCwgNDQxMDAsIDMyMDAwLCAyNDAwMCwgMjIwNTAsIDE2MDAwLCAxMjAwMCwgMTEwMjUsIDgwMDAsIDczNTBdO1xuICAgICAgLy8gYnl0ZSAyXG4gICAgICBhZHRzT2JqZWN0VHlwZSA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4QzApID4+PiA2KSArIDE7XG4gICAgICBhZHRzU2FtcGxlaW5nSW5kZXggPSAoZGF0YVtvZmZzZXQgKyAyXSAmIDB4M0MpID4+PiAyO1xuICAgICAgaWYgKGFkdHNTYW1wbGVpbmdJbmRleCA+IGFkdHNTYW1wbGVpbmdSYXRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCByZWFzb246ICdpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6JyArIGFkdHNTYW1wbGVpbmdJbmRleCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYWR0c0NoYW5lbENvbmZpZyA9IChkYXRhW29mZnNldCArIDJdICYgMHgwMSkgPDwgMjtcbiAgICAgIC8vIGJ5dGUgM1xuICAgICAgYWR0c0NoYW5lbENvbmZpZyB8PSAoZGF0YVtvZmZzZXQgKyAzXSAmIDB4QzApID4+PiA2O1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdtYW5pZmVzdCBjb2RlYzonICsgYXVkaW9Db2RlYyArICcsQURUUyBkYXRhOnR5cGU6JyArIGFkdHNPYmplY3RUeXBlICsgJyxzYW1wbGVpbmdJbmRleDonICsgYWR0c1NhbXBsZWluZ0luZGV4ICsgJ1snICsgYWR0c1NhbXBsZWluZ1JhdGVzW2FkdHNTYW1wbGVpbmdJbmRleF0gKyAnSHpdLGNoYW5uZWxDb25maWc6JyArIGFkdHNDaGFuZWxDb25maWcpO1xuICAgICAgLy8gZmlyZWZveDogZnJlcSBsZXNzIHRoYW4gMjRrSHogPSBBQUMgU0JSIChIRS1BQUMpXG4gICAgICBpZiAoL2ZpcmVmb3gvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgICAgaWYgKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2KSB7XG4gICAgICAgICAgYWR0c09iamVjdFR5cGUgPSA1O1xuICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSg0KTtcbiAgICAgICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYmVsb3csIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXG4gICAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4IC0gMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbmRyb2lkIDogYWx3YXlzIHVzZSBBQUNcbiAgICAgIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEpIHtcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKENocm9tZS9WaXZhbGRpL09wZXJhIC4uLilcbiAgICAgICAgICAgIGFsd2F5cyBmb3JjZSBhdWRpbyB0eXBlIHRvIGJlIEhFLUFBQyBTQlIsIGFzIHNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgYXVkaW8gY29kZWMgc3dpdGNoIHByb3Blcmx5IChsaWtlIENocm9tZSAuLi4pXG4gICAgICAgICovXG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgSEUtQUFDIG9yIEhFLUFBQ3YyKSBPUiAobWFuaWZlc3QgY29kZWMgbm90IHNwZWNpZmllZCBBTkQgZnJlcXVlbmN5IGxlc3MgdGhhbiAyNGtIeilcbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMgJiYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSB8fCBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkgfHwgIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsZWluZ0luZGV4ID49IDYpIHtcbiAgICAgICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYmVsb3csIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXG4gICAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4IC0gMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgQUFDKSBBTkQgKGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHogQU5EIG5iIGNoYW5uZWwgaXMgMSkgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgYW5kIG1vbm8gYXVkaW8pXG4gICAgICAgICAgLy8gQ2hyb21lIGZhaWxzIHRvIHBsYXkgYmFjayB3aXRoIGxvdyBmcmVxdWVuY3kgQUFDIExDIG1vbm8gd2hlbiBpbml0aWFsaXplZCB3aXRoIEhFLUFBQy4gIFRoaXMgaXMgbm90IGEgcHJvYmxlbSB3aXRoIHN0ZXJlby5cbiAgICAgICAgICBpZiAoYXVkaW9Db2RlYyAmJiBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSAmJiBhZHRzU2FtcGxlaW5nSW5kZXggPj0gNiAmJiBhZHRzQ2hhbmVsQ29uZmlnID09PSAxIHx8ICFhdWRpb0NvZGVjICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpIHtcbiAgICAgICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiByZWZlciB0byBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1NUEVHLTRfQXVkaW8jQXVkaW9fU3BlY2lmaWNfQ29uZmlnXG4gICAgICAgICAgSVNPIDE0NDk2LTMgKEFBQykucGRmIC0gVGFibGUgMS4xMyDigJQgU3ludGF4IG9mIEF1ZGlvU3BlY2lmaWNDb25maWcoKVxuICAgICAgICBBdWRpbyBQcm9maWxlIC8gQXVkaW8gT2JqZWN0IFR5cGVcbiAgICAgICAgMDogTnVsbFxuICAgICAgICAxOiBBQUMgTWFpblxuICAgICAgICAyOiBBQUMgTEMgKExvdyBDb21wbGV4aXR5KVxuICAgICAgICAzOiBBQUMgU1NSIChTY2FsYWJsZSBTYW1wbGUgUmF0ZSlcbiAgICAgICAgNDogQUFDIExUUCAoTG9uZyBUZXJtIFByZWRpY3Rpb24pXG4gICAgICAgIDU6IFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbilcbiAgICAgICAgNjogQUFDIFNjYWxhYmxlXG4gICAgICAgc2FtcGxpbmcgZnJlcVxuICAgICAgICAwOiA5NjAwMCBIelxuICAgICAgICAxOiA4ODIwMCBIelxuICAgICAgICAyOiA2NDAwMCBIelxuICAgICAgICAzOiA0ODAwMCBIelxuICAgICAgICA0OiA0NDEwMCBIelxuICAgICAgICA1OiAzMjAwMCBIelxuICAgICAgICA2OiAyNDAwMCBIelxuICAgICAgICA3OiAyMjA1MCBIelxuICAgICAgICA4OiAxNjAwMCBIelxuICAgICAgICA5OiAxMjAwMCBIelxuICAgICAgICAxMDogMTEwMjUgSHpcbiAgICAgICAgMTE6IDgwMDAgSHpcbiAgICAgICAgMTI6IDczNTAgSHpcbiAgICAgICAgMTM6IFJlc2VydmVkXG4gICAgICAgIDE0OiBSZXNlcnZlZFxuICAgICAgICAxNTogZnJlcXVlbmN5IGlzIHdyaXR0ZW4gZXhwbGljdGx5XG4gICAgICAgIENoYW5uZWwgQ29uZmlndXJhdGlvbnNcbiAgICAgICAgVGhlc2UgYXJlIHRoZSBjaGFubmVsIGNvbmZpZ3VyYXRpb25zOlxuICAgICAgICAwOiBEZWZpbmVkIGluIEFPVCBTcGVjaWZjIENvbmZpZ1xuICAgICAgICAxOiAxIGNoYW5uZWw6IGZyb250LWNlbnRlclxuICAgICAgICAyOiAyIGNoYW5uZWxzOiBmcm9udC1sZWZ0LCBmcm9udC1yaWdodFxuICAgICAgKi9cbiAgICAgIC8vIGF1ZGlvT2JqZWN0VHlwZSA9IHByb2ZpbGUgPT4gcHJvZmlsZSwgdGhlIE1QRUctNCBBdWRpbyBPYmplY3QgVHlwZSBtaW51cyAxXG4gICAgICBjb25maWdbMF0gPSBhZHRzT2JqZWN0VHlwZSA8PCAzO1xuICAgICAgLy8gc2FtcGxpbmdGcmVxdWVuY3lJbmRleFxuICAgICAgY29uZmlnWzBdIHw9IChhZHRzU2FtcGxlaW5nSW5kZXggJiAweDBFKSA+PiAxO1xuICAgICAgY29uZmlnWzFdIHw9IChhZHRzU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgICAgLy8gY2hhbm5lbENvbmZpZ3VyYXRpb25cbiAgICAgIGNvbmZpZ1sxXSB8PSBhZHRzQ2hhbmVsQ29uZmlnIDw8IDM7XG4gICAgICBpZiAoYWR0c09iamVjdFR5cGUgPT09IDUpIHtcbiAgICAgICAgLy8gYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4XG4gICAgICAgIGNvbmZpZ1sxXSB8PSAoYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ICYgMHgwRSkgPj4gMTtcbiAgICAgICAgY29uZmlnWzJdID0gKGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCAmIDB4MDEpIDw8IDc7XG4gICAgICAgIC8vIGFkdHNPYmplY3RUeXBlIChmb3JjZSB0byAyLCBjaHJvbWUgaXMgY2hlY2tpbmcgdGhhdCBvYmplY3QgdHlwZSBpcyBsZXNzIHRoYW4gNSA/Pz9cbiAgICAgICAgLy8gICAgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy5naXQvKy9tYXN0ZXIvbWVkaWEvZm9ybWF0cy9tcDQvYWFjLmNjXG4gICAgICAgIGNvbmZpZ1syXSB8PSAyIDw8IDI7XG4gICAgICAgIGNvbmZpZ1szXSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBjb25maWc6IGNvbmZpZywgc2FtcGxlcmF0ZTogYWR0c1NhbXBsZWluZ1JhdGVzW2FkdHNTYW1wbGVpbmdJbmRleF0sIGNoYW5uZWxDb3VudDogYWR0c0NoYW5lbENvbmZpZywgY29kZWM6ICdtcDRhLjQwLicgKyBhZHRzT2JqZWN0VHlwZSwgbWFuaWZlc3RDb2RlYzogbWFuaWZlc3RDb2RlYyB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBRFRTO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBBRFRTO1xuXG59LHtcIjMxXCI6MzEsXCI1MFwiOjUwfV0sMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpOyAvKiAgaW5saW5lIGRlbXV4ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBwcm9iZSBmcmFnbWVudHMgYW5kIGluc3RhbnRpYXRlIGFwcHJvcHJpYXRlIGRlbXV4ZXIgZGVwZW5kaW5nIG9uIGNvbnRlbnQgdHlwZSAoVFNEZW11eGVyLCBBQUNEZW11eGVyLCAuLi4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZXJyb3JzID0gX2RlcmVxXygzMSk7XG5cbnZhciBfZGVjcnlwdGVyID0gX2RlcmVxXygxOSk7XG5cbnZhciBfZGVjcnlwdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlY3J5cHRlcik7XG5cbnZhciBfYWFjZGVtdXhlciA9IF9kZXJlcV8oMjEpO1xuXG52YXIgX2FhY2RlbXV4ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWFjZGVtdXhlcik7XG5cbnZhciBfbXA0ZGVtdXhlciA9IF9kZXJlcV8oMjgpO1xuXG52YXIgX21wNGRlbXV4ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbXA0ZGVtdXhlcik7XG5cbnZhciBfdHNkZW11eGVyID0gX2RlcmVxXygzMCk7XG5cbnZhciBfdHNkZW11eGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RzZGVtdXhlcik7XG5cbnZhciBfbXA0UmVtdXhlciA9IF9kZXJlcV8oNDMpO1xuXG52YXIgX21wNFJlbXV4ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbXA0UmVtdXhlcik7XG5cbnZhciBfcGFzc3Rocm91Z2hSZW11eGVyID0gX2RlcmVxXyg0NCk7XG5cbnZhciBfcGFzc3Rocm91Z2hSZW11eGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bhc3N0aHJvdWdoUmVtdXhlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBEZW11eGVySW5saW5lID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEZW11eGVySW5saW5lKG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVtdXhlcklubGluZSk7XG5cbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEZW11eGVySW5saW5lLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgICBpZiAoZGVtdXhlcikge1xuICAgICAgICBkZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUykge1xuICAgICAgaWYgKGRhdGEuYnl0ZUxlbmd0aCA+IDAgJiYgZGVjcnlwdGRhdGEgIT0gbnVsbCAmJiBkZWNyeXB0ZGF0YS5rZXkgIT0gbnVsbCAmJiBkZWNyeXB0ZGF0YS5tZXRob2QgPT09ICdBRVMtMTI4Jykge1xuICAgICAgICB2YXIgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXI7XG4gICAgICAgIGlmIChkZWNyeXB0ZXIgPT0gbnVsbCkge1xuICAgICAgICAgIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyID0gbmV3IF9kZWNyeXB0ZXIyLmRlZmF1bHQodGhpcy5vYnNlcnZlciwgdGhpcy5jb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2NhbHRoaXMgPSB0aGlzO1xuICAgICAgICAvLyBwZXJmb3JtYW5jZS5ub3coKSBub3QgYXZhaWxhYmxlIG9uIFdlYldvcmtlciwgYXQgbGVhc3Qgb24gU2FmYXJpIERlc2t0b3BcbiAgICAgICAgdmFyIHN0YXJ0VGltZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIGRlY3J5cHRlci5kZWNyeXB0KGRhdGEsIGRlY3J5cHRkYXRhLmtleS5idWZmZXIsIGRlY3J5cHRkYXRhLml2LmJ1ZmZlciwgZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICB2YXIgZW5kVGltZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9jYWx0aGlzLm9ic2VydmVyLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX0RFQ1JZUFRFRCwgeyBzdGF0czogeyB0c3RhcnQ6IHN0YXJ0VGltZSwgdGRlY3J5cHQ6IGVuZFRpbWUgfSB9KTtcbiAgICAgICAgICBsb2NhbHRoaXMucHVzaERlY3J5cHRlZChuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKSwgZGVjcnlwdGRhdGEsIG5ldyBVaW50OEFycmF5KGluaXRTZWdtZW50KSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnB1c2hEZWNyeXB0ZWQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGRlY3J5cHRkYXRhLCBuZXcgVWludDhBcnJheShpbml0U2VnbWVudCksIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHVzaERlY3J5cHRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2hEZWNyeXB0ZWQoZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgaWYgKCFkZW11eGVyIHx8XG4gICAgICAvLyBpbiBjYXNlIG9mIGNvbnRpbnVpdHkgY2hhbmdlLCB3ZSBtaWdodCBzd2l0Y2ggZnJvbSBjb250ZW50IHR5cGUgKEFBQyBjb250YWluZXIgdG8gVFMgY29udGFpbmVyIGZvciBleGFtcGxlKVxuICAgICAgLy8gc28gbGV0J3MgY2hlY2sgdGhhdCBjdXJyZW50IGRlbXV4ZXIgaXMgc3RpbGwgdmFsaWRcbiAgICAgIGRpc2NvbnRpbnVpdHkgJiYgIXRoaXMucHJvYmUoZGF0YSkpIHtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcbiAgICAgICAgdmFyIHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQ7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgdmFyIG11eENvbmZpZyA9IFt7IGRlbXV4OiBfdHNkZW11eGVyMi5kZWZhdWx0LCByZW11eDogX21wNFJlbXV4ZXIyLmRlZmF1bHQgfSwgeyBkZW11eDogX2FhY2RlbXV4ZXIyLmRlZmF1bHQsIHJlbXV4OiBfbXA0UmVtdXhlcjIuZGVmYXVsdCB9LCB7IGRlbXV4OiBfbXA0ZGVtdXhlcjIuZGVmYXVsdCwgcmVtdXg6IF9wYXNzdGhyb3VnaFJlbXV4ZXIyLmRlZmF1bHQgfV07XG5cbiAgICAgICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuICAgICAgICBmb3IgKHZhciBpIGluIG11eENvbmZpZykge1xuICAgICAgICAgIHZhciBtdXggPSBtdXhDb25maWdbaV07XG4gICAgICAgICAgdmFyIHByb2JlID0gbXV4LmRlbXV4LnByb2JlO1xuICAgICAgICAgIGlmIChwcm9iZShkYXRhKSkge1xuICAgICAgICAgICAgdmFyIF9yZW11eGVyID0gdGhpcy5yZW11eGVyID0gbmV3IG11eC5yZW11eChvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKTtcbiAgICAgICAgICAgIGRlbXV4ZXIgPSBuZXcgbXV4LmRlbXV4KG9ic2VydmVyLCBfcmVtdXhlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKTtcbiAgICAgICAgICAgIHRoaXMucHJvYmUgPSBwcm9iZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlbXV4ZXIpIHtcbiAgICAgICAgICBvYnNlcnZlci50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCByZWFzb246ICdubyBkZW11eCBtYXRjaGluZyB3aXRoIGNvbnRlbnQgZm91bmQnIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBkZW11eGVyO1xuICAgICAgfVxuICAgICAgdmFyIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG5cbiAgICAgIGlmIChkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoKSB7XG4gICAgICAgIGRlbXV4ZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pO1xuICAgICAgICByZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXNjb250aW51aXR5KSB7XG4gICAgICAgIGRlbXV4ZXIucmVzZXRUaW1lU3RhbXAoKTtcbiAgICAgICAgcmVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFBUUyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRlbXV4ZXIuc2V0RGVjcnlwdERhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGVtdXhlci5zZXREZWNyeXB0RGF0YShkZWNyeXB0ZGF0YSk7XG4gICAgICB9XG4gICAgICBkZW11eGVyLmFwcGVuZChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEZW11eGVySW5saW5lO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEZW11eGVySW5saW5lO1xuXG59LHtcIjE5XCI6MTksXCIyMVwiOjIxLFwiMjhcIjoyOCxcIjMwXCI6MzAsXCIzMVwiOjMxLFwiMzNcIjozMyxcIjQzXCI6NDMsXCI0NFwiOjQ0fV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2RlbXV4ZXJJbmxpbmUgPSBfZGVyZXFfKDIzKTtcblxudmFyIF9kZW11eGVySW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlbXV4ZXJJbmxpbmUpO1xuXG52YXIgX2V2ZW50cyA9IF9kZXJlcV8oMzMpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG52YXIgX2V2ZW50czMgPSBfZGVyZXFfKDEpO1xuXG52YXIgX2V2ZW50czQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogZGVtdXhlciB3ZWIgd29ya2VyLlxuICogIC0gbGlzdGVuIHRvIHdvcmtlciBtZXNzYWdlLCBhbmQgdHJpZ2dlciBEZW11eGVySW5saW5lIHVwb24gcmVjZXB0aW9uIG9mIEZyYWdtZW50cy5cbiAqICAtIHByb3ZpZGVzIE1QNCBCb3hlcyBiYWNrIHRvIG1haW4gdGhyZWFkIHVzaW5nIFt0cmFuc2ZlcmFibGUgb2JqZWN0c10oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxMS8xMi9UcmFuc2ZlcmFibGUtT2JqZWN0cy1MaWdodG5pbmctRmFzdCkgaW4gb3JkZXIgdG8gbWluaW1pemUgbWVzc2FnZSBwYXNzaW5nIG92ZXJoZWFkLlxuICovXG5cbnZhciBEZW11eGVyV29ya2VyID0gZnVuY3Rpb24gRGVtdXhlcldvcmtlcihzZWxmKSB7XG4gIC8vIG9ic2VydmVyIHNldHVwXG4gIHZhciBvYnNlcnZlciA9IG5ldyBfZXZlbnRzNC5kZWZhdWx0KCk7XG4gIG9ic2VydmVyLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyKGV2ZW50KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGRhdGEgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBkYXRhW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBvYnNlcnZlci5lbWl0LmFwcGx5KG9ic2VydmVyLCBbZXZlbnQsIGV2ZW50XS5jb25jYXQoZGF0YSkpO1xuICB9O1xuXG4gIG9ic2VydmVyLm9mZiA9IGZ1bmN0aW9uIG9mZihldmVudCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgZGF0YSA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGRhdGFbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgb2JzZXJ2ZXIucmVtb3ZlTGlzdGVuZXIuYXBwbHkob2JzZXJ2ZXIsIFtldmVudF0uY29uY2F0KGRhdGEpKTtcbiAgfTtcblxuICB2YXIgZm9yd2FyZE1lc3NhZ2UgPSBmdW5jdGlvbiBmb3J3YXJkTWVzc2FnZShldiwgZGF0YSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBldmVudDogZXYsIGRhdGE6IGRhdGEgfSk7XG4gIH07XG5cbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgdmFyIGRhdGEgPSBldi5kYXRhO1xuICAgIC8vY29uc29sZS5sb2coJ2RlbXV4ZXIgY21kOicgKyBkYXRhLmNtZCk7XG4gICAgc3dpdGNoIChkYXRhLmNtZCkge1xuICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgIHZhciBjb25maWcgPSBKU09OLnBhcnNlKGRhdGEuY29uZmlnKTtcbiAgICAgICAgc2VsZi5kZW11eGVyID0gbmV3IF9kZW11eGVySW5saW5lMi5kZWZhdWx0KG9ic2VydmVyLCBkYXRhLnR5cGVTdXBwb3J0ZWQsIGNvbmZpZyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgKDAsIF9sb2dnZXIuZW5hYmxlTG9ncykoY29uZmlnLmRlYnVnID09PSB0cnVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdkZW11eGVyV29ya2VyOiB1bmFibGUgdG8gZW5hYmxlIGxvZ3MnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaWduYWwgZW5kIG9mIHdvcmtlciBpbml0XG4gICAgICAgIGZvcndhcmRNZXNzYWdlKCdpbml0JywgbnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGVtdXgnOlxuICAgICAgICBzZWxmLmRlbXV4ZXIucHVzaChkYXRhLmRhdGEsIGRhdGEuZGVjcnlwdGRhdGEsIGRhdGEuaW5pdFNlZ21lbnQsIGRhdGEuYXVkaW9Db2RlYywgZGF0YS52aWRlb0NvZGVjLCBkYXRhLnRpbWVPZmZzZXQsIGRhdGEuZGlzY29udGludWl0eSwgZGF0YS50cmFja1N3aXRjaCwgZGF0YS5jb250aWd1b3VzLCBkYXRhLmR1cmF0aW9uLCBkYXRhLmFjY3VyYXRlVGltZU9mZnNldCwgZGF0YS5kZWZhdWx0SW5pdFBUUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcblxuICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICBvYnNlcnZlci5vbihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfREVDUllQVEVELCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwgZm9yd2FyZE1lc3NhZ2UpO1xuICBvYnNlcnZlci5vbihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0VELCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oX2V2ZW50czIuZGVmYXVsdC5JTklUX1BUU19GT1VORCwgZm9yd2FyZE1lc3NhZ2UpO1xuXG4gIC8vIHNwZWNpYWwgY2FzZSBmb3IgRlJBR19QQVJTSU5HX0RBVEE6IHBhc3MgZGF0YTEvZGF0YTIgYXMgdHJhbnNmZXJhYmxlIG9iamVjdCAobm8gY29weSlcbiAgb2JzZXJ2ZXIub24oX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNJTkdfREFUQSwgZnVuY3Rpb24gKGV2LCBkYXRhKSB7XG4gICAgdmFyIHRyYW5zZmVyYWJsZSA9IFtdO1xuICAgIHZhciBtZXNzYWdlID0geyBldmVudDogZXYsIGRhdGE6IGRhdGEgfTtcbiAgICBpZiAoZGF0YS5kYXRhMSkge1xuICAgICAgbWVzc2FnZS5kYXRhMSA9IGRhdGEuZGF0YTEuYnVmZmVyO1xuICAgICAgdHJhbnNmZXJhYmxlLnB1c2goZGF0YS5kYXRhMS5idWZmZXIpO1xuICAgICAgZGVsZXRlIGRhdGEuZGF0YTE7XG4gICAgfVxuICAgIGlmIChkYXRhLmRhdGEyKSB7XG4gICAgICBtZXNzYWdlLmRhdGEyID0gZGF0YS5kYXRhMi5idWZmZXI7XG4gICAgICB0cmFuc2ZlcmFibGUucHVzaChkYXRhLmRhdGEyLmJ1ZmZlcik7XG4gICAgICBkZWxldGUgZGF0YS5kYXRhMjtcbiAgICB9XG4gICAgc2VsZi5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2ZlcmFibGUpO1xuICB9KTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERlbXV4ZXJXb3JrZXI7XG5cbn0se1wiMVwiOjEsXCIyM1wiOjIzLFwiMzNcIjozMyxcIjUwXCI6NTB9XSwyNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZGVtdXhlcklubGluZSA9IF9kZXJlcV8oMjMpO1xuXG52YXIgX2RlbXV4ZXJJbmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVtdXhlcklubGluZSk7XG5cbnZhciBfZGVtdXhlcldvcmtlciA9IF9kZXJlcV8oMjQpO1xuXG52YXIgX2RlbXV4ZXJXb3JrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVtdXhlcldvcmtlcik7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbnZhciBfZXJyb3JzID0gX2RlcmVxXygzMSk7XG5cbnZhciBfZXZlbnRzMyA9IF9kZXJlcV8oMSk7XG5cbnZhciBfZXZlbnRzNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50czMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgRGVtdXhlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVtdXhlcihobHMsIGlkKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlbXV4ZXIpO1xuXG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIC8vIG9ic2VydmVyIHNldHVwXG4gICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlciA9IG5ldyBfZXZlbnRzNC5kZWZhdWx0KCk7XG4gICAgdmFyIGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgb2JzZXJ2ZXIudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIoZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkYXRhID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBkYXRhW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgb2JzZXJ2ZXIuZW1pdC5hcHBseShvYnNlcnZlciwgW2V2ZW50LCBldmVudF0uY29uY2F0KGRhdGEpKTtcbiAgICB9O1xuXG4gICAgb2JzZXJ2ZXIub2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGRhdGEgPSBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGRhdGFbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyLmFwcGx5KG9ic2VydmVyLCBbZXZlbnRdLmNvbmNhdChkYXRhKSk7XG4gICAgfTtcblxuICAgIHZhciBmb3J3YXJkTWVzc2FnZSA9IGZ1bmN0aW9uIChldiwgZGF0YSkge1xuICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICBkYXRhLmZyYWcgPSB0aGlzLmZyYWc7XG4gICAgICBkYXRhLmlkID0gdGhpcy5pZDtcbiAgICAgIGhscy50cmlnZ2VyKGV2LCBkYXRhKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICAgIG9ic2VydmVyLm9uKF9ldmVudHMyLmRlZmF1bHQuRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19EQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oX2V2ZW50czIuZGVmYXVsdC5JTklUX1BUU19GT1VORCwgZm9yd2FyZE1lc3NhZ2UpO1xuXG4gICAgdmFyIHR5cGVTdXBwb3J0ZWQgPSB7XG4gICAgICBtcDQ6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0JyksXG4gICAgICBtcGVnOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wZWcnKSxcbiAgICAgIG1wMzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cIm1wM1wiJylcbiAgICB9O1xuICAgIGlmIChjb25maWcuZW5hYmxlV29ya2VyICYmIHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2RlbXV4aW5nIGluIHdlYndvcmtlcicpO1xuICAgICAgdmFyIHcgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgd29yayA9IF9kZXJlcV8oMyk7XG4gICAgICAgIHcgPSB0aGlzLncgPSB3b3JrKF9kZW11eGVyV29ya2VyMi5kZWZhdWx0KTtcbiAgICAgICAgdGhpcy5vbndtc2cgPSB0aGlzLm9uV29ya2VyTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICB3LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG4gICAgICAgIHcub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sIGZhdGFsOiB0cnVlLCBldmVudDogJ2RlbXV4ZXJXb3JrZXInLCBlcnI6IHsgbWVzc2FnZTogZXZlbnQubWVzc2FnZSArICcgKCcgKyBldmVudC5maWxlbmFtZSArICc6JyArIGV2ZW50LmxpbmVubyArICcpJyB9IH0pO1xuICAgICAgICB9O1xuICAgICAgICB3LnBvc3RNZXNzYWdlKHsgY21kOiAnaW5pdCcsIHR5cGVTdXBwb3J0ZWQ6IHR5cGVTdXBwb3J0ZWQsIGlkOiBpZCwgY29uZmlnOiBKU09OLnN0cmluZ2lmeShjb25maWcpIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmVycm9yKCdlcnJvciB3aGlsZSBpbml0aWFsaXppbmcgRGVtdXhlcldvcmtlciwgZmFsbGJhY2sgb24gRGVtdXhlcklubGluZScpO1xuICAgICAgICBpZiAodykge1xuICAgICAgICAgIC8vIHJldm9rZSB0aGUgT2JqZWN0IFVSTCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSBkZW11eGVyIHdvcmtlciwgc28gYXMgbm90IHRvIGxlYWsgaXRcbiAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHcub2JqZWN0VVJMKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgX2RlbXV4ZXJJbmxpbmUyLmRlZmF1bHQob2JzZXJ2ZXIsIGlkLCB0eXBlU3VwcG9ydGVkLCBjb25maWcpO1xuICAgICAgICB0aGlzLncgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBfZGVtdXhlcklubGluZTIuZGVmYXVsdChvYnNlcnZlciwgaWQsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERlbXV4ZXIsIFt7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIGlmICh3KSB7XG4gICAgICAgIHcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgICAgdy50ZXJtaW5hdGUoKTtcbiAgICAgICAgdGhpcy53ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgICBpZiAoZGVtdXhlcikge1xuICAgICAgICAgIGRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgb2JzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3B1c2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBmcmFnLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdGltZU9mZnNldCA9ICFpc05hTihmcmFnLnN0YXJ0RFRTKSA/IGZyYWcuc3RhcnREVFMgOiBmcmFnLnN0YXJ0O1xuICAgICAgdmFyIGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICAgIHZhciBsYXN0RnJhZyA9IHRoaXMuZnJhZztcbiAgICAgIHZhciBkaXNjb250aW51aXR5ID0gIShsYXN0RnJhZyAmJiBmcmFnLmNjID09PSBsYXN0RnJhZy5jYyk7XG4gICAgICB2YXIgdHJhY2tTd2l0Y2ggPSAhKGxhc3RGcmFnICYmIGZyYWcubGV2ZWwgPT09IGxhc3RGcmFnLmxldmVsKTtcbiAgICAgIHZhciBuZXh0U04gPSBsYXN0RnJhZyAmJiBmcmFnLnNuID09PSBsYXN0RnJhZy5zbiArIDE7XG4gICAgICB2YXIgY29udGlndW91cyA9ICFkaXNjb250aW51aXR5ICYmICF0cmFja1N3aXRjaCAmJiBuZXh0U047XG4gICAgICBpZiAoZGlzY29udGludWl0eSkge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2codGhpcy5pZCArICc6ZGlzY29udGludWl0eSBkZXRlY3RlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKHRyYWNrU3dpdGNoKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZyh0aGlzLmlkICsgJzpzd2l0Y2ggZGV0ZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZyA9IGZyYWc7XG4gICAgICBpZiAodykge1xuICAgICAgICAvLyBwb3N0IGZyYWdtZW50IHBheWxvYWQgYXMgdHJhbnNmZXJhYmxlIG9iamVjdHMgKG5vIGNvcHkpXG4gICAgICAgIHcucG9zdE1lc3NhZ2UoeyBjbWQ6ICdkZW11eCcsIGRhdGE6IGRhdGEsIGRlY3J5cHRkYXRhOiBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50LCBhdWRpb0NvZGVjOiBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjOiB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0OiB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5OiBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaDogdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXM6IGNvbnRpZ3VvdXMsIGR1cmF0aW9uOiBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0OiBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTOiBkZWZhdWx0SW5pdFBUUyB9LCBbZGF0YV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgICAgIGlmIChkZW11eGVyKSB7XG4gICAgICAgICAgZGVtdXhlci5wdXNoKGRhdGEsIGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uV29ya2VyTWVzc2FnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uV29ya2VyTWVzc2FnZShldikge1xuICAgICAgdmFyIGRhdGEgPSBldi5kYXRhLFxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgICAgLy9jb25zb2xlLmxvZygnb25Xb3JrZXJNZXNzYWdlOicgKyBkYXRhLmV2ZW50KTtcbiAgICAgIHN3aXRjaCAoZGF0YS5ldmVudCkge1xuICAgICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgZGVtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLncub2JqZWN0VVJMKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBGUkFHX1BBUlNJTkdfREFUQTogZGF0YTEgYW5kIGRhdGEyIGFyZSB0cmFuc2ZlcmFibGUgb2JqZWN0c1xuICAgICAgICBjYXNlIF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTSU5HX0RBVEE6XG4gICAgICAgICAgZGF0YS5kYXRhLmRhdGExID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMSk7XG4gICAgICAgICAgaWYgKGRhdGEuZGF0YTIpIHtcbiAgICAgICAgICAgIGRhdGEuZGF0YS5kYXRhMiA9IG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRhdGEuZGF0YSA9IGRhdGEuZGF0YSB8fCB7fTtcbiAgICAgICAgICBkYXRhLmRhdGEuZnJhZyA9IHRoaXMuZnJhZztcbiAgICAgICAgICBkYXRhLmRhdGEuaWQgPSB0aGlzLmlkO1xuICAgICAgICAgIGhscy50cmlnZ2VyKGRhdGEuZXZlbnQsIGRhdGEuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERlbXV4ZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERlbXV4ZXI7XG5cbn0se1wiMVwiOjEsXCIyM1wiOjIzLFwiMjRcIjoyNCxcIjNcIjozLFwiMzFcIjozMSxcIjMzXCI6MzMsXCI1MFwiOjUwfV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpOyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQYXJzZXIgZm9yIGV4cG9uZW50aWFsIEdvbG9tYiBjb2RlcywgYSB2YXJpYWJsZS1iaXR3aWR0aCBudW1iZXIgZW5jb2Rpbmcgc2NoZW1lIHVzZWQgYnkgaDI2NC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgRXhwR29sb21iID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFeHBHb2xvbWIoZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFeHBHb2xvbWIpO1xuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGlzLmRhdGFcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgYmVpbmcgZXhhbWluZWRcbiAgICB0aGlzLndvcmQgPSAwOyAvLyA6dWludFxuICAgIC8vIHRoZSBudW1iZXIgb2YgYml0cyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhlIGN1cnJlbnQgd29yZFxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IDA7IC8vIDp1aW50XG4gIH1cblxuICAvLyAoKTp2b2lkXG5cblxuICBfY3JlYXRlQ2xhc3MoRXhwR29sb21iLCBbe1xuICAgIGtleTogJ2xvYWRXb3JkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZFdvcmQoKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICBieXRlc0F2YWlsYWJsZSA9IHRoaXMuYnl0ZXNBdmFpbGFibGUsXG4gICAgICAgICAgcG9zaXRpb24gPSBkYXRhLmJ5dGVMZW5ndGggLSBieXRlc0F2YWlsYWJsZSxcbiAgICAgICAgICB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KSxcbiAgICAgICAgICBhdmFpbGFibGVCeXRlcyA9IE1hdGgubWluKDQsIGJ5dGVzQXZhaWxhYmxlKTtcbiAgICAgIGlmIChhdmFpbGFibGVCeXRlcyA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xuICAgICAgfVxuICAgICAgd29ya2luZ0J5dGVzLnNldChkYXRhLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGF2YWlsYWJsZUJ5dGVzKSk7XG4gICAgICB0aGlzLndvcmQgPSBuZXcgRGF0YVZpZXcod29ya2luZ0J5dGVzLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuICAgICAgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB0aGlzLmRhdGEgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IGF2YWlsYWJsZUJ5dGVzICogODtcbiAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gYXZhaWxhYmxlQnl0ZXM7XG4gICAgfVxuXG4gICAgLy8gKGNvdW50OmludCk6dm9pZFxuXG4gIH0sIHtcbiAgICBrZXk6ICdza2lwQml0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNraXBCaXRzKGNvdW50KSB7XG4gICAgICB2YXIgc2tpcEJ5dGVzOyAvLyA6aW50XG4gICAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gY291bnQpIHtcbiAgICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY291bnQgLT0gdGhpcy5iaXRzQXZhaWxhYmxlO1xuICAgICAgICBza2lwQnl0ZXMgPSBjb3VudCA+PiAzO1xuICAgICAgICBjb3VudCAtPSBza2lwQnl0ZXMgPj4gMztcbiAgICAgICAgdGhpcy5ieXRlc0F2YWlsYWJsZSAtPSBza2lwQnl0ZXM7XG4gICAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIChzaXplOmludCk6dWludFxuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWFkQml0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRCaXRzKHNpemUpIHtcbiAgICAgIHZhciBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKSxcbiAgICAgICAgICAvLyA6dWludFxuICAgICAgdmFsdSA9IHRoaXMud29yZCA+Pj4gMzIgLSBiaXRzOyAvLyA6dWludFxuICAgICAgaWYgKHNpemUgPiAzMikge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5lcnJvcignQ2Fubm90IHJlYWQgbW9yZSB0aGFuIDMyIGJpdHMgYXQgYSB0aW1lJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gYml0cztcbiAgICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiAwKSB7XG4gICAgICAgIHRoaXMud29yZCA8PD0gYml0cztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5ieXRlc0F2YWlsYWJsZSA+IDApIHtcbiAgICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgICAgfVxuICAgICAgYml0cyA9IHNpemUgLSBiaXRzO1xuICAgICAgaWYgKGJpdHMgPiAwICYmIHRoaXMuYml0c0F2YWlsYWJsZSkge1xuICAgICAgICByZXR1cm4gdmFsdSA8PCBiaXRzIHwgdGhpcy5yZWFkQml0cyhiaXRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vICgpOnVpbnRcblxuICB9LCB7XG4gICAga2V5OiAnc2tpcExaJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2tpcExaKCkge1xuICAgICAgdmFyIGxlYWRpbmdaZXJvQ291bnQ7IC8vIDp1aW50XG4gICAgICBmb3IgKGxlYWRpbmdaZXJvQ291bnQgPSAwOyBsZWFkaW5nWmVyb0NvdW50IDwgdGhpcy5iaXRzQXZhaWxhYmxlOyArK2xlYWRpbmdaZXJvQ291bnQpIHtcbiAgICAgICAgaWYgKDAgIT09ICh0aGlzLndvcmQgJiAweDgwMDAwMDAwID4+PiBsZWFkaW5nWmVyb0NvdW50KSkge1xuICAgICAgICAgIC8vIHRoZSBmaXJzdCBiaXQgb2Ygd29ya2luZyB3b3JkIGlzIDFcbiAgICAgICAgICB0aGlzLndvcmQgPDw9IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHdlIGV4aGF1c3RlZCB3b3JkIGFuZCBzdGlsbCBoYXZlIG5vdCBmb3VuZCBhIDFcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50ICsgdGhpcy5za2lwTFooKTtcbiAgICB9XG5cbiAgICAvLyAoKTp2b2lkXG5cbiAgfSwge1xuICAgIGtleTogJ3NraXBVRUcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBza2lwVUVHKCkge1xuICAgICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gICAgfVxuXG4gICAgLy8gKCk6dm9pZFxuXG4gIH0sIHtcbiAgICBrZXk6ICdza2lwRUcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBza2lwRUcoKSB7XG4gICAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMWigpKTtcbiAgICB9XG5cbiAgICAvLyAoKTp1aW50XG5cbiAgfSwge1xuICAgIGtleTogJ3JlYWRVRUcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkVUVHKCkge1xuICAgICAgdmFyIGNseiA9IHRoaXMuc2tpcExaKCk7IC8vIDp1aW50XG4gICAgICByZXR1cm4gdGhpcy5yZWFkQml0cyhjbHogKyAxKSAtIDE7XG4gICAgfVxuXG4gICAgLy8gKCk6aW50XG5cbiAgfSwge1xuICAgIGtleTogJ3JlYWRFRycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRFRygpIHtcbiAgICAgIHZhciB2YWx1ID0gdGhpcy5yZWFkVUVHKCk7IC8vIDppbnRcbiAgICAgIGlmICgweDAxICYgdmFsdSkge1xuICAgICAgICAvLyB0aGUgbnVtYmVyIGlzIG9kZCBpZiB0aGUgbG93IG9yZGVyIGJpdCBpcyBzZXRcbiAgICAgICAgcmV0dXJuIDEgKyB2YWx1ID4+PiAxOyAvLyBhZGQgMSB0byBtYWtlIGl0IGV2ZW4sIGFuZCBkaXZpZGUgYnkgMlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xICogKHZhbHUgPj4+IDEpOyAvLyBkaXZpZGUgYnkgdHdvIHRoZW4gbWFrZSBpdCBuZWdhdGl2ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNvbWUgY29udmVuaWVuY2UgZnVuY3Rpb25zXG4gICAgLy8gOkJvb2xlYW5cblxuICB9LCB7XG4gICAga2V5OiAncmVhZEJvb2xlYW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkQm9vbGVhbigpIHtcbiAgICAgIHJldHVybiAxID09PSB0aGlzLnJlYWRCaXRzKDEpO1xuICAgIH1cblxuICAgIC8vICgpOmludFxuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWFkVUJ5dGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkVUJ5dGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkQml0cyg4KTtcbiAgICB9XG5cbiAgICAvLyAoKTppbnRcblxuICB9LCB7XG4gICAga2V5OiAncmVhZFVTaG9ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRVU2hvcnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxNik7XG4gICAgfVxuICAgIC8vICgpOmludFxuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWFkVUludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRVSW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMzIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkdmFuY2UgdGhlIEV4cEdvbG9tYiBkZWNvZGVyIHBhc3QgYSBzY2FsaW5nIGxpc3QuIFRoZSBzY2FsaW5nXG4gICAgICogbGlzdCBpcyBvcHRpb25hbGx5IHRyYW5zbWl0dGVkIGFzIHBhcnQgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXJcbiAgICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cbiAgICAgKiBAcGFyYW0gY291bnQge251bWJlcn0gdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgc2NhbGluZyBsaXN0XG4gICAgICogQHNlZSBSZWNvbW1lbmRhdGlvbiBJVFUtVCBILjI2NCwgU2VjdGlvbiA3LjMuMi4xLjEuMVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdza2lwU2NhbGluZ0xpc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBza2lwU2NhbGluZ0xpc3QoY291bnQpIHtcbiAgICAgIHZhciBsYXN0U2NhbGUgPSA4LFxuICAgICAgICAgIG5leHRTY2FsZSA9IDgsXG4gICAgICAgICAgaixcbiAgICAgICAgICBkZWx0YVNjYWxlO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKG5leHRTY2FsZSAhPT0gMCkge1xuICAgICAgICAgIGRlbHRhU2NhbGUgPSB0aGlzLnJlYWRFRygpO1xuICAgICAgICAgIG5leHRTY2FsZSA9IChsYXN0U2NhbGUgKyBkZWx0YVNjYWxlICsgMjU2KSAlIDI1NjtcbiAgICAgICAgfVxuICAgICAgICBsYXN0U2NhbGUgPSBuZXh0U2NhbGUgPT09IDAgPyBsYXN0U2NhbGUgOiBuZXh0U2NhbGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXG4gICAgICogcHJvcGVydGllcy4gQSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGlzIHRoZSBIMjY0IG1ldGFkYXRhIHRoYXRcbiAgICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgICAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0XG4gICAgICogQHJldHVybiB7b2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgICAqIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQsIGluY2x1ZGluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcbiAgICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVhZFNQUycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRTUFMoKSB7XG4gICAgICB2YXIgZnJhbWVDcm9wTGVmdE9mZnNldCA9IDAsXG4gICAgICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSAwLFxuICAgICAgICAgIGZyYW1lQ3JvcFRvcE9mZnNldCA9IDAsXG4gICAgICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gMCxcbiAgICAgICAgICBwcm9maWxlSWRjLFxuICAgICAgICAgIHByb2ZpbGVDb21wYXQsXG4gICAgICAgICAgbGV2ZWxJZGMsXG4gICAgICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlLFxuICAgICAgICAgIHBpY1dpZHRoSW5NYnNNaW51czEsXG4gICAgICAgICAgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSxcbiAgICAgICAgICBmcmFtZU1ic09ubHlGbGFnLFxuICAgICAgICAgIHNjYWxpbmdMaXN0Q291bnQsXG4gICAgICAgICAgaSxcbiAgICAgICAgICByZWFkVUJ5dGUgPSB0aGlzLnJlYWRVQnl0ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgIHJlYWRCaXRzID0gdGhpcy5yZWFkQml0cy5iaW5kKHRoaXMpLFxuICAgICAgICAgIHJlYWRVRUcgPSB0aGlzLnJlYWRVRUcuYmluZCh0aGlzKSxcbiAgICAgICAgICByZWFkQm9vbGVhbiA9IHRoaXMucmVhZEJvb2xlYW4uYmluZCh0aGlzKSxcbiAgICAgICAgICBza2lwQml0cyA9IHRoaXMuc2tpcEJpdHMuYmluZCh0aGlzKSxcbiAgICAgICAgICBza2lwRUcgPSB0aGlzLnNraXBFRy5iaW5kKHRoaXMpLFxuICAgICAgICAgIHNraXBVRUcgPSB0aGlzLnNraXBVRUcuYmluZCh0aGlzKSxcbiAgICAgICAgICBza2lwU2NhbGluZ0xpc3QgPSB0aGlzLnNraXBTY2FsaW5nTGlzdC5iaW5kKHRoaXMpO1xuXG4gICAgICByZWFkVUJ5dGUoKTtcbiAgICAgIHByb2ZpbGVJZGMgPSByZWFkVUJ5dGUoKTsgLy8gcHJvZmlsZV9pZGNcbiAgICAgIHByb2ZpbGVDb21wYXQgPSByZWFkQml0cyg1KTsgLy8gY29uc3RyYWludF9zZXRbMC00XV9mbGFnLCB1KDUpXG4gICAgICBza2lwQml0cygzKTsgLy8gcmVzZXJ2ZWRfemVyb18zYml0cyB1KDMpLFxuICAgICAgbGV2ZWxJZGMgPSByZWFkVUJ5dGUoKTsgLy9sZXZlbF9pZGMgdSg4KVxuICAgICAgc2tpcFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxuICAgICAgLy8gc29tZSBwcm9maWxlcyBoYXZlIG1vcmUgb3B0aW9uYWwgZGF0YSB3ZSBkb24ndCBuZWVkXG4gICAgICBpZiAocHJvZmlsZUlkYyA9PT0gMTAwIHx8IHByb2ZpbGVJZGMgPT09IDExMCB8fCBwcm9maWxlSWRjID09PSAxMjIgfHwgcHJvZmlsZUlkYyA9PT0gMjQ0IHx8IHByb2ZpbGVJZGMgPT09IDQ0IHx8IHByb2ZpbGVJZGMgPT09IDgzIHx8IHByb2ZpbGVJZGMgPT09IDg2IHx8IHByb2ZpbGVJZGMgPT09IDExOCB8fCBwcm9maWxlSWRjID09PSAxMjgpIHtcbiAgICAgICAgdmFyIGNocm9tYUZvcm1hdElkYyA9IHJlYWRVRUcoKTtcbiAgICAgICAgaWYgKGNocm9tYUZvcm1hdElkYyA9PT0gMykge1xuICAgICAgICAgIHNraXBCaXRzKDEpOyAvLyBzZXBhcmF0ZV9jb2xvdXJfcGxhbmVfZmxhZ1xuICAgICAgICB9XG4gICAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2x1bWFfbWludXM4XG4gICAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2Nocm9tYV9taW51czhcbiAgICAgICAgc2tpcEJpdHMoMSk7IC8vIHFwcHJpbWVfeV96ZXJvX3RyYW5zZm9ybV9ieXBhc3NfZmxhZ1xuICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgIC8vIHNlcV9zY2FsaW5nX21hdHJpeF9wcmVzZW50X2ZsYWdcbiAgICAgICAgICBzY2FsaW5nTGlzdENvdW50ID0gY2hyb21hRm9ybWF0SWRjICE9PSAzID8gOCA6IDEyO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FsaW5nTGlzdENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgICAgICAgIC8vIHNlcV9zY2FsaW5nX2xpc3RfcHJlc2VudF9mbGFnWyBpIF1cbiAgICAgICAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDE2KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoNjQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBza2lwVUVHKCk7IC8vIGxvZzJfbWF4X2ZyYW1lX251bV9taW51czRcbiAgICAgIHZhciBwaWNPcmRlckNudFR5cGUgPSByZWFkVUVHKCk7XG4gICAgICBpZiAocGljT3JkZXJDbnRUeXBlID09PSAwKSB7XG4gICAgICAgIHJlYWRVRUcoKTsgLy9sb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czRcbiAgICAgIH0gZWxzZSBpZiAocGljT3JkZXJDbnRUeXBlID09PSAxKSB7XG4gICAgICAgIHNraXBCaXRzKDEpOyAvLyBkZWx0YV9waWNfb3JkZXJfYWx3YXlzX3plcm9fZmxhZ1xuICAgICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl9ub25fcmVmX3BpY1xuICAgICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl90b3BfdG9fYm90dG9tX2ZpZWxkXG4gICAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSA9IHJlYWRVRUcoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XG4gICAgICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfcmVmX2ZyYW1lWyBpIF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2tpcFVFRygpOyAvLyBtYXhfbnVtX3JlZl9mcmFtZXNcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBnYXBzX2luX2ZyYW1lX251bV92YWx1ZV9hbGxvd2VkX2ZsYWdcbiAgICAgIHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgICBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVNYnNPbmx5RmxhZyA9IHJlYWRCaXRzKDEpO1xuICAgICAgaWYgKGZyYW1lTWJzT25seUZsYWcgPT09IDApIHtcbiAgICAgICAgc2tpcEJpdHMoMSk7IC8vIG1iX2FkYXB0aXZlX2ZyYW1lX2ZpZWxkX2ZsYWdcbiAgICAgIH1cbiAgICAgIHNraXBCaXRzKDEpOyAvLyBkaXJlY3RfOHg4X2luZmVyZW5jZV9mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBmcmFtZV9jcm9wcGluZ19mbGFnXG4gICAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIH1cbiAgICAgIHZhciBwaXhlbFJhdGlvID0gWzEsIDFdO1xuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgICAgLy8gYXNwZWN0X3JhdGlvX2luZm9fcHJlc2VudF9mbGFnXG4gICAgICAgICAgdmFyIGFzcGVjdFJhdGlvSWRjID0gcmVhZFVCeXRlKCk7XG4gICAgICAgICAgc3dpdGNoIChhc3BlY3RSYXRpb0lkYykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEsIDFdO2JyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEyLCAxMV07YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTAsIDExXTticmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNiwgMTFdO2JyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzQwLCAzM107YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjQsIDExXTticmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyMCwgMTFdO2JyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzMyLCAxMV07YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbODAsIDMzXTticmVhaztcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTgsIDExXTticmVhaztcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTUsIDExXTticmVhaztcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNjQsIDMzXTticmVhaztcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTYwLCA5OV07YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzQsIDNdO2JyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFszLCAyXTticmVhaztcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMiwgMV07YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI1NTpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpLCByZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogTWF0aC5jZWlsKChwaWNXaWR0aEluTWJzTWludXMxICsgMSkgKiAxNiAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSxcbiAgICAgICAgaGVpZ2h0OiAoMiAtIGZyYW1lTWJzT25seUZsYWcpICogKHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgKyAxKSAqIDE2IC0gKGZyYW1lTWJzT25seUZsYWcgPyAyIDogNCkgKiAoZnJhbWVDcm9wVG9wT2Zmc2V0ICsgZnJhbWVDcm9wQm90dG9tT2Zmc2V0KSxcbiAgICAgICAgcGl4ZWxSYXRpbzogcGl4ZWxSYXRpb1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWFkU2xpY2VUeXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFNsaWNlVHlwZSgpIHtcbiAgICAgIC8vIHNraXAgTkFMdSB0eXBlXG4gICAgICB0aGlzLnJlYWRVQnl0ZSgpO1xuICAgICAgLy8gZGlzY2FyZCBmaXJzdF9tYl9pbl9zbGljZVxuICAgICAgdGhpcy5yZWFkVUVHKCk7XG4gICAgICAvLyByZXR1cm4gc2xpY2VfdHlwZVxuICAgICAgcmV0dXJuIHRoaXMucmVhZFVFRygpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFeHBHb2xvbWI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEV4cEdvbG9tYjtcblxufSx7XCI1MFwiOjUwfV0sMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpOyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBJRDMgcGFyc2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLy9pbXBvcnQgSGV4IGZyb20gJy4uL3V0aWxzL2hleCc7XG5cbnZhciBJRDMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIElEMyhkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElEMyk7XG5cbiAgICB0aGlzLl9oYXNUaW1lU3RhbXAgPSBmYWxzZTtcbiAgICB2YXIgb2Zmc2V0ID0gMCxcbiAgICAgICAgYnl0ZTEsXG4gICAgICAgIGJ5dGUyLFxuICAgICAgICBieXRlMyxcbiAgICAgICAgYnl0ZTQsXG4gICAgICAgIHRhZ1NpemUsXG4gICAgICAgIGVuZFBvcyxcbiAgICAgICAgaGVhZGVyLFxuICAgICAgICBsZW47XG4gICAgZG8ge1xuICAgICAgaGVhZGVyID0gdGhpcy5yZWFkVVRGKGRhdGEsIG9mZnNldCwgMyk7XG4gICAgICBvZmZzZXQgKz0gMztcbiAgICAgIC8vIGZpcnN0IGNoZWNrIGZvciBJRDMgaGVhZGVyXG4gICAgICBpZiAoaGVhZGVyID09PSAnSUQzJykge1xuICAgICAgICAvLyBza2lwIDI0IGJpdHNcbiAgICAgICAgb2Zmc2V0ICs9IDM7XG4gICAgICAgIC8vIHJldHJpZXZlIHRhZyhzKSBsZW5ndGhcbiAgICAgICAgYnl0ZTEgPSBkYXRhW29mZnNldCsrXSAmIDB4N2Y7XG4gICAgICAgIGJ5dGUyID0gZGF0YVtvZmZzZXQrK10gJiAweDdmO1xuICAgICAgICBieXRlMyA9IGRhdGFbb2Zmc2V0KytdICYgMHg3ZjtcbiAgICAgICAgYnl0ZTQgPSBkYXRhW29mZnNldCsrXSAmIDB4N2Y7XG4gICAgICAgIHRhZ1NpemUgPSAoYnl0ZTEgPDwgMjEpICsgKGJ5dGUyIDw8IDE0KSArIChieXRlMyA8PCA3KSArIGJ5dGU0O1xuICAgICAgICBlbmRQb3MgPSBvZmZzZXQgKyB0YWdTaXplO1xuICAgICAgICAvL2xvZ2dlci5sb2coYElEMyB0YWcgZm91bmQsIHNpemUvZW5kOiAke3RhZ1NpemV9LyR7ZW5kUG9zfWApO1xuXG4gICAgICAgIC8vIHJlYWQgSUQzIHRhZ3NcbiAgICAgICAgdGhpcy5fcGFyc2VJRDNGcmFtZXMoZGF0YSwgb2Zmc2V0LCBlbmRQb3MpO1xuICAgICAgICBvZmZzZXQgPSBlbmRQb3M7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRlciA9PT0gJzNESScpIHtcbiAgICAgICAgLy8gaHR0cDovL2lkMy5vcmcvaWQzdjIuNC4wLXN0cnVjdHVyZSBjaGFwdGVyIDMuNC4gICBJRDN2MiBmb290ZXJcbiAgICAgICAgb2Zmc2V0ICs9IDc7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnM0RJIGZvb3RlciBmb3VuZCwgZW5kOiAnICsgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCAtPSAzO1xuICAgICAgICBsZW4gPSBvZmZzZXQ7XG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAvL2xvZ2dlci5sb2coYElEMyBsZW46ICR7bGVufWApO1xuICAgICAgICAgIGlmICghdGhpcy5oYXNUaW1lU3RhbXApIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ0lEMyB0YWcgZm91bmQsIGJ1dCBubyB0aW1lc3RhbXAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgICAgICAgIHRoaXMuX3BheWxvYWQgPSBkYXRhLnN1YmFycmF5KDAsIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRydWUpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKElEMywgW3tcbiAgICBrZXk6ICdyZWFkVVRGJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFVURihkYXRhLCBzdGFydCwgbGVuKSB7XG5cbiAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCxcbiAgICAgICAgICBlbmQgPSBzdGFydCArIGxlbjtcbiAgICAgIGRvIHtcbiAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVtvZmZzZXQrK10pO1xuICAgICAgfSB3aGlsZSAob2Zmc2V0IDwgZW5kKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3BhcnNlSUQzRnJhbWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlSUQzRnJhbWVzKGRhdGEsIG9mZnNldCwgZW5kUG9zKSB7XG4gICAgICB2YXIgdGFnSWQsIHRhZ0xlbiwgdGFnU3RhcnQsIHRhZ0ZsYWdzLCB0aW1lc3RhbXA7XG4gICAgICB3aGlsZSAob2Zmc2V0ICsgOCA8PSBlbmRQb3MpIHtcbiAgICAgICAgdGFnSWQgPSB0aGlzLnJlYWRVVEYoZGF0YSwgb2Zmc2V0LCA0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG5cbiAgICAgICAgdGFnTGVuID0gZGF0YVtvZmZzZXQrK10gPDwgMjQgKyBkYXRhW29mZnNldCsrXSA8PCAxNiArIGRhdGFbb2Zmc2V0KytdIDw8IDggKyBkYXRhW29mZnNldCsrXTtcblxuICAgICAgICB0YWdGbGFncyA9IGRhdGFbb2Zmc2V0KytdIDw8IDggKyBkYXRhW29mZnNldCsrXTtcblxuICAgICAgICB0YWdTdGFydCA9IG9mZnNldDtcbiAgICAgICAgLy9sb2dnZXIubG9nKFwiSUQzIHRhZyBpZDpcIiArIHRhZ0lkKTtcbiAgICAgICAgc3dpdGNoICh0YWdJZCkge1xuICAgICAgICAgIGNhc2UgJ1BSSVYnOlxuICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdwYXJzZSBmcmFtZTonICsgSGV4LmhleER1bXAoZGF0YS5zdWJhcnJheShvZmZzZXQsZW5kUG9zKSkpO1xuICAgICAgICAgICAgLy8gb3duZXIgc2hvdWxkIGJlIFwiY29tLmFwcGxlLnN0cmVhbWluZy50cmFuc3BvcnRTdHJlYW1UaW1lc3RhbXBcIlxuICAgICAgICAgICAgaWYgKHRoaXMucmVhZFVURihkYXRhLCBvZmZzZXQsIDQ0KSA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJykge1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gNDQ7XG4gICAgICAgICAgICAgIC8vIHNtZWxsaW5nIGV2ZW4gYmV0dGVyICEgd2UgZm91bmQgdGhlIHJpZ2h0IGRlc2NyaXB0b3JcbiAgICAgICAgICAgICAgLy8gc2tpcCBudWxsIGNoYXJhY3RlciAoc3RyaW5nIGVuZCkgKyAzIGZpcnN0IGJ5dGVzXG4gICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuXG4gICAgICAgICAgICAgIC8vIHRpbWVzdGFtcCBpcyAzMyBiaXQgZXhwcmVzc2VkIGFzIGEgYmlnLWVuZGlhbiBlaWdodC1vY3RldCBudW1iZXIsIHdpdGggdGhlIHVwcGVyIDMxIGJpdHMgc2V0IHRvIHplcm8uXG4gICAgICAgICAgICAgIHZhciBwdHMzM0JpdCA9IGRhdGFbb2Zmc2V0KytdICYgMHgxO1xuICAgICAgICAgICAgICB0aGlzLl9oYXNUaW1lU3RhbXAgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIHRpbWVzdGFtcCA9ICgoZGF0YVtvZmZzZXQrK10gPDwgMjMpICsgKGRhdGFbb2Zmc2V0KytdIDw8IDE1KSArIChkYXRhW29mZnNldCsrXSA8PCA3KSArIGRhdGFbb2Zmc2V0KytdKSAvIDQ1O1xuXG4gICAgICAgICAgICAgIGlmIChwdHMzM0JpdCkge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCArPSA0NzcyMTg1OC44NDsgLy8gMl4zMiAvIDkwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGltZXN0YW1wID0gTWF0aC5yb3VuZCh0aW1lc3RhbXApO1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci50cmFjZSgnSUQzIHRpbWVzdGFtcCBmb3VuZDogJyArIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgIHRoaXMuX3RpbWVTdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhc1RpbWVTdGFtcCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFzVGltZVN0YW1wO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RpbWVTdGFtcCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZVN0YW1wO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xlbmd0aCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BheWxvYWQnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BheWxvYWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIElEMztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSUQzO1xuXG59LHtcIjUwXCI6NTB9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1QNCBkZW11eGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vL2ltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBNUDREZW11eGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNUDREZW11eGVyKG9ic2VydmVyLCByZW11eGVyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1QNERlbXV4ZXIpO1xuXG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTVA0RGVtdXhlciwgW3tcbiAgICBrZXk6ICdyZXNldFRpbWVTdGFtcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKCkge31cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0SW5pdFNlZ21lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xuICAgICAgLy9qc2hpbnQgdW51c2VkOmZhbHNlXG4gICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhID0gTVA0RGVtdXhlci5wYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KTtcbiAgICAgIHZhciB0cmFja3MgPSB7fTtcbiAgICAgIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgICB0cmFja3MuYXVkaW8gPSB7IGNvbnRhaW5lcjogJ2F1ZGlvL21wNCcsIGNvZGVjOiBhdWRpb0NvZGVjLCBpbml0U2VnbWVudDogaW5pdFNlZ21lbnQgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgICB0cmFja3MudmlkZW8gPSB7IGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsIGNvZGVjOiB2aWRlb0NvZGVjLCBpbml0U2VnbWVudDogaW5pdFNlZ21lbnQgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIHsgdW5pcXVlOiBmYWxzZSwgdHJhY2tzOiB0cmFja3MgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXBwZW5kJyxcblxuXG4gICAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xuICAgICAgdmFyIHN0YXJ0RFRTID0gTVA0RGVtdXhlci5zdGFydERUUyhpbml0RGF0YSwgZGF0YSk7XG4gICAgICB0aGlzLnJlbXV4ZXIucmVtdXgoaW5pdERhdGEuYXVkaW8sIGluaXREYXRhLnZpZGVvLCBudWxsLCBudWxsLCBzdGFydERUUywgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHt9XG4gIH1dLCBbe1xuICAgIGtleTogJ3Byb2JlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvYmUoZGF0YSkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID49IDgpIHtcbiAgICAgICAgdmFyIGRhdGFUeXBlID0gTVA0RGVtdXhlci5iaW4yc3RyKGRhdGEuc3ViYXJyYXkoNCwgOCkpO1xuICAgICAgICByZXR1cm4gWydtb29mJywgJ2Z0eXAnLCAnc3R5cCddLmluZGV4T2YoZGF0YVR5cGUpID49IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYmluMnN0cicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbjJzdHIoYnVmZmVyKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBidWZmZXIpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGRhdGEgZm9yIGEgYm94IHNwZWNpZmllZCBieSBpdHMgcGF0aFxuXG4gIH0sIHtcbiAgICBrZXk6ICdmaW5kQm94JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEJveChkYXRhLCBwYXRoKSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgICAgIGksXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGVuZCxcbiAgICAgICAgICBzdWJyZXN1bHRzO1xuXG4gICAgICBpZiAoIXBhdGgubGVuZ3RoKSB7XG4gICAgICAgIC8vIHNob3J0LWNpcmN1aXQgdGhlIHNlYXJjaCBmb3IgZW1wdHkgcGF0aHNcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmJ5dGVMZW5ndGg7KSB7XG4gICAgICAgIHNpemUgPSBkYXRhW2ldIDw8IDI0O1xuICAgICAgICBzaXplIHw9IGRhdGFbaSArIDFdIDw8IDE2O1xuICAgICAgICBzaXplIHw9IGRhdGFbaSArIDJdIDw8IDg7XG4gICAgICAgIHNpemUgfD0gZGF0YVtpICsgM107XG5cbiAgICAgICAgdHlwZSA9IE1QNERlbXV4ZXIuYmluMnN0cihkYXRhLnN1YmFycmF5KGkgKyA0LCBpICsgOCkpO1xuXG4gICAgICAgIGVuZCA9IHNpemUgPiAxID8gaSArIHNpemUgOiBkYXRhLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IHBhdGhbMF0pIHtcbiAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgcGF0aCBhbmQgd2UndmUgZm91bmQgdGhlIGJveCB3ZSB3ZXJlXG4gICAgICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGRhdGEuc3ViYXJyYXkoaSArIDgsIGVuZCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHRoZSBuZXh0IGJveCBhbG9uZyB0aGUgcGF0aFxuICAgICAgICAgICAgc3VicmVzdWx0cyA9IE1QNERlbXV4ZXIuZmluZEJveChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmQpLCBwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIGlmIChzdWJyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQoc3VicmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkgPSBlbmQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlJ3ZlIGZpbmlzaGVkIHNlYXJjaGluZyBhbGwgb2YgZGF0YVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIE1QNCBpbml0aWFsaXphdGlvbiBzZWdtZW50IGFuZCBleHRyYWN0cyBzdHJlYW0gdHlwZSBhbmRcbiAgICAgKiB0aW1lc2NhbGUgdmFsdWVzIGZvciBhbnkgZGVjbGFyZWQgdHJhY2tzLiBUaW1lc2NhbGUgdmFsdWVzIGluZGljYXRlIHRoZVxuICAgICAqIG51bWJlciBvZiBjbG9jayB0aWNrcyBwZXIgc2Vjb25kIHRvIGFzc3VtZSBmb3IgdGltZS1iYXNlZCB2YWx1ZXNcbiAgICAgKiBlbHNld2hlcmUgaW4gdGhlIE1QNC5cbiAgICAgKlxuICAgICAqIFRvIGRldGVybWluZSB0aGUgc3RhcnQgdGltZSBvZiBhbiBNUDQsIHlvdSBuZWVkIHR3byBwaWVjZXMgb2ZcbiAgICAgKiBpbmZvcm1hdGlvbjogdGhlIHRpbWVzY2FsZSB1bml0IGFuZCB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGVcbiAgICAgKiB0aW1lLiBNdWx0aXBsZSB0aW1lc2NhbGVzIGNhbiBiZSBzcGVjaWZpZWQgd2l0aGluIGFuIE1QNCBidXQgdGhlXG4gICAgICogYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBpcyBhbHdheXMgZXhwcmVzc2VkIGluIHRoZSB0aW1lc2NhbGUgZnJvbVxuICAgICAqIHRoZSBtZWRpYSBoZWFkZXIgYm94IGZvciB0aGUgdHJhY2s6XG4gICAgICogYGBgXG4gICAgICogbW9vdiA+IHRyYWsgPiBtZGlhID4gbWRoZC50aW1lc2NhbGVcbiAgICAgKiBtb292ID4gdHJhayA+IG1kaWEgPiBoZGxyXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGluaXQge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiB0aGUgaW5pdCBzZWdtZW50XG4gICAgICogQHJldHVybiB7b2JqZWN0fSBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzIG9yIG51bGwgaWZcbiAgICAgKiB0aGUgaW5pdCBzZWdtZW50IGlzIG1hbGZvcm1lZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGFyc2VJbml0U2VnbWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciB0cmFrcyA9IE1QNERlbXV4ZXIuZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ3RyYWsnXSk7XG5cbiAgICAgIHRyYWtzLmZvckVhY2goZnVuY3Rpb24gKHRyYWspIHtcbiAgICAgICAgdmFyIHRraGQgPSBNUDREZW11eGVyLmZpbmRCb3godHJhaywgWyd0a2hkJ10pWzBdO1xuICAgICAgICBpZiAodGtoZCkge1xuICAgICAgICAgIHZhciB2ZXJzaW9uID0gdGtoZFswXTtcbiAgICAgICAgICB2YXIgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gMTIgOiAyMDtcbiAgICAgICAgICB2YXIgdHJhY2tJZCA9IHRraGRbaW5kZXhdIDw8IDI0IHwgdGtoZFtpbmRleCArIDFdIDw8IDE2IHwgdGtoZFtpbmRleCArIDJdIDw8IDggfCB0a2hkW2luZGV4ICsgM107XG5cbiAgICAgICAgICB0cmFja0lkID0gdHJhY2tJZCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdHJhY2tJZCA6IHRyYWNrSWQ7XG5cbiAgICAgICAgICB2YXIgbWRoZCA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWRoZCddKVswXTtcbiAgICAgICAgICBpZiAobWRoZCkge1xuICAgICAgICAgICAgdmVyc2lvbiA9IG1kaGRbMF07XG4gICAgICAgICAgICBpbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgICAgICAgICAgdmFyIHRpbWVzY2FsZSA9IG1kaGRbaW5kZXhdIDw8IDI0IHwgbWRoZFtpbmRleCArIDFdIDw8IDE2IHwgbWRoZFtpbmRleCArIDJdIDw8IDggfCBtZGhkW2luZGV4ICsgM107XG5cbiAgICAgICAgICAgIHZhciBoZGxyID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWssIFsnbWRpYScsICdoZGxyJ10pWzBdO1xuICAgICAgICAgICAgaWYgKGhkbHIpIHtcbiAgICAgICAgICAgICAgdmFyIGhkbHJUeXBlID0gTVA0RGVtdXhlci5iaW4yc3RyKGhkbHIuc3ViYXJyYXkoOCwgMTIpKTtcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSB7ICdzb3VuJzogJ2F1ZGlvJywgJ3ZpZGUnOiAndmlkZW8nIH1baGRsclR5cGVdO1xuICAgICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFt0cmFja0lkXSA9IHsgdGltZXNjYWxlOiB0aW1lc2NhbGUsIHR5cGU6IHR5cGUgfTtcbiAgICAgICAgICAgICAgICByZXN1bHRbdHlwZV0gPSB7IHRpbWVzY2FsZTogdGltZXNjYWxlLCBpZDogdHJhY2tJZCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lLCBpbiBzZWNvbmRzLCBmb3IgYW4gTVA0XG4gICAgICogZnJhZ21lbnQuIElmIG11bHRpcGxlIGZyYWdtZW50cyBhcmUgc3BlY2lmaWVkLCB0aGUgZWFybGllc3QgdGltZSBpc1xuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogVGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgY2FuIGJlIHBhcnNlZCBmcm9tIHRyYWNrIGZyYWdtZW50XG4gICAgICogbWV0YWRhdGE6XG4gICAgICogYGBgXG4gICAgICogbW9vZiA+IHRyYWYgPiB0ZmR0LmJhc2VNZWRpYURlY29kZVRpbWVcbiAgICAgKiBgYGBcbiAgICAgKiBJdCByZXF1aXJlcyB0aGUgdGltZXNjYWxlIHZhbHVlIGZyb20gdGhlIG1kaGQgdG8gaW50ZXJwcmV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVzY2FsZSB7b2JqZWN0fSBhIGhhc2ggb2YgdHJhY2sgaWRzIHRvIHRpbWVzY2FsZSB2YWx1ZXMuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSBmb3IgdGhlXG4gICAgICogZnJhZ21lbnQsIGluIHNlY29uZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3RhcnREVFMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydERUUyhpbml0RGF0YSwgZnJhZ21lbnQpIHtcbiAgICAgIHZhciB0cmFmcywgYmFzZVRpbWVzLCByZXN1bHQ7XG5cbiAgICAgIC8vIHdlIG5lZWQgaW5mbyBmcm9tIHR3byBjaGlsZHJlbmQgb2YgZWFjaCB0cmFjayBmcmFnbWVudCBib3hcbiAgICAgIHRyYWZzID0gTVA0RGVtdXhlci5maW5kQm94KGZyYWdtZW50LCBbJ21vb2YnLCAndHJhZiddKTtcblxuICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBzdGFydCB0aW1lcyBmb3IgZWFjaCB0cmFja1xuICAgICAgYmFzZVRpbWVzID0gW10uY29uY2F0LmFwcGx5KFtdLCB0cmFmcy5tYXAoZnVuY3Rpb24gKHRyYWYpIHtcbiAgICAgICAgcmV0dXJuIE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkubWFwKGZ1bmN0aW9uICh0ZmhkKSB7XG4gICAgICAgICAgdmFyIGlkLCBzY2FsZSwgYmFzZVRpbWU7XG5cbiAgICAgICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgICAgICBpZCA9IHRmaGRbNF0gPDwgMjQgfCB0ZmhkWzVdIDw8IDE2IHwgdGZoZFs2XSA8PCA4IHwgdGZoZFs3XTtcbiAgICAgICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgICAgIHNjYWxlID0gaW5pdERhdGFbaWRdLnRpbWVzY2FsZSB8fCA5MGUzO1xuXG4gICAgICAgICAgLy8gZ2V0IHRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGZyb20gdGhlIHRmZHRcbiAgICAgICAgICBiYXNlVGltZSA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKGZ1bmN0aW9uICh0ZmR0KSB7XG4gICAgICAgICAgICB2YXIgdmVyc2lvbiwgcmVzdWx0O1xuXG4gICAgICAgICAgICB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRmZHRbNF0gPDwgMjQgfCB0ZmR0WzVdIDw8IDE2IHwgdGZkdFs2XSA8PCA4IHwgdGZkdFs3XTtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCAqPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSB0ZmR0WzhdIDw8IDI0IHwgdGZkdFs5XSA8PCAxNiB8IHRmZHRbMTBdIDw8IDggfCB0ZmR0WzExXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSlbMF07XG4gICAgICAgICAgYmFzZVRpbWUgPSBiYXNlVGltZSB8fCBJbmZpbml0eTtcblxuICAgICAgICAgIC8vIGNvbnZlcnQgYmFzZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgICByZXR1cm4gYmFzZVRpbWUgLyBzY2FsZTtcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIHJldHVybiB0aGUgbWluaW11bVxuICAgICAgcmVzdWx0ID0gTWF0aC5taW4uYXBwbHkobnVsbCwgYmFzZVRpbWVzKTtcbiAgICAgIHJldHVybiBpc0Zpbml0ZShyZXN1bHQpID8gcmVzdWx0IDogMDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTVA0RGVtdXhlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTVA0RGVtdXhlcjtcblxufSx7XCIzM1wiOjMzfV0sMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpOyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTQU1QTEUtQUVTIGRlY3J5cHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBfZGVjcnlwdGVyID0gX2RlcmVxXygxOSk7XG5cbnZhciBfZGVjcnlwdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlY3J5cHRlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTYW1wbGVBZXNEZWNyeXB0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNhbXBsZUFlc0RlY3J5cHRlcihvYnNlcnZlciwgY29uZmlnLCBkZWNyeXB0ZGF0YSwgZGlzY2FyZEVQQikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTYW1wbGVBZXNEZWNyeXB0ZXIpO1xuXG4gICAgdGhpcy5kZWNyeXB0ZGF0YSA9IGRlY3J5cHRkYXRhO1xuICAgIHRoaXMuZGlzY2FyZEVQQiA9IGRpc2NhcmRFUEI7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgX2RlY3J5cHRlcjIuZGVmYXVsdChvYnNlcnZlciwgY29uZmlnKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTYW1wbGVBZXNEZWNyeXB0ZXIsIFt7XG4gICAga2V5OiAnZGVjcnlwdEJ1ZmZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YSwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgdGhpcy5kZWNyeXB0ZGF0YS5rZXkuYnVmZmVyLCB0aGlzLmRlY3J5cHRkYXRhLml2LmJ1ZmZlciwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8vIEFBQyAtIGVuY3J5cHQgYWxsIGZ1bGwgMTYgYnl0ZXMgYmxvY2tzIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDE2XG5cbiAgfSwge1xuICAgIGtleTogJ2RlY3J5cHRBYWNTYW1wbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0QWFjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaywgc3luYykge1xuICAgICAgdmFyIGN1clVuaXQgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0O1xuICAgICAgdmFyIGVuY3J5cHRlZERhdGEgPSBjdXJVbml0LnN1YmFycmF5KDE2LCBjdXJVbml0Lmxlbmd0aCAtIGN1clVuaXQubGVuZ3RoICUgMTYpO1xuICAgICAgdmFyIGVuY3J5cHRlZEJ1ZmZlciA9IGVuY3J5cHRlZERhdGEuYnVmZmVyLnNsaWNlKGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCwgZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0ICsgZW5jcnlwdGVkRGF0YS5sZW5ndGgpO1xuXG4gICAgICB2YXIgbG9jYWx0aGlzID0gdGhpcztcbiAgICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWRCdWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgIGRlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICAgICAgY3VyVW5pdC5zZXQoZGVjcnlwdGVkRGF0YSwgMTYpO1xuXG4gICAgICAgIGlmICghc3luYykge1xuICAgICAgICAgIGxvY2FsdGhpcy5kZWNyeXB0QWFjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVjcnlwdEFhY1NhbXBsZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0QWFjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2spIHtcbiAgICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKykge1xuICAgICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0Lmxlbmd0aCA8IDMyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3luYyA9IHRoaXMuZGVjcnlwdGVyLmlzU3luYygpO1xuXG4gICAgICAgIHRoaXMuZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2ssIHN5bmMpO1xuXG4gICAgICAgIGlmICghc3luYykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFWQyAtIGVuY3J5cHQgb25lIDE2IGJ5dGVzIGJsb2NrIG91dCBvZiB0ZW4sIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDMyXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEF2Y0VuY3J5cHRlZERhdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKSB7XG4gICAgICB2YXIgZW5jcnlwdGVkRGF0YUxlbiA9IE1hdGguZmxvb3IoKGRlY29kZWREYXRhLmxlbmd0aCAtIDQ4KSAvIDE2MCkgKiAxNiArIDE2O1xuICAgICAgdmFyIGVuY3J5cHRlZERhdGEgPSBuZXcgSW50OEFycmF5KGVuY3J5cHRlZERhdGFMZW4pO1xuICAgICAgdmFyIG91dHB1dFBvcyA9IDA7XG4gICAgICBmb3IgKHZhciBpbnB1dFBvcyA9IDMyOyBpbnB1dFBvcyA8PSBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjsgaW5wdXRQb3MgKz0gMTYwLCBvdXRwdXRQb3MgKz0gMTYpIHtcbiAgICAgICAgZW5jcnlwdGVkRGF0YS5zZXQoZGVjb2RlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuY3J5cHRlZERhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0QXZjRGVjcnlwdGVkVW5pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZERhdGEpIHtcbiAgICAgIGRlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICAgIHZhciBpbnB1dFBvcyA9IDA7XG4gICAgICBmb3IgKHZhciBvdXRwdXRQb3MgPSAzMjsgb3V0cHV0UG9zIDw9IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBvdXRwdXRQb3MgKz0gMTYwLCBpbnB1dFBvcyArPSAxNikge1xuICAgICAgICBkZWNvZGVkRGF0YS5zZXQoZGVjcnlwdGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVjb2RlZERhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVjcnlwdEF2Y1NhbXBsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3J5cHRBdmNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2ssIGN1clVuaXQsIHN5bmMpIHtcbiAgICAgIHZhciBkZWNvZGVkRGF0YSA9IHRoaXMuZGlzY2FyZEVQQihjdXJVbml0LmRhdGEpO1xuICAgICAgdmFyIGVuY3J5cHRlZERhdGEgPSB0aGlzLmdldEF2Y0VuY3J5cHRlZERhdGEoZGVjb2RlZERhdGEpO1xuICAgICAgdmFyIGxvY2FsdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhLmJ1ZmZlciwgZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgY3VyVW5pdC5kYXRhID0gbG9jYWx0aGlzLmdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZERhdGEpO1xuXG4gICAgICAgIGlmICghc3luYykge1xuICAgICAgICAgIGxvY2FsdGhpcy5kZWNyeXB0QXZjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4ICsgMSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWNyeXB0QXZjU2FtcGxlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICBmb3IgKDs7IHNhbXBsZUluZGV4KyssIHVuaXRJbmRleCA9IDApIHtcbiAgICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VyVW5pdHMgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0cy51bml0cztcbiAgICAgICAgZm9yICg7OyB1bml0SW5kZXgrKykge1xuICAgICAgICAgIGlmICh1bml0SW5kZXggPj0gY3VyVW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY3VyVW5pdCA9IGN1clVuaXRzW3VuaXRJbmRleF07XG4gICAgICAgICAgaWYgKGN1clVuaXQubGVuZ3RoIDw9IDQ4IHx8IGN1clVuaXQudHlwZSAhPT0gMSAmJiBjdXJVbml0LnR5cGUgIT09IDUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzeW5jID0gdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCk7XG5cbiAgICAgICAgICB0aGlzLmRlY3J5cHRBdmNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2ssIGN1clVuaXQsIHN5bmMpO1xuXG4gICAgICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNhbXBsZUFlc0RlY3J5cHRlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU2FtcGxlQWVzRGVjcnlwdGVyO1xuXG59LHtcIjE5XCI6MTl9XSwzMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGhpZ2hseSBvcHRpbWl6ZWQgVFMgZGVtdXhlcjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBwYXJzZSBQQVQsIFBNVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGV4dHJhY3QgUEVTIHBhY2tldCBmcm9tIGF1ZGlvIGFuZCB2aWRlbyBQSURzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZXh0cmFjdCBBVkMvSDI2NCBOQUwgdW5pdHMgYW5kIEFBQy9BRFRTIHNhbXBsZXMgZnJvbSBQRVMgcGFja2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogdHJpZ2dlciB0aGUgcmVtdXhlciB1cG9uIHBhcnNpbmcgY29tcGxldGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGl0IGFsc28gdHJpZXMgdG8gd29ya2Fyb3VuZCBhcyBiZXN0IGFzIGl0IGNhbiBhdWRpbyBjb2RlYyBzd2l0Y2ggKEhFLUFBQyB0byBBQUMgYW5kIHZpY2UgdmVyc2EpLCB3aXRob3V0IGhhdmluZyB0byByZXN0YXJ0IHRoZSBNZWRpYVNvdXJjZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBpdCBhbHNvIGNvbnRyb2xzIHRoZSByZW11eGluZyBwcm9jZXNzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB1cG9uIGRpc2NvbnRpbnVpdHkgb3IgbGV2ZWwgc3dpdGNoIGRldGVjdGlvbiwgaXQgd2lsbCBhbHNvIG5vdGlmaWVzIHRoZSByZW11eGVyIHNvIHRoYXQgaXQgY2FuIHJlc2V0IGl0cyBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4vLyBpbXBvcnQgSGV4IGZyb20gJy4uL3V0aWxzL2hleCc7XG5cblxudmFyIF9hZHRzID0gX2RlcmVxXygyMik7XG5cbnZhciBfYWR0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZHRzKTtcblxudmFyIF9ldmVudHMgPSBfZGVyZXFfKDMzKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9leHBHb2xvbWIgPSBfZGVyZXFfKDI2KTtcblxudmFyIF9leHBHb2xvbWIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXhwR29sb21iKTtcblxudmFyIF9zYW1wbGVBZXMgPSBfZGVyZXFfKDI5KTtcblxudmFyIF9zYW1wbGVBZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2FtcGxlQWVzKTtcblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxudmFyIF9lcnJvcnMgPSBfZGVyZXFfKDMxKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFRTRGVtdXhlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVFNEZW11eGVyKG9ic2VydmVyLCByZW11eGVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVFNEZW11eGVyKTtcblxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRTRGVtdXhlciwgW3tcbiAgICBrZXk6ICdzZXREZWNyeXB0RGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERlY3J5cHREYXRhKGRlY3J5cHRkYXRhKSB7XG4gICAgICBpZiAoZGVjcnlwdGRhdGEgIT0gbnVsbCAmJiBkZWNyeXB0ZGF0YS5rZXkgIT0gbnVsbCAmJiBkZWNyeXB0ZGF0YS5tZXRob2QgPT09ICdTQU1QTEUtQUVTJykge1xuICAgICAgICB0aGlzLnNhbXBsZUFlcyA9IG5ldyBfc2FtcGxlQWVzMi5kZWZhdWx0KHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnLCBkZWNyeXB0ZGF0YSwgdGhpcy5kaXNjYXJkRVBCKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldEluaXRTZWdtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgICB0aGlzLl9wbXRJZCA9IC0xO1xuICAgICAgdGhpcy5fYXZjVHJhY2sgPSB7IGNvbnRhaW5lcjogJ3ZpZGVvL21wMnQnLCB0eXBlOiAndmlkZW8nLCBpZDogLTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBzYW1wbGVzOiBbXSwgbGVuOiAwLCBkcm9wcGVkOiAwIH07XG4gICAgICB0aGlzLl9hdWRpb1RyYWNrID0geyBjb250YWluZXI6ICd2aWRlby9tcDJ0JywgdHlwZTogJ2F1ZGlvJywgaWQ6IC0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlczogW10sIGxlbjogMCwgaXNBQUM6IHRydWUgfTtcbiAgICAgIHRoaXMuX2lkM1RyYWNrID0geyB0eXBlOiAnaWQzJywgaWQ6IC0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlczogW10sIGxlbjogMCB9O1xuICAgICAgdGhpcy5fdHh0VHJhY2sgPSB7IHR5cGU6ICd0ZXh0JywgaWQ6IC0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlczogW10sIGxlbjogMCB9O1xuICAgICAgLy8gZmx1c2ggYW55IHBhcnRpYWwgY29udGVudFxuICAgICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgICB0aGlzLmFhY0xhc3RQVFMgPSBudWxsO1xuICAgICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0VGltZVN0YW1wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRUaW1lU3RhbXAoKSB7fVxuXG4gICAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuXG4gIH0sIHtcbiAgICBrZXk6ICdhcHBlbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICB2YXIgc3RhcnQsXG4gICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgc3R0LFxuICAgICAgICAgIHBpZCxcbiAgICAgICAgICBhdGYsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIHBlcyxcbiAgICAgICAgICB1bmtub3duUElEcyA9IGZhbHNlO1xuICAgICAgdGhpcy5jb250aWd1b3VzID0gY29udGlndW91cztcbiAgICAgIHZhciBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCxcbiAgICAgICAgICBhdmNUcmFjayA9IHRoaXMuX2F2Y1RyYWNrLFxuICAgICAgICAgIGF1ZGlvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgICAgIGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2ssXG4gICAgICAgICAgYXZjSWQgPSBhdmNUcmFjay5pZCxcbiAgICAgICAgICBhdWRpb0lkID0gYXVkaW9UcmFjay5pZCxcbiAgICAgICAgICBpZDNJZCA9IGlkM1RyYWNrLmlkLFxuICAgICAgICAgIHBtdElkID0gdGhpcy5fcG10SWQsXG4gICAgICAgICAgYXZjRGF0YSA9IGF2Y1RyYWNrLnBlc0RhdGEsXG4gICAgICAgICAgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhLFxuICAgICAgICAgIGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhLFxuICAgICAgICAgIHBhcnNlUEFUID0gdGhpcy5fcGFyc2VQQVQsXG4gICAgICAgICAgcGFyc2VQTVQgPSB0aGlzLl9wYXJzZVBNVCxcbiAgICAgICAgICBwYXJzZVBFUyA9IHRoaXMuX3BhcnNlUEVTLFxuICAgICAgICAgIHBhcnNlQVZDUEVTID0gdGhpcy5fcGFyc2VBVkNQRVMuYmluZCh0aGlzKSxcbiAgICAgICAgICBwYXJzZUFBQ1BFUyA9IHRoaXMuX3BhcnNlQUFDUEVTLmJpbmQodGhpcyksXG4gICAgICAgICAgcGFyc2VNUEVHUEVTID0gdGhpcy5fcGFyc2VNUEVHUEVTLmJpbmQodGhpcyksXG4gICAgICAgICAgcGFyc2VJRDNQRVMgPSB0aGlzLl9wYXJzZUlEM1BFUy5iaW5kKHRoaXMpO1xuXG4gICAgICAvLyBkb24ndCBwYXJzZSBsYXN0IFRTIHBhY2tldCBpZiBpbmNvbXBsZXRlXG4gICAgICBsZW4gLT0gbGVuICUgMTg4O1xuICAgICAgLy8gbG9vcCB0aHJvdWdoIFRTIHBhY2tldHNcbiAgICAgIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IGxlbjsgc3RhcnQgKz0gMTg4KSB7XG4gICAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xuICAgICAgICAgIHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xuICAgICAgICAgIC8vIHBpZCBpcyBhIDEzLWJpdCBmaWVsZCBzdGFydGluZyBhdCB0aGUgbGFzdCBiaXQgb2YgVFNbMV1cbiAgICAgICAgICBwaWQgPSAoKGRhdGFbc3RhcnQgKyAxXSAmIDB4MWYpIDw8IDgpICsgZGF0YVtzdGFydCArIDJdO1xuICAgICAgICAgIGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0O1xuICAgICAgICAgIC8vIGlmIGFuIGFkYXB0aW9uIGZpZWxkIGlzIHByZXNlbnQsIGl0cyBsZW5ndGggaXMgc3BlY2lmaWVkIGJ5IHRoZSBmaWZ0aCBieXRlIG9mIHRoZSBUUyBwYWNrZXQgaGVhZGVyLlxuICAgICAgICAgIGlmIChhdGYgPiAxKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDUgKyBkYXRhW3N0YXJ0ICsgNF07XG4gICAgICAgICAgICAvLyBjb250aW51ZSBpZiB0aGVyZSBpcyBvbmx5IGFkYXB0YXRpb24gZmllbGRcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IHN0YXJ0ICsgMTg4KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAocGlkKSB7XG4gICAgICAgICAgICBjYXNlIGF2Y0lkOlxuICAgICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGF2Y0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF2Y0RhdGEpKSkge1xuICAgICAgICAgICAgICAgICAgcGFyc2VBVkNQRVMocGVzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF2Y0RhdGEgPSB7IGRhdGE6IFtdLCBzaXplOiAwIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGF2Y0RhdGEpIHtcbiAgICAgICAgICAgICAgICBhdmNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgICAgICBhdmNEYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGF1ZGlvSWQ6XG4gICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VBQUNQRVMocGVzKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlTVBFR1BFUyhwZXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdWRpb0RhdGEgPSB7IGRhdGE6IFtdLCBzaXplOiAwIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xuICAgICAgICAgICAgICAgIGF1ZGlvRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgICAgYXVkaW9EYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGlkM0lkOlxuICAgICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSkge1xuICAgICAgICAgICAgICAgICAgcGFyc2VJRDNQRVMocGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWQzRGF0YSA9IHsgZGF0YTogW10sIHNpemU6IDAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaWQzRGF0YSkge1xuICAgICAgICAgICAgICAgIGlkM0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xuICAgICAgICAgICAgICAgIGlkM0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBkYXRhW29mZnNldF0gKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBtdElkID0gdGhpcy5fcG10SWQgPSBwYXJzZVBBVChkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgcG10SWQ6XG4gICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcGFyc2VkUElEcyA9IHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWcgPT09IHRydWUgfHwgdGhpcy50eXBlU3VwcG9ydGVkLm1wMyA9PT0gdHJ1ZSwgdGhpcy5zYW1wbGVBZXMgIT0gbnVsbCk7XG5cbiAgICAgICAgICAgICAgLy8gb25seSB1cGRhdGUgdHJhY2sgaWQgaWYgdHJhY2sgUElEIGZvdW5kIHdoaWxlIHBhcnNpbmcgUE1UXG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gYXZvaWQgcmVzZXR0aW5nIHRoZSBQSUQgdG8gLTEgaW4gY2FzZVxuICAgICAgICAgICAgICAvLyB0cmFjayBQSUQgdHJhbnNpZW50bHkgZGlzYXBwZWFycyBmcm9tIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaW4gY2FzZSBvZiB0cmFuc2llbnQgbWlzc2luZyBhdWRpbyBzYW1wbGVzIGZvciBleGFtcGxlXG4gICAgICAgICAgICAgIGF2Y0lkID0gcGFyc2VkUElEcy5hdmM7XG4gICAgICAgICAgICAgIGlmIChhdmNJZCA+IDApIHtcbiAgICAgICAgICAgICAgICBhdmNUcmFjay5pZCA9IGF2Y0lkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF1ZGlvSWQgPSBwYXJzZWRQSURzLmF1ZGlvO1xuICAgICAgICAgICAgICBpZiAoYXVkaW9JZCA+IDApIHtcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrLmlkID0gYXVkaW9JZDtcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrLmlzQUFDID0gcGFyc2VkUElEcy5pc0FBQztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZDNJZCA9IHBhcnNlZFBJRHMuaWQzO1xuICAgICAgICAgICAgICBpZiAoaWQzSWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWQzVHJhY2suaWQgPSBpZDNJZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodW5rbm93blBJRHMgJiYgIXBtdFBhcnNlZCkge1xuICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygncmVwYXJzZSBmcm9tIGJlZ2lubmluZycpO1xuICAgICAgICAgICAgICAgIHVua25vd25QSURzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2V0IGl0IHRvIC0xODgsIHRoZSArPSAxODggaW4gdGhlIGZvciBsb29wIHdpbGwgcmVzZXQgc3RhcnQgdG8gMFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gLTE4ODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIGNhc2UgMHgxZmZmOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHVua25vd25QSURzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogZmFsc2UsIHJlYXNvbjogJ1RTIHBhY2tldCBkaWQgbm90IHN0YXJ0IHdpdGggMHg0NycgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHRyeSB0byBwYXJzZSBsYXN0IFBFUyBwYWNrZXRzXG4gICAgICBpZiAoYXZjRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXZjRGF0YSkpKSB7XG4gICAgICAgIHBhcnNlQVZDUEVTKHBlcywgdHJ1ZSk7XG4gICAgICAgIGF2Y1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZWl0aGVyIGF2Y0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgICBhdmNUcmFjay5wZXNEYXRhID0gYXZjRGF0YTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcbiAgICAgICAgaWYgKGF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgICAgICBwYXJzZUFBQ1BFUyhwZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlTVBFR1BFUyhwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYXVkaW9EYXRhICYmIGF1ZGlvRGF0YS5zaXplKSB7XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdsYXN0IEFBQyBQRVMgcGFja2V0IHRydW5jYXRlZCxtaWdodCBvdmVybGFwIGJldHdlZW4gZnJhZ21lbnRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWl0aGVyIGF1ZGlvRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSkge1xuICAgICAgICBwYXJzZUlEM1BFUyhwZXMpO1xuICAgICAgICBpZDNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVpdGhlciBpZDNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNhbXBsZUFlcyA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCBhdmNUcmFjaywgaWQzVHJhY2ssIHRoaXMuX3R4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWNyeXB0QW5kUmVtdXgoYXVkaW9UcmFjaywgYXZjVHJhY2ssIGlkM1RyYWNrLCB0aGlzLl90eHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWNyeXB0QW5kUmVtdXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0QW5kUmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoYXVkaW9UcmFjay5zYW1wbGVzICYmIGF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbG9jYWx0aGlzID0gX3RoaXM7XG4gICAgICAgICAgX3RoaXMuc2FtcGxlQWVzLmRlY3J5cHRBYWNTYW1wbGVzKGF1ZGlvVHJhY2suc2FtcGxlcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbG9jYWx0aGlzLmRlY3J5cHRBbmRSZW11eEF2YyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWNyeXB0QW5kUmVtdXhBdmMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWNyeXB0QW5kUmVtdXhBdmMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0QW5kUmVtdXhBdmMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBsb2NhbHRoaXMgPSBfdGhpczI7XG4gICAgICAgICAgX3RoaXMyLnNhbXBsZUFlcy5kZWNyeXB0QXZjU2FtcGxlcyh2aWRlb1RyYWNrLnNhbXBsZXMsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvY2FsdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19wYXJzZVBBVCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZVBBVChkYXRhLCBvZmZzZXQpIHtcbiAgICAgIC8vIHNraXAgdGhlIFBTSSBoZWFkZXIgYW5kIHBhcnNlIHRoZSBmaXJzdCBQTVQgZW50cnlcbiAgICAgIHJldHVybiAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDFGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gICAgICAvL2xvZ2dlci5sb2coJ1BNVCBQSUQ6JyAgKyB0aGlzLl9wbXRJZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3BhcnNlUE1UJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlUE1UKGRhdGEsIG9mZnNldCwgbXBlZ1N1cHBvcnRlZCwgaXNTYW1wbGVBZXMpIHtcbiAgICAgIHZhciBzZWN0aW9uTGVuZ3RoLFxuICAgICAgICAgIHRhYmxlRW5kLFxuICAgICAgICAgIHByb2dyYW1JbmZvTGVuZ3RoLFxuICAgICAgICAgIHBpZCxcbiAgICAgICAgICByZXN1bHQgPSB7IGF1ZGlvOiAtMSwgYXZjOiAtMSwgaWQzOiAtMSwgaXNBQUM6IHRydWUgfTtcbiAgICAgIHNlY3Rpb25MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICAgICAgdGFibGVFbmQgPSBvZmZzZXQgKyAzICsgc2VjdGlvbkxlbmd0aCAtIDQ7XG4gICAgICAvLyB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIHRhYmxlIGlzLCB3ZSBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93XG4gICAgICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXG4gICAgICBwcm9ncmFtSW5mb0xlbmd0aCA9IChkYXRhW29mZnNldCArIDEwXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDExXTtcbiAgICAgIC8vIGFkdmFuY2UgdGhlIG9mZnNldCB0byB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIG1hcHBpbmcgdGFibGVcbiAgICAgIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICAgICAgd2hpbGUgKG9mZnNldCA8IHRhYmxlRW5kKSB7XG4gICAgICAgIHBpZCA9IChkYXRhW29mZnNldCArIDFdICYgMHgxRikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XG4gICAgICAgIHN3aXRjaCAoZGF0YVtvZmZzZXRdKSB7XG4gICAgICAgICAgY2FzZSAweGNmOlxuICAgICAgICAgICAgLy8gU0FNUExFLUFFUyBBQUNcbiAgICAgICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCd1bmtvd24gc3RyZWFtIHR5cGU6JyArIGRhdGFbb2Zmc2V0XSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgICAgICAgIC8vIElTTy9JRUMgMTM4MTgtNyBBRFRTIEFBQyAoTVBFRy0yIGxvd2VyIGJpdC1yYXRlIGF1ZGlvKVxuICAgICAgICAgIGNhc2UgMHgwZjpcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnQUFDIFBJRDonICArIHBpZCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmF1ZGlvID09PSAtMSkge1xuICAgICAgICAgICAgICByZXN1bHQuYXVkaW8gPSBwaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIFBhY2tldGl6ZWQgbWV0YWRhdGEgKElEMylcbiAgICAgICAgICBjYXNlIDB4MTU6XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coJ0lEMyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5pZDMgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5pZDMgPSBwaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhkYjpcbiAgICAgICAgICAgIC8vIFNBTVBMRS1BRVMgQVZDXG4gICAgICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICAgICAgICAvLyBJVFUtVCBSZWMuIEguMjY0IGFuZCBJU08vSUVDIDE0NDk2LTEwIChsb3dlciBiaXQtcmF0ZSB2aWRlbylcbiAgICAgICAgICBjYXNlIDB4MWI6XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coJ0FWQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5hdmMgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5hdmMgPSBwaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIElTTy9JRUMgMTExNzItMyAoTVBFRy0xIGF1ZGlvKVxuICAgICAgICAgIC8vIG9yIElTTy9JRUMgMTM4MTgtMyAoTVBFRy0yIGhhbHZlZCBzYW1wbGUgcmF0ZSBhdWRpbylcbiAgICAgICAgICBjYXNlIDB4MDM6XG4gICAgICAgICAgY2FzZSAweDA0OlxuICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdNUEVHIFBJRDonICArIHBpZCk7XG4gICAgICAgICAgICBpZiAoIW1wZWdTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdNUEVHIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlciBmb3Igbm93Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmF1ZGlvID0gcGlkO1xuICAgICAgICAgICAgICByZXN1bHQuaXNBQUMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweDI0OlxuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignSEVWQyBzdHJlYW0gdHlwZSBmb3VuZCwgbm90IHN1cHBvcnRlZCBmb3Igbm93Jyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3Vua293biBzdHJlYW0gdHlwZTonICsgZGF0YVtvZmZzZXRdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1vdmUgdG8gdGhlIG5leHQgdGFibGUgZW50cnlcbiAgICAgICAgLy8gc2tpcCBwYXN0IHRoZSBlbGVtZW50YXJ5IHN0cmVhbSBkZXNjcmlwdG9ycywgaWYgcHJlc2VudFxuICAgICAgICBvZmZzZXQgKz0gKChkYXRhW29mZnNldCArIDNdICYgMHgwRikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgNF0pICsgNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3BhcnNlUEVTJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlUEVTKHN0cmVhbSkge1xuICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgcGVzRmxhZ3MsXG4gICAgICAgICAgcGVzUHJlZml4LFxuICAgICAgICAgIHBlc0xlbixcbiAgICAgICAgICBwZXNIZHJMZW4sXG4gICAgICAgICAgcGVzRGF0YSxcbiAgICAgICAgICBwZXNQdHMsXG4gICAgICAgICAgcGVzRHRzLFxuICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCxcbiAgICAgICAgICBkYXRhID0gc3RyZWFtLmRhdGE7XG4gICAgICAvLyBzYWZldHkgY2hlY2tcbiAgICAgIGlmICghc3RyZWFtIHx8IHN0cmVhbS5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBtaWdodCBuZWVkIHVwIHRvIDE5IGJ5dGVzIHRvIHJlYWQgUEVTIGhlYWRlclxuICAgICAgLy8gaWYgZmlyc3QgY2h1bmsgb2YgZGF0YSBpcyBsZXNzIHRoYW4gMTkgYnl0ZXMsIGxldCdzIG1lcmdlIGl0IHdpdGggZm9sbG93aW5nIG9uZXMgdW50aWwgd2UgZ2V0IDE5IGJ5dGVzXG4gICAgICAvLyB1c3VhbGx5IG9ubHkgb25lIG1lcmdlIGlzIG5lZWRlZCAoYW5kIHRoaXMgaXMgcmFyZSAuLi4pXG4gICAgICB3aGlsZSAoZGF0YVswXS5sZW5ndGggPCAxOSAmJiBkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShkYXRhWzBdLmxlbmd0aCArIGRhdGFbMV0ubGVuZ3RoKTtcbiAgICAgICAgbmV3RGF0YS5zZXQoZGF0YVswXSk7XG4gICAgICAgIG5ld0RhdGEuc2V0KGRhdGFbMV0sIGRhdGFbMF0ubGVuZ3RoKTtcbiAgICAgICAgZGF0YVswXSA9IG5ld0RhdGE7XG4gICAgICAgIGRhdGEuc3BsaWNlKDEsIDEpO1xuICAgICAgfVxuICAgICAgLy9yZXRyaWV2ZSBQVFMvRFRTIGZyb20gZmlyc3QgZnJhZ21lbnRcbiAgICAgIGZyYWcgPSBkYXRhWzBdO1xuICAgICAgcGVzUHJlZml4ID0gKGZyYWdbMF0gPDwgMTYpICsgKGZyYWdbMV0gPDwgOCkgKyBmcmFnWzJdO1xuICAgICAgaWYgKHBlc1ByZWZpeCA9PT0gMSkge1xuICAgICAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07XG4gICAgICAgIC8vIGlmIFBFUyBwYXJzZWQgbGVuZ3RoIGlzIG5vdCB6ZXJvIGFuZCBncmVhdGVyIHRoYW4gdG90YWwgcmVjZWl2ZWQgbGVuZ3RoLCBzdG9wIHBhcnNpbmcuIFBFUyBtaWdodCBiZSB0cnVuY2F0ZWRcbiAgICAgICAgLy8gbWludXMgNiA6IFBFUyBoZWFkZXIgc2l6ZVxuICAgICAgICBpZiAocGVzTGVuICYmIHBlc0xlbiA+IHN0cmVhbS5zaXplIC0gNikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHBlc0ZsYWdzID0gZnJhZ1s3XTtcbiAgICAgICAgaWYgKHBlc0ZsYWdzICYgMHhDMCkge1xuICAgICAgICAgIC8qIFBFUyBoZWFkZXIgZGVzY3JpYmVkIGhlcmUgOiBodHRwOi8vZHZkLnNvdXJjZWZvcmdlLm5ldC9kdmRpbmZvL3Blcy1oZHIuaHRtbFxuICAgICAgICAgICAgICBhcyBQVFMgLyBEVFMgaXMgMzMgYml0IHdlIGNhbm5vdCB1c2UgYml0d2lzZSBvcGVyYXRvciBpbiBKUyxcbiAgICAgICAgICAgICAgYXMgQml0d2lzZSBvcGVyYXRvcnMgdHJlYXQgdGhlaXIgb3BlcmFuZHMgYXMgYSBzZXF1ZW5jZSBvZiAzMiBiaXRzICovXG4gICAgICAgICAgcGVzUHRzID0gKGZyYWdbOV0gJiAweDBFKSAqIDUzNjg3MDkxMiArIC8vIDEgPDwgMjlcbiAgICAgICAgICAoZnJhZ1sxMF0gJiAweEZGKSAqIDQxOTQzMDQgKyAvLyAxIDw8IDIyXG4gICAgICAgICAgKGZyYWdbMTFdICYgMHhGRSkgKiAxNjM4NCArIC8vIDEgPDwgMTRcbiAgICAgICAgICAoZnJhZ1sxMl0gJiAweEZGKSAqIDEyOCArIC8vIDEgPDwgN1xuICAgICAgICAgIChmcmFnWzEzXSAmIDB4RkUpIC8gMjtcbiAgICAgICAgICAvLyBjaGVjayBpZiBncmVhdGVyIHRoYW4gMl4zMiAtMVxuICAgICAgICAgIGlmIChwZXNQdHMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAvLyBkZWNyZW1lbnQgMl4zM1xuICAgICAgICAgICAgcGVzUHRzIC09IDg1ODk5MzQ1OTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwZXNGbGFncyAmIDB4NDApIHtcbiAgICAgICAgICAgIHBlc0R0cyA9IChmcmFnWzE0XSAmIDB4MEUpICogNTM2ODcwOTEyICsgLy8gMSA8PCAyOVxuICAgICAgICAgICAgKGZyYWdbMTVdICYgMHhGRikgKiA0MTk0MzA0ICsgLy8gMSA8PCAyMlxuICAgICAgICAgICAgKGZyYWdbMTZdICYgMHhGRSkgKiAxNjM4NCArIC8vIDEgPDwgMTRcbiAgICAgICAgICAgIChmcmFnWzE3XSAmIDB4RkYpICogMTI4ICsgLy8gMSA8PCA3XG4gICAgICAgICAgICAoZnJhZ1sxOF0gJiAweEZFKSAvIDI7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBncmVhdGVyIHRoYW4gMl4zMiAtMVxuICAgICAgICAgICAgaWYgKHBlc0R0cyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IDJeMzNcbiAgICAgICAgICAgICAgcGVzRHRzIC09IDg1ODk5MzQ1OTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGVzUHRzIC0gcGVzRHRzID4gNjAgKiA5MDAwMCkge1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKE1hdGgucm91bmQoKHBlc1B0cyAtIHBlc0R0cykgLyA5MDAwMCkgKyAncyBkZWx0YSBiZXR3ZWVuIFBUUyBhbmQgRFRTLCBhbGlnbiB0aGVtJyk7XG4gICAgICAgICAgICAgIHBlc1B0cyA9IHBlc0R0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVzRHRzID0gcGVzUHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwZXNIZHJMZW4gPSBmcmFnWzhdO1xuICAgICAgICAvLyA5IGJ5dGVzIDogNiBieXRlcyBmb3IgUEVTIGhlYWRlciArIDMgYnl0ZXMgZm9yIFBFUyBleHRlbnNpb25cbiAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gcGVzSGRyTGVuICsgOTtcblxuICAgICAgICBzdHJlYW0uc2l6ZSAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAgIC8vcmVhc3NlbWJsZSBQRVMgcGFja2V0XG4gICAgICAgIHBlc0RhdGEgPSBuZXcgVWludDhBcnJheShzdHJlYW0uc2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBkYXRhTGVuID0gZGF0YS5sZW5ndGg7IGogPCBkYXRhTGVuOyBqKyspIHtcbiAgICAgICAgICBmcmFnID0gZGF0YVtqXTtcbiAgICAgICAgICB2YXIgbGVuID0gZnJhZy5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQgPiBsZW4pIHtcbiAgICAgICAgICAgICAgLy8gdHJpbSBmdWxsIGZyYWcgaWYgUEVTIGhlYWRlciBiaWdnZXIgdGhhbiBmcmFnXG4gICAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCAtPSBsZW47XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gdHJpbSBwYXJ0aWFsIGZyYWcgaWYgUEVTIGhlYWRlciBzbWFsbGVyIHRoYW4gZnJhZ1xuICAgICAgICAgICAgICBmcmFnID0gZnJhZy5zdWJhcnJheShwYXlsb2FkU3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICBsZW4gLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwZXNEYXRhLnNldChmcmFnLCBpKTtcbiAgICAgICAgICBpICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVzTGVuKSB7XG4gICAgICAgICAgLy8gcGF5bG9hZCBzaXplIDogcmVtb3ZlIFBFUyBoZWFkZXIgKyBQRVMgZXh0ZW5zaW9uXG4gICAgICAgICAgcGVzTGVuIC09IHBlc0hkckxlbiArIDM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogcGVzRGF0YSwgcHRzOiBwZXNQdHMsIGR0czogcGVzRHRzLCBsZW46IHBlc0xlbiB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHVzaEFjY2VzVW5pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2hBY2Nlc1VuaXQoYXZjU2FtcGxlLCBhdmNUcmFjaykge1xuICAgICAgaWYgKGF2Y1NhbXBsZS51bml0cy51bml0cy5sZW5ndGggJiYgYXZjU2FtcGxlLmZyYW1lKSB7XG4gICAgICAgIC8vIG9ubHkgcHVzaCBBVkMgc2FtcGxlIGlmIHN0YXJ0aW5nIHdpdGggYSBrZXlmcmFtZSBpcyBub3QgbWFuZGF0b3J5IE9SXG4gICAgICAgIC8vICAgIGlmIGtleWZyYW1lIGFscmVhZHkgZm91bmQgaW4gdGhpcyBmcmFnbWVudCBPUlxuICAgICAgICAvLyAgICAgICBrZXlmcmFtZSBmb3VuZCBpbiBsYXN0IGZyYWdtZW50ICh0cmFjay5zcHMpIEFORFxuICAgICAgICAvLyAgICAgICAgICBzYW1wbGVzIGFscmVhZHkgYXBwZW5kZWQgKHdlIGFscmVhZHkgZm91bmQgYSBrZXlmcmFtZSBpbiB0aGlzIGZyYWdtZW50KSBPUiBmcmFnbWVudCBpcyBjb250aWd1b3VzXG4gICAgICAgIGlmICghdGhpcy5jb25maWcuZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eSB8fCBhdmNTYW1wbGUua2V5ID09PSB0cnVlIHx8IGF2Y1RyYWNrLnNwcyAmJiAoYXZjVHJhY2suc2FtcGxlcy5sZW5ndGggfHwgdGhpcy5jb250aWd1b3VzKSkge1xuICAgICAgICAgIGF2Y1RyYWNrLnNhbXBsZXMucHVzaChhdmNTYW1wbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRyb3BwZWQgc2FtcGxlcywgdHJhY2sgaXRcbiAgICAgICAgICBhdmNUcmFjay5kcm9wcGVkKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhdmNTYW1wbGUuZGVidWcubGVuZ3RoKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICc6JyArIGF2Y1NhbXBsZS5kZWJ1ZyArICcsJyArIGF2Y1NhbXBsZS51bml0cy5sZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19wYXJzZUFWQ1BFUycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZUFWQ1BFUyhwZXMsIGxhc3QpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAvL2xvZ2dlci5sb2coJ3BhcnNlIG5ldyBQRVMnKTtcbiAgICAgIHZhciB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLFxuICAgICAgICAgIHVuaXRzID0gdGhpcy5fcGFyc2VBVkNOQUx1KHBlcy5kYXRhKSxcbiAgICAgICAgICBkZWJ1ZyA9IGZhbHNlLFxuICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIsXG4gICAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUsXG4gICAgICAgICAgcHVzaCxcbiAgICAgICAgICBpO1xuICAgICAgLy9mcmVlIHBlcy5kYXRhIHRvIHNhdmUgdXAgc29tZSBtZW1vcnlcbiAgICAgIHBlcy5kYXRhID0gbnVsbDtcblxuICAgICAgdW5pdHMuZm9yRWFjaChmdW5jdGlvbiAodW5pdCkge1xuICAgICAgICBzd2l0Y2ggKHVuaXQudHlwZSkge1xuICAgICAgICAgIC8vTkRSXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnTkRSICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdmNTYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgLy8gcmV0cmlldmUgc2xpY2UgdHlwZSBieSBwYXJzaW5nIGJlZ2lubmluZyBvZiBOQUwgdW5pdCAoZm9sbG93IEgyNjQgc3BlYywgc2xpY2VfaGVhZGVyIGRlZmluaXRpb24pIHRvIGRldGVjdCBrZXlmcmFtZSBlbWJlZGRlZCBpbiBORFJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdW5pdC5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICB2YXIgc2xpY2VUeXBlID0gbmV3IF9leHBHb2xvbWIyLmRlZmF1bHQoZGF0YSkucmVhZFNsaWNlVHlwZSgpO1xuICAgICAgICAgICAgICAvLyAyIDogSSBzbGljZSwgNCA6IFNJIHNsaWNlLCA3IDogSSBzbGljZSwgOTogU0kgc2xpY2VcbiAgICAgICAgICAgICAgLy8gU0kgc2xpY2UgOiBBIHNsaWNlIHRoYXQgaXMgY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5IGFuZCB1c2luZyBxdWFudGlzYXRpb24gb2YgdGhlIHByZWRpY3Rpb24gc2FtcGxlcy5cbiAgICAgICAgICAgICAgLy8gQW4gU0kgc2xpY2UgY2FuIGJlIGNvZGVkIHN1Y2ggdGhhdCBpdHMgZGVjb2RlZCBzYW1wbGVzIGNhbiBiZSBjb25zdHJ1Y3RlZCBpZGVudGljYWxseSB0byBhbiBTUCBzbGljZS5cbiAgICAgICAgICAgICAgLy8gSSBzbGljZTogQSBzbGljZSB0aGF0IGlzIG5vdCBhbiBTSSBzbGljZSB0aGF0IGlzIGRlY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5LlxuICAgICAgICAgICAgICAvL2lmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA3KSB7XG4gICAgICAgICAgICAgIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA0IHx8IHNsaWNlVHlwZSA9PT0gNyB8fCBzbGljZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy9JRFJcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBQRVMgbm90IHN0YXJ0aW5nIHdpdGggQVVEXG4gICAgICAgICAgICBpZiAoIWF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICBhdmNTYW1wbGUgPSBfdGhpczMuYXZjU2FtcGxlID0gX3RoaXMzLl9jcmVhdGVBVkNTYW1wbGUodHJ1ZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnSURSICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvL1NFSVxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1NFSSAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBfZXhwR29sb21iMi5kZWZhdWx0KF90aGlzMy5kaXNjYXJkRVBCKHVuaXQuZGF0YSkpO1xuXG4gICAgICAgICAgICAvLyBza2lwIGZyYW1lVHlwZVxuICAgICAgICAgICAgZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICAgICAgdmFyIHBheWxvYWRUeXBlID0gMDtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkU2l6ZSA9IDA7XG4gICAgICAgICAgICB2YXIgZW5kT2ZDYXB0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGIgPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSAoIWVuZE9mQ2FwdGlvbnMgJiYgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSA+IDEpIHtcbiAgICAgICAgICAgICAgcGF5bG9hZFR5cGUgPSAwO1xuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgYiA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFR5cGUgKz0gYjtcbiAgICAgICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XG5cbiAgICAgICAgICAgICAgLy8gUGFyc2UgcGF5bG9hZCBzaXplLlxuICAgICAgICAgICAgICBwYXlsb2FkU2l6ZSA9IDA7XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBiID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSBiO1xuICAgICAgICAgICAgICB9IHdoaWxlIChiID09PSAweEZGKTtcblxuICAgICAgICAgICAgICAvLyBUT0RPOiB0aGVyZSBjYW4gYmUgbW9yZSB0aGFuIG9uZSBwYXlsb2FkIGluIGFuIFNFSSBwYWNrZXQuLi5cbiAgICAgICAgICAgICAgLy8gVE9ETzogbmVlZCB0byByZWFkIHR5cGUgYW5kIHNpemUgaW4gYSB3aGlsZSBsb29wIHRvIGdldCB0aGVtIGFsbFxuICAgICAgICAgICAgICBpZiAocGF5bG9hZFR5cGUgPT09IDQgJiYgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSAhPT0gMCkge1xuXG4gICAgICAgICAgICAgICAgZW5kT2ZDYXB0aW9ucyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgY291bnRyeUNvZGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50cnlDb2RlID09PSAxODEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm92aWRlckNvZGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVU2hvcnQoKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyQ29kZSA9PT0gNDkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJTdHJ1Y3R1cmUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVSW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlckRhdGFUeXBlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIFJhdyBDRUEtNjA4IGJ5dGVzIHdyYXBwZWQgaW4gQ0VBLTcwOCBwYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlckRhdGFUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRCeXRlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsQ0NzID0gMzEgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZUFycmF5ID0gW2ZpcnN0Qnl0ZSwgc2Vjb25kQnl0ZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENDczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMgYnl0ZXMgcGVyIENDXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMy5faW5zZXJ0U2FtcGxlSW5PcmRlcihfdGhpczMuX3R4dFRyYWNrLnNhbXBsZXMsIHsgdHlwZTogMywgcHRzOiBwZXMucHRzLCBieXRlczogYnl0ZUFycmF5IH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkU2l6ZSA8IGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF5bG9hZFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vU1BTXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU1BTICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRyYWNrLnNwcykge1xuICAgICAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyID0gbmV3IF9leHBHb2xvbWIyLmRlZmF1bHQodW5pdC5kYXRhKTtcbiAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFNQUygpO1xuICAgICAgICAgICAgICB0cmFjay53aWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICAgICAgICAgICAgdHJhY2suaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcbiAgICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgICB0cmFjay5zcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICAgICAgdHJhY2suZHVyYXRpb24gPSBfdGhpczMuX2R1cmF0aW9uO1xuICAgICAgICAgICAgICB2YXIgY29kZWNhcnJheSA9IHVuaXQuZGF0YS5zdWJhcnJheSgxLCA0KTtcbiAgICAgICAgICAgICAgdmFyIGNvZGVjc3RyaW5nID0gJ2F2YzEuJztcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBoID0gY29kZWNhcnJheVtpXS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGVjc3RyaW5nICs9IGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJhY2suY29kZWMgPSBjb2RlY3N0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vUFBTXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnUFBTICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRyYWNrLnBwcykge1xuICAgICAgICAgICAgICB0cmFjay5wcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIEFVRFxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLnB1c2hBY2Nlc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdmNTYW1wbGUgPSBfdGhpczMuYXZjU2FtcGxlID0gX3RoaXMzLl9jcmVhdGVBVkNTYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMsIGRlYnVnID8gJ0FVRCAnIDogJycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gRmlsbGVyIERhdGFcbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICd1bmtub3duIE5BTCAnICsgdW5pdC50eXBlICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF2Y1NhbXBsZSAmJiBwdXNoKSB7XG4gICAgICAgICAgdmFyIF91bml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgICAgICAgICBfdW5pdHMudW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBpZiBsYXN0IFBFUyBwYWNrZXQsIHB1c2ggc2FtcGxlc1xuICAgICAgaWYgKGxhc3QgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgIHRoaXMucHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19jcmVhdGVBVkNTYW1wbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQVZDU2FtcGxlKGtleSwgcHRzLCBkdHMsIGRlYnVnKSB7XG4gICAgICByZXR1cm4geyBrZXk6IGtleSwgcHRzOiBwdHMsIGR0czogZHRzLCB1bml0czogeyB1bml0czogW10sIGxlbmd0aDogMCB9LCBkZWJ1ZzogZGVidWcgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfaW5zZXJ0U2FtcGxlSW5PcmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnNlcnRTYW1wbGVJbk9yZGVyKGFyciwgZGF0YSkge1xuICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICBpZiAoZGF0YS5wdHMgPj0gYXJyW2xlbiAtIDFdLnB0cykge1xuICAgICAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIHBvcyA9IGxlbiAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICAgICAgaWYgKGRhdGEucHRzIDwgYXJyW3Bvc10ucHRzKSB7XG4gICAgICAgICAgICAgIGFyci5zcGxpY2UocG9zLCAwLCBkYXRhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnIucHVzaChkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0TGFzdE5hbFVuaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TGFzdE5hbFVuaXQoKSB7XG4gICAgICB2YXIgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUsXG4gICAgICAgICAgbGFzdFVuaXQgPSB2b2lkIDA7XG4gICAgICAvLyB0cnkgdG8gZmFsbGJhY2sgdG8gcHJldmlvdXMgc2FtcGxlIGlmIGN1cnJlbnQgb25lIGlzIGVtcHR5XG4gICAgICBpZiAoIWF2Y1NhbXBsZSB8fCBhdmNTYW1wbGUudW5pdHMudW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLFxuICAgICAgICAgICAgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgICAgIGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgICAgdmFyIHVuaXRzID0gYXZjU2FtcGxlLnVuaXRzLnVuaXRzO1xuICAgICAgICBsYXN0VW5pdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RVbml0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19wYXJzZUFWQ05BTHUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VBVkNOQUx1KGFycmF5KSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgbGVuID0gYXJyYXkuYnl0ZUxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBvdmVyZmxvdyxcbiAgICAgICAgICB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLFxuICAgICAgICAgIHN0YXRlID0gdHJhY2submFsdVN0YXRlIHx8IDAsXG4gICAgICAgICAgbGFzdFN0YXRlID0gc3RhdGU7XG4gICAgICB2YXIgdW5pdHMgPSBbXSxcbiAgICAgICAgICB1bml0LFxuICAgICAgICAgIHVuaXRUeXBlLFxuICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSAtMSxcbiAgICAgICAgICBsYXN0VW5pdFR5cGU7XG4gICAgICAvL2xvZ2dlci5sb2coJ1BFUzonICsgSGV4LmhleER1bXAoYXJyYXkpKTtcblxuICAgICAgaWYgKHN0YXRlID09PSAtMSkge1xuICAgICAgICAvLyBzcGVjaWFsIHVzZSBjYXNlIHdoZXJlIHdlIGZvdW5kIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBwcmV2aW91cyBQRVMgcGFja2V0XG4gICAgICAgIGxhc3RVbml0U3RhcnQgPSAwO1xuICAgICAgICAvLyBOQUx1IHR5cGUgaXMgdmFsdWUgcmVhZCBmcm9tIG9mZnNldCAwXG4gICAgICAgIGxhc3RVbml0VHlwZSA9IGFycmF5WzBdICYgMHgxZjtcbiAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICBpID0gMTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgdmFsdWUgPSBhcnJheVtpKytdO1xuICAgICAgICAvLyBvcHRpbWl6YXRpb24uIHN0YXRlIDAgYW5kIDEgYXJlIHRoZSBwcmVkb21pbmFudCBjYXNlLiBsZXQncyBoYW5kbGUgdGhlbSBvdXRzaWRlIG9mIHRoZSBzd2l0Y2gvY2FzZVxuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gMSkge1xuICAgICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoZXJlIHdlIGhhdmUgc3RhdGUgZWl0aGVyIGVxdWFsIHRvIDIgb3IgM1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgc3RhdGUgPSAzO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgdW5pdCA9IHsgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgaSAtIHN0YXRlIC0gMSksIHR5cGU6IGxhc3RVbml0VHlwZSB9O1xuICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbGFzdFVuaXRTdGFydCBpcyB1bmRlZmluZWQgPT4gdGhpcyBpcyB0aGUgZmlyc3Qgc3RhcnQgY29kZSBmb3VuZCBpbiB0aGlzIFBFUyBwYWNrZXRcbiAgICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGlmIHN0YXJ0IGNvZGUgZGVsaW1pdGVyIGlzIG92ZXJsYXBwaW5nIGJldHdlZW4gMiBQRVMgcGFja2V0cyxcbiAgICAgICAgICAgIC8vIGllIGl0IHN0YXJ0ZWQgaW4gbGFzdCBwYWNrZXQgKGxhc3RTdGF0ZSBub3QgemVybylcbiAgICAgICAgICAgIC8vIGFuZCBlbmRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgUEVTIHBhY2tldCAoaSA8PSA0IC0gbGFzdFN0YXRlKVxuICAgICAgICAgICAgdmFyIGxhc3RVbml0ID0gdGhpcy5fZ2V0TGFzdE5hbFVuaXQoKTtcbiAgICAgICAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICAgICAgICBpZiAobGFzdFN0YXRlICYmIGkgPD0gNCAtIGxhc3RTdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbGFzdFVuaXQgaGFkIGEgc3RhdGUgZGlmZmVyZW50IGZyb20gemVyb1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VW5pdC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlc1xuICAgICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IGxhc3RVbml0LmRhdGEuc3ViYXJyYXkoMCwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoIC0gbGFzdFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gSWYgTkFMIHVuaXRzIGFyZSBub3Qgc3RhcnRpbmcgcmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBhY2tldCwgcHVzaCBwcmVjZWRpbmcgZGF0YSBpbnRvIHByZXZpb3VzIE5BTCB1bml0LlxuICAgICAgICAgICAgICBvdmVyZmxvdyA9IGkgLSBzdGF0ZSAtIDE7XG4gICAgICAgICAgICAgIGlmIChvdmVyZmxvdyA+IDApIHtcbiAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coJ2ZpcnN0IE5BTFUgZm91bmQgd2l0aCBvdmVyZmxvdzonICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgICAgdG1wLnNldChsYXN0VW5pdC5kYXRhLCAwKTtcbiAgICAgICAgICAgICAgICB0bXAuc2V0KGFycmF5LnN1YmFycmF5KDAsIG92ZXJmbG93KSwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gdG1wO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiByZWFkIHVuaXQgdHlwZVxuICAgICAgICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICAgICAgICB1bml0VHlwZSA9IGFycmF5W2ldICYgMHgxZjtcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnZmluZCBOQUxVIEAgb2Zmc2V0OicgKyBpICsgJyx0eXBlOicgKyB1bml0VHlwZSk7XG4gICAgICAgICAgICBsYXN0VW5pdFN0YXJ0ID0gaTtcbiAgICAgICAgICAgIGxhc3RVbml0VHlwZSA9IHVuaXRUeXBlO1xuICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBub3QgZW5vdWdoIGJ5dGUgdG8gcmVhZCB1bml0IHR5cGUuIGxldCdzIHJlYWQgaXQgb24gbmV4dCBQRVMgcGFyc2luZ1xuICAgICAgICAgICAgc3RhdGUgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwICYmIHN0YXRlID49IDApIHtcbiAgICAgICAgdW5pdCA9IHsgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgbGVuKSwgdHlwZTogbGFzdFVuaXRUeXBlLCBzdGF0ZTogc3RhdGUgfTtcbiAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgLy9sb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZS9zdGF0ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGggKyAnLycgKyBzdGF0ZSk7XG4gICAgICB9XG4gICAgICAvLyBubyBOQUx1IGZvdW5kXG4gICAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIGFwcGVuZCBwZXMuZGF0YSB0byBwcmV2aW91cyBOQUwgdW5pdFxuICAgICAgICB2YXIgX2xhc3RVbml0ID0gdGhpcy5fZ2V0TGFzdE5hbFVuaXQoKTtcbiAgICAgICAgaWYgKF9sYXN0VW5pdCkge1xuICAgICAgICAgIHZhciBfdG1wID0gbmV3IFVpbnQ4QXJyYXkoX2xhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIGFycmF5LmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIF90bXAuc2V0KF9sYXN0VW5pdC5kYXRhLCAwKTtcbiAgICAgICAgICBfdG1wLnNldChhcnJheSwgX2xhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgX2xhc3RVbml0LmRhdGEgPSBfdG1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmFjay5uYWx1U3RhdGUgPSBzdGF0ZTtcbiAgICAgIHJldHVybiB1bml0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgRW11bGF0aW9uIFByZXZlbnRpb24gYnl0ZXMgZnJvbSBhIFJCU1BcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGlzY2FyZEVQQicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2NhcmRFUEIoZGF0YSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgICAgICBFUEJQb3NpdGlvbnMgPSBbXSxcbiAgICAgICAgICBpID0gMSxcbiAgICAgICAgICBuZXdMZW5ndGgsXG4gICAgICAgICAgbmV3RGF0YTtcblxuICAgICAgLy8gRmluZCBhbGwgYEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzYFxuICAgICAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgICAgIGlmIChkYXRhW2ldID09PSAwICYmIGRhdGFbaSArIDFdID09PSAwICYmIGRhdGFbaSArIDJdID09PSAweDAzKSB7XG4gICAgICAgICAgRVBCUG9zaXRpb25zLnB1c2goaSArIDIpO1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXMgd2VyZSBmb3VuZCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWxcbiAgICAgIC8vIGFycmF5XG4gICAgICBpZiAoRVBCUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcbiAgICAgIG5ld0xlbmd0aCA9IGxlbmd0aCAtIEVQQlBvc2l0aW9ucy5sZW5ndGg7XG4gICAgICBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgICAgIHZhciBzb3VyY2VJbmRleCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXdMZW5ndGg7IHNvdXJjZUluZGV4KyssIGkrKykge1xuICAgICAgICBpZiAoc291cmNlSW5kZXggPT09IEVQQlBvc2l0aW9uc1swXSkge1xuICAgICAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICAgICAgc291cmNlSW5kZXgrKztcbiAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuICAgICAgICAgIEVQQlBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIG5ld0RhdGFbaV0gPSBkYXRhW3NvdXJjZUluZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19wYXJzZUFBQ1BFUycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZUFBQ1BFUyhwZXMpIHtcbiAgICAgIHZhciB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICAgICAgZGF0YSA9IHBlcy5kYXRhLFxuICAgICAgICAgIHB0cyA9IHBlcy5wdHMsXG4gICAgICAgICAgc3RhcnRPZmZzZXQgPSAwLFxuICAgICAgICAgIGFhY092ZXJGbG93ID0gdGhpcy5hYWNPdmVyRmxvdyxcbiAgICAgICAgICBhYWNMYXN0UFRTID0gdGhpcy5hYWNMYXN0UFRTLFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBmcmFtZUxlbmd0aCxcbiAgICAgICAgICBmcmFtZUR1cmF0aW9uLFxuICAgICAgICAgIGZyYW1lSW5kZXgsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIGhlYWRlckxlbmd0aCxcbiAgICAgICAgICBzdGFtcCxcbiAgICAgICAgICBsZW4sXG4gICAgICAgICAgYWFjU2FtcGxlO1xuICAgICAgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShhYWNPdmVyRmxvdy5ieXRlTGVuZ3RoICsgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdG1wLnNldChhYWNPdmVyRmxvdywgMCk7XG4gICAgICAgIHRtcC5zZXQoZGF0YSwgYWFjT3ZlckZsb3cuYnl0ZUxlbmd0aCk7XG4gICAgICAgIC8vbG9nZ2VyLmxvZyhgQUFDOiBhcHBlbmQgb3ZlcmZsb3dpbmcgJHthYWNPdmVyRmxvdy5ieXRlTGVuZ3RofSBieXRlcyB0byBiZWdpbm5pbmcgb2YgbmV3IFBFU2ApO1xuICAgICAgICBkYXRhID0gdG1wO1xuICAgICAgfVxuICAgICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICAgIGZvciAob2Zmc2V0ID0gc3RhcnRPZmZzZXQsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhmMCkgPT09IDB4ZjApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgQURUUyBoZWFkZXIgZG9lcyBub3Qgc3RhcnQgc3RyYWlnaHQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGF5bG9hZCwgcmFpc2UgYW4gZXJyb3JcbiAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgdmFyIHJlYXNvbiwgZmF0YWw7XG4gICAgICAgIGlmIChvZmZzZXQgPCBsZW4gLSAxKSB7XG4gICAgICAgICAgcmVhc29uID0gJ0FBQyBQRVMgZGlkIG5vdCBzdGFydCB3aXRoIEFEVFMgaGVhZGVyLG9mZnNldDonICsgb2Zmc2V0O1xuICAgICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVhc29uID0gJ25vIEFEVFMgaGVhZGVyIGZvdW5kIGluIEFBQyBQRVMnO1xuICAgICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdwYXJzaW5nIGVycm9yOicgKyByZWFzb24pO1xuICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhdGFsLCByZWFzb246IHJlYXNvbiB9KTtcbiAgICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRyYWNrLmF1ZGlvc2FtcGxlcmF0ZSkge1xuICAgICAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMuYXVkaW9Db2RlYztcbiAgICAgICAgY29uZmlnID0gX2FkdHMyLmRlZmF1bHQuZ2V0QXVkaW9Db25maWcodGhpcy5vYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKTtcbiAgICAgICAgdHJhY2suY29uZmlnID0gY29uZmlnLmNvbmZpZztcbiAgICAgICAgdHJhY2suYXVkaW9zYW1wbGVyYXRlID0gY29uZmlnLnNhbXBsZXJhdGU7XG4gICAgICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XG4gICAgICAgIHRyYWNrLmNvZGVjID0gY29uZmlnLmNvZGVjO1xuICAgICAgICB0cmFjay5tYW5pZmVzdENvZGVjID0gY29uZmlnLm1hbmlmZXN0Q29kZWM7XG4gICAgICAgIHRyYWNrLmR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygncGFyc2VkIGNvZGVjOicgKyB0cmFjay5jb2RlYyArICcscmF0ZTonICsgY29uZmlnLnNhbXBsZXJhdGUgKyAnLG5iIGNoYW5uZWw6JyArIGNvbmZpZy5jaGFubmVsQ291bnQpO1xuICAgICAgfVxuICAgICAgZnJhbWVJbmRleCA9IDA7XG4gICAgICBmcmFtZUR1cmF0aW9uID0gMTAyNCAqIDkwMDAwIC8gdHJhY2suYXVkaW9zYW1wbGVyYXRlO1xuXG4gICAgICAvLyBpZiBsYXN0IEFBQyBmcmFtZSBpcyBvdmVyZmxvd2luZywgd2Ugc2hvdWxkIGVuc3VyZSB0aW1lc3RhbXBzIGFyZSBjb250aWd1b3VzOlxuICAgICAgLy8gZmlyc3Qgc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZnJhbWVEdXJhdGlvblxuICAgICAgaWYgKGFhY092ZXJGbG93ICYmIGFhY0xhc3RQVFMpIHtcbiAgICAgICAgdmFyIG5ld1BUUyA9IGFhY0xhc3RQVFMgKyBmcmFtZUR1cmF0aW9uO1xuICAgICAgICBpZiAoTWF0aC5hYnMobmV3UFRTIC0gcHRzKSA+IDEpIHtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ0FBQzogYWxpZ24gUFRTIGZvciBvdmVybGFwcGluZyBmcmFtZXMgYnkgJyArIE1hdGgucm91bmQoKG5ld1BUUyAtIHB0cykgLyA5MCkpO1xuICAgICAgICAgIHB0cyA9IG5ld1BUUztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAob2Zmc2V0ICsgNSA8IGxlbikge1xuICAgICAgICAvLyBUaGUgcHJvdGVjdGlvbiBza2lwIGJpdCB0ZWxscyB1cyBpZiB3ZSBoYXZlIDIgYnl0ZXMgb2YgQ1JDIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgQURUUyBoZWFkZXJcbiAgICAgICAgaGVhZGVyTGVuZ3RoID0gISEoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDEpID8gNyA6IDk7XG4gICAgICAgIC8vIHJldHJpZXZlIGZyYW1lIHNpemVcbiAgICAgICAgZnJhbWVMZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MDMpIDw8IDExIHwgZGF0YVtvZmZzZXQgKyA0XSA8PCAzIHwgKGRhdGFbb2Zmc2V0ICsgNV0gJiAweEUwKSA+Pj4gNTtcbiAgICAgICAgZnJhbWVMZW5ndGggLT0gaGVhZGVyTGVuZ3RoO1xuICAgICAgICAvL3N0YW1wID0gcGVzLnB0cztcblxuICAgICAgICBpZiAoZnJhbWVMZW5ndGggPiAwICYmIG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoIDw9IGxlbikge1xuICAgICAgICAgIHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgICAgICAgLy9sb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9LyR7KHN0YW1wLzkwKS50b0ZpeGVkKDApfWApO1xuICAgICAgICAgIGFhY1NhbXBsZSA9IHsgdW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoKSwgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcCB9O1xuICAgICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNTYW1wbGUpO1xuICAgICAgICAgIHRyYWNrLmxlbiArPSBmcmFtZUxlbmd0aDtcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWVMZW5ndGggKyBoZWFkZXJMZW5ndGg7XG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgICAgICAgZm9yICg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhmMCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICAgIGFhY092ZXJGbG93ID0gZGF0YS5zdWJhcnJheShvZmZzZXQsIGxlbik7XG4gICAgICAgIC8vbG9nZ2VyLmxvZyhgQUFDOiBvdmVyZmxvdyBkZXRlY3RlZDoke2xlbi1vZmZzZXR9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmFhY092ZXJGbG93ID0gYWFjT3ZlckZsb3c7XG4gICAgICB0aGlzLmFhY0xhc3RQVFMgPSBzdGFtcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfcGFyc2VNUEVHUEVTJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlTVBFR1BFUyhwZXMpIHtcbiAgICAgIHZhciBkYXRhID0gcGVzLmRhdGE7XG4gICAgICB2YXIgcHRzID0gcGVzLnB0cztcbiAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgdmFyIHBhcnNlZDtcblxuICAgICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCAmJiAocGFyc2VkID0gdGhpcy5fcGFyc2VNcGVnKGRhdGEsIG9mZnNldCwgbGVuZ3RoLCBmcmFtZUluZGV4KyssIHB0cykpID4gMCkge1xuICAgICAgICBvZmZzZXQgKz0gcGFyc2VkO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19vbk1wZWdGcmFtZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk1wZWdGcmFtZShkYXRhLCBiaXRSYXRlLCBzYW1wbGVSYXRlLCBjaGFubmVsQ291bnQsIGZyYW1lSW5kZXgsIHB0cykge1xuICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSAxMTUyIC8gc2FtcGxlUmF0ZSAqIDEwMDA7XG4gICAgICB2YXIgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICAgIHZhciB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG5cbiAgICAgIHRyYWNrLmNvbmZpZyA9IFtdO1xuICAgICAgdHJhY2suY2hhbm5lbENvdW50ID0gY2hhbm5lbENvdW50O1xuICAgICAgdHJhY2suYXVkaW9zYW1wbGVyYXRlID0gc2FtcGxlUmF0ZTtcbiAgICAgIHRyYWNrLmR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgICB0cmFjay5zYW1wbGVzLnB1c2goeyB1bml0OiBkYXRhLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wIH0pO1xuICAgICAgdHJhY2subGVuICs9IGRhdGEubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19vbk1wZWdOb2lzZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk1wZWdOb2lzZShkYXRhKSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdtcGVnIGF1ZGlvIGhhcyBub2lzZTogJyArIGRhdGEubGVuZ3RoICsgJyBieXRlcycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19wYXJzZU1wZWcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VNcGVnKGRhdGEsIHN0YXJ0LCBlbmQsIGZyYW1lSW5kZXgsIHB0cykge1xuICAgICAgdmFyIEJpdHJhdGVzTWFwID0gWzMyLCA2NCwgOTYsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAyODgsIDMyMCwgMzUyLCAzODQsIDQxNiwgNDQ4LCAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDM4NCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwLCAxNzYsIDE5MiwgMjI0LCAyNTYsIDgsIDE2LCAyNCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MF07XG4gICAgICB2YXIgU2FtcGxpbmdSYXRlTWFwID0gWzQ0MTAwLCA0ODAwMCwgMzIwMDAsIDIyMDUwLCAyNDAwMCwgMTYwMDAsIDExMDI1LCAxMjAwMCwgODAwMF07XG5cbiAgICAgIGlmIChzdGFydCArIDIgPiBlbmQpIHtcbiAgICAgICAgcmV0dXJuIC0xOyAvLyB3ZSBuZWVkIGF0IGxlYXN0IDIgYnl0ZXMgdG8gZGV0ZWN0IHN5bmMgcGF0dGVyblxuICAgICAgfVxuICAgICAgaWYgKGRhdGFbc3RhcnRdID09PSAweEZGIHx8IChkYXRhW3N0YXJ0ICsgMV0gJiAweEUwKSA9PT0gMHhFMCkge1xuICAgICAgICAvLyBVc2luZyBodHRwOi8vd3d3LmRhdGF2b3lhZ2UuY29tL21wZ3NjcmlwdC9tcGVnaGRyLmh0bSBhcyBhIHJlZmVyZW5jZVxuICAgICAgICBpZiAoc3RhcnQgKyAyNCA+IGVuZCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVyQiA9IGRhdGFbc3RhcnQgKyAxXSA+PiAzICYgMztcbiAgICAgICAgdmFyIGhlYWRlckMgPSBkYXRhW3N0YXJ0ICsgMV0gPj4gMSAmIDM7XG4gICAgICAgIHZhciBoZWFkZXJFID0gZGF0YVtzdGFydCArIDJdID4+IDQgJiAxNTtcbiAgICAgICAgdmFyIGhlYWRlckYgPSBkYXRhW3N0YXJ0ICsgMl0gPj4gMiAmIDM7XG4gICAgICAgIHZhciBoZWFkZXJHID0gISEoZGF0YVtzdGFydCArIDJdICYgMik7XG4gICAgICAgIGlmIChoZWFkZXJCICE9PSAxICYmIGhlYWRlckUgIT09IDAgJiYgaGVhZGVyRSAhPT0gMTUgJiYgaGVhZGVyRiAhPT0gMykge1xuICAgICAgICAgIHZhciBjb2x1bW5JbkJpdHJhdGVzID0gaGVhZGVyQiA9PT0gMyA/IDMgLSBoZWFkZXJDIDogaGVhZGVyQyA9PT0gMyA/IDMgOiA0O1xuICAgICAgICAgIHZhciBiaXRSYXRlID0gQml0cmF0ZXNNYXBbY29sdW1uSW5CaXRyYXRlcyAqIDE0ICsgaGVhZGVyRSAtIDFdICogMTAwMDtcbiAgICAgICAgICB2YXIgY29sdW1uSW5TYW1wbGVSYXRlcyA9IGhlYWRlckIgPT09IDMgPyAwIDogaGVhZGVyQiA9PT0gMiA/IDEgOiAyO1xuICAgICAgICAgIHZhciBzYW1wbGVSYXRlID0gU2FtcGxpbmdSYXRlTWFwW2NvbHVtbkluU2FtcGxlUmF0ZXMgKiAzICsgaGVhZGVyRl07XG4gICAgICAgICAgdmFyIHBhZGRpbmcgPSBoZWFkZXJHID8gMSA6IDA7XG4gICAgICAgICAgdmFyIGNoYW5uZWxDb3VudCA9IGRhdGFbc3RhcnQgKyAzXSA+PiA2ID09PSAzID8gMSA6IDI7IC8vIElmIGJpdHMgb2YgY2hhbm5lbCBtb2RlIGFyZSBgMTFgIHRoZW4gaXQgaXMgYSBzaW5nbGUgY2hhbm5lbCAoTW9ubylcbiAgICAgICAgICB2YXIgZnJhbWVMZW5ndGggPSBoZWFkZXJDID09PSAzID8gKGhlYWRlckIgPT09IDMgPyAxMiA6IDYpICogYml0UmF0ZSAvIHNhbXBsZVJhdGUgKyBwYWRkaW5nIDw8IDIgOiAoaGVhZGVyQiA9PT0gMyA/IDE0NCA6IDcyKSAqIGJpdFJhdGUgLyBzYW1wbGVSYXRlICsgcGFkZGluZyB8IDA7XG4gICAgICAgICAgaWYgKHN0YXJ0ICsgZnJhbWVMZW5ndGggPiBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX29uTXBlZ0ZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9vbk1wZWdGcmFtZShkYXRhLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGZyYW1lTGVuZ3RoKSwgYml0UmF0ZSwgc2FtcGxlUmF0ZSwgY2hhbm5lbENvdW50LCBmcmFtZUluZGV4LCBwdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnJhbWVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG5vaXNlIG9yIElEMywgdHJ5aW5nIHRvIHNraXBcbiAgICAgIHZhciBvZmZzZXQgPSBzdGFydCArIDI7XG4gICAgICB3aGlsZSAob2Zmc2V0IDwgZW5kKSB7XG4gICAgICAgIGlmIChkYXRhW29mZnNldCAtIDFdID09PSAweEZGICYmIChkYXRhW29mZnNldF0gJiAweEUwKSA9PT0gMHhFMCkge1xuICAgICAgICAgIC8vIHN5bmMgcGF0dGVybiBpcyBmb3VuZFxuICAgICAgICAgIGlmICh0aGlzLl9vbk1wZWdOb2lzZSkge1xuICAgICAgICAgICAgdGhpcy5fb25NcGVnTm9pc2UoZGF0YS5zdWJhcnJheShzdGFydCwgb2Zmc2V0IC0gMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19wYXJzZUlEM1BFUycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZUlEM1BFUyhwZXMpIHtcbiAgICAgIHRoaXMuX2lkM1RyYWNrLnNhbXBsZXMucHVzaChwZXMpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAncHJvYmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9iZShkYXRhKSB7XG4gICAgICAvLyBhIFRTIGZyYWdtZW50IHNob3VsZCBjb250YWluIGF0IGxlYXN0IDMgVFMgcGFja2V0cywgYSBQQVQsIGEgUE1ULCBhbmQgb25lIFBJRCwgZWFjaCBzdGFydGluZyB3aXRoIDB4NDdcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA+PSAzICogMTg4ICYmIGRhdGFbMF0gPT09IDB4NDcgJiYgZGF0YVsxODhdID09PSAweDQ3ICYmIGRhdGFbMiAqIDE4OF0gPT09IDB4NDcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRTRGVtdXhlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVFNEZW11eGVyO1xuXG59LHtcIjIyXCI6MjIsXCIyNlwiOjI2LFwiMjlcIjoyOSxcIjMxXCI6MzEsXCIzM1wiOjMzLFwiNTBcIjo1MH1dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBFcnJvclR5cGVzID0gZXhwb3J0cy5FcnJvclR5cGVzID0ge1xuICAvLyBJZGVudGlmaWVyIGZvciBhIG5ldHdvcmsgZXJyb3IgKGxvYWRpbmcgZXJyb3IgLyB0aW1lb3V0IC4uLilcbiAgTkVUV09SS19FUlJPUjogJ25ldHdvcmtFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWVkaWEgRXJyb3IgKHZpZGVvL3BhcnNpbmcvbWVkaWFzb3VyY2UgZXJyb3IpXG4gIE1FRElBX0VSUk9SOiAnbWVkaWFFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbXV4IEVycm9yIChkZW11eGluZy9yZW11eGluZylcbiAgTVVYX0VSUk9SOiAnbXV4RXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbGwgb3RoZXIgZXJyb3JzXG4gIE9USEVSX0VSUk9SOiAnb3RoZXJFcnJvcidcbn07XG5cbnZhciBFcnJvckRldGFpbHMgPSBleHBvcnRzLkVycm9yRGV0YWlscyA9IHtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBNQU5JRkVTVF9MT0FEX0VSUk9SOiAnbWFuaWZlc3RMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTUFOSUZFU1RfTE9BRF9USU1FT1VUOiAnbWFuaWZlc3RMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgcGFyc2luZyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICBNQU5JRkVTVF9QQVJTSU5HX0VSUk9SOiAnbWFuaWZlc3RQYXJzaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IHdpdGggb25seSBpbmNvbXBhdGlibGUgY29kZWNzIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb259XG4gIE1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1I6ICdtYW5pZmVzdEluY29tcGF0aWJsZUNvZGVjc0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBMRVZFTF9MT0FEX0VSUk9SOiAnbGV2ZWxMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTEVWRUxfTE9BRF9USU1FT1VUOiAnbGV2ZWxMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgc3dpdGNoIGVycm9yIC0gZGF0YTogeyBsZXZlbCA6IGZhdWx0eSBsZXZlbCBJZCwgZXZlbnQgOiBlcnJvciBkZXNjcmlwdGlvbn1cbiAgTEVWRUxfU1dJVENIX0VSUk9SOiAnbGV2ZWxTd2l0Y2hFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGF1ZGlvIHRyYWNrIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEFVRElPX1RSQUNLX0xPQURfRVJST1I6ICdhdWRpb1RyYWNrTG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gYXVkaW8gdHJhY2sgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBBVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6ICdhdWRpb1RyYWNrTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBGUkFHX0xPQURfRVJST1I6ICdmcmFnTG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9vcCBsb2FkaW5nIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBGUkFHX0xPT1BfTE9BRElOR19FUlJPUjogJ2ZyYWdMb29wTG9hZGluZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCB0aW1lb3V0IGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBGUkFHX0xPQURfVElNRU9VVDogJ2ZyYWdMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgZGVjcnlwdGlvbiBlcnJvciBldmVudCAtIGRhdGE6IHtpZCA6IGRlbXV4ZXIgSWQsZnJhZzogZnJhZ21lbnQgb2JqZWN0LCByZWFzb24gOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uIH1cbiAgRlJBR19ERUNSWVBUX0VSUk9SOiAnZnJhZ0RlY3J5cHRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgcGFyc2luZyBlcnJvciBldmVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIElkLCByZWFzb24gOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uIH1cbiAgLy8gd2lsbCBiZSByZW5hbWVkIERFTVVYX1BBUlNJTkdfRVJST1IgYW5kIHN3aXRjaGVkIHRvIE1VWF9FUlJPUiBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG4gIEZSQUdfUEFSU0lOR19FUlJPUjogJ2ZyYWdQYXJzaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIHJlbXV4IGFsbG9jIGVycm9yIGV2ZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgSWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIGJ5dGVzIDogbmIgb2YgYnl0ZXMgb24gd2hpY2ggYWxsb2NhdGlvbiBmYWlsZWQgLCByZWFzb24gOiBlcnJvciB0ZXh0IH1cbiAgUkVNVVhfQUxMT0NfRVJST1I6ICdyZW11eEFsbG9jRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBLRVlfTE9BRF9FUlJPUjogJ2tleUxvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgS0VZX0xPQURfVElNRU9VVDogJ2tleUxvYWRUaW1lT3V0JyxcbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gZXhjZXB0aW9uIG9jY3VycyB3aGlsZSBhZGRpbmcgYSBzb3VyY2VCdWZmZXIgdG8gTWVkaWFTb3VyY2UgLSBkYXRhIDogeyAgZXJyIDogZXhjZXB0aW9uICwgbWltZVR5cGUgOiBtaW1lVHlwZSB9XG4gIEJVRkZFUl9BRERfQ09ERUNfRVJST1I6ICdidWZmZXJBZGRDb2RlY0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgYXBwZW5kIGVycm9yIC0gZGF0YTogYXBwZW5kIGVycm9yIGRlc2NyaXB0aW9uXG4gIEJVRkZFUl9BUFBFTkRfRVJST1I6ICdidWZmZXJBcHBlbmRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZGluZyBlcnJvciBldmVudCAtIGRhdGE6IGFwcGVuZGluZyBlcnJvciBkZXNjcmlwdGlvblxuICBCVUZGRVJfQVBQRU5ESU5HX0VSUk9SOiAnYnVmZmVyQXBwZW5kaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzdGFsbGVkIGVycm9yIGV2ZW50XG4gIEJVRkZFUl9TVEFMTEVEX0VSUk9SOiAnYnVmZmVyU3RhbGxlZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgZnVsbCBldmVudFxuICBCVUZGRVJfRlVMTF9FUlJPUjogJ2J1ZmZlckZ1bGxFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHNlZWsgb3ZlciBob2xlIGV2ZW50XG4gIEJVRkZFUl9TRUVLX09WRVJfSE9MRTogJ2J1ZmZlclNlZWtPdmVySG9sZScsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIG51ZGdlIG9uIHN0YWxsIChwbGF5YmFjayBpcyBzdHVjayBhbHRob3VnaCBjdXJyZW50VGltZSBpcyBpbiBhIGJ1ZmZlcmVkIGFyZWEpXG4gIEJVRkZFUl9OVURHRV9PTl9TVEFMTDogJ2J1ZmZlck51ZGdlT25TdGFsbCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGludGVybmFsIGV4Y2VwdGlvbiBoYXBwZW5pbmcgaW5zaWRlIGhscy5qcyB3aGlsZSBoYW5kbGluZyBhbiBldmVudFxuICBJTlRFUk5BTF9FWENFUFRJT046ICdpbnRlcm5hbEV4Y2VwdGlvbicsXG4gIC8vIE1hbGZvcm1lZCBXZWJWVFQgY29udGVudHNcbiAgV0VCVlRUX0VYQ0VQVElPTjogJ3dlYlZUVEV4Y2VwdGlvbidcbn07XG5cbn0se31dLDMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpOyAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFsbCBvYmplY3RzIGluIHRoZSBldmVudCBoYW5kbGluZyBjaGFpbiBzaG91bGQgaW5oZXJpdCBmcm9tIHRoaXMgY2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxudmFyIF9lcnJvcnMgPSBfZGVyZXFfKDMxKTtcblxudmFyIF9ldmVudHMgPSBfZGVyZXFfKDMzKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyKGhscykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudEhhbmRsZXIpO1xuXG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5vbkV2ZW50ID0gdGhpcy5vbkV2ZW50LmJpbmQodGhpcyk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZXZlbnRzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgZXZlbnRzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZWRFdmVudHMgPSBldmVudHM7XG4gICAgdGhpcy51c2VHZW5lcmljSGFuZGxlciA9IHRydWU7XG5cbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXZlbnRIYW5kbGVyLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNFdmVudEhhbmRsZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0V2ZW50SGFuZGxlcigpIHtcbiAgICAgIHJldHVybiBfdHlwZW9mKHRoaXMuaGFuZGxlZEV2ZW50cykgPT09ICdvYmplY3QnICYmIHRoaXMuaGFuZGxlZEV2ZW50cy5sZW5ndGggJiYgdHlwZW9mIHRoaXMub25FdmVudCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWdpc3Rlckxpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgaWYgKHRoaXMuaXNFdmVudEhhbmRsZXIoKSkge1xuICAgICAgICB0aGlzLmhhbmRsZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQgPT09ICdobHNFdmVudEdlbmVyaWMnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvcmJpZGRlbiBldmVudCBuYW1lOiAnICsgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhscy5vbihldmVudCwgdGhpcy5vbkV2ZW50KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bnJlZ2lzdGVyTGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIGlmICh0aGlzLmlzRXZlbnRIYW5kbGVyKCkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5obHMub2ZmKGV2ZW50LCB0aGlzLm9uRXZlbnQpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFyZ3VtZW50czogZXZlbnQgKHN0cmluZyksIGRhdGEgKGFueSlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25FdmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMub25FdmVudEdlbmVyaWMoZXZlbnQsIGRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRXZlbnRHZW5lcmljJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25FdmVudEdlbmVyaWMoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBldmVudFRvRnVuY3Rpb24gPSBmdW5jdGlvbiBldmVudFRvRnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgdmFyIGZ1bmNOYW1lID0gJ29uJyArIGV2ZW50LnJlcGxhY2UoJ2hscycsICcnKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2Z1bmNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnQgJyArIGV2ZW50ICsgJyBoYXMgbm8gZ2VuZXJpYyBoYW5kbGVyIGluIHRoaXMgJyArIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgY2xhc3MgKHRyaWVkICcgKyBmdW5jTmFtZSArICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbZnVuY05hbWVdLmJpbmQodGhpcywgZGF0YSk7XG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXZlbnRUb0Z1bmN0aW9uLmNhbGwodGhpcywgZXZlbnQsIGRhdGEpLmNhbGwoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5lcnJvcignaW50ZXJuYWwgZXJyb3IgaGFwcGVuZWQgd2hpbGUgcHJvY2Vzc2luZyAnICsgZXZlbnQgKyAnOicgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuT1RIRVJfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTiwgZmF0YWw6IGZhbHNlLCBldmVudDogZXZlbnQsIGVycjogZXJyIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudEhhbmRsZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50SGFuZGxlcjtcblxufSx7XCIzMVwiOjMxLFwiMzNcIjozMyxcIjUwXCI6NTB9XSwzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBmaXJlZCBiZWZvcmUgTWVkaWFTb3VyY2UgaXMgYXR0YWNoaW5nIHRvIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IG1lZGlhIH1cbiAgTUVESUFfQVRUQUNISU5HOiAnaGxzTWVkaWFBdHRhY2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIHN1Y2Nlc2Z1bGx5IGF0dGFjaGVkIHRvIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IH1cbiAgTUVESUFfQVRUQUNIRUQ6ICdobHNNZWRpYUF0dGFjaGVkJyxcbiAgLy8gZmlyZWQgYmVmb3JlIGRldGFjaGluZyBNZWRpYVNvdXJjZSBmcm9tIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IH1cbiAgTUVESUFfREVUQUNISU5HOiAnaGxzTWVkaWFEZXRhY2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIGRldGFjaGVkIGZyb20gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxuICBNRURJQV9ERVRBQ0hFRDogJ2hsc01lZGlhRGV0YWNoZWQnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGJ1ZmZlciBpcyBnb2luZyB0byBiZSByZXNldHRlZFxuICBCVUZGRVJfUkVTRVQ6ICdobHNCdWZmZXJSZXNldCcsXG4gIC8vIGZpcmVkIHdoZW4gd2Uga25vdyBhYm91dCB0aGUgY29kZWNzIHRoYXQgd2UgbmVlZCBidWZmZXJzIGZvciB0byBwdXNoIGludG8gLSBkYXRhOiB7dHJhY2tzIDogeyBjb250YWluZXIsIGNvZGVjLCBsZXZlbENvZGVjLCBpbml0U2VnbWVudCwgbWV0YWRhdGEgfX1cbiAgQlVGRkVSX0NPREVDUzogJ2hsc0J1ZmZlckNvZGVjcycsXG4gIC8vIGZpcmVkIHdoZW4gc291cmNlYnVmZmVycyBoYXZlIGJlZW4gY3JlYXRlZCBkYXRhOiB7IHRyYWNrcyA6IHRyYWNrc31cbiAgQlVGRkVSX0NSRUFURUQ6ICdobHNCdWZmZXJDcmVhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBhcHBlbmQgYSBzZWdtZW50IHRvIHRoZSBidWZmZXIgLSBkYXRhOiB7IHNlZ21lbnQ6IHNlZ21lbnQgb2JqZWN0IH1cbiAgQlVGRkVSX0FQUEVORElORzogJ2hsc0J1ZmZlckFwcGVuZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gd2UgYXJlIGRvbmUgd2l0aCBhcHBlbmRpbmcgYSBtZWRpYSBzZWdtZW50IHRvIHRoZSBidWZmZXIgZGF0YSA6IHsgcGFyZW50IDogc2VnbWVudCBwYXJlbnQgdGhhdCB0cmlnZ2VyZWQgQlVGRkVSX0FQUEVORElORyAsIHBlbmRpbmcgOiBuYiBvZiBzZWdtZW50cyB3YWl0aW5nIGZvciBhcHBlbmRpbmcgZm9yIHRoaXMgc2VnbWVudCBwYXJlbnR9XG4gIEJVRkZFUl9BUFBFTkRFRDogJ2hsc0J1ZmZlckFwcGVuZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIGFuZCB3ZSB3YW50IHRvIG5vdGlmeSB0aGUgbWVkaWEgYnVmZmVyIHRoYXQgdGhlcmUgd2lsbCBiZSBubyBtb3JlIGRhdGFcbiAgQlVGRkVSX0VPUzogJ2hsc0J1ZmZlckVvcycsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGJ1ZmZlciBzaG91bGQgYmUgZmx1c2hlZCAtIGRhdGEge3N0YXJ0T2Zmc2V0LCBlbmRPZmZzZXR9XG4gIEJVRkZFUl9GTFVTSElORzogJ2hsc0J1ZmZlckZsdXNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgbWVkaWEgaGFzIGJlZW4gZmx1c2hlZFxuICBCVUZGRVJfRkxVU0hFRDogJ2hsc0J1ZmZlckZsdXNoZWQnLFxuICAvLyBmaXJlZCB0byBzaWduYWwgdGhhdCBhIG1hbmlmZXN0IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBtYW5pZmVzdFVSTH1cbiAgTUFOSUZFU1RfTE9BRElORzogJ2hsc01hbmlmZXN0TG9hZGluZycsXG4gIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10gLCBhdWRpb1RyYWNrcyA6IFsgYXZhaWxhYmxlIGF1ZGlvIHRyYWNrc10sIHVybCA6IG1hbmlmZXN0VVJMLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfX1cbiAgTUFOSUZFU1RfTE9BREVEOiAnaGxzTWFuaWZlc3RMb2FkZWQnLFxuICAvLyBmaXJlZCBhZnRlciBtYW5pZmVzdCBoYXMgYmVlbiBwYXJzZWQgLSBkYXRhOiB7IGxldmVscyA6IFthdmFpbGFibGUgcXVhbGl0eSBsZXZlbHNdICwgZmlyc3RMZXZlbCA6IGluZGV4IG9mIGZpcnN0IHF1YWxpdHkgbGV2ZWwgYXBwZWFyaW5nIGluIE1hbmlmZXN0fVxuICBNQU5JRkVTVF9QQVJTRUQ6ICdobHNNYW5pZmVzdFBhcnNlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBzd2l0Y2ggaXMgcmVxdWVzdGVkIC0gZGF0YTogeyBsZXZlbCA6IGlkIG9mIG5ldyBsZXZlbCB9IC8vIGRlcHJlY2F0ZWQgaW4gZmF2b3IgTEVWRUxfU1dJVENISU5HXG4gIExFVkVMX1NXSVRDSDogJ2hsc0xldmVsU3dpdGNoJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cbiAgTEVWRUxfU1dJVENISU5HOiAnaGxzTGV2ZWxTd2l0Y2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIGVmZmVjdGl2ZSAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfVxuICBMRVZFTF9TV0lUQ0hFRDogJ2hsc0xldmVsU3dpdGNoZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IGxldmVsIFVSTCAgbGV2ZWwgOiBpZCBvZiBsZXZlbCBiZWluZyBsb2FkZWR9XG4gIExFVkVMX0xPQURJTkc6ICdobHNMZXZlbExvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgbG9hZGVkIGxldmVsLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfSB9XG4gIExFVkVMX0xPQURFRDogJ2hsc0xldmVsTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsJ3MgZGV0YWlscyBoYXZlIGJlZW4gdXBkYXRlZCBiYXNlZCBvbiBwcmV2aW91cyBkZXRhaWxzLCBhZnRlciBpdCBoYXMgYmVlbiBsb2FkZWQuIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiB1cGRhdGVkIGxldmVsIH1cbiAgTEVWRUxfVVBEQVRFRDogJ2hsc0xldmVsVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIFBUUyBpbmZvcm1hdGlvbiBoYXMgYmVlbiB1cGRhdGVkIGFmdGVyIHBhcnNpbmcgYSBmcmFnbWVudCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCwgZHJpZnQ6IFBUUyBkcmlmdCBvYnNlcnZlZCB3aGVuIHBhcnNpbmcgbGFzdCBmcmFnbWVudCB9XG4gIExFVkVMX1BUU19VUERBVEVEOiAnaGxzTGV2ZWxQdHNVcGRhdGVkJyxcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgYXVkaW8gdHJhY2sgbGlzdHMgaGFzIGJlZW4gdXBkYXRlZCBkYXRhOiB7IGF1ZGlvVHJhY2tzIDogYXVkaW9UcmFja3N9XG4gIEFVRElPX1RSQUNLU19VUERBVEVEOiAnaGxzQXVkaW9UcmFja3NVcGRhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2ggb2NjdXJzIC0gZGF0YTogeyAgaWQgOiBhdWRpbyB0cmFjayBpZH0gLy8gZGVwcmVjYXRlZCBpbiBmYXZvciBBVURJT19UUkFDS19TV0lUQ0hJTkdcbiAgQVVESU9fVFJBQ0tfU1dJVENIOiAnaGxzQXVkaW9UcmFja1N3aXRjaCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgc3dpdGNoaW5nIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgIGlkIDogYXVkaW8gdHJhY2sgaWR9XG4gIEFVRElPX1RSQUNLX1NXSVRDSElORzogJ2hsc0F1ZGlvVHJhY2tTd2l0Y2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaCBhY3R1YWxseSBvY2N1cnMgLSBkYXRhOiB7ICBpZCA6IGF1ZGlvIHRyYWNrIGlkfVxuICBBVURJT19UUkFDS19TV0lUQ0hFRDogJ2hsc0F1ZGlvVHJhY2tTd2l0Y2hlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IGF1ZGlvIHRyYWNrIFVSTCAgaWQgOiBhdWRpbyB0cmFjayBpZH1cbiAgQVVESU9fVFJBQ0tfTE9BRElORzogJ2hsc0F1ZGlvVHJhY2tMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBsb2FkaW5nICBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogYXVkaW8gdHJhY2sgaWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWV9IH1cbiAgQVVESU9fVFJBQ0tfTE9BREVEOiAnaGxzQXVkaW9UcmFja0xvYWRlZCcsXG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IHN1YnRpdGxlIHRyYWNrIGxpc3RzIGhhcyBiZWVuIHVwZGF0ZWQgZGF0YTogeyBzdWJ0aXRsZVRyYWNrcyA6IHN1YnRpdGxlVHJhY2tzfVxuICBTVUJUSVRMRV9UUkFDS1NfVVBEQVRFRDogJ2hsc1N1YnRpdGxlVHJhY2tzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gc3VidGl0bGUgdHJhY2sgc3dpdGNoIG9jY3VycyAtIGRhdGE6IHsgIGlkIDogc3VidGl0bGUgdHJhY2sgaWR9XG4gIFNVQlRJVExFX1RSQUNLX1NXSVRDSDogJ2hsc1N1YnRpdGxlVHJhY2tTd2l0Y2gnLFxuICAvLyBmaXJlZCB3aGVuIGFuIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBzdWJ0aXRsZSB0cmFjayBVUkwgIGlkIDogc3VidGl0bGUgdHJhY2sgaWR9XG4gIFNVQlRJVExFX1RSQUNLX0xPQURJTkc6ICdobHNTdWJ0aXRsZVRyYWNrTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYW4gc3VidGl0bGUgdHJhY2sgbG9hZGluZyAgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfSB9XG4gIFNVQlRJVExFX1RSQUNLX0xPQURFRDogJ2hsc1N1YnRpdGxlVHJhY2tMb2FkZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgZnJhZ21lbnQgaGFzIGJlZW4gcHJvY2Vzc2VkIC0gZGF0YTogeyBzdWNjZXNzIDogYm9vbGVhbiwgZnJhZyA6IHRoZSBwcm9jZXNzZWQgZnJhZ31cbiAgU1VCVElUTEVfRlJBR19QUk9DRVNTRUQ6ICdobHNTdWJ0aXRsZUZyYWdQcm9jZXNzZWQnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBmaXJzdCB0aW1lc3RhbXAgaXMgZm91bmQuIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGluaXRQVFM6IGluaXRQVFMgLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBJTklUX1BUU19GT1VORDogJ2hsc0luaXRQdHNGb3VuZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgRlJBR19MT0FESU5HOiAnaGxzRnJhZ0xvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBwcm9ncmVzc2luZyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgeyB0cmVxdWVzdCwgdGZpcnN0LCBsb2FkZWR9fVxuICBGUkFHX0xPQURfUFJPR1JFU1M6ICdobHNGcmFnTG9hZFByb2dyZXNzJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBhYm9ydGluZyBmb3IgZW1lcmdlbmN5IHN3aXRjaCBkb3duIC0gZGF0YToge2ZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRDogJ2hsc0ZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGZyYWdtZW50IHBheWxvYWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbGVuZ3RofX1cbiAgRlJBR19MT0FERUQ6ICdobHNGcmFnTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGhhcyBmaW5pc2hlZCBkZWNyeXB0aW5nIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgc3RhdHMgOiB7dHN0YXJ0LHRkZWNyeXB0fSB9XG4gIEZSQUdfREVDUllQVEVEOiAnaGxzRnJhZ0RlY3J5cHRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gSW5pdCBTZWdtZW50IGhhcyBiZWVuIGV4dHJhY3RlZCBmcm9tIGZyYWdtZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgbW9vdiA6IG1vb3YgTVA0IGJveCwgY29kZWNzIDogY29kZWNzIGZvdW5kIHdoaWxlIHBhcnNpbmcgZnJhZ21lbnR9XG4gIEZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQ6ICdobHNGcmFnUGFyc2luZ0luaXRTZWdtZW50JyxcbiAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIHNlaSB0ZXh0IGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCAsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgc2FtcGxlcyA6IFsgc2VpIHNhbXBsZXMgcGVzIF0gfVxuICBGUkFHX1BBUlNJTkdfVVNFUkRBVEE6ICdobHNGcmFnUGFyc2luZ1VzZXJkYXRhJyxcbiAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIGlkMyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBzYW1wbGVzIDogWyBpZDMgc2FtcGxlcyBwZXMgXSB9XG4gIEZSQUdfUEFSU0lOR19NRVRBREFUQTogJ2hsc0ZyYWdQYXJzaW5nTWV0YWRhdGEnLFxuICAvLyBmaXJlZCB3aGVuIGRhdGEgaGF2ZSBiZWVuIGV4dHJhY3RlZCBmcm9tIGZyYWdtZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgZGF0YTEgOiBtb29mIE1QNCBib3ggb3IgVFMgZnJhZ21lbnRzLCBkYXRhMiA6IG1kYXQgTVA0IGJveCBvciBudWxsfVxuICBGUkFHX1BBUlNJTkdfREFUQTogJ2hsc0ZyYWdQYXJzaW5nRGF0YScsXG4gIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgcGFyc2luZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCxmcmFnOiBmcmFnbWVudCBvYmplY3QgfVxuICBGUkFHX1BBUlNFRDogJ2hsc0ZyYWdQYXJzZWQnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHJlbXV4ZWQgTVA0IGJveGVzIGhhdmUgYWxsIGJlZW4gYXBwZW5kZWQgaW50byBTb3VyY2VCdWZmZXIgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCxmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIHRwYXJzZWQsIHRidWZmZXJlZCwgbGVuZ3RofSB9XG4gIEZSQUdfQlVGRkVSRUQ6ICdobHNGcmFnQnVmZmVyZWQnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IG1hdGNoaW5nIHdpdGggY3VycmVudCBtZWRpYSBwb3NpdGlvbiBpcyBjaGFuZ2luZyAtIGRhdGEgOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEZSQUdfQ0hBTkdFRDogJ2hsc0ZyYWdDaGFuZ2VkJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBGUFMgZHJvcCBldmVudCAtIGRhdGE6IHtjdXJlbnREcm9wcGVkLCBjdXJyZW50RGVjb2RlZCwgdG90YWxEcm9wcGVkRnJhbWVzfVxuICBGUFNfRFJPUDogJ2hsc0Zwc0Ryb3AnLFxuICAvL3RyaWdnZXJlZCB3aGVuIEZQUyBkcm9wIHRyaWdnZXJzIGF1dG8gbGV2ZWwgY2FwcGluZyAtIGRhdGE6IHtsZXZlbCwgZHJvcHBlZGxldmVsfVxuICBGUFNfRFJPUF9MRVZFTF9DQVBQSU5HOiAnaGxzRnBzRHJvcExldmVsQ2FwcGluZycsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGVycm9yIGV2ZW50IC0gZGF0YTogeyB0eXBlIDogZXJyb3IgdHlwZSwgZGV0YWlscyA6IGVycm9yIGRldGFpbHMsIGZhdGFsIDogaWYgdHJ1ZSwgaGxzLmpzIGNhbm5vdC93aWxsIG5vdCB0cnkgdG8gcmVjb3ZlciwgaWYgZmFsc2UsIGhscy5qcyB3aWxsIHRyeSB0byByZWNvdmVyLG90aGVyIGVycm9yIHNwZWNpZmljIGRhdGF9XG4gIEVSUk9SOiAnaGxzRXJyb3InLFxuICAvLyBmaXJlZCB3aGVuIGhscy5qcyBpbnN0YW5jZSBzdGFydHMgZGVzdHJveWluZy4gRGlmZmVyZW50IGZyb20gTUVESUFfREVUQUNIRUQgYXMgb25lIGNvdWxkIHdhbnQgdG8gZGV0YWNoIGFuZCByZWF0dGFjaCBhIG1lZGlhIHRvIHRoZSBpbnN0YW5jZSBvZiBobHMuanMgdG8gaGFuZGxlIG1pZC1yb2xscyBmb3IgZXhhbXBsZVxuICBERVNUUk9ZSU5HOiAnaGxzRGVzdHJveWluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgS0VZX0xPQURJTkc6ICdobHNLZXlMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGRlY3J5cHQga2V5IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDoga2V5IHBheWxvYWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbGVuZ3RofX1cbiAgS0VZX0xPQURFRDogJ2hsc0tleUxvYWRlZCcsXG4gIC8vIGZpcmVkIHVwb24gc3RyZWFtIGNvbnRyb2xsZXIgc3RhdGUgdHJhbnNpdGlvbnMgLSBkYXRhOiB7cHJldmlvdXNTdGF0ZSwgbmV4dFN0YXRlfVxuICBTVFJFQU1fU1RBVEVfVFJBTlNJVElPTjogJ2hsc1N0cmVhbVN0YXRlVHJhbnNpdGlvbidcbn07XG5cbn0se31dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiAgQUFDIGhlbHBlclxuICovXG5cbnZhciBBQUMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFBQygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQUFDKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBQUMsIG51bGwsIFt7XG4gICAga2V5OiAnZ2V0U2lsZW50RnJhbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaWxlbnRGcmFtZShjb2RlYywgY2hhbm5lbENvdW50KSB7XG4gICAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICAgIGNhc2UgJ21wNGEuNDAuMic6XG4gICAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIzLCAweDgwXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgyMSwgMHgwMCwgMHg0OSwgMHg5MCwgMHgwMiwgMHgxOSwgMHgwMCwgMHgyMywgMHg4MF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4OGVdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgwLCAweDJjLCAweDgwLCAweDA4LCAweDAyLCAweDM4XSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgzOF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA2KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MDAsIDB4YjIsIDB4MDAsIDB4MjAsIDB4MDgsIDB4ZTBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGhhbmRsZSBIRS1BQUMgYmVsb3cgKG1wNGEuNDAuNSAvIG1wNGEuNDAuMjkpXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGUgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDRlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MWMsIDB4NiwgMHhmMSwgMHhjMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHg5NSwgMHgwLCAweDYsIDB4ZjEsIDB4YTEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHg5NSwgMHgwLCAweDYsIDB4ZjEsIDB4YTEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBQUM7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFBQztcblxufSx7fV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQnVmZmVyIEhlbHBlciBjbGFzcywgcHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyBidWZmZXIgbGVuZ3RoIHJldHJpZXZhbFxuKi9cblxudmFyIEJ1ZmZlckhlbHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVySGVscGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJIZWxwZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJ1ZmZlckhlbHBlciwgbnVsbCwgW3tcbiAgICBrZXk6IFwiaXNCdWZmZXJlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0J1ZmZlcmVkKG1lZGlhLCBwb3NpdGlvbikge1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHZhciBidWZmZXJlZCA9IG1lZGlhLmJ1ZmZlcmVkO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uID49IGJ1ZmZlcmVkLnN0YXJ0KGkpICYmIHBvc2l0aW9uIDw9IGJ1ZmZlcmVkLmVuZChpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1ZmZlckluZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVmZmVySW5mbyhtZWRpYSwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICB2YXIgdmJ1ZmZlcmVkID0gbWVkaWEuYnVmZmVyZWQsXG4gICAgICAgICAgICBidWZmZXJlZCA9IFtdLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlcmVkLnB1c2goeyBzdGFydDogdmJ1ZmZlcmVkLnN0YXJ0KGkpLCBlbmQ6IHZidWZmZXJlZC5lbmQoaSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBsZW46IDAsIHN0YXJ0OiBwb3MsIGVuZDogcG9zLCBuZXh0U3RhcnQ6IHVuZGVmaW5lZCB9O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWZmZXJlZEluZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbikge1xuICAgICAgdmFyIGJ1ZmZlcmVkMiA9IFtdLFxuXG4gICAgICAvLyBidWZmZXJTdGFydCBhbmQgYnVmZmVyRW5kIGFyZSBidWZmZXIgYm91bmRhcmllcyBhcm91bmQgY3VycmVudCB2aWRlbyBwb3NpdGlvblxuICAgICAgYnVmZmVyTGVuLFxuICAgICAgICAgIGJ1ZmZlclN0YXJ0LFxuICAgICAgICAgIGJ1ZmZlckVuZCxcbiAgICAgICAgICBidWZmZXJTdGFydE5leHQsXG4gICAgICAgICAgaTtcbiAgICAgIC8vIHNvcnQgb24gYnVmZmVyLnN0YXJ0L3NtYWxsZXIgZW5kIChJRSBkb2VzIG5vdCBhbHdheXMgcmV0dXJuIHNvcnRlZCBidWZmZXJlZCByYW5nZSlcbiAgICAgIGJ1ZmZlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBhLnN0YXJ0IC0gYi5zdGFydDtcbiAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYi5lbmQgLSBhLmVuZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyB0aGVyZSBtaWdodCBiZSBzb21lIHNtYWxsIGhvbGVzIGJldHdlZW4gYnVmZmVyIHRpbWUgcmFuZ2VcbiAgICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxuICAgICAgLy8gYnVmZmVyIHRpbWUgcmFuZ2UgcmVwcmVzZW50YXRpb25zIHRoYXQgZGlzY2FyZHMgdGhvc2UgaG9sZXNcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYnVmMmxlbiA9IGJ1ZmZlcmVkMi5sZW5ndGg7XG4gICAgICAgIGlmIChidWYybGVuKSB7XG4gICAgICAgICAgdmFyIGJ1ZjJlbmQgPSBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZDtcbiAgICAgICAgICAvLyBpZiBzbWFsbCBob2xlICh2YWx1ZSBiZXR3ZWVuIDAgb3IgbWF4SG9sZUR1cmF0aW9uICkgb3Igb3ZlcmxhcHBpbmcgKG5lZ2F0aXZlKVxuICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5zdGFydCAtIGJ1ZjJlbmQgPCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIG1lcmdlIG92ZXJsYXBwaW5nIHRpbWUgcmFuZ2VzXG4gICAgICAgICAgICAvLyB1cGRhdGUgbGFzdFJhbmdlLmVuZCBvbmx5IGlmIHNtYWxsZXIgdGhhbiBpdGVtLmVuZFxuICAgICAgICAgICAgLy8gZS5nLiAgWyAxLCAxNV0gd2l0aCAgWyAyLDhdID0+IFsgMSwxNV0gKG5vIG5lZWQgdG8gbW9kaWZ5IGxhc3RSYW5nZS5lbmQpXG4gICAgICAgICAgICAvLyB3aGVyZWFzIFsgMSwgOF0gd2l0aCAgWyAyLDE1XSA9PiBbIDEsMTVdICggbGFzdFJhbmdlIHNob3VsZCBzd2l0Y2ggZnJvbSBbMSw4XSB0byBbMSwxNV0pXG4gICAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uZW5kID4gYnVmMmVuZCkge1xuICAgICAgICAgICAgICBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZCA9IGJ1ZmZlcmVkW2ldLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYmlnIGhvbGVcbiAgICAgICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZmlyc3QgdmFsdWVcbiAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGJ1ZmZlckxlbiA9IDAsIGJ1ZmZlclN0YXJ0ID0gYnVmZmVyRW5kID0gcG9zOyBpIDwgYnVmZmVyZWQyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGJ1ZmZlcmVkMltpXS5zdGFydCxcbiAgICAgICAgICAgIGVuZCA9IGJ1ZmZlcmVkMltpXS5lbmQ7XG4gICAgICAgIC8vbG9nZ2VyLmxvZygnYnVmIHN0YXJ0L2VuZDonICsgYnVmZmVyZWQuc3RhcnQoaSkgKyAnLycgKyBidWZmZXJlZC5lbmQoaSkpO1xuICAgICAgICBpZiAocG9zICsgbWF4SG9sZUR1cmF0aW9uID49IHN0YXJ0ICYmIHBvcyA8IGVuZCkge1xuICAgICAgICAgIC8vIHBsYXkgcG9zaXRpb24gaXMgaW5zaWRlIHRoaXMgYnVmZmVyIFRpbWVSYW5nZSwgcmV0cmlldmUgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvbiBhbmQgYnVmZmVyIGxlbmd0aFxuICAgICAgICAgIGJ1ZmZlclN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgYnVmZmVyRW5kID0gZW5kO1xuICAgICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckVuZCAtIHBvcztcbiAgICAgICAgfSBlbHNlIGlmIChwb3MgKyBtYXhIb2xlRHVyYXRpb24gPCBzdGFydCkge1xuICAgICAgICAgIGJ1ZmZlclN0YXJ0TmV4dCA9IHN0YXJ0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBsZW46IGJ1ZmZlckxlbiwgc3RhcnQ6IGJ1ZmZlclN0YXJ0LCBlbmQ6IGJ1ZmZlckVuZCwgbmV4dFN0YXJ0OiBidWZmZXJTdGFydE5leHQgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnVmZmVySGVscGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCdWZmZXJIZWxwZXI7XG5cbn0se31dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTGV2ZWwgSGVscGVyIGNsYXNzLCBwcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIHdpdGggcGxheWxpc3Qgc2xpZGluZyBhbmQgZHJpZnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgTGV2ZWxIZWxwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExldmVsSGVscGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMZXZlbEhlbHBlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGV2ZWxIZWxwZXIsIG51bGwsIFt7XG4gICAga2V5OiAnbWVyZ2VEZXRhaWxzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2VEZXRhaWxzKG9sZERldGFpbHMsIG5ld0RldGFpbHMpIHtcbiAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KG9sZERldGFpbHMuc3RhcnRTTiwgbmV3RGV0YWlscy5zdGFydFNOKSAtIG5ld0RldGFpbHMuc3RhcnRTTixcbiAgICAgICAgICBlbmQgPSBNYXRoLm1pbihvbGREZXRhaWxzLmVuZFNOLCBuZXdEZXRhaWxzLmVuZFNOKSAtIG5ld0RldGFpbHMuc3RhcnRTTixcbiAgICAgICAgICBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiAtIG9sZERldGFpbHMuc3RhcnRTTixcbiAgICAgICAgICBvbGRmcmFnbWVudHMgPSBvbGREZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgICAgICBuZXdmcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgICAgICBjY09mZnNldCA9IDAsXG4gICAgICAgICAgUFRTRnJhZztcblxuICAgICAgLy8gY2hlY2sgaWYgb2xkL25ldyBwbGF5bGlzdHMgaGF2ZSBmcmFnbWVudHMgaW4gY29tbW9uXG4gICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBsb29wIHRocm91Z2ggb3ZlcmxhcHBpbmcgU04gYW5kIHVwZGF0ZSBzdGFydFBUUyAsIGNjLCBhbmQgZHVyYXRpb24gaWYgYW55IGZvdW5kXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgdmFyIG9sZEZyYWcgPSBvbGRmcmFnbWVudHNbZGVsdGEgKyBpXSxcbiAgICAgICAgICAgIG5ld0ZyYWcgPSBuZXdmcmFnbWVudHNbaV07XG4gICAgICAgIGlmIChuZXdGcmFnICYmIG9sZEZyYWcpIHtcbiAgICAgICAgICBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xuICAgICAgICAgIGlmICghaXNOYU4ob2xkRnJhZy5zdGFydFBUUykpIHtcbiAgICAgICAgICAgIG5ld0ZyYWcuc3RhcnQgPSBuZXdGcmFnLnN0YXJ0UFRTID0gb2xkRnJhZy5zdGFydFBUUztcbiAgICAgICAgICAgIG5ld0ZyYWcuZW5kUFRTID0gb2xkRnJhZy5lbmRQVFM7XG4gICAgICAgICAgICBuZXdGcmFnLmR1cmF0aW9uID0gb2xkRnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICAgIFBUU0ZyYWcgPSBuZXdGcmFnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2NPZmZzZXQpIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdkaXNjb250aW51aXR5IHNsaWRpbmcgZnJvbSBwbGF5bGlzdCwgdGFrZSBkcmlmdCBpbnRvIGFjY291bnQnKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ld2ZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5ld2ZyYWdtZW50c1tpXS5jYyArPSBjY09mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiBhdCBsZWFzdCBvbmUgZnJhZ21lbnQgY29udGFpbnMgUFRTIGluZm8sIHJlY29tcHV0ZSBQVFMgaW5mb3JtYXRpb24gZm9yIGFsbCBmcmFnbWVudHNcbiAgICAgIGlmIChQVFNGcmFnKSB7XG4gICAgICAgIExldmVsSGVscGVyLnVwZGF0ZUZyYWdQVFNEVFMobmV3RGV0YWlscywgUFRTRnJhZy5zbiwgUFRTRnJhZy5zdGFydFBUUywgUFRTRnJhZy5lbmRQVFMsIFBUU0ZyYWcuc3RhcnREVFMsIFBUU0ZyYWcuZW5kRFRTKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IGRlbHRhIGlzIHdpdGhpbiBvbGRmcmFnbWVudHMgcmFuZ2VcbiAgICAgICAgLy8gYWxzbyBhZGp1c3Qgc2xpZGluZyBpbiBjYXNlIGRlbHRhIGlzIDAgKHdlIGNvdWxkIGhhdmUgb2xkPVs1MC02MF0gYW5kIG5ldz1vbGQ9WzUwLTYxXSlcbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGFsc28gbmVlZCB0byBhZGp1c3Qgc3RhcnQgb2Zmc2V0IG9mIGFsbCBmcmFnbWVudHNcbiAgICAgICAgaWYgKGRlbHRhID49IDAgJiYgZGVsdGEgPCBvbGRmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gYWRqdXN0IHN0YXJ0IGJ5IHNsaWRpbmcgb2Zmc2V0XG4gICAgICAgICAgdmFyIHNsaWRpbmcgPSBvbGRmcmFnbWVudHNbZGVsdGFdLnN0YXJ0O1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXdmcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld2ZyYWdtZW50c1tpXS5zdGFydCArPSBzbGlkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIGl0IG1lYW5zIHdlIGhhdmUgZnJhZ21lbnRzIG92ZXJsYXBwaW5nIGJldHdlZW5cbiAgICAgIC8vIG9sZCBhbmQgbmV3IGxldmVsLiByZWxpYWJsZSBQVFMgaW5mbyBpcyB0aHVzIHJlbHlpbmcgb24gb2xkIGxldmVsXG4gICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gb2xkRGV0YWlscy5QVFNLbm93bjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVGcmFnUFRTRFRTJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRnJhZ1BUU0RUUyhkZXRhaWxzLCBzbiwgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUykge1xuICAgICAgdmFyIGZyYWdJZHgsIGZyYWdtZW50cywgZnJhZywgaTtcbiAgICAgIC8vIGV4aXQgaWYgc24gb3V0IG9mIHJhbmdlXG4gICAgICBpZiAoIWRldGFpbHMgfHwgc24gPCBkZXRhaWxzLnN0YXJ0U04gfHwgc24gPiBkZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgZnJhZ0lkeCA9IHNuIC0gZGV0YWlscy5zdGFydFNOO1xuICAgICAgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWdJZHhdO1xuICAgICAgaWYgKCFpc05hTihmcmFnLnN0YXJ0UFRTKSkge1xuICAgICAgICAvLyBkZWx0YSBQVFMgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW9cbiAgICAgICAgdmFyIGRlbHRhUFRTID0gTWF0aC5hYnMoZnJhZy5zdGFydFBUUyAtIHN0YXJ0UFRTKTtcbiAgICAgICAgaWYgKGlzTmFOKGZyYWcuZGVsdGFQVFMpKSB7XG4gICAgICAgICAgZnJhZy5kZWx0YVBUUyA9IGRlbHRhUFRTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWcuZGVsdGFQVFMgPSBNYXRoLm1heChkZWx0YVBUUywgZnJhZy5kZWx0YVBUUyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRQVFMgPSBNYXRoLm1pbihzdGFydFBUUywgZnJhZy5zdGFydFBUUyk7XG4gICAgICAgIGVuZFBUUyA9IE1hdGgubWF4KGVuZFBUUywgZnJhZy5lbmRQVFMpO1xuICAgICAgICBzdGFydERUUyA9IE1hdGgubWluKHN0YXJ0RFRTLCBmcmFnLnN0YXJ0RFRTKTtcbiAgICAgICAgZW5kRFRTID0gTWF0aC5tYXgoZW5kRFRTLCBmcmFnLmVuZERUUyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkcmlmdCA9IHN0YXJ0UFRTIC0gZnJhZy5zdGFydDtcblxuICAgICAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydFBUUztcbiAgICAgIGZyYWcuZW5kUFRTID0gZW5kUFRTO1xuICAgICAgZnJhZy5zdGFydERUUyA9IHN0YXJ0RFRTO1xuICAgICAgZnJhZy5lbmREVFMgPSBlbmREVFM7XG4gICAgICBmcmFnLmR1cmF0aW9uID0gZW5kUFRTIC0gc3RhcnRQVFM7XG4gICAgICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtLTEgdG8gZnJhZyAwXG4gICAgICBmb3IgKGkgPSBmcmFnSWR4OyBpID4gMDsgaS0tKSB7XG4gICAgICAgIExldmVsSGVscGVyLnVwZGF0ZVBUUyhmcmFnbWVudHMsIGksIGkgLSAxKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bSB0byBsYXN0IGZyYWdcbiAgICAgIGZvciAoaSA9IGZyYWdJZHg7IGkgPCBmcmFnbWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIExldmVsSGVscGVyLnVwZGF0ZVBUUyhmcmFnbWVudHMsIGksIGkgKyAxKTtcbiAgICAgIH1cbiAgICAgIGRldGFpbHMuUFRTS25vd24gPSB0cnVlO1xuICAgICAgLy9sb2dnZXIubG9nKGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgc3RhcnQvZW5kOiR7c3RhcnRQVFMudG9GaXhlZCgzKX0vJHtlbmRQVFMudG9GaXhlZCgzKX1gKTtcblxuICAgICAgcmV0dXJuIGRyaWZ0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVBUUycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVBUUyhmcmFnbWVudHMsIGZyb21JZHgsIHRvSWR4KSB7XG4gICAgICB2YXIgZnJhZ0Zyb20gPSBmcmFnbWVudHNbZnJvbUlkeF0sXG4gICAgICAgICAgZnJhZ1RvID0gZnJhZ21lbnRzW3RvSWR4XSxcbiAgICAgICAgICBmcmFnVG9QVFMgPSBmcmFnVG8uc3RhcnRQVFM7XG4gICAgICAvLyBpZiB3ZSBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICAgICAgaWYgKCFpc05hTihmcmFnVG9QVFMpKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBmcmFnbWVudCBkdXJhdGlvbi5cbiAgICAgICAgLy8gaXQgaGVscHMgdG8gZml4IGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0IHJlcG9ydGVkIGR1cmF0aW9uIGFuZCBmcmFnbWVudCByZWFsIGR1cmF0aW9uXG4gICAgICAgIGlmICh0b0lkeCA+IGZyb21JZHgpIHtcbiAgICAgICAgICBmcmFnRnJvbS5kdXJhdGlvbiA9IGZyYWdUb1BUUyAtIGZyYWdGcm9tLnN0YXJ0O1xuICAgICAgICAgIGlmIChmcmFnRnJvbS5kdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ25lZ2F0aXZlIGR1cmF0aW9uIGNvbXB1dGVkIGZvciBmcmFnICcgKyBmcmFnRnJvbS5zbiArICcsbGV2ZWwgJyArIGZyYWdGcm9tLmxldmVsICsgJywgdGhlcmUgc2hvdWxkIGJlIHNvbWUgZHVyYXRpb24gZHJpZnQgYmV0d2VlbiBwbGF5bGlzdCBhbmQgZnJhZ21lbnQhJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWdUby5kdXJhdGlvbiA9IGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvUFRTO1xuICAgICAgICAgIGlmIChmcmFnVG8uZHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCduZWdhdGl2ZSBkdXJhdGlvbiBjb21wdXRlZCBmb3IgZnJhZyAnICsgZnJhZ1RvLnNuICsgJyxsZXZlbCAnICsgZnJhZ1RvLmxldmVsICsgJywgdGhlcmUgc2hvdWxkIGJlIHNvbWUgZHVyYXRpb24gZHJpZnQgYmV0d2VlbiBwbGF5bGlzdCBhbmQgZnJhZ21lbnQhJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBkb250IGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gICAgICAgIGlmICh0b0lkeCA+IGZyb21JZHgpIHtcbiAgICAgICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIGZyYWdGcm9tLmR1cmF0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWdUby5zdGFydCA9IGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExldmVsSGVscGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMZXZlbEhlbHBlcjtcblxufSx7XCI1MFwiOjUwfV0sMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBITFMgaW50ZXJmYWNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ldmVudHMgPSBfZGVyZXFfKDMzKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9lcnJvcnMgPSBfZGVyZXFfKDMxKTtcblxudmFyIF9wbGF5bGlzdExvYWRlciA9IF9kZXJlcV8oNDEpO1xuXG52YXIgX3BsYXlsaXN0TG9hZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYXlsaXN0TG9hZGVyKTtcblxudmFyIF9mcmFnbWVudExvYWRlciA9IF9kZXJlcV8oMzkpO1xuXG52YXIgX2ZyYWdtZW50TG9hZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZyYWdtZW50TG9hZGVyKTtcblxudmFyIF9rZXlMb2FkZXIgPSBfZGVyZXFfKDQwKTtcblxudmFyIF9rZXlMb2FkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5TG9hZGVyKTtcblxudmFyIF9zdHJlYW1Db250cm9sbGVyID0gX2RlcmVxXygxMyk7XG5cbnZhciBfc3RyZWFtQ29udHJvbGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJlYW1Db250cm9sbGVyKTtcblxudmFyIF9sZXZlbENvbnRyb2xsZXIgPSBfZGVyZXFfKDEyKTtcblxudmFyIF9sZXZlbENvbnRyb2xsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGV2ZWxDb250cm9sbGVyKTtcblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxudmFyIF9ldmVudHMzID0gX2RlcmVxXygxKTtcblxudmFyIF9ldmVudHM0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzMyk7XG5cbnZhciBfY29uZmlnID0gX2RlcmVxXyg0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEhscyA9IGZ1bmN0aW9uICgpIHtcbiAgX2NyZWF0ZUNsYXNzKEhscywgbnVsbCwgW3tcbiAgICBrZXk6ICdpc1N1cHBvcnRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgICAgd2luZG93Lk1lZGlhU291cmNlID0gd2luZG93Lk1lZGlhU291cmNlIHx8IHdpbmRvdy5XZWJLaXRNZWRpYVNvdXJjZTtcbiAgICAgIHJldHVybiB3aW5kb3cuTWVkaWFTb3VyY2UgJiYgdHlwZW9mIHdpbmRvdy5NZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQgPT09ICdmdW5jdGlvbicgJiYgd2luZG93Lk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyRTAxRSxtcDRhLjQwLjJcIicpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ZlcnNpb24nLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gcmVwbGFjZWQgd2l0aCBicm93c2VyaWZ5LXZlcnNpb25pZnkgdHJhbnNmb3JtXG4gICAgICByZXR1cm4gJzAuNy4yJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdFdmVudHMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9ldmVudHMyLmRlZmF1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnRXJyb3JUeXBlcycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2Vycm9ycy5FcnJvclR5cGVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ0Vycm9yRGV0YWlscycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2Vycm9ycy5FcnJvckRldGFpbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnRGVmYXVsdENvbmZpZycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUhscy5kZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfY29uZmlnLmhsc0RlZmF1bHRDb25maWc7XG4gICAgICB9XG4gICAgICByZXR1cm4gSGxzLmRlZmF1bHRDb25maWc7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChkZWZhdWx0Q29uZmlnKSB7XG4gICAgICBIbHMuZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWc7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gSGxzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIbHMpO1xuXG4gICAgdmFyIGRlZmF1bHRDb25maWcgPSBIbHMuRGVmYXVsdENvbmZpZztcblxuICAgIGlmICgoY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KSAmJiAoY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogZG9uXFwndCBtaXggdXAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50L2xpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCBhbmQgbGl2ZVN5bmNEdXJhdGlvbi9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBkZWZhdWx0Q29uZmlnKSB7XG4gICAgICBpZiAocHJvcCBpbiBjb25maWcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25maWdbcHJvcF0gPSBkZWZhdWx0Q29uZmlnW3Byb3BdO1xuICAgIH1cblxuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCA8PSBjb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRcIiBtdXN0IGJlIGd0IFwibGl2ZVN5bmNEdXJhdGlvbkNvdW50XCInKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCAmJiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gPD0gY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25cIiBtdXN0IGJlIGd0IFwibGl2ZVN5bmNEdXJhdGlvblwiJyk7XG4gICAgfVxuXG4gICAgKDAsIF9sb2dnZXIuZW5hYmxlTG9ncykoY29uZmlnLmRlYnVnKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgLy8gb2JzZXJ2ZXIgc2V0dXBcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyID0gbmV3IF9ldmVudHM0LmRlZmF1bHQoKTtcbiAgICBvYnNlcnZlci50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlcihldmVudCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGRhdGEgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGRhdGFbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBvYnNlcnZlci5lbWl0LmFwcGx5KG9ic2VydmVyLCBbZXZlbnQsIGV2ZW50XS5jb25jYXQoZGF0YSkpO1xuICAgIH07XG5cbiAgICBvYnNlcnZlci5vZmYgPSBmdW5jdGlvbiBvZmYoZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgZGF0YSA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgZGF0YVtfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgb2JzZXJ2ZXIucmVtb3ZlTGlzdGVuZXIuYXBwbHkob2JzZXJ2ZXIsIFtldmVudF0uY29uY2F0KGRhdGEpKTtcbiAgICB9O1xuICAgIHRoaXMub24gPSBvYnNlcnZlci5vbi5iaW5kKG9ic2VydmVyKTtcbiAgICB0aGlzLm9mZiA9IG9ic2VydmVyLm9mZi5iaW5kKG9ic2VydmVyKTtcbiAgICB0aGlzLnRyaWdnZXIgPSBvYnNlcnZlci50cmlnZ2VyLmJpbmQob2JzZXJ2ZXIpO1xuXG4gICAgLy8gY29yZSBjb250cm9sbGVycyBhbmQgbmV0d29yayBsb2FkZXJzXG4gICAgdmFyIGFickNvbnRyb2xsZXIgPSB0aGlzLmFickNvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmFickNvbnRyb2xsZXIodGhpcyk7XG4gICAgdmFyIGJ1ZmZlckNvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmJ1ZmZlckNvbnRyb2xsZXIodGhpcyk7XG4gICAgdmFyIGNhcExldmVsQ29udHJvbGxlciA9IG5ldyBjb25maWcuY2FwTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xuICAgIHZhciBmcHNDb250cm9sbGVyID0gbmV3IGNvbmZpZy5mcHNDb250cm9sbGVyKHRoaXMpO1xuICAgIHZhciBwbGF5TGlzdExvYWRlciA9IG5ldyBfcGxheWxpc3RMb2FkZXIyLmRlZmF1bHQodGhpcyk7XG4gICAgdmFyIGZyYWdtZW50TG9hZGVyID0gbmV3IF9mcmFnbWVudExvYWRlcjIuZGVmYXVsdCh0aGlzKTtcbiAgICB2YXIga2V5TG9hZGVyID0gbmV3IF9rZXlMb2FkZXIyLmRlZmF1bHQodGhpcyk7XG5cbiAgICAvLyBuZXR3b3JrIGNvbnRyb2xsZXJzXG4gICAgdmFyIGxldmVsQ29udHJvbGxlciA9IHRoaXMubGV2ZWxDb250cm9sbGVyID0gbmV3IF9sZXZlbENvbnRyb2xsZXIyLmRlZmF1bHQodGhpcyk7XG4gICAgdmFyIHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBuZXcgX3N0cmVhbUNvbnRyb2xsZXIyLmRlZmF1bHQodGhpcyk7XG4gICAgdmFyIG5ldHdvcmtDb250cm9sbGVycyA9IFtsZXZlbENvbnRyb2xsZXIsIHN0cmVhbUNvbnRyb2xsZXJdO1xuXG4gICAgLy8gb3B0aW9uYWwgYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXJcbiAgICB2YXIgQ29udHJvbGxlciA9IGNvbmZpZy5hdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG4gICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKG5ldyBDb250cm9sbGVyKHRoaXMpKTtcbiAgICB9XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMgPSBuZXR3b3JrQ29udHJvbGxlcnM7XG5cbiAgICB2YXIgY29yZUNvbXBvbmVudHMgPSBbcGxheUxpc3RMb2FkZXIsIGZyYWdtZW50TG9hZGVyLCBrZXlMb2FkZXIsIGFickNvbnRyb2xsZXIsIGJ1ZmZlckNvbnRyb2xsZXIsIGNhcExldmVsQ29udHJvbGxlciwgZnBzQ29udHJvbGxlcl07XG5cbiAgICAvLyBvcHRpb25hbCBhdWRpbyB0cmFjayBhbmQgc3VidGl0bGUgY29udHJvbGxlclxuICAgIENvbnRyb2xsZXIgPSBjb25maWcuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBhdWRpb1RyYWNrQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKHRoaXMpO1xuICAgICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlciA9IGF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgICAgY29yZUNvbXBvbmVudHMucHVzaChhdWRpb1RyYWNrQ29udHJvbGxlcik7XG4gICAgfVxuXG4gICAgQ29udHJvbGxlciA9IGNvbmZpZy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoQ29udHJvbGxlcikge1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIodGhpcyk7XG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICBjb3JlQ29tcG9uZW50cy5wdXNoKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKTtcbiAgICB9XG5cbiAgICAvLyBvcHRpb25hbCBzdWJ0aXRsZSBjb250cm9sbGVyXG4gICAgW2NvbmZpZy5zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIsIGNvbmZpZy50aW1lbGluZUNvbnRyb2xsZXJdLmZvckVhY2goZnVuY3Rpb24gKENvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICAgIGNvcmVDb21wb25lbnRzLnB1c2gobmV3IENvbnRyb2xsZXIoX3RoaXMpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzID0gY29yZUNvbXBvbmVudHM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSGxzLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdkZXN0cm95Jyk7XG4gICAgICB0aGlzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5ERVNUUk9ZSU5HKTtcbiAgICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICAgIHRoaXMuY29yZUNvbXBvbmVudHMuY29uY2F0KHRoaXMubmV0d29ya0NvbnRyb2xsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cmwgPSBudWxsO1xuICAgICAgdGhpcy5vYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhdHRhY2hNZWRpYScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaE1lZGlhKG1lZGlhKSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2F0dGFjaE1lZGlhJyk7XG4gICAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgICB0aGlzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5NRURJQV9BVFRBQ0hJTkcsIHsgbWVkaWE6IG1lZGlhIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RldGFjaE1lZGlhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoTWVkaWEoKSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2RldGFjaE1lZGlhJyk7XG4gICAgICB0aGlzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5NRURJQV9ERVRBQ0hJTkcpO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZFNvdXJjZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRTb3VyY2UodXJsKSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2xvYWRTb3VyY2U6JyArIHVybCk7XG4gICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgIC8vIHdoZW4gYXR0YWNoaW5nIHRvIGEgc291cmNlIFVSTCwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWRcbiAgICAgIHRoaXMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0Lk1BTklGRVNUX0xPQURJTkcsIHsgdXJsOiB1cmwgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RhcnRMb2FkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRMb2FkKCkge1xuICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IC0xO1xuXG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3N0YXJ0TG9hZCgnICsgc3RhcnRQb3NpdGlvbiArICcpJyk7XG4gICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RvcExvYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wTG9hZCgpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc3RvcExvYWQnKTtcbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3dhcEF1ZGlvQ29kZWMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc3dhcEF1ZGlvQ29kZWMnKTtcbiAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zd2FwQXVkaW9Db2RlYygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlY292ZXJNZWRpYUVycm9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb3Zlck1lZGlhRXJyb3IoKSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3JlY292ZXJNZWRpYUVycm9yJyk7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybiBhbGwgcXVhbGl0eSBsZXZlbHMgKiovXG5cbiAgfSwge1xuICAgIGtleTogJ2xldmVscycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWxzO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm4gY3VycmVudCBwbGF5YmFjayBxdWFsaXR5IGxldmVsICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjdXJyZW50TGV2ZWwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50TGV2ZWw7XG4gICAgfVxuXG4gICAgLyogc2V0IHF1YWxpdHkgbGV2ZWwgaW1tZWRpYXRlbHkgKC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uKSAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzZXQgY3VycmVudExldmVsOicgKyBuZXdMZXZlbCk7XG4gICAgICB0aGlzLmxvYWRMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLmltbWVkaWF0ZUxldmVsU3dpdGNoKCk7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybiBuZXh0IHBsYXliYWNrIHF1YWxpdHkgbGV2ZWwgKHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBmcmFnbWVudCkgKiovXG5cbiAgfSwge1xuICAgIGtleTogJ25leHRMZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbDtcbiAgICB9XG5cbiAgICAvKiBzZXQgcXVhbGl0eSBsZXZlbCBmb3IgbmV4dCBmcmFnbWVudCAoLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24pICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3NldCBuZXh0TGV2ZWw6JyArIG5ld0xldmVsKTtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybiB0aGUgcXVhbGl0eSBsZXZlbCBvZiBjdXJyZW50L2xhc3QgbG9hZGVkIGZyYWdtZW50ICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkTGV2ZWwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVsO1xuICAgIH1cblxuICAgIC8qIHNldCBxdWFsaXR5IGxldmVsIGZvciBjdXJyZW50L25leHQgbG9hZGVkIGZyYWdtZW50ICgtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbikgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc2V0IGxvYWRMZXZlbDonICsgbmV3TGV2ZWwpO1xuICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIGZyYWdtZW50ICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICduZXh0TG9hZExldmVsJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsO1xuICAgIH1cblxuICAgIC8qKiBzZXQgcXVhbGl0eSBsZXZlbCBvZiBuZXh0IGxvYWRlZCBmcmFnbWVudCAqKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobGV2ZWwpIHtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJuIGZpcnN0IGxldmVsIChpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0KVxuICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmaXJzdExldmVsJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gICAgfVxuXG4gICAgLyoqIHNldCBmaXJzdCBsZXZlbCAoaW5kZXggb2YgZmlyc3QgbGV2ZWwgcmVmZXJlbmNlZCBpbiBtYW5pZmVzdClcbiAgICAqKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc2V0IGZpcnN0TGV2ZWw6JyArIG5ld0xldmVsKTtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJuIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAgICAgIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgICAgICBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGggKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxuICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzdGFydExldmVsJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsO1xuICAgIH1cblxuICAgIC8qKiBzZXQgIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAgICAgIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgICAgICBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGggKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxuICAgICoqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzZXQgc3RhcnRMZXZlbDonICsgbmV3TGV2ZWwpO1xuICAgICAgdmFyIGhscyA9IHRoaXM7XG4gICAgICAvLyBpZiBub3QgaW4gYXV0b21hdGljIHN0YXJ0IGxldmVsIGRldGVjdGlvbiwgZW5zdXJlIHN0YXJ0TGV2ZWwgaXMgZ3JlYXRlciB0aGFuIG1pbkF1dG9MZXZlbFxuICAgICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgICBuZXdMZXZlbCA9IE1hdGgubWF4KG5ld0xldmVsLCBobHMubWluQXV0b0xldmVsKTtcbiAgICAgIH1cbiAgICAgIGhscy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm4gdGhlIGNhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgY291bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAqKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXV0b0xldmVsQ2FwcGluZycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXV0b0xldmVsQ2FwcGluZztcbiAgICB9XG5cbiAgICAvKiogc2V0IHRoZSBjYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IGNvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKiovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3NldCBhdXRvTGV2ZWxDYXBwaW5nOicgKyBuZXdMZXZlbCk7XG4gICAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gICAgfVxuXG4gICAgLyogY2hlY2sgaWYgd2UgYXJlIGluIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gbW9kZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhdXRvTGV2ZWxFbmFibGVkJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9PT0gLTE7XG4gICAgfVxuXG4gICAgLyogcmV0dXJuIG1hbnVhbCBsZXZlbCAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtYW51YWxMZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWw7XG4gICAgfVxuXG4gICAgLyogcmV0dXJuIG1pbiBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gY29uZmlnLm1pbkF1dG9CaXRyYXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ21pbkF1dG9MZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcyxcbiAgICAgICAgICBsZXZlbHMgPSBobHMubGV2ZWxzLFxuICAgICAgICAgIG1pbkF1dG9CaXRyYXRlID0gaGxzLmNvbmZpZy5taW5BdXRvQml0cmF0ZSxcbiAgICAgICAgICBsZW4gPSBsZXZlbHMgPyBsZXZlbHMubGVuZ3RoIDogMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGxldmVsTmV4dEJpdHJhdGUgPSBsZXZlbHNbaV0ucmVhbEJpdHJhdGUgPyBNYXRoLm1heChsZXZlbHNbaV0ucmVhbEJpdHJhdGUsIGxldmVsc1tpXS5iaXRyYXRlKSA6IGxldmVsc1tpXS5iaXRyYXRlO1xuICAgICAgICBpZiAobGV2ZWxOZXh0Qml0cmF0ZSA+IG1pbkF1dG9CaXRyYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qIHJldHVybiBtYXggbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGF1dG9MZXZlbENhcHBpbmcgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWF4QXV0b0xldmVsJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzO1xuICAgICAgdmFyIGxldmVscyA9IGhscy5sZXZlbHM7XG4gICAgICB2YXIgYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgdmFyIG1heEF1dG9MZXZlbCA9IHZvaWQgMDtcbiAgICAgIGlmIChhdXRvTGV2ZWxDYXBwaW5nID09PSAtMSAmJiBsZXZlbHMgJiYgbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICBtYXhBdXRvTGV2ZWwgPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heEF1dG9MZXZlbCA9IGF1dG9MZXZlbENhcHBpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF4QXV0b0xldmVsO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBuZXh0IGF1dG8gbGV2ZWxcblxuICB9LCB7XG4gICAga2V5OiAnbmV4dEF1dG9MZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcztcbiAgICAgIC8vIGVuc3VyZSBuZXh0IGF1dG8gbGV2ZWwgaXMgYmV0d2VlbiAgbWluIGFuZCBtYXggYXV0byBsZXZlbFxuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwsIGhscy5taW5BdXRvTGV2ZWwpLCBobHMubWF4QXV0b0xldmVsKTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIHNldHRlciBpcyB1c2VkIHRvIGZvcmNlIG5leHQgYXV0byBsZXZlbFxuICAgIC8vIHRoaXMgaXMgdXNlZnVsIHRvIGZvcmNlIGEgc3dpdGNoIGRvd24gaW4gYXV0byBtb2RlIDogaW4gY2FzZSBvZiBsb2FkIGVycm9yIG9uIGxldmVsIE4sIGhscy5qcyBjYW4gc2V0IG5leHRBdXRvTGV2ZWwgdG8gTi0xIGZvciBleGFtcGxlKVxuICAgIC8vIGZvcmNlZCB2YWx1ZSBpcyB2YWxpZCBmb3Igb25lIGZyYWdtZW50LiB1cG9uIHN1Y2Nlc2Z1bCBmcmFnIGxvYWRpbmcgYXQgZm9yY2VkIGxldmVsLCB0aGlzIHZhbHVlIHdpbGwgYmUgcmVzZXR0ZWQgdG8gLTEgYnkgQUJSIGNvbnRyb2xsZXJcbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV4dExldmVsKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcztcbiAgICAgIGhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwgPSBNYXRoLm1heChobHMubWluQXV0b0xldmVsLCBuZXh0TGV2ZWwpO1xuICAgIH1cblxuICAgIC8qKiBnZXQgYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXG5cbiAgfSwge1xuICAgIGtleTogJ2F1ZGlvVHJhY2tzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrcyA6IFtdO1xuICAgIH1cblxuICAgIC8qKiBnZXQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cykgKiovXG5cbiAgfSwge1xuICAgIGtleTogJ2F1ZGlvVHJhY2snLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgOiAtMTtcbiAgICB9XG5cbiAgICAvKiogc2VsZWN0IGFuIGF1ZGlvIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHMqKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoYXVkaW9UcmFja0lkKSB7XG4gICAgICB2YXIgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgICAgaWYgKGF1ZGlvVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgIGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgPSBhdWRpb1RyYWNrSWQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGl2ZVN5bmNQb3NpdGlvbicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmxpdmVTeW5jUG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3VidGl0bGVUcmFja3MnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2tzIDogW107XG4gICAgfVxuXG4gICAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKSAqKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3VidGl0bGVUcmFjaycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA6IC0xO1xuICAgIH1cblxuICAgIC8qKiBzZWxlY3QgYW4gc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cyoqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICBpZiAoc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA9IHN1YnRpdGxlVHJhY2tJZDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGxzO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBIbHM7XG5cbn0se1wiMVwiOjEsXCIxMlwiOjEyLFwiMTNcIjoxMyxcIjMxXCI6MzEsXCIzM1wiOjMzLFwiMzlcIjozOSxcIjRcIjo0LFwiNDBcIjo0MCxcIjQxXCI6NDEsXCI1MFwiOjUwfV0sMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGlzIG1vc3RseSBmb3Igc3VwcG9ydCBvZiB0aGUgZXM2IG1vZHVsZSBleHBvcnRcbi8vIHN5bnRheCB3aXRoIHRoZSBiYWJlbCBjb21waWxlciwgaXQgbG9va3MgbGlrZSBpdCBkb2VzbnQgc3VwcG9ydFxuLy8gZnVuY3Rpb24gZXhwb3J0cyBsaWtlIHdlIGFyZSB1c2VkIHRvIGluIG5vZGUvY29tbW9uanNcbm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygzNykuZGVmYXVsdDtcblxufSx7XCIzN1wiOjM3fV0sMzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V2ZW50cyA9IF9kZXJlcV8oMzMpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX2V2ZW50SGFuZGxlciA9IF9kZXJlcV8oMzIpO1xuXG52YXIgX2V2ZW50SGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudEhhbmRsZXIpO1xuXG52YXIgX2Vycm9ycyA9IF9kZXJlcV8oMzEpO1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBGcmFnbWVudCBMb2FkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBGcmFnbWVudExvYWRlciA9IGZ1bmN0aW9uIChfRXZlbnRIYW5kbGVyKSB7XG4gIF9pbmhlcml0cyhGcmFnbWVudExvYWRlciwgX0V2ZW50SGFuZGxlcik7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnRMb2FkZXIoaGxzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZyYWdtZW50TG9hZGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGcmFnbWVudExvYWRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZyYWdtZW50TG9hZGVyKSkuY2FsbCh0aGlzLCBobHMsIF9ldmVudHMyLmRlZmF1bHQuRlJBR19MT0FESU5HKSk7XG5cbiAgICBfdGhpcy5sb2FkZXJzID0ge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZyYWdtZW50TG9hZGVyLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdmFyIGxvYWRlcnMgPSB0aGlzLmxvYWRlcnM7XG4gICAgICBmb3IgKHZhciBsb2FkZXJOYW1lIGluIGxvYWRlcnMpIHtcbiAgICAgICAgdmFyIGxvYWRlciA9IGxvYWRlcnNbbG9hZGVyTmFtZV07XG4gICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgICAgIF9ldmVudEhhbmRsZXIyLmRlZmF1bHQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZyYWdMb2FkaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GcmFnTG9hZGluZyhkYXRhKSB7XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgICB0eXBlID0gZnJhZy50eXBlLFxuICAgICAgICAgIGxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSxcbiAgICAgICAgICBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICAgIGZyYWcubG9hZGVkID0gMDtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignYWJvcnQgcHJldmlvdXMgZnJhZ21lbnQgbG9hZGVyIGZvciB0eXBlOicgKyB0eXBlKTtcbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbdHlwZV0gPSBmcmFnLmxvYWRlciA9IHR5cGVvZiBjb25maWcuZkxvYWRlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgY29uZmlnLmZMb2FkZXIoY29uZmlnKSA6IG5ldyBjb25maWcubG9hZGVyKGNvbmZpZyk7XG5cbiAgICAgIHZhciBsb2FkZXJDb250ZXh0ID0gdm9pZCAwLFxuICAgICAgICAgIGxvYWRlckNvbmZpZyA9IHZvaWQgMCxcbiAgICAgICAgICBsb2FkZXJDYWxsYmFja3MgPSB2b2lkIDA7XG4gICAgICBsb2FkZXJDb250ZXh0ID0geyB1cmw6IGZyYWcudXJsLCBmcmFnOiBmcmFnLCByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsIHByb2dyZXNzRGF0YTogZmFsc2UgfTtcbiAgICAgIHZhciBzdGFydCA9IGZyYWcuYnl0ZVJhbmdlU3RhcnRPZmZzZXQsXG4gICAgICAgICAgZW5kID0gZnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICBpZiAoIWlzTmFOKHN0YXJ0KSAmJiAhaXNOYU4oZW5kKSkge1xuICAgICAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICAgICAgbG9hZGVyQ29udGV4dC5yYW5nZUVuZCA9IGVuZDtcbiAgICAgIH1cbiAgICAgIGxvYWRlckNvbmZpZyA9IHsgdGltZW91dDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCwgbWF4UmV0cnk6IDAsIHJldHJ5RGVsYXk6IDAsIG1heFJldHJ5RGVsYXk6IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCB9O1xuICAgICAgbG9hZGVyQ2FsbGJhY2tzID0geyBvblN1Y2Nlc3M6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSwgb25FcnJvcjogdGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSwgb25UaW1lb3V0OiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIG9uUHJvZ3Jlc3M6IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcykgfTtcbiAgICAgIGxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2Fkc3VjY2VzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRzdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCkge1xuICAgICAgdmFyIHBheWxvYWQgPSByZXNwb25zZS5kYXRhLFxuICAgICAgICAgIGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgICAvLyBkZXRhY2ggZnJhZ21lbnQgbG9hZGVyIG9uIGxvYWQgc3VjY2Vzc1xuICAgICAgZnJhZy5sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX0xPQURFRCwgeyBwYXlsb2FkOiBwYXlsb2FkLCBmcmFnOiBmcmFnLCBzdGF0czogc3RhdHMgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZGVycm9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZGVycm9yKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbG9hZGVyID0gY29udGV4dC5sb2FkZXI7XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiBjb250ZXh0LmZyYWcsIHJlc3BvbnNlOiByZXNwb25zZSB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkdGltZW91dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWR0aW1lb3V0KHN0YXRzLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbG9hZGVyID0gY29udGV4dC5sb2FkZXI7XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VULCBmYXRhbDogZmFsc2UsIGZyYWc6IGNvbnRleHQuZnJhZyB9KTtcbiAgICB9XG5cbiAgICAvLyBkYXRhIHdpbGwgYmUgdXNlZCBmb3IgcHJvZ3Jlc3NpdmUgcGFyc2luZ1xuXG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkcHJvZ3Jlc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkcHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGRhdGEpIHtcbiAgICAgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgICBmcmFnLmxvYWRlZCA9IHN0YXRzLmxvYWRlZDtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX0xPQURfUFJPR1JFU1MsIHsgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGcmFnbWVudExvYWRlcjtcbn0oX2V2ZW50SGFuZGxlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEZyYWdtZW50TG9hZGVyO1xuXG59LHtcIjMxXCI6MzEsXCIzMlwiOjMyLFwiMzNcIjozMyxcIjUwXCI6NTB9XSw0MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZXZlbnRIYW5kbGVyID0gX2RlcmVxXygzMik7XG5cbnZhciBfZXZlbnRIYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50SGFuZGxlcik7XG5cbnZhciBfZXJyb3JzID0gX2RlcmVxXygzMSk7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERlY3J5cHQga2V5IExvYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIEtleUxvYWRlciA9IGZ1bmN0aW9uIChfRXZlbnRIYW5kbGVyKSB7XG4gIF9pbmhlcml0cyhLZXlMb2FkZXIsIF9FdmVudEhhbmRsZXIpO1xuXG4gIGZ1bmN0aW9uIEtleUxvYWRlcihobHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgS2V5TG9hZGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChLZXlMb2FkZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihLZXlMb2FkZXIpKS5jYWxsKHRoaXMsIGhscywgX2V2ZW50czIuZGVmYXVsdC5LRVlfTE9BRElORykpO1xuXG4gICAgX3RoaXMubG9hZGVycyA9IHt9O1xuICAgIF90aGlzLmRlY3J5cHRrZXkgPSBudWxsO1xuICAgIF90aGlzLmRlY3J5cHR1cmwgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhLZXlMb2FkZXIsIFt7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBmb3IgKHZhciBsb2FkZXJOYW1lIGluIHRoaXMubG9hZGVycykge1xuICAgICAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2xvYWRlck5hbWVdO1xuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgICBfZXZlbnRIYW5kbGVyMi5kZWZhdWx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25LZXlMb2FkaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25LZXlMb2FkaW5nKGRhdGEpIHtcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICAgIHR5cGUgPSBmcmFnLnR5cGUsXG4gICAgICAgICAgbG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdLFxuICAgICAgICAgIGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YSxcbiAgICAgICAgICB1cmkgPSBkZWNyeXB0ZGF0YS51cmk7XG4gICAgICAvLyBpZiB1cmkgaXMgZGlmZmVyZW50IGZyb20gcHJldmlvdXMgb25lIG9yIGlmIGRlY3J5cHQga2V5IG5vdCByZXRyaWV2ZWQgeWV0XG4gICAgICBpZiAodXJpICE9PSB0aGlzLmRlY3J5cHR1cmwgfHwgdGhpcy5kZWNyeXB0a2V5ID09PSBudWxsKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2Fib3J0IHByZXZpb3VzIGtleSBsb2FkZXIgZm9yIHR5cGU6JyArIHR5cGUpO1xuICAgICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGZyYWcubG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdID0gbmV3IGNvbmZpZy5sb2FkZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5kZWNyeXB0dXJsID0gdXJpO1xuICAgICAgICB0aGlzLmRlY3J5cHRrZXkgPSBudWxsO1xuXG4gICAgICAgIHZhciBsb2FkZXJDb250ZXh0ID0gdm9pZCAwLFxuICAgICAgICAgICAgbG9hZGVyQ29uZmlnID0gdm9pZCAwLFxuICAgICAgICAgICAgbG9hZGVyQ2FsbGJhY2tzID0gdm9pZCAwO1xuICAgICAgICBsb2FkZXJDb250ZXh0ID0geyB1cmw6IHVyaSwgZnJhZzogZnJhZywgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInIH07XG4gICAgICAgIGxvYWRlckNvbmZpZyA9IHsgdGltZW91dDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCwgbWF4UmV0cnk6IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5LCByZXRyeURlbGF5OiBjb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5OiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQgfTtcbiAgICAgICAgbG9hZGVyQ2FsbGJhY2tzID0geyBvblN1Y2Nlc3M6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSwgb25FcnJvcjogdGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSwgb25UaW1lb3V0OiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcykgfTtcbiAgICAgICAgZnJhZy5sb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGVjcnlwdGtleSkge1xuICAgICAgICAvLyB3ZSBhbHJlYWR5IGxvYWRlZCB0aGlzIGtleSwgcmV0dXJuIGl0XG4gICAgICAgIGRlY3J5cHRkYXRhLmtleSA9IHRoaXMuZGVjcnlwdGtleTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LktFWV9MT0FERUQsIHsgZnJhZzogZnJhZyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2Fkc3VjY2VzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRzdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCkge1xuICAgICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgICB0aGlzLmRlY3J5cHRrZXkgPSBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpO1xuICAgICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICAgIGZyYWcubG9hZGVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuS0VZX0xPQURFRCwgeyBmcmFnOiBmcmFnIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRlcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRlcnJvcihyZXNwb25zZSwgY29udGV4dCkge1xuICAgICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICAgICAgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IGZyYWcsIHJlc3BvbnNlOiByZXNwb25zZSB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkdGltZW91dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWR0aW1lb3V0KHN0YXRzLCBjb250ZXh0KSB7XG4gICAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZyxcbiAgICAgICAgICBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVCwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBLZXlMb2FkZXI7XG59KF9ldmVudEhhbmRsZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLZXlMb2FkZXI7XG5cbn0se1wiMzFcIjozMSxcIjMyXCI6MzIsXCIzM1wiOjMzLFwiNTBcIjo1MH1dLDQxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUGxheWxpc3QgTG9hZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIF91cmxUb29sa2l0ID0gX2RlcmVxXygyKTtcblxudmFyIF91cmxUb29sa2l0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VybFRvb2xraXQpO1xuXG52YXIgX2V2ZW50cyA9IF9kZXJlcV8oMzMpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX2V2ZW50SGFuZGxlciA9IF9kZXJlcV8oMzIpO1xuXG52YXIgX2V2ZW50SGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudEhhbmRsZXIpO1xuXG52YXIgX2Vycm9ycyA9IF9kZXJlcV8oMzEpO1xuXG52YXIgX2F0dHJMaXN0ID0gX2RlcmVxXyg0NSk7XG5cbnZhciBfYXR0ckxpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXR0ckxpc3QpO1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8vIGh0dHBzOi8vcmVnZXgxMDEuY29tIGlzIHlvdXIgZnJpZW5kXG52YXIgTUFTVEVSX1BMQVlMSVNUX1JFR0VYID0gLyNFWFQtWC1TVFJFQU0tSU5GOihbXlxcblxccl0qKVtcXHJcXG5dKyhbXlxcclxcbl0rKS9nO1xudmFyIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCA9IC8jRVhULVgtTUVESUE6KC4qKS9nO1xudmFyIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSAvI0VYVElORjooXFxkKig/OlxcLlxcZCspPykoPzosKC4qKSk/fCg/ISMpKFxcUy4rKXwjRVhULVgtQllURVJBTkdFOiAqKC4rKXwjRVhULVgtUFJPR1JBTS1EQVRFLVRJTUU6KC4rKXwjLiovZztcbnZhciBMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XID0gLyg/Oig/OiMoRVhUTTNVKSl8KD86I0VYVC1YLShQTEFZTElTVC1UWVBFKTooLispKXwoPzojRVhULVgtKE1FRElBLVNFUVVFTkNFKTogKihcXGQrKSl8KD86I0VYVC1YLShUQVJHRVREVVJBVElPTik6ICooXFxkKykpfCg/OiNFWFQtWC0oS0VZKTooLispKXwoPzojRVhULVgtKFNUQVJUKTooLispKXwoPzojRVhULVgtKEVORExJU1QpKXwoPzojRVhULVgtKERJU0NPTlRJTlVJVFktU0VRKVVFTkNFOihcXGQrKSl8KD86I0VYVC1YLShESVMpQ09OVElOVUlUWSkpfCg/OiNFWFQtWC0oVkVSU0lPTik6KFxcZCspKXwoPzojRVhULVgtKE1BUCk6KC4rKSl8KD86KCMpKC4qKTooLiopKXwoPzooIykoLiopKSg/Oi4qKVxccj9cXG4/LztcblxudmFyIExldmVsS2V5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMZXZlbEtleSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGV2ZWxLZXkpO1xuXG4gICAgdGhpcy5tZXRob2QgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLml2ID0gbnVsbDtcbiAgICB0aGlzLl91cmkgPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExldmVsS2V5LCBbe1xuICAgIGtleTogJ3VyaScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMuX3VyaSAmJiB0aGlzLnJlbHVyaSkge1xuICAgICAgICB0aGlzLl91cmkgPSBfdXJsVG9vbGtpdDIuZGVmYXVsdC5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVyaSwgdGhpcy5yZWx1cmkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGV2ZWxLZXk7XG59KCk7XG5cbnZhciBGcmFnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRnJhZ21lbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZyYWdtZW50KTtcblxuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5fYnl0ZVJhbmdlID0gbnVsbDtcbiAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IG51bGw7XG4gICAgdGhpcy50YWdMaXN0ID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRnJhZ21lbnQsIFt7XG4gICAga2V5OiAnY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3InLFxuXG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgcGFyc2VMZXZlbFBsYXlsaXN0IHRvIGNyZWF0ZSBhbiBpbml0aWFsaXphdGlvbiB2ZWN0b3IgZm9yIGEgZ2l2ZW4gc2VnbWVudFxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihzZWdtZW50TnVtYmVyKSB7XG4gICAgICB2YXIgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIHVpbnQ4Vmlld1tpXSA9IHNlZ21lbnROdW1iZXIgPj4gOCAqICgxNSAtIGkpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVpbnQ4VmlldztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgcGFyc2VMZXZlbFBsYXlsaXN0IHRvIGdldCBhIGZyYWdtZW50J3MgZGVjcnlwdGlvbiBkYXRhIGZyb20gdGhlIGN1cnJlbnRseSBwYXJzZWQgZW5jcnlwdGlvbiBrZXkgZGF0YVxuICAgICAqIEBwYXJhbSBsZXZlbGtleSAtIGEgcGxheWxpc3QncyBlbmNyeXB0aW9uIGluZm9cbiAgICAgKiBAcGFyYW0gc2VnbWVudE51bWJlciAtIHRoZSBmcmFnbWVudCdzIHNlZ21lbnQgbnVtYmVyXG4gICAgICogQHJldHVybnMgeyp9IC0gYW4gb2JqZWN0IHRvIGJlIGFwcGxpZWQgYXMgYSBmcmFnbWVudCdzIGRlY3J5cHRkYXRhXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcmFnbWVudERlY3J5cHRkYXRhRnJvbUxldmVsa2V5KGxldmVsa2V5LCBzZWdtZW50TnVtYmVyKSB7XG4gICAgICB2YXIgZGVjcnlwdGRhdGEgPSBsZXZlbGtleTtcblxuICAgICAgaWYgKGxldmVsa2V5ICYmIGxldmVsa2V5Lm1ldGhvZCAmJiBsZXZlbGtleS51cmkgJiYgIWxldmVsa2V5Lml2KSB7XG4gICAgICAgIGRlY3J5cHRkYXRhID0gbmV3IExldmVsS2V5KCk7XG4gICAgICAgIGRlY3J5cHRkYXRhLm1ldGhvZCA9IGxldmVsa2V5Lm1ldGhvZDtcbiAgICAgICAgZGVjcnlwdGRhdGEuYmFzZXVyaSA9IGxldmVsa2V5LmJhc2V1cmk7XG4gICAgICAgIGRlY3J5cHRkYXRhLnJlbHVyaSA9IGxldmVsa2V5LnJlbHVyaTtcbiAgICAgICAgZGVjcnlwdGRhdGEuaXYgPSB0aGlzLmNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVjcnlwdGRhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2xvbmVPYmonLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZU9iaihvYmopIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VybCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMuX3VybCAmJiB0aGlzLnJlbHVybCkge1xuICAgICAgICB0aGlzLl91cmwgPSBfdXJsVG9vbGtpdDIuZGVmYXVsdC5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVybCwgdGhpcy5yZWx1cmwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl91cmwgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcm9ncmFtRGF0ZVRpbWUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLl9wcm9ncmFtRGF0ZVRpbWUgJiYgdGhpcy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgdGhpcy5fcHJvZ3JhbURhdGVUaW1lID0gbmV3IERhdGUoRGF0ZS5wYXJzZSh0aGlzLnJhd1Byb2dyYW1EYXRlVGltZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyYW1EYXRlVGltZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdieXRlUmFuZ2UnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UpIHtcbiAgICAgICAgdmFyIGJ5dGVSYW5nZSA9IHRoaXMuX2J5dGVSYW5nZSA9IFtdO1xuICAgICAgICBpZiAodGhpcy5yYXdCeXRlUmFuZ2UpIHtcbiAgICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5yYXdCeXRlUmFuZ2Uuc3BsaXQoJ0AnLCAyKTtcbiAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgPSB0aGlzLmxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgICBieXRlUmFuZ2VbMF0gPSBsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0ID8gbGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA6IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVSYW5nZVswXSA9IHBhcnNlSW50KHBhcmFtc1sxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ5dGVSYW5nZVsxXSA9IHBhcnNlSW50KHBhcmFtc1swXSkgKyBieXRlUmFuZ2VbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9ieXRlUmFuZ2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnl0ZVJhbmdlU3RhcnRPZmZzZXQnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzBdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J5dGVSYW5nZUVuZE9mZnNldCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVjcnlwdGRhdGEnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLl9kZWNyeXB0ZGF0YSkge1xuICAgICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IHRoaXMuZnJhZ21lbnREZWNyeXB0ZGF0YUZyb21MZXZlbGtleSh0aGlzLmxldmVsa2V5LCB0aGlzLnNuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9kZWNyeXB0ZGF0YTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRnJhZ21lbnQ7XG59KCk7XG5cbnZhciBQbGF5bGlzdExvYWRlciA9IGZ1bmN0aW9uIChfRXZlbnRIYW5kbGVyKSB7XG4gIF9pbmhlcml0cyhQbGF5bGlzdExvYWRlciwgX0V2ZW50SGFuZGxlcik7XG5cbiAgZnVuY3Rpb24gUGxheWxpc3RMb2FkZXIoaGxzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXlsaXN0TG9hZGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQbGF5bGlzdExvYWRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBsYXlsaXN0TG9hZGVyKSkuY2FsbCh0aGlzLCBobHMsIF9ldmVudHMyLmRlZmF1bHQuTUFOSUZFU1RfTE9BRElORywgX2V2ZW50czIuZGVmYXVsdC5MRVZFTF9MT0FESU5HLCBfZXZlbnRzMi5kZWZhdWx0LkFVRElPX1RSQUNLX0xPQURJTkcsIF9ldmVudHMyLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tfTE9BRElORykpO1xuXG4gICAgX3RoaXMubG9hZGVycyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQbGF5bGlzdExvYWRlciwgW3tcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGZvciAodmFyIGxvYWRlck5hbWUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbbG9hZGVyTmFtZV07XG4gICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgICAgIF9ldmVudEhhbmRsZXIyLmRlZmF1bHQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1hbmlmZXN0TG9hZGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKGRhdGEpIHtcbiAgICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlOiAnbWFuaWZlc3QnIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTGV2ZWxMb2FkaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25MZXZlbExvYWRpbmcoZGF0YSkge1xuICAgICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGU6ICdsZXZlbCcsIGxldmVsOiBkYXRhLmxldmVsLCBpZDogZGF0YS5pZCB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkF1ZGlvVHJhY2tMb2FkaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25BdWRpb1RyYWNrTG9hZGluZyhkYXRhKSB7XG4gICAgICB0aGlzLmxvYWQoZGF0YS51cmwsIHsgdHlwZTogJ2F1ZGlvVHJhY2snLCBpZDogZGF0YS5pZCB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvblN1YnRpdGxlVHJhY2tMb2FkaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrTG9hZGluZyhkYXRhKSB7XG4gICAgICB0aGlzLmxvYWQoZGF0YS51cmwsIHsgdHlwZTogJ3N1YnRpdGxlVHJhY2snLCBpZDogZGF0YS5pZCB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwsIGNvbnRleHQpIHtcbiAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgdmFyIGxvYWRlckNvbnRleHQgPSBsb2FkZXIuY29udGV4dDtcbiAgICAgICAgaWYgKGxvYWRlckNvbnRleHQgJiYgbG9hZGVyQ29udGV4dC51cmwgPT09IHVybCkge1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLnRyYWNlKCdwbGF5bGlzdCByZXF1ZXN0IG9uZ29pbmcnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignYWJvcnQgcHJldmlvdXMgbG9hZGVyIGZvciB0eXBlOicgKyBjb250ZXh0LnR5cGUpO1xuICAgICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnLFxuICAgICAgICAgIHJldHJ5ID0gdm9pZCAwLFxuICAgICAgICAgIHRpbWVvdXQgPSB2b2lkIDAsXG4gICAgICAgICAgcmV0cnlEZWxheSA9IHZvaWQgMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5ID0gdm9pZCAwO1xuICAgICAgaWYgKGNvbnRleHQudHlwZSA9PT0gJ21hbmlmZXN0Jykge1xuICAgICAgICByZXRyeSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeTtcbiAgICAgICAgdGltZW91dCA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdUaW1lT3V0O1xuICAgICAgICByZXRyeURlbGF5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk7XG4gICAgICAgIG1heFJldHJ5RGVsYXkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0cnkgPSBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnk7XG4gICAgICAgIHRpbWVvdXQgPSBjb25maWcubGV2ZWxMb2FkaW5nVGltZU91dDtcbiAgICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgICBtYXhSZXRyeURlbGF5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdsb2FkaW5nIHBsYXlsaXN0IGZvciAnICsgY29udGV4dC50eXBlICsgJyAnICsgKGNvbnRleHQubGV2ZWwgfHwgY29udGV4dC5pZCkpO1xuICAgICAgfVxuICAgICAgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSBjb250ZXh0LmxvYWRlciA9IHR5cGVvZiBjb25maWcucExvYWRlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgY29uZmlnLnBMb2FkZXIoY29uZmlnKSA6IG5ldyBjb25maWcubG9hZGVyKGNvbmZpZyk7XG4gICAgICBjb250ZXh0LnVybCA9IHVybDtcbiAgICAgIGNvbnRleHQucmVzcG9uc2VUeXBlID0gJyc7XG5cbiAgICAgIHZhciBsb2FkZXJDb25maWcgPSB2b2lkIDAsXG4gICAgICAgICAgbG9hZGVyQ2FsbGJhY2tzID0gdm9pZCAwO1xuICAgICAgbG9hZGVyQ29uZmlnID0geyB0aW1lb3V0OiB0aW1lb3V0LCBtYXhSZXRyeTogcmV0cnksIHJldHJ5RGVsYXk6IHJldHJ5RGVsYXksIG1heFJldHJ5RGVsYXk6IG1heFJldHJ5RGVsYXkgfTtcbiAgICAgIGxvYWRlckNhbGxiYWNrcyA9IHsgb25TdWNjZXNzOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksIG9uRXJyb3I6IHRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksIG9uVGltZW91dDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpIH07XG4gICAgICBsb2FkZXIubG9hZChjb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVzb2x2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmUodXJsLCBiYXNlVXJsKSB7XG4gICAgICByZXR1cm4gX3VybFRvb2xraXQyLmRlZmF1bHQuYnVpbGRBYnNvbHV0ZVVSTChiYXNlVXJsLCB1cmwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BhcnNlTWFzdGVyUGxheWxpc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgYmFzZXVybCkge1xuICAgICAgdmFyIGxldmVscyA9IFtdLFxuICAgICAgICAgIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIE1BU1RFUl9QTEFZTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBsZXZlbCA9IHt9O1xuXG4gICAgICAgIHZhciBhdHRycyA9IGxldmVsLmF0dHJzID0gbmV3IF9hdHRyTGlzdDIuZGVmYXVsdChyZXN1bHRbMV0pO1xuICAgICAgICBsZXZlbC51cmwgPSB0aGlzLnJlc29sdmUocmVzdWx0WzJdLCBiYXNldXJsKTtcblxuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGF0dHJzLmRlY2ltYWxSZXNvbHV0aW9uKCdSRVNPTFVUSU9OJyk7XG4gICAgICAgIGlmIChyZXNvbHV0aW9uKSB7XG4gICAgICAgICAgbGV2ZWwud2lkdGggPSByZXNvbHV0aW9uLndpZHRoO1xuICAgICAgICAgIGxldmVsLmhlaWdodCA9IHJlc29sdXRpb24uaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGxldmVsLmJpdHJhdGUgPSBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJyk7XG4gICAgICAgIGxldmVsLm5hbWUgPSBhdHRycy5OQU1FO1xuXG4gICAgICAgIHZhciBjb2RlY3MgPSBhdHRycy5DT0RFQ1M7XG4gICAgICAgIGlmIChjb2RlY3MpIHtcbiAgICAgICAgICBjb2RlY3MgPSBjb2RlY3Muc3BsaXQoL1sgLF0rLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb2RlYyA9IGNvZGVjc1tpXTtcbiAgICAgICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdhdmMxJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGxldmVsLnZpZGVvQ29kZWMgPSB0aGlzLmF2YzF0b2F2Y290aShjb2RlYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXZlbC5hdWRpb0NvZGVjID0gY29kZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxldmVscztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCBiYXNldXJsLCB0eXBlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwLFxuICAgICAgICAgIG1lZGlhcyA9IFtdLFxuICAgICAgICAgIGlkID0gMDtcbiAgICAgIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtZWRpYSA9IHt9O1xuICAgICAgICB2YXIgYXR0cnMgPSBuZXcgX2F0dHJMaXN0Mi5kZWZhdWx0KHJlc3VsdFsxXSk7XG4gICAgICAgIGlmIChhdHRycy5UWVBFID09PSB0eXBlKSB7XG4gICAgICAgICAgbWVkaWEuZ3JvdXBJZCA9IGF0dHJzWydHUk9VUC1JRCddO1xuICAgICAgICAgIG1lZGlhLm5hbWUgPSBhdHRycy5OQU1FO1xuICAgICAgICAgIG1lZGlhLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIG1lZGlhLmRlZmF1bHQgPSBhdHRycy5ERUZBVUxUID09PSAnWUVTJztcbiAgICAgICAgICBtZWRpYS5hdXRvc2VsZWN0ID0gYXR0cnMuQVVUT1NFTEVDVCA9PT0gJ1lFUyc7XG4gICAgICAgICAgbWVkaWEuZm9yY2VkID0gYXR0cnMuRk9SQ0VEID09PSAnWUVTJztcbiAgICAgICAgICBpZiAoYXR0cnMuVVJJKSB7XG4gICAgICAgICAgICBtZWRpYS51cmwgPSB0aGlzLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVkaWEubGFuZyA9IGF0dHJzLkxBTkdVQUdFO1xuICAgICAgICAgIGlmICghbWVkaWEubmFtZSkge1xuICAgICAgICAgICAgbWVkaWEubmFtZSA9IG1lZGlhLmxhbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lZGlhLmlkID0gaWQrKztcbiAgICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZWRpYXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXZjMXRvYXZjb3RpJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXZjMXRvYXZjb3RpKGNvZGVjKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGF2Y2RhdGEgPSBjb2RlYy5zcGxpdCgnLicpO1xuICAgICAgaWYgKGF2Y2RhdGEubGVuZ3RoID4gMikge1xuICAgICAgICByZXN1bHQgPSBhdmNkYXRhLnNoaWZ0KCkgKyAnLic7XG4gICAgICAgIHJlc3VsdCArPSBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgcmVzdWx0ICs9ICgnMDAwJyArIHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY29kZWM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BhcnNlTGV2ZWxQbGF5bGlzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwsIGlkLCB0eXBlKSB7XG4gICAgICB2YXIgY3VycmVudFNOID0gMCxcbiAgICAgICAgICB0b3RhbGR1cmF0aW9uID0gMCxcbiAgICAgICAgICBsZXZlbCA9IHsgdHlwZTogbnVsbCwgdmVyc2lvbjogbnVsbCwgdXJsOiBiYXNldXJsLCBmcmFnbWVudHM6IFtdLCBsaXZlOiB0cnVlLCBzdGFydFNOOiAwIH0sXG4gICAgICAgICAgbGV2ZWxrZXkgPSBuZXcgTGV2ZWxLZXkoKSxcbiAgICAgICAgICBjYyA9IDAsXG4gICAgICAgICAgcHJldkZyYWcgPSBudWxsLFxuICAgICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQoKSxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgaTtcblxuICAgICAgTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVC5sYXN0SW5kZXggPSAwO1xuXG4gICAgICB3aGlsZSAoKHJlc3VsdCA9IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QuZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSByZXN1bHRbMV07XG4gICAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAgIC8vIElORlxuICAgICAgICAgIGZyYWcuZHVyYXRpb24gPSBwYXJzZUZsb2F0KGR1cmF0aW9uKTtcbiAgICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vZGFpbHltb3Rpb24vaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgICB2YXIgdGl0bGUgPSAoJyAnICsgcmVzdWx0WzJdKS5zbGljZSgxKTtcbiAgICAgICAgICBmcmFnLnRpdGxlID0gdGl0bGUgPyB0aXRsZSA6IG51bGw7XG4gICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godGl0bGUgPyBbJ0lORicsIGR1cmF0aW9uLCB0aXRsZV0gOiBbJ0lORicsIGR1cmF0aW9uXSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzNdKSB7XG4gICAgICAgICAgLy8gdXJsXG4gICAgICAgICAgaWYgKCFpc05hTihmcmFnLmR1cmF0aW9uKSkge1xuICAgICAgICAgICAgdmFyIHNuID0gY3VycmVudFNOKys7XG4gICAgICAgICAgICBmcmFnLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgZnJhZy5zdGFydCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgICAgICBmcmFnLmxldmVsa2V5ID0gbGV2ZWxrZXk7XG4gICAgICAgICAgICBmcmFnLnNuID0gc247XG4gICAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgICBmcmFnLmNjID0gY2M7XG4gICAgICAgICAgICBmcmFnLmJhc2V1cmwgPSBiYXNldXJsO1xuICAgICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL2RhaWx5bW90aW9uL2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgICAgICBmcmFnLnJlbHVybCA9ICgnICcgKyByZXN1bHRbM10pLnNsaWNlKDEpO1xuXG4gICAgICAgICAgICBsZXZlbC5mcmFnbWVudHMucHVzaChmcmFnKTtcbiAgICAgICAgICAgIHByZXZGcmFnID0gZnJhZztcbiAgICAgICAgICAgIHRvdGFsZHVyYXRpb24gKz0gZnJhZy5kdXJhdGlvbjtcblxuICAgICAgICAgICAgZnJhZyA9IG5ldyBGcmFnbWVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNF0pIHtcbiAgICAgICAgICAvLyBYLUJZVEVSQU5HRVxuICAgICAgICAgIGZyYWcucmF3Qnl0ZVJhbmdlID0gKCcgJyArIHJlc3VsdFs0XSkuc2xpY2UoMSk7XG4gICAgICAgICAgaWYgKHByZXZGcmFnKSB7XG4gICAgICAgICAgICB2YXIgbGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA9IHByZXZGcmFnLmJ5dGVSYW5nZUVuZE9mZnNldDtcbiAgICAgICAgICAgIGlmIChsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIGZyYWcubGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA9IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdFs1XSkge1xuICAgICAgICAgIC8vIFBST0dSQU0tREFURS1USU1FXG4gICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL2RhaWx5bW90aW9uL2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSAoJyAnICsgcmVzdWx0WzVdKS5zbGljZSgxKTtcbiAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ1BST0dSQU0tREFURS1USU1FJywgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHRbMF0ubWF0Y2goTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyk7XG4gICAgICAgICAgZm9yIChpID0gMTsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9kYWlseW1vdGlvbi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgIHZhciB2YWx1ZTEgPSAoJyAnICsgcmVzdWx0W2kgKyAxXSkuc2xpY2UoMSk7XG4gICAgICAgICAgdmFyIHZhbHVlMiA9ICgnICcgKyByZXN1bHRbaSArIDJdKS5zbGljZSgxKTtcblxuICAgICAgICAgIHN3aXRjaCAocmVzdWx0W2ldKSB7XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godmFsdWUyID8gW3ZhbHVlMSwgdmFsdWUyXSA6IFt2YWx1ZTFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQTEFZTElTVC1UWVBFJzpcbiAgICAgICAgICAgICAgbGV2ZWwudHlwZSA9IHZhbHVlMS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ01FRElBLVNFUVVFTkNFJzpcbiAgICAgICAgICAgICAgY3VycmVudFNOID0gbGV2ZWwuc3RhcnRTTiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVEFSR0VURFVSQVRJT04nOlxuICAgICAgICAgICAgICBsZXZlbC50YXJnZXRkdXJhdGlvbiA9IHBhcnNlRmxvYXQodmFsdWUxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdWRVJTSU9OJzpcbiAgICAgICAgICAgICAgbGV2ZWwudmVyc2lvbiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRVhUTTNVJzpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdFTkRMSVNUJzpcbiAgICAgICAgICAgICAgbGV2ZWwubGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0RJUyc6XG4gICAgICAgICAgICAgIGNjKys7XG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnRElTJ10pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0RJU0NPTlRJTlVJVFktU0VRJzpcbiAgICAgICAgICAgICAgY2MgPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0tFWSc6XG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1wYW50b3MtaHR0cC1saXZlLXN0cmVhbWluZy0wOCNzZWN0aW9uLTMuNC40XG4gICAgICAgICAgICAgIHZhciBkZWNyeXB0cGFyYW1zID0gdmFsdWUxO1xuICAgICAgICAgICAgICB2YXIga2V5QXR0cnMgPSBuZXcgX2F0dHJMaXN0Mi5kZWZhdWx0KGRlY3J5cHRwYXJhbXMpO1xuICAgICAgICAgICAgICB2YXIgZGVjcnlwdG1ldGhvZCA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ01FVEhPRCcpLFxuICAgICAgICAgICAgICAgICAgZGVjcnlwdHVyaSA9IGtleUF0dHJzLlVSSSxcbiAgICAgICAgICAgICAgICAgIGRlY3J5cHRpdiA9IGtleUF0dHJzLmhleGFkZWNpbWFsSW50ZWdlcignSVYnKTtcbiAgICAgICAgICAgICAgaWYgKGRlY3J5cHRtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBsZXZlbGtleSA9IG5ldyBMZXZlbEtleSgpO1xuICAgICAgICAgICAgICAgIGlmIChkZWNyeXB0dXJpICYmIFsnQUVTLTEyOCcsICdTQU1QTEUtQUVTJ10uaW5kZXhPZihkZWNyeXB0bWV0aG9kKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICBsZXZlbGtleS5tZXRob2QgPSBkZWNyeXB0bWV0aG9kO1xuICAgICAgICAgICAgICAgICAgLy8gVVJJIHRvIGdldCB0aGUga2V5XG4gICAgICAgICAgICAgICAgICBsZXZlbGtleS5iYXNldXJpID0gYmFzZXVybDtcbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5LnJlbHVyaSA9IGRlY3J5cHR1cmk7XG4gICAgICAgICAgICAgICAgICBsZXZlbGtleS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6YXRpb24gVmVjdG9yIChJVilcbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5Lml2ID0gZGVjcnlwdGl2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1NUQVJUJzpcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0UGFyYW1zID0gdmFsdWUxO1xuICAgICAgICAgICAgICB2YXIgc3RhcnRBdHRycyA9IG5ldyBfYXR0ckxpc3QyLmRlZmF1bHQoc3RhcnRQYXJhbXMpO1xuICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lT2Zmc2V0ID0gc3RhcnRBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnVElNRS1PRkZTRVQnKTtcbiAgICAgICAgICAgICAgLy9USU1FLU9GRlNFVCBjYW4gYmUgMFxuICAgICAgICAgICAgICBpZiAoIWlzTmFOKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5zdGFydFRpbWVPZmZzZXQgPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdNQVAnOlxuICAgICAgICAgICAgICB2YXIgbWFwQXR0cnMgPSBuZXcgX2F0dHJMaXN0Mi5kZWZhdWx0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIGZyYWcucmVsdXJsID0gbWFwQXR0cnMuVVJJO1xuICAgICAgICAgICAgICBmcmFnLnJhd0J5dGVSYW5nZSA9IG1hcEF0dHJzLkJZVEVSQU5HRTtcbiAgICAgICAgICAgICAgZnJhZy5iYXNldXJsID0gYmFzZXVybDtcbiAgICAgICAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICAgICAgICBmcmFnLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICBmcmFnLnNuID0gJ2luaXRTZWdtZW50JztcbiAgICAgICAgICAgICAgbGV2ZWwuaW5pdFNlZ21lbnQgPSBmcmFnO1xuICAgICAgICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignbGluZSBwYXJzZWQgYnV0IG5vdCBoYW5kbGVkOiAnICsgcmVzdWx0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmcmFnID0gcHJldkZyYWc7XG4gICAgICAvL2xvZ2dlci5sb2coJ2ZvdW5kICcgKyBsZXZlbC5mcmFnbWVudHMubGVuZ3RoICsgJyBmcmFnbWVudHMnKTtcbiAgICAgIGlmIChmcmFnICYmICFmcmFnLnJlbHVybCkge1xuICAgICAgICBsZXZlbC5mcmFnbWVudHMucG9wKCk7XG4gICAgICAgIHRvdGFsZHVyYXRpb24gLT0gZnJhZy5kdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIGxldmVsLnRvdGFsZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uO1xuICAgICAgbGV2ZWwuYXZlcmFnZXRhcmdldGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbiAvIGxldmVsLmZyYWdtZW50cy5sZW5ndGg7XG4gICAgICBsZXZlbC5lbmRTTiA9IGN1cnJlbnRTTiAtIDE7XG4gICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZHN1Y2Nlc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2Fkc3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSByZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHVybCA9IHJlc3BvbnNlLnVybCxcbiAgICAgICAgICB0eXBlID0gY29udGV4dC50eXBlLFxuICAgICAgICAgIGlkID0gY29udGV4dC5pZCxcbiAgICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWwsXG4gICAgICAgICAgaGxzID0gdGhpcy5obHM7XG5cbiAgICAgIHRoaXMubG9hZGVyc1t0eXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgIC8vIHJlc3BvbnNlVVJMIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2VycyAoaXQgaXMgdXNlZCB0byBkZXRlY3QgVVJMIHJlZGlyZWN0aW9uKVxuICAgICAgLy8gZGF0YS11cmkgbW9kZSBhbHNvIG5vdCBzdXBwb3J0ZWQgKGJ1dCBubyBuZWVkIHRvIGRldGVjdCByZWRpcmVjdGlvbilcbiAgICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCB8fCB1cmwuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgICAvLyBmYWxsYmFjayB0byBpbml0aWFsIFVSTFxuICAgICAgICB1cmwgPSBjb250ZXh0LnVybDtcbiAgICAgIH1cbiAgICAgIHN0YXRzLnRsb2FkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAvL3N0YXRzLm10aW1lID0gbmV3IERhdGUodGFyZ2V0LmdldFJlc3BvbnNlSGVhZGVyKCdMYXN0LU1vZGlmaWVkJykpO1xuICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUTTNVJykgPT09IDApIHtcbiAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUSU5GOicpID4gMCkge1xuICAgICAgICAgIHZhciBpc0xldmVsID0gdHlwZSAhPT0gJ2F1ZGlvVHJhY2snICYmIHR5cGUgIT09ICdzdWJ0aXRsZVRyYWNrJyxcbiAgICAgICAgICAgICAgbGV2ZWxJZCA9ICFpc05hTihsZXZlbCkgPyBsZXZlbCA6ICFpc05hTihpZCkgPyBpZCA6IDAsXG4gICAgICAgICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMucGFyc2VMZXZlbFBsYXlsaXN0KHN0cmluZywgdXJsLCBsZXZlbElkLCB0eXBlID09PSAnYXVkaW9UcmFjaycgPyAnYXVkaW8nIDogdHlwZSA9PT0gJ3N1YnRpdGxlVHJhY2snID8gJ3N1YnRpdGxlJyA6ICdtYWluJyk7XG4gICAgICAgICAgbGV2ZWxEZXRhaWxzLnRsb2FkID0gc3RhdHMudGxvYWQ7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdtYW5pZmVzdCcpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHJlcXVlc3QsIHN0cmVhbSBtYW5pZmVzdCAobm8gbWFzdGVyIHBsYXlsaXN0KSwgZmlyZSBtYW5pZmVzdCBsb2FkZWQgZXZlbnQgd2l0aCBsZXZlbCBkZXRhaWxzXG4gICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0Lk1BTklGRVNUX0xPQURFRCwgeyBsZXZlbHM6IFt7IHVybDogdXJsLCBkZXRhaWxzOiBsZXZlbERldGFpbHMgfV0sIGF1ZGlvVHJhY2tzOiBbXSwgdXJsOiB1cmwsIHN0YXRzOiBzdGF0cyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdHMudHBhcnNlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGlmIChsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChpc0xldmVsKSB7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuTEVWRUxfTE9BREVELCB7IGRldGFpbHM6IGxldmVsRGV0YWlscywgbGV2ZWw6IGxldmVsIHx8IDAsIGlkOiBpZCB8fCAwLCBzdGF0czogc3RhdHMgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvVHJhY2snKSB7XG4gICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5BVURJT19UUkFDS19MT0FERUQsIHsgZGV0YWlsczogbGV2ZWxEZXRhaWxzLCBpZDogaWQsIHN0YXRzOiBzdGF0cyB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3VidGl0bGVUcmFjaycpIHtcbiAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LlNVQlRJVExFX1RSQUNLX0xPQURFRCwgeyBkZXRhaWxzOiBsZXZlbERldGFpbHMsIGlkOiBpZCwgc3RhdHM6IHN0YXRzIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCB1cmw6IHVybCwgcmVhc29uOiAnaW52YWxpZCB0YXJnZXRkdXJhdGlvbicgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLnBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCB1cmwpO1xuICAgICAgICAgIC8vIG11bHRpIGxldmVsIHBsYXlsaXN0LCBwYXJzZSBsZXZlbCBpbmZvXG4gICAgICAgICAgaWYgKGxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBhdWRpb1RyYWNrcyA9IHRoaXMucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnQVVESU8nKTtcbiAgICAgICAgICAgIHZhciBzdWJ0aXRsZXMgPSB0aGlzLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgJ1NVQlRJVExFUycpO1xuICAgICAgICAgICAgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGZvdW5kIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcbiAgICAgICAgICAgICAgdmFyIGVtYmVkZGVkQXVkaW9Gb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBhdWRpb1RyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChhdWRpb1RyYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhdWRpb1RyYWNrLnVybCkge1xuICAgICAgICAgICAgICAgICAgZW1iZWRkZWRBdWRpb0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvLyBpZiBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBkZWZpbmVkLCBidXQgYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgd2UgbmVlZCB0byBzaWduYWwgdGhpcyBtYWluIGF1ZGlvIHRyYWNrXG4gICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIHdpdGggcGxheWxpc3RzIHdpdGggYWx0IGF1ZGlvIHJlbmRpdGlvbiBpbiB3aGljaCBxdWFsaXR5IGxldmVscyAobWFpbikgY29udGFpbnMgYm90aCBhdWRpbyt2aWRlby4gYnV0IHdpdGggbWl4ZWQgYXVkaW8gdHJhY2sgbm90IHNpZ25hbGVkXG4gICAgICAgICAgICAgIGlmIChlbWJlZGRlZEF1ZGlvRm91bmQgPT09IGZhbHNlICYmIGxldmVsc1swXS5hdWRpb0NvZGVjICYmICFsZXZlbHNbMF0uYXR0cnMuQVVESU8pIHtcbiAgICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2F1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsIGJ1dCBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBzaWduYWxlZCwgY3JlYXRlIG9uZScpO1xuICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2tzLnVuc2hpZnQoeyB0eXBlOiAnbWFpbicsIG5hbWU6ICdtYWluJyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5NQU5JRkVTVF9MT0FERUQsIHsgbGV2ZWxzOiBsZXZlbHMsIGF1ZGlvVHJhY2tzOiBhdWRpb1RyYWNrcywgc3VidGl0bGVzOiBzdWJ0aXRsZXMsIHVybDogdXJsLCBzdGF0czogc3RhdHMgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCB1cmw6IHVybCwgcmVhc29uOiAnbm8gbGV2ZWwgZm91bmQgaW4gbWFuaWZlc3QnIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuTUFOSUZFU1RfUEFSU0lOR19FUlJPUiwgZmF0YWw6IHRydWUsIHVybDogdXJsLCByZWFzb246ICdubyBFWFRNM1UgZGVsaW1pdGVyJyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkZXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkZXJyb3IocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICAgIHZhciBkZXRhaWxzLFxuICAgICAgICAgIGZhdGFsLFxuICAgICAgICAgIGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xuICAgICAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnbWFuaWZlc3QnOlxuICAgICAgICAgIGRldGFpbHMgPSBfZXJyb3JzLkVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX0VSUk9SO1xuICAgICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGV2ZWwnOlxuICAgICAgICAgIGRldGFpbHMgPSBfZXJyb3JzLkVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SO1xuICAgICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2F1ZGlvVHJhY2snOlxuICAgICAgICAgIGRldGFpbHMgPSBfZXJyb3JzLkVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SO1xuICAgICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogZGV0YWlscywgZmF0YWw6IGZhdGFsLCB1cmw6IGxvYWRlci51cmwsIGxvYWRlcjogbG9hZGVyLCByZXNwb25zZTogcmVzcG9uc2UsIGNvbnRleHQ6IGNvbnRleHQgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZHRpbWVvdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkdGltZW91dChzdGF0cywgY29udGV4dCkge1xuICAgICAgdmFyIGRldGFpbHMsXG4gICAgICAgICAgZmF0YWwsXG4gICAgICAgICAgbG9hZGVyID0gY29udGV4dC5sb2FkZXI7XG4gICAgICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgICAgICBjYXNlICdtYW5pZmVzdCc6XG4gICAgICAgICAgZGV0YWlscyA9IF9lcnJvcnMuRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfVElNRU9VVDtcbiAgICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xldmVsJzpcbiAgICAgICAgICBkZXRhaWxzID0gX2Vycm9ycy5FcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUO1xuICAgICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2F1ZGlvVHJhY2snOlxuICAgICAgICAgIGRldGFpbHMgPSBfZXJyb3JzLkVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ7XG4gICAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBkZXRhaWxzLCBmYXRhbDogZmF0YWwsIHVybDogbG9hZGVyLnVybCwgbG9hZGVyOiBsb2FkZXIsIGNvbnRleHQ6IGNvbnRleHQgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBsYXlsaXN0TG9hZGVyO1xufShfZXZlbnRIYW5kbGVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUGxheWxpc3RMb2FkZXI7XG5cbn0se1wiMlwiOjIsXCIzMVwiOjMxLFwiMzJcIjozMixcIjMzXCI6MzMsXCI0NVwiOjQ1LFwiNTBcIjo1MH1dLDQyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBHZW5lcmF0ZSBNUDQgQm94XG4qL1xuXG4vL2ltcG9ydCBIZXggZnJvbSAnLi4vdXRpbHMvaGV4JztcbnZhciBNUDQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1QNCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTVA0KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNUDQsIG51bGwsIFt7XG4gICAga2V5OiAnaW5pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBNUDQudHlwZXMgPSB7XG4gICAgICAgIGF2YzE6IFtdLCAvLyBjb2RpbmduYW1lXG4gICAgICAgIGF2Y0M6IFtdLFxuICAgICAgICBidHJ0OiBbXSxcbiAgICAgICAgZGluZjogW10sXG4gICAgICAgIGRyZWY6IFtdLFxuICAgICAgICBlc2RzOiBbXSxcbiAgICAgICAgZnR5cDogW10sXG4gICAgICAgIGhkbHI6IFtdLFxuICAgICAgICBtZGF0OiBbXSxcbiAgICAgICAgbWRoZDogW10sXG4gICAgICAgIG1kaWE6IFtdLFxuICAgICAgICBtZmhkOiBbXSxcbiAgICAgICAgbWluZjogW10sXG4gICAgICAgIG1vb2Y6IFtdLFxuICAgICAgICBtb292OiBbXSxcbiAgICAgICAgbXA0YTogW10sXG4gICAgICAgICcubXAzJzogW10sXG4gICAgICAgIG12ZXg6IFtdLFxuICAgICAgICBtdmhkOiBbXSxcbiAgICAgICAgcGFzcDogW10sXG4gICAgICAgIHNkdHA6IFtdLFxuICAgICAgICBzdGJsOiBbXSxcbiAgICAgICAgc3RjbzogW10sXG4gICAgICAgIHN0c2M6IFtdLFxuICAgICAgICBzdHNkOiBbXSxcbiAgICAgICAgc3RzejogW10sXG4gICAgICAgIHN0dHM6IFtdLFxuICAgICAgICB0ZmR0OiBbXSxcbiAgICAgICAgdGZoZDogW10sXG4gICAgICAgIHRyYWY6IFtdLFxuICAgICAgICB0cmFrOiBbXSxcbiAgICAgICAgdHJ1bjogW10sXG4gICAgICAgIHRyZXg6IFtdLFxuICAgICAgICB0a2hkOiBbXSxcbiAgICAgICAgdm1oZDogW10sXG4gICAgICAgIHNtaGQ6IFtdXG4gICAgICB9O1xuXG4gICAgICB2YXIgaTtcbiAgICAgIGZvciAoaSBpbiBNUDQudHlwZXMpIHtcbiAgICAgICAgaWYgKE1QNC50eXBlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIE1QNC50eXBlc1tpXSA9IFtpLmNoYXJDb2RlQXQoMCksIGkuY2hhckNvZGVBdCgxKSwgaS5jaGFyQ29kZUF0KDIpLCBpLmNoYXJDb2RlQXQoMyldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2aWRlb0hkbHIgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsIC8vIGhhbmRsZXJfdHlwZTogJ3ZpZGUnXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDU2LCAweDY5LCAweDY0LCAweDY1LCAweDZmLCAweDQ4LCAweDYxLCAweDZlLCAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdWaWRlb0hhbmRsZXInXG4gICAgICBdKTtcblxuICAgICAgdmFyIGF1ZGlvSGRsciA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHg3MywgMHg2ZiwgMHg3NSwgMHg2ZSwgLy8gaGFuZGxlcl90eXBlOiAnc291bidcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4NTMsIDB4NmYsIDB4NzUsIDB4NmUsIDB4NjQsIDB4NDgsIDB4NjEsIDB4NmUsIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1NvdW5kSGFuZGxlcidcbiAgICAgIF0pO1xuXG4gICAgICBNUDQuSERMUl9UWVBFUyA9IHtcbiAgICAgICAgJ3ZpZGVvJzogdmlkZW9IZGxyLFxuICAgICAgICAnYXVkaW8nOiBhdWRpb0hkbHJcbiAgICAgIH07XG5cbiAgICAgIHZhciBkcmVmID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGVudHJ5X2NvdW50XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDBjLCAvLyBlbnRyeV9zaXplXG4gICAgICAweDc1LCAweDcyLCAweDZjLCAweDIwLCAvLyAndXJsJyB0eXBlXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDEgLy8gZW50cnlfZmxhZ3NcbiAgICAgIF0pO1xuXG4gICAgICB2YXIgc3RjbyA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBlbnRyeV9jb3VudFxuICAgICAgXSk7XG5cbiAgICAgIE1QNC5TVFRTID0gTVA0LlNUU0MgPSBNUDQuU1RDTyA9IHN0Y287XG5cbiAgICAgIE1QNC5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBzYW1wbGVfc2l6ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMF0pO1xuICAgICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGdyYXBoaWNzbW9kZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBvcGNvbG9yXG4gICAgICBdKTtcbiAgICAgIE1QNC5TTUhEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAvLyBiYWxhbmNlXG4gICAgICAweDAwLCAweDAwIC8vIHJlc2VydmVkXG4gICAgICBdKTtcblxuICAgICAgTVA0LlNUU0QgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pOyAvLyBlbnRyeV9jb3VudFxuXG4gICAgICB2YXIgbWFqb3JCcmFuZCA9IG5ldyBVaW50OEFycmF5KFsxMDUsIDExNSwgMTExLCAxMDldKTsgLy8gaXNvbVxuICAgICAgdmFyIGF2YzFCcmFuZCA9IG5ldyBVaW50OEFycmF5KFs5NywgMTE4LCA5OSwgNDldKTsgLy8gYXZjMVxuICAgICAgdmFyIG1pbm9yVmVyc2lvbiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAxXSk7XG5cbiAgICAgIE1QNC5GVFlQID0gTVA0LmJveChNUDQudHlwZXMuZnR5cCwgbWFqb3JCcmFuZCwgbWlub3JWZXJzaW9uLCBtYWpvckJyYW5kLCBhdmMxQnJhbmQpO1xuICAgICAgTVA0LkRJTkYgPSBNUDQuYm94KE1QNC50eXBlcy5kaW5mLCBNUDQuYm94KE1QNC50eXBlcy5kcmVmLCBkcmVmKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYm94JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYm94KHR5cGUpIHtcbiAgICAgIHZhciBwYXlsb2FkID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICBzaXplID0gOCxcbiAgICAgICAgICBpID0gcGF5bG9hZC5sZW5ndGgsXG4gICAgICAgICAgbGVuID0gaSxcbiAgICAgICAgICByZXN1bHQ7XG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHNpemUgd2UgbmVlZCB0byBhbGxvY2F0ZVxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgcmVzdWx0WzBdID0gc2l6ZSA+PiAyNCAmIDB4ZmY7XG4gICAgICByZXN1bHRbMV0gPSBzaXplID4+IDE2ICYgMHhmZjtcbiAgICAgIHJlc3VsdFsyXSA9IHNpemUgPj4gOCAmIDB4ZmY7XG4gICAgICByZXN1bHRbM10gPSBzaXplICYgMHhmZjtcbiAgICAgIHJlc3VsdC5zZXQodHlwZSwgNCk7XG4gICAgICAvLyBjb3B5IHRoZSBwYXlsb2FkIGludG8gdGhlIHJlc3VsdFxuICAgICAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBjb3B5IHBheWxvYWRbaV0gYXJyYXkgQCBvZmZzZXQgc2l6ZVxuICAgICAgICByZXN1bHQuc2V0KHBheWxvYWRbaV0sIHNpemUpO1xuICAgICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGRscicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhkbHIodHlwZSkge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmhkbHIsIE1QNC5IRExSX1RZUEVTW3R5cGVdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtZGF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWRhdChkYXRhKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRhdCwgZGF0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWRoZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1kaGQodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaGQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAzLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgdGltZXNjYWxlID4+IDI0ICYgMHhGRiwgdGltZXNjYWxlID4+IDE2ICYgMHhGRiwgdGltZXNjYWxlID4+IDggJiAweEZGLCB0aW1lc2NhbGUgJiAweEZGLCAvLyB0aW1lc2NhbGVcbiAgICAgIGR1cmF0aW9uID4+IDI0LCBkdXJhdGlvbiA+PiAxNiAmIDB4RkYsIGR1cmF0aW9uID4+IDggJiAweEZGLCBkdXJhdGlvbiAmIDB4RkYsIC8vIGR1cmF0aW9uXG4gICAgICAweDU1LCAweGM0LCAvLyAndW5kJyBsYW5ndWFnZSAodW5kZXRlcm1pbmVkKVxuICAgICAgMHgwMCwgMHgwMF0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtZGlhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWRpYSh0cmFjaykge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaWEsIE1QNC5tZGhkKHRyYWNrLnRpbWVzY2FsZSwgdHJhY2suZHVyYXRpb24pLCBNUDQuaGRscih0cmFjay50eXBlKSwgTVA0Lm1pbmYodHJhY2spKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtZmhkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWZoZChzZXF1ZW5jZU51bWJlcikge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1maGQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgc2VxdWVuY2VOdW1iZXIgPj4gMjQsIHNlcXVlbmNlTnVtYmVyID4+IDE2ICYgMHhGRiwgc2VxdWVuY2VOdW1iZXIgPj4gOCAmIDB4RkYsIHNlcXVlbmNlTnVtYmVyICYgMHhGRl0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtaW5mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluZih0cmFjaykge1xuICAgICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnNtaGQsIE1QNC5TTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMudm1oZCwgTVA0LlZNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtb29mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9vZihzbiwgYmFzZU1lZGlhRGVjb2RlVGltZSwgdHJhY2spIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tb29mLCBNUDQubWZoZChzbiksIE1QNC50cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB0cmFja3MuLi4gKG9wdGlvbmFsKSB7YXJyYXl9IHRoZSB0cmFja3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbW92aWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbW9vdicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vb3YodHJhY2tzKSB7XG4gICAgICB2YXIgaSA9IHRyYWNrcy5sZW5ndGgsXG4gICAgICAgICAgYm94ZXMgPSBbXTtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBib3hlc1tpXSA9IE1QNC50cmFrKHRyYWNrc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubW9vdiwgTVA0Lm12aGQodHJhY2tzWzBdLnRpbWVzY2FsZSwgdHJhY2tzWzBdLmR1cmF0aW9uKV0uY29uY2F0KGJveGVzKS5jb25jYXQoTVA0Lm12ZXgodHJhY2tzKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ212ZXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtdmV4KHRyYWNrcykge1xuICAgICAgdmFyIGkgPSB0cmFja3MubGVuZ3RoLFxuICAgICAgICAgIGJveGVzID0gW107XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgYm94ZXNbaV0gPSBNUDQudHJleCh0cmFja3NbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1QNC5ib3guYXBwbHkobnVsbCwgW01QNC50eXBlcy5tdmV4XS5jb25jYXQoYm94ZXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtdmhkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXZoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMiwgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgIHRpbWVzY2FsZSA+PiAyNCAmIDB4RkYsIHRpbWVzY2FsZSA+PiAxNiAmIDB4RkYsIHRpbWVzY2FsZSA+PiA4ICYgMHhGRiwgdGltZXNjYWxlICYgMHhGRiwgLy8gdGltZXNjYWxlXG4gICAgICBkdXJhdGlvbiA+PiAyNCAmIDB4RkYsIGR1cmF0aW9uID4+IDE2ICYgMHhGRiwgZHVyYXRpb24gPj4gOCAmIDB4RkYsIGR1cmF0aW9uICYgMHhGRiwgLy8gZHVyYXRpb25cbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIC8vIDEuMCByYXRlXG4gICAgICAweDAxLCAweDAwLCAvLyAxLjAgdm9sdW1lXG4gICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiAvLyBuZXh0X3RyYWNrX0lEXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmhkLCBieXRlcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2R0cCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNkdHAodHJhY2spIHtcbiAgICAgIHZhciBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXSxcbiAgICAgICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KDQgKyBzYW1wbGVzLmxlbmd0aCksXG4gICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgaTtcbiAgICAgIC8vIGxlYXZlIHRoZSBmdWxsIGJveCBoZWFkZXIgKDQgYnl0ZXMpIGFsbCB6ZXJvXG4gICAgICAvLyB3cml0ZSB0aGUgc2FtcGxlIHRhYmxlXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XG4gICAgICAgIGJ5dGVzW2kgKyA0XSA9IGZsYWdzLmRlcGVuZHNPbiA8PCA0IHwgZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDIgfCBmbGFncy5oYXNSZWR1bmRhbmN5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc2R0cCwgYnl0ZXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0YmwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGJsKHRyYWNrKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RibCwgTVA0LnN0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuU1RUUyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c2MsIE1QNC5TVFNDKSwgTVA0LmJveChNUDQudHlwZXMuc3RzeiwgTVA0LlNUU1opLCBNUDQuYm94KE1QNC50eXBlcy5zdGNvLCBNUDQuU1RDTykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2F2YzEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdmMxKHRyYWNrKSB7XG4gICAgICB2YXIgc3BzID0gW10sXG4gICAgICAgICAgcHBzID0gW10sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGxlbjtcbiAgICAgIC8vIGFzc2VtYmxlIHRoZSBTUFNzXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5zcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YSA9IHRyYWNrLnNwc1tpXTtcbiAgICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICBzcHMucHVzaChsZW4gPj4+IDggJiAweEZGKTtcbiAgICAgICAgc3BzLnB1c2gobGVuICYgMHhGRik7XG4gICAgICAgIHNwcyA9IHNwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpOyAvLyBTUFNcbiAgICAgIH1cblxuICAgICAgLy8gYXNzZW1ibGUgdGhlIFBQU3NcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5wcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YSA9IHRyYWNrLnBwc1tpXTtcbiAgICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICBwcHMucHVzaChsZW4gPj4+IDggJiAweEZGKTtcbiAgICAgICAgcHBzLnB1c2gobGVuICYgMHhGRik7XG4gICAgICAgIHBwcyA9IHBwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXZjYyA9IE1QNC5ib3goTVA0LnR5cGVzLmF2Y0MsIG5ldyBVaW50OEFycmF5KFsweDAxLCAvLyB2ZXJzaW9uXG4gICAgICBzcHNbM10sIC8vIHByb2ZpbGVcbiAgICAgIHNwc1s0XSwgLy8gcHJvZmlsZSBjb21wYXRcbiAgICAgIHNwc1s1XSwgLy8gbGV2ZWxcbiAgICAgIDB4ZmMgfCAzLCAvLyBsZW5ndGhTaXplTWludXNPbmUsIGhhcmQtY29kZWQgdG8gNCBieXRlc1xuICAgICAgMHhFMCB8IHRyYWNrLnNwcy5sZW5ndGggLy8gM2JpdCByZXNlcnZlZCAoMTExKSArIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgICBdLmNvbmNhdChzcHMpLmNvbmNhdChbdHJhY2sucHBzLmxlbmd0aCAvLyBudW1PZlBpY3R1cmVQYXJhbWV0ZXJTZXRzXG4gICAgICBdKS5jb25jYXQocHBzKSkpLFxuICAgICAgICAgIC8vIFwiUFBTXCJcbiAgICAgIHdpZHRoID0gdHJhY2sud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0LFxuICAgICAgICAgIGhTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1swXSxcbiAgICAgICAgICB2U3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMV07XG4gICAgICAvL2NvbnNvbGUubG9nKCdhdmNjOicgKyBIZXguaGV4RHVtcChhdmNjKSk7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuYXZjMSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgIHdpZHRoID4+IDggJiAweEZGLCB3aWR0aCAmIDB4ZmYsIC8vIHdpZHRoXG4gICAgICBoZWlnaHQgPj4gOCAmIDB4RkYsIGhlaWdodCAmIDB4ZmYsIC8vIGhlaWdodFxuICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCwgLy8gaG9yaXpyZXNvbHV0aW9uXG4gICAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyB2ZXJ0cmVzb2x1dGlvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGZyYW1lX2NvdW50XG4gICAgICAweDEyLCAweDY0LCAweDYxLCAweDY5LCAweDZDLCAvL2RhaWx5bW90aW9uL2hscy5qc1xuICAgICAgMHg3OSwgMHg2RCwgMHg2RiwgMHg3NCwgMHg2OSwgMHg2RiwgMHg2RSwgMHgyRiwgMHg2OCwgMHg2QywgMHg3MywgMHgyRSwgMHg2QSwgMHg3MywgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY29tcHJlc3Nvcm5hbWVcbiAgICAgIDB4MDAsIDB4MTgsIC8vIGRlcHRoID0gMjRcbiAgICAgIDB4MTEsIDB4MTFdKSwgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgICAgYXZjYywgTVA0LmJveChNUDQudHlwZXMuYnRydCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MWMsIDB4OWMsIDB4ODAsIC8vIGJ1ZmZlclNpemVEQlxuICAgICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMCwgLy8gbWF4Qml0cmF0ZVxuICAgICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMF0pKSwgLy8gYXZnQml0cmF0ZVxuICAgICAgTVA0LmJveChNUDQudHlwZXMucGFzcCwgbmV3IFVpbnQ4QXJyYXkoW2hTcGFjaW5nID4+IDI0LCAvLyBoU3BhY2luZ1xuICAgICAgaFNwYWNpbmcgPj4gMTYgJiAweEZGLCBoU3BhY2luZyA+PiA4ICYgMHhGRiwgaFNwYWNpbmcgJiAweEZGLCB2U3BhY2luZyA+PiAyNCwgLy8gdlNwYWNpbmdcbiAgICAgIHZTcGFjaW5nID4+IDE2ICYgMHhGRiwgdlNwYWNpbmcgPj4gOCAmIDB4RkYsIHZTcGFjaW5nICYgMHhGRl0pKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZXNkcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVzZHModHJhY2spIHtcbiAgICAgIHZhciBjb25maWdsZW4gPSB0cmFjay5jb25maWcubGVuZ3RoO1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG5cbiAgICAgIDB4MDMsIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgMHgxNyArIGNvbmZpZ2xlbiwgLy8gbGVuZ3RoXG4gICAgICAweDAwLCAweDAxLCAvL2VzX2lkXG4gICAgICAweDAwLCAvLyBzdHJlYW1fcHJpb3JpdHlcblxuICAgICAgMHgwNCwgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgICAweDBmICsgY29uZmlnbGVuLCAvLyBsZW5ndGhcbiAgICAgIDB4NDAsIC8vY29kZWMgOiBtcGVnNF9hdWRpb1xuICAgICAgMHgxNSwgLy8gc3RyZWFtX3R5cGVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGJ1ZmZlcl9zaXplXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBhdmdCaXRyYXRlXG5cbiAgICAgIDB4MDUgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgICBdLmNvbmNhdChbY29uZmlnbGVuXSkuY29uY2F0KHRyYWNrLmNvbmZpZykuY29uY2F0KFsweDA2LCAweDAxLCAweDAyXSkpOyAvLyBHQVNwZWNpZmljQ29uZmlnKSk7IC8vIGxlbmd0aCArIGF1ZGlvIGNvbmZpZyBkZXNjcmlwdG9yXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbXA0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1wNGEodHJhY2spIHtcbiAgICAgIHZhciBhdWRpb3NhbXBsZXJhdGUgPSB0cmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXA0YSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCB0cmFjay5jaGFubmVsQ291bnQsIC8vIGNoYW5uZWxjb3VudFxuICAgICAgMHgwMCwgMHgxMCwgLy8gc2FtcGxlU2l6ZToxNmJpdHNcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkMlxuICAgICAgYXVkaW9zYW1wbGVyYXRlID4+IDggJiAweEZGLCBhdWRpb3NhbXBsZXJhdGUgJiAweGZmLCAvL1xuICAgICAgMHgwMCwgMHgwMF0pLCBNUDQuYm94KE1QNC50eXBlcy5lc2RzLCBNUDQuZXNkcyh0cmFjaykpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtcDMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtcDModHJhY2spIHtcbiAgICAgIHZhciBhdWRpb3NhbXBsZXJhdGUgPSB0cmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXNbJy5tcDMnXSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCB0cmFjay5jaGFubmVsQ291bnQsIC8vIGNoYW5uZWxjb3VudFxuICAgICAgMHgwMCwgMHgxMCwgLy8gc2FtcGxlU2l6ZToxNmJpdHNcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkMlxuICAgICAgYXVkaW9zYW1wbGVyYXRlID4+IDggJiAweEZGLCBhdWRpb3NhbXBsZXJhdGUgJiAweGZmLCAvL1xuICAgICAgMHgwMCwgMHgwMF0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdHNkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RzZCh0cmFjaykge1xuICAgICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgaWYgKCF0cmFjay5pc0FBQyAmJiB0cmFjay5jb2RlYyA9PT0gJ21wMycpIHtcbiAgICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDModHJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDRhKHRyYWNrKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5hdmMxKHRyYWNrKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndGtoZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRraGQodHJhY2spIHtcbiAgICAgIHZhciBpZCA9IHRyYWNrLmlkLFxuICAgICAgICAgIGR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gKiB0cmFjay50aW1lc2NhbGUsXG4gICAgICAgICAgd2lkdGggPSB0cmFjay53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSB0cmFjay5oZWlnaHQ7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudGtoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwNywgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICBpZCA+PiAyNCAmIDB4RkYsIGlkID4+IDE2ICYgMHhGRiwgaWQgPj4gOCAmIDB4RkYsIGlkICYgMHhGRiwgLy8gdHJhY2tfSURcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICBkdXJhdGlvbiA+PiAyNCwgZHVyYXRpb24gPj4gMTYgJiAweEZGLCBkdXJhdGlvbiA+PiA4ICYgMHhGRiwgZHVyYXRpb24gJiAweEZGLCAvLyBkdXJhdGlvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGxheWVyXG4gICAgICAweDAwLCAweDAwLCAvLyBhbHRlcm5hdGVfZ3JvdXBcbiAgICAgIDB4MDAsIDB4MDAsIC8vIG5vbi1hdWRpbyB0cmFjayB2b2x1bWVcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgICB3aWR0aCA+PiA4ICYgMHhGRiwgd2lkdGggJiAweEZGLCAweDAwLCAweDAwLCAvLyB3aWR0aFxuICAgICAgaGVpZ2h0ID4+IDggJiAweEZGLCBoZWlnaHQgJiAweEZGLCAweDAwLCAweDAwIC8vIGhlaWdodFxuICAgICAgXSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RyYWYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgICB2YXIgc2FtcGxlRGVwZW5kZW5jeVRhYmxlID0gTVA0LnNkdHAodHJhY2spLFxuICAgICAgICAgIGlkID0gdHJhY2suaWQ7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhZiwgTVA0LmJveChNUDQudHlwZXMudGZoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIGlkID4+IDI0LCBpZCA+PiAxNiAmIDBYRkYsIGlkID4+IDggJiAwWEZGLCBpZCAmIDB4RkZdKSksIE1QNC5ib3goTVA0LnR5cGVzLnRmZHQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lID4+IDI0LCBiYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2ICYgMFhGRiwgYmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4ICYgMFhGRiwgYmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4RkZdKSksIE1QNC50cnVuKHRyYWNrLCBzYW1wbGVEZXBlbmRlbmN5VGFibGUubGVuZ3RoICsgMTYgKyAvLyB0ZmhkXG4gICAgICAxNiArIC8vIHRmZHRcbiAgICAgIDggKyAvLyB0cmFmIGhlYWRlclxuICAgICAgMTYgKyAvLyBtZmhkXG4gICAgICA4ICsgLy8gbW9vZiBoZWFkZXJcbiAgICAgIDgpLCAvLyBtZGF0IGhlYWRlclxuICAgICAgc2FtcGxlRGVwZW5kZW5jeVRhYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHRyYWNrIGJveC5cbiAgICAgKiBAcGFyYW0gdHJhY2sge29iamVjdH0gYSB0cmFjayBkZWZpbml0aW9uXG4gICAgICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIHRyYWNrIGJveFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0cmFrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhayh0cmFjaykge1xuICAgICAgdHJhY2suZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiB8fCAweGZmZmZmZmZmO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWssIE1QNC50a2hkKHRyYWNrKSwgTVA0Lm1kaWEodHJhY2spKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0cmV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJleCh0cmFjaykge1xuICAgICAgdmFyIGlkID0gdHJhY2suaWQ7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJleCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIGlkID4+IDI0LCBpZCA+PiAxNiAmIDBYRkYsIGlkID4+IDggJiAwWEZGLCBpZCAmIDB4RkYsIC8vIHRyYWNrX0lEXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBkZWZhdWx0X3NhbXBsZV9kZXNjcmlwdGlvbl9pbmRleFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX3NpemVcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDEgLy8gZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgICAgIF0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0cnVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJ1bih0cmFjaywgb2Zmc2V0KSB7XG4gICAgICB2YXIgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW10sXG4gICAgICAgICAgbGVuID0gc2FtcGxlcy5sZW5ndGgsXG4gICAgICAgICAgYXJyYXlsZW4gPSAxMiArIDE2ICogbGVuLFxuICAgICAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlsZW4pLFxuICAgICAgICAgIGksXG4gICAgICAgICAgc2FtcGxlLFxuICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgY3RzO1xuICAgICAgb2Zmc2V0ICs9IDggKyBhcnJheWxlbjtcbiAgICAgIGFycmF5LnNldChbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDBmLCAweDAxLCAvLyBmbGFnc1xuICAgICAgbGVuID4+PiAyNCAmIDB4RkYsIGxlbiA+Pj4gMTYgJiAweEZGLCBsZW4gPj4+IDggJiAweEZGLCBsZW4gJiAweEZGLCAvLyBzYW1wbGVfY291bnRcbiAgICAgIG9mZnNldCA+Pj4gMjQgJiAweEZGLCBvZmZzZXQgPj4+IDE2ICYgMHhGRiwgb2Zmc2V0ID4+PiA4ICYgMHhGRiwgb2Zmc2V0ICYgMHhGRiAvLyBkYXRhX29mZnNldFxuICAgICAgXSwgMCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc2FtcGxlID0gc2FtcGxlc1tpXTtcbiAgICAgICAgZHVyYXRpb24gPSBzYW1wbGUuZHVyYXRpb247XG4gICAgICAgIHNpemUgPSBzYW1wbGUuc2l6ZTtcbiAgICAgICAgZmxhZ3MgPSBzYW1wbGUuZmxhZ3M7XG4gICAgICAgIGN0cyA9IHNhbXBsZS5jdHM7XG4gICAgICAgIGFycmF5LnNldChbZHVyYXRpb24gPj4+IDI0ICYgMHhGRiwgZHVyYXRpb24gPj4+IDE2ICYgMHhGRiwgZHVyYXRpb24gPj4+IDggJiAweEZGLCBkdXJhdGlvbiAmIDB4RkYsIC8vIHNhbXBsZV9kdXJhdGlvblxuICAgICAgICBzaXplID4+PiAyNCAmIDB4RkYsIHNpemUgPj4+IDE2ICYgMHhGRiwgc2l6ZSA+Pj4gOCAmIDB4RkYsIHNpemUgJiAweEZGLCAvLyBzYW1wbGVfc2l6ZVxuICAgICAgICBmbGFncy5pc0xlYWRpbmcgPDwgMiB8IGZsYWdzLmRlcGVuZHNPbiwgZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDYgfCBmbGFncy5oYXNSZWR1bmRhbmN5IDw8IDQgfCBmbGFncy5wYWRkaW5nVmFsdWUgPDwgMSB8IGZsYWdzLmlzTm9uU3luYywgZmxhZ3MuZGVncmFkUHJpbyAmIDB4RjAgPDwgOCwgZmxhZ3MuZGVncmFkUHJpbyAmIDB4MEYsIC8vIHNhbXBsZV9mbGFnc1xuICAgICAgICBjdHMgPj4+IDI0ICYgMHhGRiwgY3RzID4+PiAxNiAmIDB4RkYsIGN0cyA+Pj4gOCAmIDB4RkYsIGN0cyAmIDB4RkYgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICAgIF0sIDEyICsgMTYgKiBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cnVuLCBhcnJheSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5pdFNlZ21lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0U2VnbWVudCh0cmFja3MpIHtcbiAgICAgIGlmICghTVA0LnR5cGVzKSB7XG4gICAgICAgIE1QNC5pbml0KCk7XG4gICAgICB9XG4gICAgICB2YXIgbW92aWUgPSBNUDQubW9vdih0cmFja3MpLFxuICAgICAgICAgIHJlc3VsdDtcbiAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KE1QNC5GVFlQLmJ5dGVMZW5ndGggKyBtb3ZpZS5ieXRlTGVuZ3RoKTtcbiAgICAgIHJlc3VsdC5zZXQoTVA0LkZUWVApO1xuICAgICAgcmVzdWx0LnNldChtb3ZpZSwgTVA0LkZUWVAuYnl0ZUxlbmd0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNUDQ7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1QNDtcblxufSx7fV0sNDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpOyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBmTVA0IHJlbXV4ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgX2FhYyA9IF9kZXJlcV8oMzQpO1xuXG52YXIgX2FhYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hYWMpO1xuXG52YXIgX2V2ZW50cyA9IF9kZXJlcV8oMzMpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG52YXIgX21wNEdlbmVyYXRvciA9IF9kZXJlcV8oNDIpO1xuXG52YXIgX21wNEdlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tcDRHZW5lcmF0b3IpO1xuXG52YXIgX2Vycm9ycyA9IF9kZXJlcV8oMzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgTVA0UmVtdXhlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTVA0UmVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1QNFJlbXV4ZXIpO1xuXG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuUEVTMk1QNFNDQUxFRkFDVE9SID0gNDtcbiAgICB0aGlzLlBFU19USU1FU0NBTEUgPSA5MDAwMDtcbiAgICB0aGlzLk1QNF9USU1FU0NBTEUgPSB0aGlzLlBFU19USU1FU0NBTEUgLyB0aGlzLlBFUzJNUDRTQ0FMRUZBQ1RPUjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNUDRSZW11eGVyLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge31cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0VGltZVN0YW1wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRUaW1lU3RhbXAoZGVmYXVsdFRpbWVTdGFtcCkge1xuICAgICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSBkZWZhdWx0VGltZVN0YW1wO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0SW5pdFNlZ21lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KCkge1xuICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbXV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICAvLyBnZW5lcmF0ZSBJbml0IFNlZ21lbnQgaWYgbmVlZGVkXG4gICAgICBpZiAoIXRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgICAvLyBQdXJwb3NlZnVsbHkgcmVtdXhpbmcgYXVkaW8gYmVmb3JlIHZpZGVvLCBzbyB0aGF0IHJlbXV4VmlkZW8gY2FuIHVzZSBuZXh0QXVkaW9QdHMsIHdoaWNoIGlzXG4gICAgICAgIC8vIGNhbGN1bGF0ZWQgaW4gcmVtdXhBdWRpby5cbiAgICAgICAgLy9sb2dnZXIubG9nKCduYiBBQUMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGF1ZGlvRGF0YSA9IHRoaXMucmVtdXhBdWRpbyhhdWRpb1RyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAgIC8vbG9nZ2VyLmxvZygnbmIgQVZDIHNhbXBsZXM6JyArIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYXVkaW9UcmFja0xlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChhdWRpb0RhdGEpIHtcbiAgICAgICAgICAgICAgYXVkaW9UcmFja0xlbmd0aCA9IGF1ZGlvRGF0YS5lbmRQVFMgLSBhdWRpb0RhdGEuc3RhcnRQVFM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2aWRlb0RhdGEgPSB2b2lkIDA7XG4gICAgICAgICAgLy9sb2dnZXIubG9nKCduYiBBVkMgc2FtcGxlczonICsgdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgICAgICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZpZGVvRGF0YSA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZpZGVvRGF0YSAmJiBhdWRpb1RyYWNrLmNvZGVjKSB7XG4gICAgICAgICAgICB0aGlzLnJlbXV4RW1wdHlBdWRpbyhhdWRpb1RyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCB2aWRlb0RhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9sb2dnZXIubG9nKCduYiBJRDMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgICBpZiAoaWQzVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5yZW11eElEMyhpZDNUcmFjaywgdGltZU9mZnNldCk7XG4gICAgICB9XG4gICAgICAvL2xvZ2dlci5sb2coJ25iIElEMyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICAgIGlmICh0ZXh0VHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5yZW11eFRleHQodGV4dFRyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIC8vbm90aWZ5IGVuZCBvZiBwYXJzaW5nXG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNFRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2VuZXJhdGVJUycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCkge1xuICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcixcbiAgICAgICAgICBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMsXG4gICAgICAgICAgdmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLFxuICAgICAgICAgIHBlc1RpbWVTY2FsZSA9IHRoaXMuUEVTX1RJTUVTQ0FMRSxcbiAgICAgICAgICB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkLFxuICAgICAgICAgIGNvbnRhaW5lciA9ICdhdWRpby9tcDQnLFxuICAgICAgICAgIHRyYWNrcyA9IHt9LFxuICAgICAgICAgIGRhdGEgPSB7IHRyYWNrczogdHJhY2tzLCB1bmlxdWU6IGZhbHNlIH0sXG4gICAgICAgICAgY29tcHV0ZVBUU0RUUyA9IHRoaXMuX2luaXRQVFMgPT09IHVuZGVmaW5lZCxcbiAgICAgICAgICBpbml0UFRTLFxuICAgICAgICAgIGluaXREVFM7XG5cbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBpZiAoYXVkaW9UcmFjay5jb25maWcgJiYgYXVkaW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suYXVkaW9zYW1wbGVyYXRlO1xuICAgICAgICAvLyBNUDQgZHVyYXRpb24gKHRyYWNrIGR1cmF0aW9uIGluIHNlY29uZHMgbXVsdGlwbGllZCBieSB0aW1lc2NhbGUpIGlzIGNvZGVkIG9uIDMyIGJpdHNcbiAgICAgICAgLy8gd2Uga25vdyB0aGF0IGVhY2ggQUFDIHNhbXBsZSBjb250YWlucyAxMDI0IGZyYW1lcy4uLi5cbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gYXZvaWQgb3ZlcmZsb3dpbmcgdGhlIDMyIGJpdCBjb3VudGVyIGZvciBsYXJnZSBkdXJhdGlvbiwgd2UgdXNlIHNtYWxsZXIgdGltZXNjYWxlICh0aW1lc2NhbGUvZ2NkKVxuICAgICAgICAvLyB3ZSBqdXN0IG5lZWQgdG8gZW5zdXJlIHRoYXQgQUFDIHNhbXBsZSBkdXJhdGlvbiB3aWxsIHN0aWxsIGJlIGFuIGludGVnZXIgKHdpbGwgYmUgMTAyNC9nY2QpXG4gICAgICAgIGlmIChhdWRpb1RyYWNrLnRpbWVzY2FsZSAqIGF1ZGlvVHJhY2suZHVyYXRpb24gPiBNYXRoLnBvdygyLCAzMikpIHtcbiAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGdyZWF0ZXN0Q29tbW9uRGl2aXNvciA9IGZ1bmN0aW9uIGdyZWF0ZXN0Q29tbW9uRGl2aXNvcihhLCBiKSB7XG4gICAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBncmVhdGVzdENvbW1vbkRpdmlzb3IoYiwgYSAlIGIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5hdWRpb3NhbXBsZXJhdGUgLyBncmVhdGVzdENvbW1vbkRpdmlzb3IoYXVkaW9UcmFjay5hdWRpb3NhbXBsZXJhdGUsIGF1ZGlvVHJhY2suaXNBQUMgPyAxMDI0IDogMTE1Mik7XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2F1ZGlvIG1wNCB0aW1lc2NhbGUgOicgKyBhdWRpb1RyYWNrLnRpbWVzY2FsZSk7XG4gICAgICAgIGlmICghYXVkaW9UcmFjay5pc0FBQykge1xuICAgICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLm1wZWcpIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBhbmQgU2FmYXJpXG4gICAgICAgICAgICBjb250YWluZXIgPSAnYXVkaW8vbXBlZyc7XG4gICAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJyc7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlU3VwcG9ydGVkLm1wMykge1xuICAgICAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICdtcDMnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgICAgY29kZWM6IGF1ZGlvVHJhY2suY29kZWMsXG4gICAgICAgICAgaW5pdFNlZ21lbnQ6ICFhdWRpb1RyYWNrLmlzQUFDICYmIHR5cGVTdXBwb3J0ZWQubXBlZyA/IG5ldyBVaW50OEFycmF5KCkgOiBfbXA0R2VuZXJhdG9yMi5kZWZhdWx0LmluaXRTZWdtZW50KFthdWRpb1RyYWNrXSksXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudDogYXVkaW9UcmFjay5jaGFubmVsQ291bnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIHRoaXMgZGVtdXhpbmcgY29udGV4dC4gZm9yIGF1ZGlvLCBQVFMgPSBEVFNcbiAgICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IGF1ZGlvU2FtcGxlc1swXS5wdHMgLSBwZXNUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHZpZGVvVHJhY2sudGltZXNjYWxlID0gdGhpcy5NUDRfVElNRVNDQUxFO1xuICAgICAgICB0cmFja3MudmlkZW8gPSB7XG4gICAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgICBjb2RlYzogdmlkZW9UcmFjay5jb2RlYyxcbiAgICAgICAgICBpbml0U2VnbWVudDogX21wNEdlbmVyYXRvcjIuZGVmYXVsdC5pbml0U2VnbWVudChbdmlkZW9UcmFja10pLFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICB3aWR0aDogdmlkZW9UcmFjay53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdmlkZW9UcmFjay5oZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgICAgaW5pdFBUUyA9IE1hdGgubWluKGluaXRQVFMsIHZpZGVvU2FtcGxlc1swXS5wdHMgLSBwZXNUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgICAgICBpbml0RFRTID0gTWF0aC5taW4oaW5pdERUUywgdmlkZW9TYW1wbGVzWzBdLmR0cyAtIHBlc1RpbWVTY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LklOSVRfUFRTX0ZPVU5ELCB7IGluaXRQVFM6IGluaXRQVFMgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRyYWNrcykubGVuZ3RoKSB7XG4gICAgICAgIG9ic2VydmVyLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBkYXRhKTtcbiAgICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IHRydWU7XG4gICAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgICAgdGhpcy5faW5pdFBUUyA9IGluaXRQVFM7XG4gICAgICAgICAgdGhpcy5faW5pdERUUyA9IGluaXREVFM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ic2VydmVyLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdubyBhdWRpby92aWRlbyBzYW1wbGVzIGZvdW5kJyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW11eFZpZGVvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtdXhWaWRlbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCkge1xuICAgICAgdmFyIG9mZnNldCA9IDgsXG4gICAgICAgICAgcGVzVGltZVNjYWxlID0gdGhpcy5QRVNfVElNRVNDQUxFLFxuICAgICAgICAgIHBlczJtcDRTY2FsZUZhY3RvciA9IHRoaXMuUEVTMk1QNFNDQUxFRkFDVE9SLFxuICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uLFxuICAgICAgICAgIG1kYXQsXG4gICAgICAgICAgbW9vZixcbiAgICAgICAgICBmaXJzdFBUUyxcbiAgICAgICAgICBmaXJzdERUUyxcbiAgICAgICAgICBuZXh0RFRTLFxuICAgICAgICAgIGxhc3RQVFMsXG4gICAgICAgICAgbGFzdERUUyxcbiAgICAgICAgICBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzLFxuICAgICAgICAgIG91dHB1dFNhbXBsZXMgPSBbXSxcbiAgICAgICAgICBuYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoLFxuICAgICAgICAgIHB0c05vcm1hbGl6ZSA9IHRoaXMuX1BUU05vcm1hbGl6ZSxcbiAgICAgICAgICBpbml0RFRTID0gdGhpcy5faW5pdERUUztcblxuICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFjay5zYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyAgIGxldCBhdmNTYW1wbGUgPSB0cmFjay5zYW1wbGVzW2ldO1xuICAgICAgLy8gICBsZXQgdW5pdHMgPSBhdmNTYW1wbGUudW5pdHMudW5pdHM7XG4gICAgICAvLyAgIGxldCB1bml0c1N0cmluZyA9ICcnO1xuICAgICAgLy8gICBmb3IgKGxldCBqID0gMDsgaiA8IHVuaXRzLmxlbmd0aCA7IGorKykge1xuICAgICAgLy8gICAgIHVuaXRzU3RyaW5nICs9IHVuaXRzW2pdLnR5cGUgKyAnLCc7XG4gICAgICAvLyAgICAgaWYgKHVuaXRzW2pdLmRhdGEubGVuZ3RoIDwgNTAwKSB7XG4gICAgICAvLyAgICAgICB1bml0c1N0cmluZyArPSBIZXguaGV4RHVtcCh1bml0c1tqXS5kYXRhKTtcbiAgICAgIC8vICAgICB9XG4gICAgICAvLyAgIH1cbiAgICAgIC8vICAgbG9nZ2VyLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICcsJyArIHVuaXRzU3RyaW5nICsgYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCk7XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIHNvcnQgdmlkZW8gc2FtcGxlcyBieSBEVFMgdGhlbiBQVFMgb3JkZXJcbiAgICAgIGlucHV0U2FtcGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBkZWx0YWR0cyA9IGEuZHRzIC0gYi5kdHM7XG4gICAgICAgIHJldHVybiBkZWx0YWR0cyA/IGRlbHRhZHRzIDogYS5wdHMgLSBiLnB0cztcbiAgICAgIH0pO1xuXG4gICAgICAvLyBoYW5kbGUgYnJva2VuIHN0cmVhbXMgd2l0aCBQVFMgPCBEVFMsIHRvbGVyYW5jZSB1cCAyMDBtcyAoMTgwMDAgaW4gOTBrSHogdGltZXNjYWxlKVxuICAgICAgdmFyIFBUU0RUU3NoaWZ0ID0gaW5wdXRTYW1wbGVzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocHJldiwgY3Vyci5wdHMgLSBjdXJyLmR0cyksIC0xODAwMCk7XG4gICAgICB9LCAwKTtcbiAgICAgIGlmIChQVFNEVFNzaGlmdCA8IDApIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignUFRTIDwgRFRTIGRldGVjdGVkIGluIHZpZGVvIHNhbXBsZXMsIHNoaWZ0aW5nIERUUyBieSAnICsgTWF0aC5yb3VuZChQVFNEVFNzaGlmdCAvIDkwKSArICcgbXMgdG8gb3ZlcmNvbWUgdGhpcyBpc3N1ZScpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlucHV0U2FtcGxlc1tpXS5kdHMgKz0gUFRTRFRTc2hpZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUFRTIGlzIGNvZGVkIG9uIDMzYml0cywgYW5kIGNhbiBsb29wIGZyb20gLTJeMzIgdG8gMl4zMlxuICAgICAgLy8gcHRzTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxuICAgICAgdmFyIG5leHRBdmNEdHMgPSB2b2lkIDA7XG4gICAgICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxuICAgICAgaWYgKGNvbnRpZ3VvdXMpIHtcbiAgICAgICAgLy8gaWYgcGFyc2VkIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXMgd2l0aCBsYXN0IG9uZSwgbGV0J3MgdXNlIGxhc3QgRFRTIHZhbHVlIGFzIHJlZmVyZW5jZVxuICAgICAgICBuZXh0QXZjRHRzID0gdGhpcy5uZXh0QXZjRHRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgbm90IGNvbnRpZ3VvdXMsIGxldCdzIHVzZSB0YXJnZXQgdGltZU9mZnNldFxuICAgICAgICBuZXh0QXZjRHRzID0gdGltZU9mZnNldCAqIHBlc1RpbWVTY2FsZTtcbiAgICAgIH1cblxuICAgICAgLy8gY29tcHV0ZSBmaXJzdCBEVFMgYW5kIGxhc3QgRFRTLCBub3JtYWxpemUgdGhlbSBhZ2FpbnN0IHJlZmVyZW5jZSB2YWx1ZVxuICAgICAgdmFyIHNhbXBsZSA9IGlucHV0U2FtcGxlc1swXTtcbiAgICAgIGZpcnN0RFRTID0gTWF0aC5tYXgocHRzTm9ybWFsaXplKHNhbXBsZS5kdHMgLSBpbml0RFRTLCBuZXh0QXZjRHRzKSwgMCk7XG4gICAgICBmaXJzdFBUUyA9IE1hdGgubWF4KHB0c05vcm1hbGl6ZShzYW1wbGUucHRzIC0gaW5pdERUUywgbmV4dEF2Y0R0cyksIDApO1xuXG4gICAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY2Nyb3NzIGNvbnNlY3V0aXZlIGZyYWdtZW50cyAodGhpcyBpcyB0byByZW1vdmUgaW50ZXItZnJhZ21lbnQgZ2FwL2hvbGUpXG4gICAgICB2YXIgZGVsdGEgPSBNYXRoLnJvdW5kKChmaXJzdERUUyAtIG5leHRBdmNEdHMpIC8gOTApO1xuICAgICAgLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXG4gICAgICBpZiAoY29udGlndW91cykge1xuICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICBpZiAoZGVsdGEgPiAxKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ0FWQzonICsgZGVsdGEgKyAnIG1zIGhvbGUgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWQsZmlsbGluZyBpdCcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPCAtMSkge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdBVkM6JyArIC1kZWx0YSArICcgbXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcmVtb3ZlIGhvbGUvZ2FwIDogc2V0IERUUyB0byBuZXh0IGV4cGVjdGVkIERUU1xuICAgICAgICAgIGZpcnN0RFRTID0gbmV4dEF2Y0R0cztcbiAgICAgICAgICBpbnB1dFNhbXBsZXNbMF0uZHRzID0gZmlyc3REVFMgKyBpbml0RFRTO1xuICAgICAgICAgIC8vIG9mZnNldCBQVFMgYXMgd2VsbCwgZW5zdXJlIHRoYXQgUFRTIGlzIHNtYWxsZXIgb3IgZXF1YWwgdGhhbiBuZXcgRFRTXG4gICAgICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heChmaXJzdFBUUyAtIGRlbHRhLCBuZXh0QXZjRHRzKTtcbiAgICAgICAgICBpbnB1dFNhbXBsZXNbMF0ucHRzID0gZmlyc3RQVFMgKyBpbml0RFRTO1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnVmlkZW8vUFRTL0RUUyBhZGp1c3RlZDogJyArIE1hdGgucm91bmQoZmlyc3RQVFMgLyA5MCkgKyAnLycgKyBNYXRoLnJvdW5kKGZpcnN0RFRTIC8gOTApICsgJyxkZWx0YTonICsgZGVsdGEgKyAnIG1zJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHREVFMgPSBmaXJzdERUUztcblxuICAgICAgLy8gY29tcHV0ZSBsYXN0UFRTL2xhc3REVFNcbiAgICAgIHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpbnB1dFNhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgICBsYXN0RFRTID0gTWF0aC5tYXgocHRzTm9ybWFsaXplKHNhbXBsZS5kdHMgLSBpbml0RFRTLCBuZXh0QXZjRHRzKSwgMCk7XG4gICAgICBsYXN0UFRTID0gTWF0aC5tYXgocHRzTm9ybWFsaXplKHNhbXBsZS5wdHMgLSBpbml0RFRTLCBuZXh0QXZjRHRzKSwgMCk7XG4gICAgICBsYXN0UFRTID0gTWF0aC5tYXgobGFzdFBUUywgbGFzdERUUyk7XG5cbiAgICAgIHZhciB2ZW5kb3IgPSBuYXZpZ2F0b3IudmVuZG9yLFxuICAgICAgICAgIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgICAgaXNTYWZhcmkgPSB2ZW5kb3IgJiYgdmVuZG9yLmluZGV4T2YoJ0FwcGxlJykgPiAtMSAmJiB1c2VyQWdlbnQgJiYgIXVzZXJBZ2VudC5tYXRjaCgnQ3JpT1MnKTtcblxuICAgICAgLy8gb24gU2FmYXJpIGxldCdzIHNpZ25hbCB0aGUgc2FtZSBzYW1wbGUgZHVyYXRpb24gZm9yIGFsbCBzYW1wbGVzXG4gICAgICAvLyBzYW1wbGUgZHVyYXRpb24gKGFzIGV4cGVjdGVkIGJ5IHRydW4gTVA0IGJveGVzKSwgc2hvdWxkIGJlIHRoZSBkZWx0YSBiZXR3ZWVuIHNhbXBsZSBEVFNcbiAgICAgIC8vIHNldCB0aGlzIGNvbnN0YW50IGR1cmF0aW9uIGFzIGJlaW5nIHRoZSBhdmcgZGVsdGEgYmV0d2VlbiBjb25zZWN1dGl2ZSBEVFMuXG4gICAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBNYXRoLnJvdW5kKChsYXN0RFRTIC0gZmlyc3REVFMpIC8gKHBlczJtcDRTY2FsZUZhY3RvciAqIChpbnB1dFNhbXBsZXMubGVuZ3RoIC0gMSkpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5iTmFsdSA9IDAsXG4gICAgICAgICAgbmFsdUxlbiA9IDA7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbmJTYW1wbGVzOyBfaSsrKSB7XG4gICAgICAgIC8vIGNvbXB1dGUgdG90YWwvYXZjIHNhbXBsZSBsZW5ndGggYW5kIG5iIG9mIE5BTCB1bml0c1xuICAgICAgICB2YXIgX3NhbXBsZSA9IGlucHV0U2FtcGxlc1tfaV0sXG4gICAgICAgICAgICB1bml0cyA9IF9zYW1wbGUudW5pdHMudW5pdHMsXG4gICAgICAgICAgICBuYlVuaXRzID0gdW5pdHMubGVuZ3RoLFxuICAgICAgICAgICAgc2FtcGxlTGVuID0gMDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuYlVuaXRzOyBqKyspIHtcbiAgICAgICAgICBzYW1wbGVMZW4gKz0gdW5pdHNbal0uZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbmFsdUxlbiArPSBzYW1wbGVMZW47XG4gICAgICAgIG5iTmFsdSArPSBuYlVuaXRzO1xuICAgICAgICBfc2FtcGxlLmxlbmd0aCA9IHNhbXBsZUxlbjtcblxuICAgICAgICAvLyBub3JtYWxpemUgUFRTL0RUU1xuICAgICAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgICAgICAvLyBzYW1wbGUgRFRTIGlzIGNvbXB1dGVkIHVzaW5nIGEgY29uc3RhbnQgZGVjb2Rpbmcgb2Zmc2V0IChtcDRTYW1wbGVEdXJhdGlvbikgYmV0d2VlbiBzYW1wbGVzXG4gICAgICAgICAgX3NhbXBsZS5kdHMgPSBmaXJzdERUUyArIF9pICogcGVzMm1wNFNjYWxlRmFjdG9yICogbXA0U2FtcGxlRHVyYXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZW5zdXJlIHNhbXBsZSBtb25vdG9uaWMgRFRTXG4gICAgICAgICAgX3NhbXBsZS5kdHMgPSBNYXRoLm1heChwdHNOb3JtYWxpemUoX3NhbXBsZS5kdHMgLSBpbml0RFRTLCBuZXh0QXZjRHRzKSwgZmlyc3REVFMpO1xuICAgICAgICAgIC8vIGVuc3VyZSBkdHMgaXMgYSBtdWx0aXBsZSBvZiBzY2FsZSBmYWN0b3IgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzXG4gICAgICAgICAgX3NhbXBsZS5kdHMgPSBNYXRoLnJvdW5kKF9zYW1wbGUuZHRzIC8gcGVzMm1wNFNjYWxlRmFjdG9yKSAqIHBlczJtcDRTY2FsZUZhY3RvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBub3JtYWxpemUgUFRTIGFnYWluc3QgbmV4dEF2Y0R0cywgd2UgYWxzbyBzdWJzdHJhY3QgaW5pdERUUyAoc29tZSBzdHJlYW1zIGRvbid0IHN0YXJ0IEAgUFRTIE8pXG4gICAgICAgIC8vIGFuZCB3ZSBlbnN1cmUgdGhhdCBjb21wdXRlZCB2YWx1ZSBpcyBncmVhdGVyIG9yIGVxdWFsIHRoYW4gc2FtcGxlIERUU1xuICAgICAgICBfc2FtcGxlLnB0cyA9IE1hdGgubWF4KHB0c05vcm1hbGl6ZShfc2FtcGxlLnB0cyAtIGluaXREVFMsIG5leHRBdmNEdHMpLCBfc2FtcGxlLmR0cyk7XG4gICAgICAgIC8vIGVuc3VyZSBwdHMgaXMgYSBtdWx0aXBsZSBvZiBzY2FsZSBmYWN0b3IgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzXG4gICAgICAgIF9zYW1wbGUucHRzID0gTWF0aC5yb3VuZChfc2FtcGxlLnB0cyAvIHBlczJtcDRTY2FsZUZhY3RvcikgKiBwZXMybXA0U2NhbGVGYWN0b3I7XG4gICAgICB9XG5cbiAgICAgIC8qIGNvbmNhdGVuYXRlIHRoZSB2aWRlbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgICAgKG5lZWQgOCBtb3JlIGJ5dGVzIHRvIGZpbGwgbGVuZ3RoIGFuZCBtcGRhdCB0eXBlKSAqL1xuICAgICAgdmFyIG1kYXRTaXplID0gbmFsdUxlbiArIDQgKiBuYk5hbHUgKyA4O1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTVVYX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUiwgZmF0YWw6IGZhbHNlLCBieXRlczogbWRhdFNpemUsIHJlYXNvbjogJ2ZhaWwgYWxsb2NhdGluZyB2aWRlbyBtZGF0ICcgKyBtZGF0U2l6ZSB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgICAgbWRhdC5zZXQoX21wNEdlbmVyYXRvcjIuZGVmYXVsdC50eXBlcy5tZGF0LCA0KTtcblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbmJTYW1wbGVzOyBfaTIrKykge1xuICAgICAgICB2YXIgYXZjU2FtcGxlID0gaW5wdXRTYW1wbGVzW19pMl0sXG4gICAgICAgICAgICBhdmNTYW1wbGVVbml0cyA9IGF2Y1NhbXBsZS51bml0cy51bml0cyxcbiAgICAgICAgICAgIG1wNFNhbXBsZUxlbmd0aCA9IDAsXG4gICAgICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSB2b2lkIDA7XG4gICAgICAgIC8vIGNvbnZlcnQgTkFMVSBiaXRzdHJlYW0gdG8gTVA0IGZvcm1hdCAocHJlcGVuZCBOQUxVIHdpdGggc2l6ZSBmaWVsZClcbiAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBfbmJVbml0cyA9IGF2Y1NhbXBsZVVuaXRzLmxlbmd0aDsgX2ogPCBfbmJVbml0czsgX2orKykge1xuICAgICAgICAgIHZhciB1bml0ID0gYXZjU2FtcGxlVW5pdHNbX2pdLFxuICAgICAgICAgICAgICB1bml0RGF0YSA9IHVuaXQuZGF0YSxcbiAgICAgICAgICAgICAgdW5pdERhdGFMZW4gPSB1bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIHVuaXREYXRhTGVuKTtcbiAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICBtZGF0LnNldCh1bml0RGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICBvZmZzZXQgKz0gdW5pdERhdGFMZW47XG4gICAgICAgICAgbXA0U2FtcGxlTGVuZ3RoICs9IDQgKyB1bml0RGF0YUxlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTYWZhcmkpIHtcbiAgICAgICAgICAvLyBleHBlY3RlZCBzYW1wbGUgZHVyYXRpb24gaXMgdGhlIERlY29kaW5nIFRpbWVzdGFtcCBkaWZmIG9mIGNvbnNlY3V0aXZlIHNhbXBsZXNcbiAgICAgICAgICBpZiAoX2kyIDwgbmJTYW1wbGVzIC0gMSkge1xuICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBpbnB1dFNhbXBsZXNbX2kyICsgMV0uZHRzIC0gYXZjU2FtcGxlLmR0cztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgICAgIGxhc3RGcmFtZUR1cmF0aW9uID0gYXZjU2FtcGxlLmR0cyAtIGlucHV0U2FtcGxlc1tfaTIgPiAwID8gX2kyIC0gMSA6IF9pMl0uZHRzO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5zdHJldGNoU2hvcnRWaWRlb1RyYWNrKSB7XG4gICAgICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMsIGEgc2VnbWVudCdzIGF1ZGlvIHRyYWNrIGR1cmF0aW9uIG1heSBleGNlZWQgdGhlIHZpZGVvIHRyYWNrIGR1cmF0aW9uLlxuICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBhbHJlYWR5IHJlbXV4ZWQgYXVkaW8sIGFuZCB3ZSBrbm93IGhvdyBsb25nIHRoZSBhdWRpbyB0cmFjayBpcywgd2UgbG9vayB0b1xuICAgICAgICAgICAgICAvLyBzZWUgaWYgdGhlIGRlbHRhIHRvIHRoZSBuZXh0IHNlZ21lbnQgaXMgbG9uZ2VyIHRoYW4gdGhlIG1pbmltdW0gb2YgbWF4QnVmZmVySG9sZSBhbmRcbiAgICAgICAgICAgICAgLy8gbWF4U2Vla0hvbGUuIElmIHNvLCBwbGF5YmFjayB3b3VsZCBwb3RlbnRpYWxseSBnZXQgc3R1Y2ssIHNvIHdlIGFydGlmaWNpYWxseSBpbmZsYXRlXG4gICAgICAgICAgICAgIC8vIHRoZSBkdXJhdGlvbiBvZiB0aGUgbGFzdCBmcmFtZSB0byBtaW5pbWl6ZSBhbnkgcG90ZW50aWFsIGdhcCBiZXR3ZWVuIHNlZ21lbnRzLlxuICAgICAgICAgICAgICB2YXIgbWF4QnVmZmVySG9sZSA9IGNvbmZpZy5tYXhCdWZmZXJIb2xlLFxuICAgICAgICAgICAgICAgICAgbWF4U2Vla0hvbGUgPSBjb25maWcubWF4U2Vla0hvbGUsXG4gICAgICAgICAgICAgICAgICBnYXBUb2xlcmFuY2UgPSBNYXRoLmZsb29yKE1hdGgubWluKG1heEJ1ZmZlckhvbGUsIG1heFNlZWtIb2xlKSAqIHBlc1RpbWVTY2FsZSksXG4gICAgICAgICAgICAgICAgICBkZWx0YVRvRnJhbWVFbmQgPSAoYXVkaW9UcmFja0xlbmd0aCA/IGZpcnN0UFRTICsgYXVkaW9UcmFja0xlbmd0aCAqIHBlc1RpbWVTY2FsZSA6IHRoaXMubmV4dEF1ZGlvUHRzKSAtIGF2Y1NhbXBsZS5wdHM7XG4gICAgICAgICAgICAgIGlmIChkZWx0YVRvRnJhbWVFbmQgPiBnYXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBzdWJ0cmFjdCBsYXN0RnJhbWVEdXJhdGlvbiBmcm9tIGRlbHRhVG9GcmFtZUVuZCB0byB0cnkgdG8gcHJldmVudCBhbnkgdmlkZW9cbiAgICAgICAgICAgICAgICAvLyBmcmFtZSBvdmVybGFwLiBtYXhCdWZmZXJIb2xlL21heFNlZWtIb2xlIHNob3VsZCBiZSA+PiBsYXN0RnJhbWVEdXJhdGlvbiBhbnl3YXkuXG4gICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBkZWx0YVRvRnJhbWVFbmQgLSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAobXA0U2FtcGxlRHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ0l0IGlzIGFwcHJveGltYXRlbHkgJyArIGRlbHRhVG9GcmFtZUVuZCAvIDkwICsgJyBtcyB0byB0aGUgbmV4dCBzZWdtZW50OyB1c2luZyBkdXJhdGlvbiAnICsgbXA0U2FtcGxlRHVyYXRpb24gLyA5MCArICcgbXMgZm9yIHRoZSBsYXN0IHZpZGVvIGZyYW1lLicpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uIC89IHBlczJtcDRTY2FsZUZhY3RvcjtcbiAgICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSBNYXRoLnJvdW5kKChhdmNTYW1wbGUucHRzIC0gYXZjU2FtcGxlLmR0cykgLyBwZXMybXA0U2NhbGVGYWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgubWF4KDAsIG1wNFNhbXBsZUR1cmF0aW9uICogTWF0aC5yb3VuZCgoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpIC8gKHBlczJtcDRTY2FsZUZhY3RvciAqIG1wNFNhbXBsZUR1cmF0aW9uKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZygnUFRTL0RUUy9pbml0RFRTL25vcm1QVFMvbm9ybURUUy9yZWxhdGl2ZSBQVFMgOiAke2F2Y1NhbXBsZS5wdHN9LyR7YXZjU2FtcGxlLmR0c30vJHtpbml0RFRTfS8ke3B0c25vcm19LyR7ZHRzbm9ybX0vJHsoYXZjU2FtcGxlLnB0cy80Mjk0OTY3Mjk2KS50b0ZpeGVkKDMpfScpO1xuICAgICAgICBvdXRwdXRTYW1wbGVzLnB1c2goe1xuICAgICAgICAgIHNpemU6IG1wNFNhbXBsZUxlbmd0aCxcbiAgICAgICAgICAvLyBjb25zdGFudCBkdXJhdGlvblxuICAgICAgICAgIGR1cmF0aW9uOiBtcDRTYW1wbGVEdXJhdGlvbixcbiAgICAgICAgICBjdHM6IGNvbXBvc2l0aW9uVGltZU9mZnNldCxcbiAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgICAgICAgIGRlZ3JhZFByaW86IDAsXG4gICAgICAgICAgICBkZXBlbmRzT246IGF2Y1NhbXBsZS5rZXkgPyAyIDogMSxcbiAgICAgICAgICAgIGlzTm9uU3luYzogYXZjU2FtcGxlLmtleSA/IDAgOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIG5leHQgQVZDIHNhbXBsZSBEVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIERUUyArIGxhc3Qgc2FtcGxlIGR1cmF0aW9uIChpbiBQRVMgdGltZXNjYWxlKVxuICAgICAgdGhpcy5uZXh0QXZjRHRzID0gbGFzdERUUyArIG1wNFNhbXBsZUR1cmF0aW9uICogcGVzMm1wNFNjYWxlRmFjdG9yO1xuICAgICAgdmFyIGRyb3BwZWQgPSB0cmFjay5kcm9wcGVkO1xuICAgICAgdHJhY2subGVuID0gMDtcbiAgICAgIHRyYWNrLm5iTmFsdSA9IDA7XG4gICAgICB0cmFjay5kcm9wcGVkID0gMDtcbiAgICAgIGlmIChvdXRwdXRTYW1wbGVzLmxlbmd0aCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2hyb21lJykgPiAtMSkge1xuICAgICAgICB2YXIgZmxhZ3MgPSBvdXRwdXRTYW1wbGVzWzBdLmZsYWdzO1xuICAgICAgICAvLyBjaHJvbWUgd29ya2Fyb3VuZCwgbWFyayBmaXJzdCBzYW1wbGUgYXMgYmVpbmcgYSBSYW5kb20gQWNjZXNzIFBvaW50IHRvIGF2b2lkIHNvdXJjZWJ1ZmZlciBhcHBlbmQgaXNzdWVcbiAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTQxMlxuICAgICAgICBmbGFncy5kZXBlbmRzT24gPSAyO1xuICAgICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xuICAgICAgfVxuICAgICAgdHJhY2suc2FtcGxlcyA9IG91dHB1dFNhbXBsZXM7XG4gICAgICBtb29mID0gX21wNEdlbmVyYXRvcjIuZGVmYXVsdC5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0RFRTIC8gcGVzMm1wNFNjYWxlRmFjdG9yLCB0cmFjayk7XG4gICAgICB0cmFjay5zYW1wbGVzID0gW107XG5cbiAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICBkYXRhMTogbW9vZixcbiAgICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICAgIHN0YXJ0UFRTOiBmaXJzdFBUUyAvIHBlc1RpbWVTY2FsZSxcbiAgICAgICAgZW5kUFRTOiAobGFzdFBUUyArIHBlczJtcDRTY2FsZUZhY3RvciAqIG1wNFNhbXBsZUR1cmF0aW9uKSAvIHBlc1RpbWVTY2FsZSxcbiAgICAgICAgc3RhcnREVFM6IGZpcnN0RFRTIC8gcGVzVGltZVNjYWxlLFxuICAgICAgICBlbmREVFM6IHRoaXMubmV4dEF2Y0R0cyAvIHBlc1RpbWVTY2FsZSxcbiAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgbmI6IG91dHB1dFNhbXBsZXMubGVuZ3RoLFxuICAgICAgICBkcm9wcGVkOiBkcm9wcGVkXG4gICAgICB9O1xuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTSU5HX0RBVEEsIGRhdGEpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVtdXhBdWRpbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgdmFyIHBlc1RpbWVTY2FsZSA9IHRoaXMuUEVTX1RJTUVTQ0FMRSxcbiAgICAgICAgICBtcDR0aW1lU2NhbGUgPSB0cmFjay50aW1lc2NhbGUsXG4gICAgICAgICAgcGVzMm1wNFNjYWxlRmFjdG9yID0gcGVzVGltZVNjYWxlIC8gbXA0dGltZVNjYWxlLFxuICAgICAgICAgIGV4cGVjdGVkU2FtcGxlRHVyYXRpb24gPSB0cmFjay50aW1lc2NhbGUgKiAodHJhY2suaXNBQUMgPyAxMDI0IDogMTE1MikgLyB0cmFjay5hdWRpb3NhbXBsZXJhdGUsXG4gICAgICAgICAgcGVzRnJhbWVEdXJhdGlvbiA9IGV4cGVjdGVkU2FtcGxlRHVyYXRpb24gKiBwZXMybXA0U2NhbGVGYWN0b3IsXG4gICAgICAgICAgcHRzTm9ybWFsaXplID0gdGhpcy5fUFRTTm9ybWFsaXplLFxuICAgICAgICAgIGluaXREVFMgPSB0aGlzLl9pbml0RFRTLFxuICAgICAgICAgIHJhd01QRUcgPSAhdHJhY2suaXNBQUMgJiYgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWc7XG5cbiAgICAgIHZhciB2aWV3LFxuICAgICAgICAgIG9mZnNldCA9IHJhd01QRUcgPyAwIDogOCxcbiAgICAgICAgICBhdWRpb1NhbXBsZSxcbiAgICAgICAgICBtcDRTYW1wbGUsXG4gICAgICAgICAgdW5pdCxcbiAgICAgICAgICBtZGF0LFxuICAgICAgICAgIG1vb2YsXG4gICAgICAgICAgZmlyc3RQVFMsXG4gICAgICAgICAgZmlyc3REVFMsXG4gICAgICAgICAgbGFzdERUUyxcbiAgICAgICAgICBwdHMsXG4gICAgICAgICAgZHRzLFxuICAgICAgICAgIHB0c25vcm0sXG4gICAgICAgICAgZHRzbm9ybSxcbiAgICAgICAgICBvdXRwdXRTYW1wbGVzID0gW10sXG4gICAgICAgICAgaW5wdXRTYW1wbGVzID0gW10sXG4gICAgICAgICAgZmlsbEZyYW1lLFxuICAgICAgICAgIG5ld1N0YW1wLFxuICAgICAgICAgIG5leHRBdWRpb1B0cztcblxuICAgICAgdHJhY2suc2FtcGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnB0cyAtIGIucHRzO1xuICAgICAgfSk7XG4gICAgICBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuXG4gICAgICAvLyBmb3IgYXVkaW8gc2FtcGxlcywgYWxzbyBjb25zaWRlciBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXMgYmVpbmcgY29udGlndW91cyAoZXZlbiBpZiBhIGxldmVsIHN3aXRjaCBvY2N1cnMpLFxuICAgICAgLy8gZm9yIHNha2Ugb2YgY2xhcml0eTpcbiAgICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aFxuICAgICAgLy8gIC0gbGVzcyB0aGFuIDEwMG1zIGdhcHMgYmV0d2VlbiBuZXcgdGltZSBvZmZzZXQgYW5kIG5leHQgZXhwZWN0ZWQgUFRTIE9SXG4gICAgICAvLyAgLSBsZXNzIHRoYW4gMjAgYXVkaW8gZnJhbWVzIGRpc3RhbmNlXG4gICAgICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxuICAgICAgLy8gdGhpcyBoZWxwcyBlbnN1cmluZyBhdWRpbyBjb250aW51aXR5XG4gICAgICAvLyBhbmQgdGhpcyBhbHNvIGF2b2lkcyBhdWRpbyBnbGl0Y2hlcy9jdXQgd2hlbiBzd2l0Y2hpbmcgcXVhbGl0eSwgb3IgcmVwb3J0aW5nIHdyb25nIGR1cmF0aW9uIG9uIGZpcnN0IGF1ZGlvIGZyYW1lXG5cbiAgICAgIG5leHRBdWRpb1B0cyA9IHRoaXMubmV4dEF1ZGlvUHRzO1xuICAgICAgY29udGlndW91cyB8PSBpbnB1dFNhbXBsZXMubGVuZ3RoICYmIG5leHRBdWRpb1B0cyAmJiAoTWF0aC5hYnModGltZU9mZnNldCAtIG5leHRBdWRpb1B0cyAvIHBlc1RpbWVTY2FsZSkgPCAwLjEgfHwgTWF0aC5hYnMoaW5wdXRTYW1wbGVzWzBdLnB0cyAtIG5leHRBdWRpb1B0cyAtIHRoaXMuX2luaXREVFMpIDwgMjAgKiBwZXNGcmFtZUR1cmF0aW9uKTtcblxuICAgICAgaWYgKCFjb250aWd1b3VzKSB7XG4gICAgICAgIC8vIGlmIGZyYWdtZW50cyBhcmUgbm90IGNvbnRpZ3VvdXMsIGxldCdzIHVzZSB0aW1lT2Zmc2V0IHRvIGNvbXB1dGUgbmV4dCBBdWRpbyBQVFNcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gdGltZU9mZnNldCAqIHBlc1RpbWVTY2FsZTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBhdWRpbyB0cmFjayBpcyBtaXNzaW5nIHNhbXBsZXMsIHRoZSBmcmFtZXMgc2VlbSB0byBnZXQgXCJsZWZ0LXNoaWZ0ZWRcIiB3aXRoaW4gdGhlXG4gICAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxuICAgICAgLy8gSW4gYW4gZWZmb3J0IHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZywgd2UgaW5qZWN0IGZyYW1lcyBoZXJlIHdoZXJlIHRoZXJlIGFyZSBnYXBzLlxuICAgICAgLy8gV2hlbiBwb3NzaWJsZSwgd2UgaW5qZWN0IGEgc2lsZW50IGZyYW1lOyB3aGVuIHRoYXQncyBub3QgcG9zc2libGUsIHdlIGR1cGxpY2F0ZSB0aGUgbGFzdFxuICAgICAgLy8gZnJhbWUuXG5cbiAgICAgIC8vIG9ubHkgaW5qZWN0L2Ryb3AgYXVkaW8gZnJhbWVzIGluIGNhc2UgdGltZSBvZmZzZXQgaXMgYWNjdXJhdGVcbiAgICAgIGlmIChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgdHJhY2suaXNBQUMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5leHRQdHNOb3JtID0gbmV4dEF1ZGlvUHRzOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDspIHtcbiAgICAgICAgICAvLyBGaXJzdCwgbGV0J3Mgc2VlIGhvdyBmYXIgb2ZmIHRoaXMgZnJhbWUgaXMgZnJvbSB3aGVyZSB3ZSBleHBlY3QgaXQgdG8gYmVcbiAgICAgICAgICB2YXIgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldLFxuICAgICAgICAgICAgICBwdHNOb3JtID0gcHRzTm9ybWFsaXplKHNhbXBsZS5wdHMgLSBpbml0RFRTLCBuZXh0QXVkaW9QdHMpLFxuICAgICAgICAgICAgICBkZWx0YSA9IHB0c05vcm0gLSBuZXh0UHRzTm9ybTtcblxuICAgICAgICAgIC8vIElmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBhIGR1cmF0aW9uLCBkcm9wIHRoaXMgc2FtcGxlXG4gICAgICAgICAgaWYgKGRlbHRhIDw9IC1wZXNGcmFtZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdEcm9wcGluZyAxIGF1ZGlvIGZyYW1lIEAgJyArIE1hdGgucm91bmQobmV4dFB0c05vcm0gLyA5MCkgLyAxMDAwICsgJ3MgZHVlIHRvICcgKyBNYXRoLnJvdW5kKE1hdGguYWJzKGRlbHRhIC8gOTApKSArICcgbXMgb3ZlcmxhcC4nKTtcbiAgICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB0cmFjay5sZW4gLT0gc2FtcGxlLnVuaXQubGVuZ3RoO1xuICAgICAgICAgICAgLy8gRG9uJ3QgdG91Y2ggbmV4dFB0c05vcm0gb3IgaVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHdlJ3JlIG1vcmUgdGhhbiBhIGZyYW1lIGF3YXkgZnJvbSB3aGVyZSB3ZSBzaG91bGQgYmUsIGluc2VydCBtaXNzaW5nIGZyYW1lc1xuICAgICAgICAgIC8vIGFsc28gb25seSBpbmplY3Qgc2lsZW50IGF1ZGlvIGZyYW1lcyBpZiBjdXJyZW50VGltZSAhPT0gMCAobmV4dFB0c05vcm0gIT09IDApXG4gICAgICAgICAgZWxzZSBpZiAoZGVsdGEgPj0gcGVzRnJhbWVEdXJhdGlvbiAmJiBuZXh0UHRzTm9ybSkge1xuICAgICAgICAgICAgICB2YXIgbWlzc2luZyA9IE1hdGgucm91bmQoZGVsdGEgLyBwZXNGcmFtZUR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignSW5qZWN0aW5nICcgKyBtaXNzaW5nICsgJyBhdWRpbyBmcmFtZSBAICcgKyBNYXRoLnJvdW5kKG5leHRQdHNOb3JtIC8gOTApIC8gMTAwMCArICdzIGR1ZSB0byAnICsgTWF0aC5yb3VuZChkZWx0YSAvIDkwKSArICcgbXMgZ2FwLicpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1pc3Npbmc7IGorKykge1xuICAgICAgICAgICAgICAgIG5ld1N0YW1wID0gbmV4dFB0c05vcm0gKyBpbml0RFRTO1xuICAgICAgICAgICAgICAgIG5ld1N0YW1wID0gTWF0aC5tYXgobmV3U3RhbXAsIGluaXREVFMpO1xuICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IF9hYWMyLmRlZmF1bHQuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIGxhc3QgZnJhbWUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IHNhbXBsZS51bml0LnN1YmFycmF5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMCwgeyB1bml0OiBmaWxsRnJhbWUsIHB0czogbmV3U3RhbXAsIGR0czogbmV3U3RhbXAgfSk7XG4gICAgICAgICAgICAgICAgdHJhY2subGVuICs9IGZpbGxGcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbmV4dFB0c05vcm0gKz0gcGVzRnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBBZGp1c3Qgc2FtcGxlIHRvIG5leHQgZXhwZWN0ZWQgcHRzXG4gICAgICAgICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gbmV4dFB0c05vcm0gKyBpbml0RFRTO1xuICAgICAgICAgICAgICBuZXh0UHRzTm9ybSArPSBwZXNGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlJ3JlIHdpdGhpbiBoYWxmIGEgZnJhbWUgZHVyYXRpb24sIHNvIGp1c3QgYWRqdXN0IHB0c1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+IDAuMSAqIHBlc0ZyYW1lRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgSW52YWxpZCBmcmFtZSBkZWx0YSAke01hdGgucm91bmQocHRzTm9ybSAtIG5leHRQdHNOb3JtICsgcGVzRnJhbWVEdXJhdGlvbil9IGF0IFBUUyAke01hdGgucm91bmQocHRzTm9ybSAvIDkwKX0gKHNob3VsZCBiZSAke01hdGgucm91bmQocGVzRnJhbWVEdXJhdGlvbil9KS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dFB0c05vcm0gKz0gcGVzRnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBpbml0RFRTICsgbmV4dEF1ZGlvUHRzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzYW1wbGUucHRzID0gc2FtcGxlLmR0cyA9IGlucHV0U2FtcGxlc1tpIC0gMV0ucHRzICsgcGVzRnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2oyID0gMCwgX25iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7IF9qMiA8IF9uYlNhbXBsZXM7IF9qMisrKSB7XG4gICAgICAgIGF1ZGlvU2FtcGxlID0gaW5wdXRTYW1wbGVzW19qMl07XG4gICAgICAgIHVuaXQgPSBhdWRpb1NhbXBsZS51bml0O1xuICAgICAgICBwdHMgPSBhdWRpb1NhbXBsZS5wdHMgLSBpbml0RFRTO1xuICAgICAgICBkdHMgPSBhdWRpb1NhbXBsZS5kdHMgLSBpbml0RFRTO1xuICAgICAgICAvL2xvZ2dlci5sb2coYEF1ZGlvL1BUUzoke01hdGgucm91bmQocHRzLzkwKX1gKTtcbiAgICAgICAgLy8gaWYgbm90IGZpcnN0IHNhbXBsZVxuICAgICAgICBpZiAobGFzdERUUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHRzbm9ybSA9IHB0c05vcm1hbGl6ZShwdHMsIGxhc3REVFMpO1xuICAgICAgICAgIGR0c25vcm0gPSBwdHNOb3JtYWxpemUoZHRzLCBsYXN0RFRTKTtcbiAgICAgICAgICBtcDRTYW1wbGUuZHVyYXRpb24gPSBNYXRoLnJvdW5kKChkdHNub3JtIC0gbGFzdERUUykgLyBwZXMybXA0U2NhbGVGYWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB0c25vcm0gPSBwdHNOb3JtYWxpemUocHRzLCBuZXh0QXVkaW9QdHMpO1xuICAgICAgICAgIGR0c25vcm0gPSBwdHNOb3JtYWxpemUoZHRzLCBuZXh0QXVkaW9QdHMpO1xuICAgICAgICAgIHZhciBfZGVsdGEgPSBNYXRoLnJvdW5kKDEwMDAgKiAocHRzbm9ybSAtIG5leHRBdWRpb1B0cykgLyBwZXNUaW1lU2NhbGUpLFxuICAgICAgICAgICAgICBudW1NaXNzaW5nRnJhbWVzID0gMDtcbiAgICAgICAgICAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICAgICAgICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxuICAgICAgICAgIGlmIChjb250aWd1b3VzICYmIHRyYWNrLmlzQUFDKSB7XG4gICAgICAgICAgICAvLyBsb2cgZGVsdGFcbiAgICAgICAgICAgIGlmIChfZGVsdGEpIHtcbiAgICAgICAgICAgICAgaWYgKF9kZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgICBudW1NaXNzaW5nRnJhbWVzID0gTWF0aC5yb3VuZCgocHRzbm9ybSAtIG5leHRBdWRpb1B0cykgLyBwZXNGcmFtZUR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coX2RlbHRhICsgJyBtcyBob2xlIGJldHdlZW4gQUFDIHNhbXBsZXMgZGV0ZWN0ZWQsZmlsbGluZyBpdCcpO1xuICAgICAgICAgICAgICAgIGlmIChudW1NaXNzaW5nRnJhbWVzID4gMCkge1xuICAgICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gX2FhYzIuZGVmYXVsdC5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gdW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdHJhY2subGVuICs9IG51bU1pc3NpbmdGcmFtZXMgKiBmaWxsRnJhbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGZyYW1lIG92ZXJsYXAsIG92ZXJsYXBwaW5nIGZvciBtb3JlIHRoYW4gaGFsZiBhIGZyYW1lIGR1cmFpb25cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChfZGVsdGEgPCAtMTIpIHtcbiAgICAgICAgICAgICAgICAvLyBkcm9wIG92ZXJsYXBwaW5nIGF1ZGlvIGZyYW1lcy4uLiBicm93c2VyIHdpbGwgZGVhbCB3aXRoIGl0XG4gICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKC1fZGVsdGEgKyAnIG1zIG92ZXJsYXBwaW5nIGJldHdlZW4gQUFDIHNhbXBsZXMgZGV0ZWN0ZWQsIGRyb3AgZnJhbWUnKTtcbiAgICAgICAgICAgICAgICB0cmFjay5sZW4gLT0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHNldCBQVFMvRFRTIHRvIGV4cGVjdGVkIFBUUy9EVFNcbiAgICAgICAgICAgICAgcHRzbm9ybSA9IGR0c25vcm0gPSBuZXh0QXVkaW9QdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiBvdXIgYXVkaW9TYW1wbGVzLCBlbnN1cmUgdmFsdWUgaXMgcG9zaXRpdmVcbiAgICAgICAgICBmaXJzdFBUUyA9IE1hdGgubWF4KDAsIHB0c25vcm0pO1xuICAgICAgICAgIGZpcnN0RFRTID0gTWF0aC5tYXgoMCwgZHRzbm9ybSk7XG4gICAgICAgICAgaWYgKHRyYWNrLmxlbiA+IDApIHtcbiAgICAgICAgICAgIC8qIGNvbmNhdGVuYXRlIHRoZSBhdWRpbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgICAgICAgICAgKG5lZWQgOCBtb3JlIGJ5dGVzIHRvIGZpbGwgbGVuZ3RoIGFuZCBtZGF0IHR5cGUpICovXG5cbiAgICAgICAgICAgIHZhciBtZGF0U2l6ZSA9IHJhd01QRUcgPyB0cmFjay5sZW4gOiB0cmFjay5sZW4gKyA4O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTVVYX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUiwgZmF0YWw6IGZhbHNlLCBieXRlczogbWRhdFNpemUsIHJlYXNvbjogJ2ZhaWwgYWxsb2NhdGluZyBhdWRpbyBtZGF0ICcgKyBtZGF0U2l6ZSB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyYXdNUEVHKSB7XG4gICAgICAgICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgICAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICAgICAgICAgIG1kYXQuc2V0KF9tcDRHZW5lcmF0b3IyLmRlZmF1bHQudHlwZXMubWRhdCwgNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIGF1ZGlvIHNhbXBsZXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbnVtTWlzc2luZ0ZyYW1lczsgX2kzKyspIHtcbiAgICAgICAgICAgIG5ld1N0YW1wID0gcHRzbm9ybSAtIChudW1NaXNzaW5nRnJhbWVzIC0gX2kzKSAqIHBlc0ZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICBmaWxsRnJhbWUgPSBfYWFjMi5kZWZhdWx0LmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ1VuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgdGhpcyBmcmFtZSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICBmaWxsRnJhbWUgPSB1bml0LnN1YmFycmF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZGF0LnNldChmaWxsRnJhbWUsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gZmlsbEZyYW1lLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBtcDRTYW1wbGUgPSB7XG4gICAgICAgICAgICAgIHNpemU6IGZpbGxGcmFtZS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICBjdHM6IDAsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAxMDI0LFxuICAgICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICAgICAgICBpc0RlcGVuZGVkT246IDAsXG4gICAgICAgICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgICAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgICAgICAgICAgIGRlcGVuZHNPbjogMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1kYXQuc2V0KHVuaXQsIG9mZnNldCk7XG4gICAgICAgIHZhciB1bml0TGVuID0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgICBvZmZzZXQgKz0gdW5pdExlbjtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnUFRTL0RUUy9pbml0RFRTL25vcm1QVFMvbm9ybURUUy9yZWxhdGl2ZSBQVFMgOiAke2F1ZGlvU2FtcGxlLnB0c30vJHthdWRpb1NhbXBsZS5kdHN9LyR7aW5pdERUU30vJHtwdHNub3JtfS8ke2R0c25vcm19LyR7KGF1ZGlvU2FtcGxlLnB0cy80Mjk0OTY3Mjk2KS50b0ZpeGVkKDMpfScpO1xuICAgICAgICBtcDRTYW1wbGUgPSB7XG4gICAgICAgICAgc2l6ZTogdW5pdExlbixcbiAgICAgICAgICBjdHM6IDAsXG4gICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgICAgICAgZGVwZW5kc09uOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobXA0U2FtcGxlKTtcbiAgICAgICAgbGFzdERUUyA9IGR0c25vcm07XG4gICAgICB9XG4gICAgICB2YXIgbGFzdFNhbXBsZUR1cmF0aW9uID0gMDtcbiAgICAgIHZhciBuYlNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDtcbiAgICAgIC8vc2V0IGxhc3Qgc2FtcGxlIGR1cmF0aW9uIGFzIGJlaW5nIGlkZW50aWNhbCB0byBwcmV2aW91cyBzYW1wbGVcbiAgICAgIGlmIChuYlNhbXBsZXMgPj0gMikge1xuICAgICAgICBsYXN0U2FtcGxlRHVyYXRpb24gPSBvdXRwdXRTYW1wbGVzW25iU2FtcGxlcyAtIDJdLmR1cmF0aW9uO1xuICAgICAgICBtcDRTYW1wbGUuZHVyYXRpb24gPSBsYXN0U2FtcGxlRHVyYXRpb247XG4gICAgICB9XG4gICAgICBpZiAobmJTYW1wbGVzKSB7XG4gICAgICAgIC8vIG5leHQgYXVkaW8gc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZHVyYXRpb25cbiAgICAgICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBwdHNub3JtICsgcGVzMm1wNFNjYWxlRmFjdG9yICogbGFzdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAvL2xvZ2dlci5sb2coJ0F1ZGlvL1BUUy9QVFNlbmQ6JyArIGF1ZGlvU2FtcGxlLnB0cy50b0ZpeGVkKDApICsgJy8nICsgdGhpcy5uZXh0QWFjRHRzLnRvRml4ZWQoMCkpO1xuICAgICAgICB0cmFjay5sZW4gPSAwO1xuICAgICAgICB0cmFjay5zYW1wbGVzID0gb3V0cHV0U2FtcGxlcztcbiAgICAgICAgaWYgKHJhd01QRUcpIHtcbiAgICAgICAgICBtb29mID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb29mID0gX21wNEdlbmVyYXRvcjIuZGVmYXVsdC5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0RFRTIC8gcGVzMm1wNFNjYWxlRmFjdG9yLCB0cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgICAgICB2YXIgYXVkaW9EYXRhID0ge1xuICAgICAgICAgIGRhdGExOiBtb29mLFxuICAgICAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgICAgIHN0YXJ0UFRTOiBmaXJzdFBUUyAvIHBlc1RpbWVTY2FsZSxcbiAgICAgICAgICBlbmRQVFM6IHRoaXMubmV4dEF1ZGlvUHRzIC8gcGVzVGltZVNjYWxlLFxuICAgICAgICAgIHN0YXJ0RFRTOiBmaXJzdERUUyAvIHBlc1RpbWVTY2FsZSxcbiAgICAgICAgICBlbmREVFM6IChkdHNub3JtICsgcGVzMm1wNFNjYWxlRmFjdG9yICogbGFzdFNhbXBsZUR1cmF0aW9uKSAvIHBlc1RpbWVTY2FsZSxcbiAgICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICAgIG5iOiBuYlNhbXBsZXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTSU5HX0RBVEEsIGF1ZGlvRGF0YSk7XG4gICAgICAgIHJldHVybiBhdWRpb0RhdGE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW11eEVtcHR5QXVkaW8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW11eEVtcHR5QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIHZpZGVvRGF0YSkge1xuICAgICAgdmFyIHBlc1RpbWVTY2FsZSA9IHRoaXMuUEVTX1RJTUVTQ0FMRSxcbiAgICAgICAgICBtcDR0aW1lU2NhbGUgPSB0cmFjay50aW1lc2NhbGUgPyB0cmFjay50aW1lc2NhbGUgOiB0cmFjay5hdWRpb3NhbXBsZXJhdGUsXG4gICAgICAgICAgcGVzMm1wNFNjYWxlRmFjdG9yID0gcGVzVGltZVNjYWxlIC8gbXA0dGltZVNjYWxlLFxuICAgICAgICAgIG5leHRBdWRpb1B0cyA9IHRoaXMubmV4dEF1ZGlvUHRzLFxuXG5cbiAgICAgIC8vIHN5bmMgd2l0aCB2aWRlbydzIHRpbWVzdGFtcFxuICAgICAgc3RhcnREVFMgPSAobmV4dEF1ZGlvUHRzICE9PSB1bmRlZmluZWQgPyBuZXh0QXVkaW9QdHMgOiB2aWRlb0RhdGEuc3RhcnREVFMgKiBwZXNUaW1lU2NhbGUpICsgdGhpcy5faW5pdERUUyxcbiAgICAgICAgICBlbmREVFMgPSB2aWRlb0RhdGEuZW5kRFRTICogcGVzVGltZVNjYWxlICsgdGhpcy5faW5pdERUUyxcblxuICAgICAgLy8gb25lIHNhbXBsZSdzIGR1cmF0aW9uIHZhbHVlXG4gICAgICBzYW1wbGVEdXJhdGlvbiA9IDEwMjQsXG4gICAgICAgICAgZnJhbWVEdXJhdGlvbiA9IHBlczJtcDRTY2FsZUZhY3RvciAqIHNhbXBsZUR1cmF0aW9uLFxuXG5cbiAgICAgIC8vIHNhbXBsZXMgY291bnQgb2YgdGhpcyBzZWdtZW50J3MgZHVyYXRpb25cbiAgICAgIG5iU2FtcGxlcyA9IE1hdGguY2VpbCgoZW5kRFRTIC0gc3RhcnREVFMpIC8gZnJhbWVEdXJhdGlvbiksXG5cblxuICAgICAgLy8gc2lsZW50IGZyYW1lXG4gICAgICBzaWxlbnRGcmFtZSA9IF9hYWMyLmRlZmF1bHQuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcblxuICAgICAgX2xvZ2dlci5sb2dnZXIud2FybigncmVtdXggZW1wdHkgQXVkaW8nKTtcbiAgICAgIC8vIENhbid0IHJlbXV4IGlmIHdlIGNhbid0IGdlbmVyYXRlIGEgc2lsZW50IGZyYW1lLi4uXG4gICAgICBpZiAoIXNpbGVudEZyYW1lKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLnRyYWNlKCdVbmFibGUgdG8gcmVtdXhFbXB0eUF1ZGlvIHNpbmNlIHdlIHdlcmUgdW5hYmxlIHRvIGdldCBhIHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWMhJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNhbXBsZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgICAgdmFyIHN0YW1wID0gc3RhcnREVFMgKyBpICogZnJhbWVEdXJhdGlvbjtcbiAgICAgICAgc2FtcGxlcy5wdXNoKHsgdW5pdDogc2lsZW50RnJhbWUsIHB0czogc3RhbXAsIGR0czogc3RhbXAgfSk7XG4gICAgICAgIHRyYWNrLmxlbiArPSBzaWxlbnRGcmFtZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB0cmFjay5zYW1wbGVzID0gc2FtcGxlcztcblxuICAgICAgdGhpcy5yZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW11eElEMycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbXV4SUQzKHRyYWNrLCB0aW1lT2Zmc2V0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGgsXG4gICAgICAgICAgc2FtcGxlO1xuICAgICAgLy8gY29uc3VtZSBzYW1wbGVzXG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAgICAgICAvLyBzZXR0aW5nIGlkMyBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgICAgICAgIHNhbXBsZS5wdHMgPSAoc2FtcGxlLnB0cyAtIHRoaXMuX2luaXRQVFMpIC8gdGhpcy5QRVNfVElNRVNDQUxFO1xuICAgICAgICAgIHNhbXBsZS5kdHMgPSAoc2FtcGxlLmR0cyAtIHRoaXMuX2luaXREVFMpIC8gdGhpcy5QRVNfVElNRVNDQUxFO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19NRVRBREFUQSwge1xuICAgICAgICAgIHNhbXBsZXM6IHRyYWNrLnNhbXBsZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICAgIHRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbXV4VGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbXV4VGV4dCh0cmFjaywgdGltZU9mZnNldCkge1xuICAgICAgdHJhY2suc2FtcGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnB0cyAtIGIucHRzO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aCxcbiAgICAgICAgICBzYW1wbGU7XG4gICAgICAvLyBjb25zdW1lIHNhbXBsZXNcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgICAgICAgIC8vIHNldHRpbmcgdGV4dCBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgICAgICAgIHNhbXBsZS5wdHMgPSAoc2FtcGxlLnB0cyAtIHRoaXMuX2luaXRQVFMpIC8gdGhpcy5QRVNfVElNRVNDQUxFO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19VU0VSREFUQSwge1xuICAgICAgICAgIHNhbXBsZXM6IHRyYWNrLnNhbXBsZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICAgIHRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19QVFNOb3JtYWxpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfUFRTTm9ybWFsaXplKHZhbHVlLCByZWZlcmVuY2UpIHtcbiAgICAgIHZhciBvZmZzZXQ7XG4gICAgICBpZiAocmVmZXJlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlZmVyZW5jZSA8IHZhbHVlKSB7XG4gICAgICAgIC8vIC0gMl4zM1xuICAgICAgICBvZmZzZXQgPSAtODU4OTkzNDU5MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICsgMl4zM1xuICAgICAgICBvZmZzZXQgPSA4NTg5OTM0NTkyO1xuICAgICAgfVxuICAgICAgLyogUFRTIGlzIDMzYml0IChmcm9tIDAgdG8gMl4zMyAtMSlcbiAgICAgICAgaWYgZGlmZiBiZXR3ZWVuIHZhbHVlIGFuZCByZWZlcmVuY2UgaXMgYmlnZ2VyIHRoYW4gaGFsZiBvZiB0aGUgYW1wbGl0dWRlICgyXjMyKSB0aGVuIGl0IG1lYW5zIHRoYXRcbiAgICAgICAgUFRTIGxvb3Bpbmcgb2NjdXJlZC4gZmlsbCB0aGUgZ2FwICovXG4gICAgICB3aGlsZSAoTWF0aC5hYnModmFsdWUgLSByZWZlcmVuY2UpID4gNDI5NDk2NzI5Nikge1xuICAgICAgICB2YWx1ZSArPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1QNFJlbXV4ZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1QNFJlbXV4ZXI7XG5cbn0se1wiMzFcIjozMSxcIjMzXCI6MzMsXCIzNFwiOjM0LFwiNDJcIjo0MixcIjUwXCI6NTB9XSw0NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHBhc3N0aHJvdWdoIHJlbXV4ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBQYXNzVGhyb3VnaFJlbXV4ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhc3NUaHJvdWdoUmVtdXhlcihvYnNlcnZlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXNzVGhyb3VnaFJlbXV4ZXIpO1xuXG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhc3NUaHJvdWdoUmVtdXhlciwgW3tcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldFRpbWVTdGFtcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKCkge31cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0SW5pdFNlZ21lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KCkge31cbiAgfSwge1xuICAgIGtleTogJ3JlbXV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCByYXdEYXRhKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgICAgdmFyIHN0cmVhbVR5cGUgPSAnJztcbiAgICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICAgIHN0cmVhbVR5cGUgKz0gJ2F1ZGlvJztcbiAgICAgIH1cbiAgICAgIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgICAgIHN0cmVhbVR5cGUgKz0gJ3ZpZGVvJztcbiAgICAgIH1cbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNJTkdfREFUQSwge1xuICAgICAgICBkYXRhMTogcmF3RGF0YSxcbiAgICAgICAgc3RhcnRQVFM6IHRpbWVPZmZzZXQsXG4gICAgICAgIHN0YXJ0RFRTOiB0aW1lT2Zmc2V0LFxuICAgICAgICB0eXBlOiBzdHJlYW1UeXBlLFxuICAgICAgICBuYjogMSxcbiAgICAgICAgZHJvcHBlZDogMFxuICAgICAgfSk7XG4gICAgICAvL25vdGlmeSBlbmQgb2YgcGFyc2luZ1xuICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0VEKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFzc1Rocm91Z2hSZW11eGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQYXNzVGhyb3VnaFJlbXV4ZXI7XG5cbn0se1wiMzNcIjozM31dLDQ1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWCA9IC9eKFxcZCspeChcXGQrKSQvO1xudmFyIEFUVFJfTElTVF9SRUdFWCA9IC9cXHMqKC4rPylcXHMqPSgoPzpcXFwiLio/XFxcIil8Lio/KSg/Oix8JCkvZztcblxuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5vbmdpbC9ub2RlLW0zdThwYXJzZS9ibG9iL21hc3Rlci9hdHRybGlzdC5qc1xuXG52YXIgQXR0ckxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF0dHJMaXN0KGF0dHJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF0dHJMaXN0KTtcblxuICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhdHRycyA9IEF0dHJMaXN0LnBhcnNlQXR0ckxpc3QoYXR0cnMpO1xuICAgIH1cbiAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgdGhpc1thdHRyXSA9IGF0dHJzW2F0dHJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBdHRyTGlzdCwgW3tcbiAgICBrZXk6ICdkZWNpbWFsSW50ZWdlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgICB2YXIgaW50VmFsdWUgPSBwYXJzZUludCh0aGlzW2F0dHJOYW1lXSwgMTApO1xuICAgICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGludFZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hleGFkZWNpbWFsSW50ZWdlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhleGFkZWNpbWFsSW50ZWdlcihhdHRyTmFtZSkge1xuICAgICAgaWYgKHRoaXNbYXR0ck5hbWVdKSB7XG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9ICh0aGlzW2F0dHJOYW1lXSB8fCAnMHgnKS5zbGljZSgyKTtcbiAgICAgICAgc3RyaW5nVmFsdWUgPSAoc3RyaW5nVmFsdWUubGVuZ3RoICYgMSA/ICcwJyA6ICcnKSArIHN0cmluZ1ZhbHVlO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICAgIHZhbHVlW2ldID0gcGFyc2VJbnQoc3RyaW5nVmFsdWUuc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoZXhhZGVjaW1hbEludGVnZXJBc051bWJlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhleGFkZWNpbWFsSW50ZWdlckFzTnVtYmVyKGF0dHJOYW1lKSB7XG4gICAgICB2YXIgaW50VmFsdWUgPSBwYXJzZUludCh0aGlzW2F0dHJOYW1lXSwgMTYpO1xuICAgICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGludFZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlY2ltYWxGbG9hdGluZ1BvaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjaW1hbEZsb2F0aW5nUG9pbnQoYXR0ck5hbWUpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXNbYXR0ck5hbWVdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbnVtZXJhdGVkU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW51bWVyYXRlZFN0cmluZyhhdHRyTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlY2ltYWxSZXNvbHV0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjaW1hbFJlc29sdXRpb24oYXR0ck5hbWUpIHtcbiAgICAgIHZhciByZXMgPSBERUNJTUFMX1JFU09MVVRJT05fUkVHRVguZXhlYyh0aGlzW2F0dHJOYW1lXSk7XG4gICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogcGFyc2VJbnQocmVzWzFdLCAxMCksXG4gICAgICAgIGhlaWdodDogcGFyc2VJbnQocmVzWzJdLCAxMClcbiAgICAgIH07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdwYXJzZUF0dHJMaXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VBdHRyTGlzdChpbnB1dCkge1xuICAgICAgdmFyIG1hdGNoLFxuICAgICAgICAgIGF0dHJzID0ge307XG4gICAgICBBVFRSX0xJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICAgIHdoaWxlICgobWF0Y2ggPSBBVFRSX0xJU1RfUkVHRVguZXhlYyhpbnB1dCkpICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG1hdGNoWzJdLFxuICAgICAgICAgICAgcXVvdGUgPSAnXCInO1xuXG4gICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKHF1b3RlKSA9PT0gMCAmJiB2YWx1ZS5sYXN0SW5kZXhPZihxdW90ZSkgPT09IHZhbHVlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyc1ttYXRjaFsxXV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRycztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXR0ckxpc3Q7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEF0dHJMaXN0O1xuXG59LHt9XSw0NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEJpbmFyeVNlYXJjaCA9IHtcbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBmb3IgYW4gaXRlbSBpbiBhbiBhcnJheSB3aGljaCBtYXRjaGVzIGEgY2VydGFpbiBjb25kaXRpb24uXG4gICAgICogVGhpcyByZXF1aXJlcyB0aGUgY29uZGl0aW9uIHRvIG9ubHkgbWF0Y2ggb25lIGl0ZW0gaW4gdGhlIGFycmF5LFxuICAgICAqIGFuZCBmb3IgdGhlIGFycmF5IHRvIGJlIG9yZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyaXNvbkZ1bmN0aW9uXG4gICAgICogICAgICBDYWxsZWQgYW5kIHByb3ZpZGVkIGEgY2FuZGlkYXRlIGl0ZW0gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgICAqICAgICAgU2hvdWxkIHJldHVybjpcbiAgICAgKiAgICAgICAgICA+IC0xIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgbG93ZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICAgKiAgICAgICAgICA+IDEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBoaWdoZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICAgKiAgICAgICAgICA+IDAgaWYgdGhlIGl0ZW0gaXMgdGhlIGl0ZW0geW91J3JlIGxvb2tpbmcgZm9yLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Kn0gVGhlIG9iamVjdCBpZiBpdCBpcyBmb3VuZCBvciBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWFyY2g6IGZ1bmN0aW9uIHNlYXJjaChsaXN0LCBjb21wYXJpc29uRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG1pbkluZGV4ID0gMDtcbiAgICAgICAgdmFyIG1heEluZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnRFbGVtZW50ID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IChtaW5JbmRleCArIG1heEluZGV4KSAvIDIgfCAwO1xuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBsaXN0W2N1cnJlbnRJbmRleF07XG5cbiAgICAgICAgICAgIHZhciBjb21wYXJpc29uUmVzdWx0ID0gY29tcGFyaXNvbkZ1bmN0aW9uKGN1cnJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGFyaXNvblJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmluYXJ5U2VhcmNoO1xuXG59LHt9XSw0NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKlxuICogVGhpcyBjb2RlIHdhcyBwb3J0ZWQgZnJvbSB0aGUgZGFzaC5qcyBwcm9qZWN0IGF0OlxuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2Jsb2IvZGV2ZWxvcG1lbnQvZXh0ZXJuYWxzL2NlYTYwOC1wYXJzZXIuanNcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9jb21taXQvODI2OWIyNmE3NjFlMDg1M2JiMjFkNzg3ODBlZDk0NTE0NGVjZGQ0ZCNkaWZmLTcxYmMyOTVhMmQ2YjZiNzA5M2ExZDMyOTBkNTNhNGIyXG4gKlxuICogVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBhcHBlYXJzIGJlbG93OlxuICpcbiAqIFRoZSBjb3B5cmlnaHQgaW4gdGhpcyBzb2Z0d2FyZSBpcyBiZWluZyBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgQlNEIExpY2Vuc2UsXG4gKiBpbmNsdWRlZCBiZWxvdy4gVGhpcyBzb2Z0d2FyZSBtYXkgYmUgc3ViamVjdCB0byBvdGhlciB0aGlyZCBwYXJ0eSBhbmQgY29udHJpYnV0b3JcbiAqIHJpZ2h0cywgaW5jbHVkaW5nIHBhdGVudCByaWdodHMsIGFuZCBubyBzdWNoIHJpZ2h0cyBhcmUgZ3JhbnRlZCB1bmRlciB0aGlzIGxpY2Vuc2UuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYsIERBU0ggSW5kdXN0cnkgRm9ydW0uXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gKiAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3JcbiAqICBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogIDIuIE5laXRoZXIgdGhlIG5hbWUgb2YgRGFzaCBJbmR1c3RyeSBGb3J1bSBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAqICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBBUyBJUyBBTkQgQU5ZXG4gKiAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC5cbiAqICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULFxuICogIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVRcbiAqICBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiAgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbi8qKlxuICogIEV4Y2VwdGlvbnMgZnJvbSByZWd1bGFyIEFTQ0lJLiBDb2RlUG9pbnRzIGFyZSBtYXBwZWQgdG8gVVRGLTE2IGNvZGVzXG4gKi9cblxudmFyIHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzID0ge1xuICAgIDB4MmE6IDB4ZTEsIC8vIGxvd2VyY2FzZSBhLCBhY3V0ZSBhY2NlbnRcbiAgICAweDVjOiAweGU5LCAvLyBsb3dlcmNhc2UgZSwgYWN1dGUgYWNjZW50XG4gICAgMHg1ZTogMHhlZCwgLy8gbG93ZXJjYXNlIGksIGFjdXRlIGFjY2VudFxuICAgIDB4NWY6IDB4ZjMsIC8vIGxvd2VyY2FzZSBvLCBhY3V0ZSBhY2NlbnRcbiAgICAweDYwOiAweGZhLCAvLyBsb3dlcmNhc2UgdSwgYWN1dGUgYWNjZW50XG4gICAgMHg3YjogMHhlNywgLy8gbG93ZXJjYXNlIGMgd2l0aCBjZWRpbGxhXG4gICAgMHg3YzogMHhmNywgLy8gZGl2aXNpb24gc3ltYm9sXG4gICAgMHg3ZDogMHhkMSwgLy8gdXBwZXJjYXNlIE4gdGlsZGVcbiAgICAweDdlOiAweGYxLCAvLyBsb3dlcmNhc2UgbiB0aWxkZVxuICAgIDB4N2Y6IDB4MjU4OCwgLy8gRnVsbCBibG9ja1xuICAgIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gICAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDExIEFORCBMT1cgQkVUV0VFTiAweDMwIEFORCAweDNGXG4gICAgLy8gVEhJUyBNRUFOUyBUSEFUIFxceDUwIE1VU1QgQkUgQURERUQgVE8gVEhFIFZBTFVFU1xuICAgIDB4ODA6IDB4YWUsIC8vIFJlZ2lzdGVyZWQgc3ltYm9sIChSKVxuICAgIDB4ODE6IDB4YjAsIC8vIGRlZ3JlZSBzaWduXG4gICAgMHg4MjogMHhiZCwgLy8gMS8yIHN5bWJvbFxuICAgIDB4ODM6IDB4YmYsIC8vIEludmVydGVkIChvcGVuKSBxdWVzdGlvbiBtYXJrXG4gICAgMHg4NDogMHgyMTIyLCAvLyBUcmFkZW1hcmsgc3ltYm9sIChUTSlcbiAgICAweDg1OiAweGEyLCAvLyBDZW50cyBzeW1ib2xcbiAgICAweDg2OiAweGEzLCAvLyBQb3VuZHMgc3RlcmxpbmdcbiAgICAweDg3OiAweDI2NmEsIC8vIE11c2ljIDgndGggbm90ZVxuICAgIDB4ODg6IDB4ZTAsIC8vIGxvd2VyY2FzZSBhLCBncmF2ZSBhY2NlbnRcbiAgICAweDg5OiAweDIwLCAvLyB0cmFuc3BhcmVudCBzcGFjZSAocmVndWxhcilcbiAgICAweDhhOiAweGU4LCAvLyBsb3dlcmNhc2UgZSwgZ3JhdmUgYWNjZW50XG4gICAgMHg4YjogMHhlMiwgLy8gbG93ZXJjYXNlIGEsIGNpcmN1bWZsZXggYWNjZW50XG4gICAgMHg4YzogMHhlYSwgLy8gbG93ZXJjYXNlIGUsIGNpcmN1bWZsZXggYWNjZW50XG4gICAgMHg4ZDogMHhlZSwgLy8gbG93ZXJjYXNlIGksIGNpcmN1bWZsZXggYWNjZW50XG4gICAgMHg4ZTogMHhmNCwgLy8gbG93ZXJjYXNlIG8sIGNpcmN1bWZsZXggYWNjZW50XG4gICAgMHg4ZjogMHhmYiwgLy8gbG93ZXJjYXNlIHUsIGNpcmN1bWZsZXggYWNjZW50XG4gICAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTIgQU5EIExPVyBCRVRXRUVOIDB4MjAgQU5EIDB4M0ZcbiAgICAweDkwOiAweGMxLCAvLyBjYXBpdGFsIGxldHRlciBBIHdpdGggYWN1dGVcbiAgICAweDkxOiAweGM5LCAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggYWN1dGVcbiAgICAweDkyOiAweGQzLCAvLyBjYXBpdGFsIGxldHRlciBPIHdpdGggYWN1dGVcbiAgICAweDkzOiAweGRhLCAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggYWN1dGVcbiAgICAweDk0OiAweGRjLCAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggZGlhcmVzaXNcbiAgICAweDk1OiAweGZjLCAvLyBsb3dlcmNhc2UgbGV0dGVyIFUgd2l0aCBkaWFlcmVzaXNcbiAgICAweDk2OiAweDIwMTgsIC8vIG9wZW5pbmcgc2luZ2xlIHF1b3RlXG4gICAgMHg5NzogMHhhMSwgLy8gaW52ZXJ0ZWQgZXhjbGFtYXRpb24gbWFya1xuICAgIDB4OTg6IDB4MmEsIC8vIGFzdGVyaXNrXG4gICAgMHg5OTogMHgyMDE5LCAvLyBjbG9zaW5nIHNpbmdsZSBxdW90ZVxuICAgIDB4OWE6IDB4MjUwMSwgLy8gYm94IGRyYXdpbmdzIGhlYXZ5IGhvcml6b250YWxcbiAgICAweDliOiAweGE5LCAvLyBjb3B5cmlnaHQgc2lnblxuICAgIDB4OWM6IDB4MjEyMCwgLy8gU2VydmljZSBtYXJrXG4gICAgMHg5ZDogMHgyMDIyLCAvLyAocm91bmQpIGJ1bGxldFxuICAgIDB4OWU6IDB4MjAxYywgLy8gTGVmdCBkb3VibGUgcXVvdGF0aW9uIG1hcmtcbiAgICAweDlmOiAweDIwMWQsIC8vIFJpZ2h0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAgIDB4YTA6IDB4YzAsIC8vIHVwcGVyY2FzZSBBLCBncmF2ZSBhY2NlbnRcbiAgICAweGExOiAweGMyLCAvLyB1cHBlcmNhc2UgQSwgY2lyY3VtZmxleFxuICAgIDB4YTI6IDB4YzcsIC8vIHVwcGVyY2FzZSBDIHdpdGggY2VkaWxsYVxuICAgIDB4YTM6IDB4YzgsIC8vIHVwcGVyY2FzZSBFLCBncmF2ZSBhY2NlbnRcbiAgICAweGE0OiAweGNhLCAvLyB1cHBlcmNhc2UgRSwgY2lyY3VtZmxleFxuICAgIDB4YTU6IDB4Y2IsIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBkaWFyZXNpc1xuICAgIDB4YTY6IDB4ZWIsIC8vIGxvd2VyY2FzZSBsZXR0ZXIgZSB3aXRoIGRpYXJlc2lzXG4gICAgMHhhNzogMHhjZSwgLy8gdXBwZXJjYXNlIEksIGNpcmN1bWZsZXhcbiAgICAweGE4OiAweGNmLCAvLyB1cHBlcmNhc2UgSSwgd2l0aCBkaWFyZXNpc1xuICAgIDB4YTk6IDB4ZWYsIC8vIGxvd2VyY2FzZSBpLCB3aXRoIGRpYXJlc2lzXG4gICAgMHhhYTogMHhkNCwgLy8gdXBwZXJjYXNlIE8sIGNpcmN1bWZsZXhcbiAgICAweGFiOiAweGQ5LCAvLyB1cHBlcmNhc2UgVSwgZ3JhdmUgYWNjZW50XG4gICAgMHhhYzogMHhmOSwgLy8gbG93ZXJjYXNlIHUsIGdyYXZlIGFjY2VudFxuICAgIDB4YWQ6IDB4ZGIsIC8vIHVwcGVyY2FzZSBVLCBjaXJjdW1mbGV4XG4gICAgMHhhZTogMHhhYiwgLy8gbGVmdC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgICAweGFmOiAweGJiLCAvLyByaWdodC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMyBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAgIDB4YjA6IDB4YzMsIC8vIFVwcGVyY2FzZSBBLCB0aWxkZVxuICAgIDB4YjE6IDB4ZTMsIC8vIExvd2VyY2FzZSBhLCB0aWxkZVxuICAgIDB4YjI6IDB4Y2QsIC8vIFVwcGVyY2FzZSBJLCBhY3V0ZSBhY2NlbnRcbiAgICAweGIzOiAweGNjLCAvLyBVcHBlcmNhc2UgSSwgZ3JhdmUgYWNjZW50XG4gICAgMHhiNDogMHhlYywgLy8gTG93ZXJjYXNlIGksIGdyYXZlIGFjY2VudFxuICAgIDB4YjU6IDB4ZDIsIC8vIFVwcGVyY2FzZSBPLCBncmF2ZSBhY2NlbnRcbiAgICAweGI2OiAweGYyLCAvLyBMb3dlcmNhc2UgbywgZ3JhdmUgYWNjZW50XG4gICAgMHhiNzogMHhkNSwgLy8gVXBwZXJjYXNlIE8sIHRpbGRlXG4gICAgMHhiODogMHhmNSwgLy8gTG93ZXJjYXNlIG8sIHRpbGRlXG4gICAgMHhiOTogMHg3YiwgLy8gT3BlbiBjdXJseSBicmFjZVxuICAgIDB4YmE6IDB4N2QsIC8vIENsb3NpbmcgY3VybHkgYnJhY2VcbiAgICAweGJiOiAweDVjLCAvLyBCYWNrc2xhc2hcbiAgICAweGJjOiAweDVlLCAvLyBDYXJldFxuICAgIDB4YmQ6IDB4NWYsIC8vIFVuZGVyc2NvcmVcbiAgICAweGJlOiAweDdjLCAvLyBQaXBlICh2ZXJ0aWNhbCBsaW5lKVxuICAgIDB4YmY6IDB4MjIzYywgLy8gVGlsZGUgb3BlcmF0b3JcbiAgICAweGMwOiAweGM0LCAvLyBVcHBlcmNhc2UgQSwgdW1sYXV0XG4gICAgMHhjMTogMHhlNCwgLy8gTG93ZXJjYXNlIEEsIHVtbGF1dFxuICAgIDB4YzI6IDB4ZDYsIC8vIFVwcGVyY2FzZSBPLCB1bWxhdXRcbiAgICAweGMzOiAweGY2LCAvLyBMb3dlcmNhc2UgbywgdW1sYXV0XG4gICAgMHhjNDogMHhkZiwgLy8gRXNzemV0dCAoc2hhcnAgUylcbiAgICAweGM1OiAweGE1LCAvLyBZZW4gc3ltYm9sXG4gICAgMHhjNjogMHhhNCwgLy8gR2VuZXJpYyBjdXJyZW5jeSBzaWduXG4gICAgMHhjNzogMHgyNTAzLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdmVydGljYWxcbiAgICAweGM4OiAweGM1LCAvLyBVcHBlcmNhc2UgQSwgcmluZ1xuICAgIDB4Yzk6IDB4ZTUsIC8vIExvd2VyY2FzZSBBLCByaW5nXG4gICAgMHhjYTogMHhkOCwgLy8gVXBwZXJjYXNlIE8sIHN0cm9rZVxuICAgIDB4Y2I6IDB4ZjgsIC8vIExvd2VyY2FzZSBvLCBzdHJva1xuICAgIDB4Y2M6IDB4MjUwZiwgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIHJpZ2h0XG4gICAgMHhjZDogMHgyNTEzLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgbGVmdFxuICAgIDB4Y2U6IDB4MjUxNywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCByaWdodFxuICAgIDB4Y2Y6IDB4MjUxYiAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIGxlZnRcbn07XG5cbi8qKlxuICogVXRpbHNcbiAqL1xudmFyIGdldENoYXJGb3JCeXRlID0gZnVuY3Rpb24gZ2V0Q2hhckZvckJ5dGUoYnl0ZSkge1xuICAgIHZhciBjaGFyQ29kZSA9IGJ5dGU7XG4gICAgaWYgKHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzLmhhc093blByb3BlcnR5KGJ5dGUpKSB7XG4gICAgICAgIGNoYXJDb2RlID0gc3BlY2lhbENlYTYwOENoYXJzQ29kZXNbYnl0ZV07XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn07XG5cbnZhciBOUl9ST1dTID0gMTUsXG4gICAgTlJfQ09MUyA9IDEwMDtcbi8vIFRhYmxlcyB0byBsb29rIHVwIHJvdyBmcm9tIFBBQyBkYXRhXG52YXIgcm93c0xvd0NoMSA9IHsgMHgxMTogMSwgMHgxMjogMywgMHgxNTogNSwgMHgxNjogNywgMHgxNzogOSwgMHgxMDogMTEsIDB4MTM6IDEyLCAweDE0OiAxNCB9O1xudmFyIHJvd3NIaWdoQ2gxID0geyAweDExOiAyLCAweDEyOiA0LCAweDE1OiA2LCAweDE2OiA4LCAweDE3OiAxMCwgMHgxMzogMTMsIDB4MTQ6IDE1IH07XG52YXIgcm93c0xvd0NoMiA9IHsgMHgxOTogMSwgMHgxQTogMywgMHgxRDogNSwgMHgxRTogNywgMHgxRjogOSwgMHgxODogMTEsIDB4MUI6IDEyLCAweDFDOiAxNCB9O1xudmFyIHJvd3NIaWdoQ2gyID0geyAweDE5OiAyLCAweDFBOiA0LCAweDFEOiA2LCAweDFFOiA4LCAweDFGOiAxMCwgMHgxQjogMTMsIDB4MUM6IDE1IH07XG5cbnZhciBiYWNrZ3JvdW5kQ29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ2JsYWNrJywgJ3RyYW5zcGFyZW50J107XG5cbi8qKlxuICogU2ltcGxlIGxvZ2dlciBjbGFzcyB0byBiZSBhYmxlIHRvIHdyaXRlIHdpdGggdGltZS1zdGFtcHMgYW5kIGZpbHRlciBvbiBsZXZlbC5cbiAqL1xudmFyIGxvZ2dlciA9IHtcbiAgICB2ZXJib3NlRmlsdGVyOiB7ICdEQVRBJzogMywgJ0RFQlVHJzogMywgJ0lORk8nOiAyLCAnV0FSTklORyc6IDIsICdURVhUJzogMSwgJ0VSUk9SJzogMCB9LFxuICAgIHRpbWU6IG51bGwsXG4gICAgdmVyYm9zZUxldmVsOiAwLCAvLyBPbmx5IHdyaXRlIGVycm9yc1xuICAgIHNldFRpbWU6IGZ1bmN0aW9uIHNldFRpbWUobmV3VGltZSkge1xuICAgICAgICB0aGlzLnRpbWUgPSBuZXdUaW1lO1xuICAgIH0sXG4gICAgbG9nOiBmdW5jdGlvbiBsb2coc2V2ZXJpdHksIG1zZykge1xuICAgICAgICB2YXIgbWluTGV2ZWwgPSB0aGlzLnZlcmJvc2VGaWx0ZXJbc2V2ZXJpdHldO1xuICAgICAgICBpZiAodGhpcy52ZXJib3NlTGV2ZWwgPj0gbWluTGV2ZWwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudGltZSArICcgWycgKyBzZXZlcml0eSArICddICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIG51bUFycmF5VG9IZXhBcnJheSA9IGZ1bmN0aW9uIG51bUFycmF5VG9IZXhBcnJheShudW1BcnJheSkge1xuICAgIHZhciBoZXhBcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaGV4QXJyYXkucHVzaChudW1BcnJheVtqXS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4QXJyYXk7XG59O1xuXG52YXIgUGVuU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGVuU3RhdGUoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGVuU3RhdGUpO1xuXG4gICAgICAgIHRoaXMuZm9yZWdyb3VuZCA9IGZvcmVncm91bmQgfHwgJ3doaXRlJztcbiAgICAgICAgdGhpcy51bmRlcmxpbmUgPSB1bmRlcmxpbmUgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuaXRhbGljcyA9IGl0YWxpY3MgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IGJhY2tncm91bmQgfHwgJ2JsYWNrJztcbiAgICAgICAgdGhpcy5mbGFzaCA9IGZsYXNoIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQZW5TdGF0ZSwgW3tcbiAgICAgICAga2V5OiAncmVzZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICB0aGlzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgICAgICAgICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXRhbGljcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gJ2JsYWNrJztcbiAgICAgICAgICAgIHRoaXMuZmxhc2ggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0U3R5bGVzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJzID0gWydmb3JlZ3JvdW5kJywgJ3VuZGVybGluZScsICdpdGFsaWNzJywgJ2JhY2tncm91bmQnLCAnZmxhc2gnXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGF0dHJpYnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tzdHlsZV0gPSBzdHlsZXNbc3R5bGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNEZWZhdWx0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGVmYXVsdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcmVncm91bmQgPT09ICd3aGl0ZScgJiYgIXRoaXMudW5kZXJsaW5lICYmICF0aGlzLml0YWxpY3MgJiYgdGhpcy5iYWNrZ3JvdW5kID09PSAnYmxhY2snICYmICF0aGlzLmZsYXNoO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlcXVhbHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JlZ3JvdW5kID09PSBvdGhlci5mb3JlZ3JvdW5kICYmIHRoaXMudW5kZXJsaW5lID09PSBvdGhlci51bmRlcmxpbmUgJiYgdGhpcy5pdGFsaWNzID09PSBvdGhlci5pdGFsaWNzICYmIHRoaXMuYmFja2dyb3VuZCA9PT0gb3RoZXIuYmFja2dyb3VuZCAmJiB0aGlzLmZsYXNoID09PSBvdGhlci5mbGFzaDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29weScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KG5ld1BlblN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmZvcmVncm91bmQgPSBuZXdQZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgICAgICAgICAgdGhpcy51bmRlcmxpbmUgPSBuZXdQZW5TdGF0ZS51bmRlcmxpbmU7XG4gICAgICAgICAgICB0aGlzLml0YWxpY3MgPSBuZXdQZW5TdGF0ZS5pdGFsaWNzO1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3UGVuU3RhdGUuYmFja2dyb3VuZDtcbiAgICAgICAgICAgIHRoaXMuZmxhc2ggPSBuZXdQZW5TdGF0ZS5mbGFzaDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NvbG9yPScgKyB0aGlzLmZvcmVncm91bmQgKyAnLCB1bmRlcmxpbmU9JyArIHRoaXMudW5kZXJsaW5lICsgJywgaXRhbGljcz0nICsgdGhpcy5pdGFsaWNzICsgJywgYmFja2dyb3VuZD0nICsgdGhpcy5iYWNrZ3JvdW5kICsgJywgZmxhc2g9JyArIHRoaXMuZmxhc2g7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUGVuU3RhdGU7XG59KCk7XG5cbi8qKlxuICogVW5pY29kZSBjaGFyYWN0ZXIgd2l0aCBzdHlsaW5nIGFuZCBiYWNrZ3JvdW5kLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgU3R5bGVkVW5pY29kZUNoYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVkVW5pY29kZUNoYXIodWNoYXIsIGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlZFVuaWNvZGVDaGFyKTtcblxuICAgICAgICB0aGlzLnVjaGFyID0gdWNoYXIgfHwgJyAnOyAvLyB1bmljb2RlIGNoYXJhY3RlclxuICAgICAgICB0aGlzLnBlblN0YXRlID0gbmV3IFBlblN0YXRlKGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhTdHlsZWRVbmljb2RlQ2hhciwgW3tcbiAgICAgICAga2V5OiAncmVzZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICB0aGlzLnVjaGFyID0gJyAnO1xuICAgICAgICAgICAgdGhpcy5wZW5TdGF0ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRDaGFyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldENoYXIodWNoYXIsIG5ld1BlblN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnVjaGFyID0gdWNoYXI7XG4gICAgICAgICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRQZW5TdGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQZW5TdGF0ZShuZXdQZW5TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXF1YWxzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudWNoYXIgPT09IG90aGVyLnVjaGFyICYmIHRoaXMucGVuU3RhdGUuZXF1YWxzKG90aGVyLnBlblN0YXRlKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29weScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KG5ld0NoYXIpIHtcbiAgICAgICAgICAgIHRoaXMudWNoYXIgPSBuZXdDaGFyLnVjaGFyO1xuICAgICAgICAgICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld0NoYXIucGVuU3RhdGUpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc0VtcHR5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gJyAnICYmIHRoaXMucGVuU3RhdGUuaXNEZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU3R5bGVkVW5pY29kZUNoYXI7XG59KCk7XG5cbi8qKlxuICogQ0VBLTYwOCByb3cgY29uc2lzdGluZyBvZiBOUl9DT0xTIGluc3RhbmNlcyBvZiBTdHlsZWRVbmljb2RlQ2hhci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3coKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3cpO1xuXG4gICAgICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2hhcnMucHVzaChuZXcgU3R5bGVkVW5pY29kZUNoYXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmN1cnJQZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZSgpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhSb3csIFt7XG4gICAgICAgIGtleTogJ2VxdWFscycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciBlcXVhbCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5lcXVhbHMob3RoZXIuY2hhcnNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlcXVhbDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29weScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KG90aGVyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhcnNbaV0uY29weShvdGhlci5jaGFyc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzRW1wdHknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICBTZXQgdGhlIGN1cnNvciB0byBhIHZhbGlkIGNvbHVtbi5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldEN1cnNvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXJzb3IoYWJzUG9zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgIT09IGFic1Bvcykge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gYWJzUG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucG9zIDwgMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ05lZ2F0aXZlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wb3MgPiBOUl9DT0xTKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnVG9vIGxhcmdlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gTlJfQ09MUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb3ZlIHRoZSBjdXJzb3IgcmVsYXRpdmUgdG8gY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21vdmVDdXJzb3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZUN1cnNvcihyZWxQb3MpIHtcbiAgICAgICAgICAgIHZhciBuZXdQb3MgPSB0aGlzLnBvcyArIHJlbFBvcztcbiAgICAgICAgICAgIGlmIChyZWxQb3MgPiAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zICsgMTsgaSA8IG5ld1BvcyArIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJzW2ldLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihuZXdQb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhY2tzcGFjZSwgbW92ZSBvbmUgc3RlcCBiYWNrIGFuZCBjbGVhciBjaGFyYWN0ZXIuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdiYWNrU3BhY2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmFja1NwYWNlKCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yKC0xKTtcbiAgICAgICAgICAgIHRoaXMuY2hhcnNbdGhpcy5wb3NdLnNldENoYXIoJyAnLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2luc2VydENoYXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Q2hhcihieXRlKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZSA+PSAweDkwKSB7XG4gICAgICAgICAgICAgICAgLy9FeHRlbmRlZCBjaGFyXG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGFyID0gZ2V0Q2hhckZvckJ5dGUoYnl0ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gTlJfQ09MUykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ0Nhbm5vdCBpbnNlcnQgJyArIGJ5dGUudG9TdHJpbmcoMTYpICsgJyAoJyArIGNoYXIgKyAnKSBhdCBwb3NpdGlvbiAnICsgdGhpcy5wb3MgKyAnLiBTa2lwcGluZyBpdCEnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKGNoYXIsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvcigxKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2xlYXJGcm9tUG9zJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyRnJvbVBvcyhzdGFydFBvcykge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSBzdGFydFBvczsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhcnNbaV0ucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2xlYXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyRnJvbVBvcygwKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuY3VyclBlblN0YXRlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NsZWFyVG9FbmRPZlJvdycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclRvRW5kT2ZSb3coKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyRnJvbVBvcyh0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFRleHRTdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dFN0cmluZygpIHtcbiAgICAgICAgICAgIHZhciBjaGFycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXIgPSB0aGlzLmNoYXJzW2ldLnVjaGFyO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyICE9PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhcnMucHVzaChjaGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRQZW5TdHlsZXMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGVuU3R5bGVzKHN0eWxlcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyUGVuU3RhdGUuc2V0U3R5bGVzKHN0eWxlcyk7XG4gICAgICAgICAgICB2YXIgY3VyckNoYXIgPSB0aGlzLmNoYXJzW3RoaXMucG9zXTtcbiAgICAgICAgICAgIGN1cnJDaGFyLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBSb3c7XG59KCk7XG5cbi8qKlxuICogS2VlcCBhIENFQS02MDggc2NyZWVuIG9mIDMyeDE1IHN0eWxlZCBjaGFyYWN0ZXJzXG4gKiBAY29uc3RydWN0b3JcbiovXG5cblxudmFyIENhcHRpb25TY3JlZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FwdGlvblNjcmVlbigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhcHRpb25TY3JlZW4pO1xuXG4gICAgICAgIHRoaXMucm93cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzLnB1c2gobmV3IFJvdygpKTsgLy8gTm90ZSB0aGF0IHdlIHVzZSB6ZXJvLWJhc2VkIG51bWJlcmluZyAoMC0xNClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgICAgICAgdGhpcy5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENhcHRpb25TY3JlZW4sIFt7XG4gICAgICAgIGtleTogJ3Jlc2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvd3NbaV0uY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlcXVhbHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICB2YXIgZXF1YWwgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucm93c1tpXS5lcXVhbHMob3RoZXIucm93c1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVxdWFsO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb3B5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkob3RoZXIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzW2ldLmNvcHkob3RoZXIucm93c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzRW1wdHknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yb3dzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2JhY2tTcGFjZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBiYWNrU3BhY2UoKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgICAgICByb3cuYmFja1NwYWNlKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NsZWFyVG9FbmRPZlJvdycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclRvRW5kT2ZSb3coKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgICAgICByb3cuY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IGEgY2hhcmFjdGVyICh3aXRob3V0IHN0eWxpbmcpIGluIHRoZSBjdXJyZW50IHJvdy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2luc2VydENoYXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Q2hhcihjaGFyKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgICAgICByb3cuaW5zZXJ0Q2hhcihjaGFyKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0UGVuJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBlbihzdHlsZXMpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgICAgIHJvdy5zZXRQZW5TdHlsZXMoc3R5bGVzKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbW92ZUN1cnNvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlQ3Vyc29yKHJlbFBvcykge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICAgICAgcm93Lm1vdmVDdXJzb3IocmVsUG9zKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0Q3Vyc29yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1cnNvcihhYnNQb3MpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnc2V0Q3Vyc29yOiAnICsgYWJzUG9zKTtcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgICAgIHJvdy5zZXRDdXJzb3IoYWJzUG9zKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0UEFDJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBBQyhwYWNEYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ3BhY0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkocGFjRGF0YSkpO1xuICAgICAgICAgICAgdmFyIG5ld1JvdyA9IHBhY0RhdGEucm93IC0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiBuZXdSb3cgPCB0aGlzLm5yUm9sbFVwUm93cyAtIDEpIHtcbiAgICAgICAgICAgICAgICBuZXdSb3cgPSB0aGlzLm5yUm9sbFVwUm93cyAtIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vTWFrZSBzdXJlIHRoaXMgb25seSBhZmZlY3RzIFJvbGwtdXAgQ2FwdGlvbnMgYnkgY2hlY2tpbmcgdGhpcy5uclJvbGxVcFJvd3NcbiAgICAgICAgICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiB0aGlzLmN1cnJSb3cgIT09IG5ld1Jvdykge1xuICAgICAgICAgICAgICAgIC8vY2xlYXIgYWxsIHJvd3MgZmlyc3RcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd3NbaV0uY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL0NvcHkgdGhpcy5uclJvbGxVcFJvd3Mgcm93cyBmcm9tIGxhc3RPdXRwdXRTY3JlZW4gYW5kIHBsYWNlIGl0IGluIHRoZSBuZXdSb3cgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAvL3RvcFJvd0luZGV4IC0gdGhlIHN0YXJ0IG9mIHJvd3MgdG8gY29weSAoaW5jbHVzaXZlIGluZGV4KVxuICAgICAgICAgICAgICAgIHZhciB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSB0aGlzLm5yUm9sbFVwUm93cztcbiAgICAgICAgICAgICAgICAvL1dlIG9ubHkgY29weSBpZiB0aGUgbGFzdCBwb3NpdGlvbiB3YXMgYWxyZWFkeSBzaG93bi5cbiAgICAgICAgICAgICAgICAvL1dlIHVzZSB0aGUgY3VlU3RhcnRUaW1lIHZhbHVlIHRvIGNoZWNrIHRoaXMuXG4gICAgICAgICAgICAgICAgdmFyIGxhc3RPdXRwdXRTY3JlZW4gPSB0aGlzLmxhc3RPdXRwdXRTY3JlZW47XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RPdXRwdXRTY3JlZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZMaW5lVGltZSA9IGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleF0uY3VlU3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldkxpbmVUaW1lICYmIHByZXZMaW5lVGltZSA8IGxvZ2dlci50aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5uclJvbGxVcFJvd3M7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd3NbbmV3Um93IC0gdGhpcy5uclJvbGxVcFJvd3MgKyBfaSArIDFdLmNvcHkobGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4ICsgX2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdXJyUm93ID0gbmV3Um93O1xuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICAgICAgaWYgKHBhY0RhdGEuaW5kZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGVudCA9IHBhY0RhdGEuaW5kZW50O1xuICAgICAgICAgICAgICAgIHZhciBwcmV2UG9zID0gTWF0aC5tYXgoaW5kZW50IC0gMSwgMCk7XG4gICAgICAgICAgICAgICAgcm93LnNldEN1cnNvcihwYWNEYXRhLmluZGVudCk7XG4gICAgICAgICAgICAgICAgcGFjRGF0YS5jb2xvciA9IHJvdy5jaGFyc1twcmV2UG9zXS5wZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHsgZm9yZWdyb3VuZDogcGFjRGF0YS5jb2xvciwgdW5kZXJsaW5lOiBwYWNEYXRhLnVuZGVybGluZSwgaXRhbGljczogcGFjRGF0YS5pdGFsaWNzLCBiYWNrZ3JvdW5kOiAnYmxhY2snLCBmbGFzaDogZmFsc2UgfTtcbiAgICAgICAgICAgIHRoaXMuc2V0UGVuKHN0eWxlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGJhY2tncm91bmQvZXh0cmEgZm9yZWdyb3VuZCwgYnV0IGZpcnN0IGRvIGJhY2tfc3BhY2UsIGFuZCB0aGVuIGluc2VydCBzcGFjZSAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0QmtnRGF0YScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRCa2dEYXRhKGJrZ0RhdGEpIHtcblxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdia2dEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KGJrZ0RhdGEpKTtcbiAgICAgICAgICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgICAgICAgICB0aGlzLnNldFBlbihia2dEYXRhKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0Q2hhcigweDIwKTsgLy9TcGFjZVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRSb2xsVXBSb3dzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFJvbGxVcFJvd3MobnJSb3dzKSB7XG4gICAgICAgICAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG5yUm93cztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncm9sbFVwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJvbGxVcCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ3JvbGxfdXAgYnV0IG5yUm9sbFVwUm93cyBub3Qgc2V0IHlldCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy9Ob3QgcHJvcGVybHkgc2V0dXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCB0aGlzLmdldERpc3BsYXlUZXh0KCkpO1xuICAgICAgICAgICAgdmFyIHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtIHRoaXMubnJSb2xsVXBSb3dzO1xuICAgICAgICAgICAgdmFyIHRvcFJvdyA9IHRoaXMucm93cy5zcGxpY2UodG9wUm93SW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgdG9wUm93LmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnJvd3Muc3BsaWNlKHRoaXMuY3VyclJvdywgMCwgdG9wUm93KTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUm9sbGluZyB1cCcpO1xuICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdURVhUJywgdGhpcy5nZXRfZGlzcGxheV90ZXh0KCkpXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFsbCBub24tZW1wdHkgcm93cyB3aXRoIGFzIHVuaWNvZGUgdGV4dC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldERpc3BsYXlUZXh0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpc3BsYXlUZXh0KGFzT25lUm93KSB7XG4gICAgICAgICAgICBhc09uZVJvdyA9IGFzT25lUm93IHx8IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlUZXh0ID0gW107XG4gICAgICAgICAgICB2YXIgdGV4dCA9ICcnO1xuICAgICAgICAgICAgdmFyIHJvd05yID0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByb3dUZXh0ID0gdGhpcy5yb3dzW2ldLmdldFRleHRTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAocm93VGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByb3dOciA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2goJ1JvdyAnICsgcm93TnIgKyAnOiBcXCcnICsgcm93VGV4dCArICdcXCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2gocm93VGV4dC50cmltKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc3BsYXlUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICdbJyArIGRpc3BsYXlUZXh0LmpvaW4oJyB8ICcpICsgJ10nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0VGV4dEFuZEZvcm1hdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0QW5kRm9ybWF0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93cztcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDYXB0aW9uU2NyZWVuO1xufSgpO1xuXG4vL3ZhciBtb2RlcyA9IFsnTU9ERV9ST0xMLVVQJywgJ01PREVfUE9QLU9OJywgJ01PREVfUEFJTlQtT04nLCAnTU9ERV9URVhUJ107XG5cbnZhciBDZWE2MDhDaGFubmVsID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENlYTYwOENoYW5uZWwoY2hhbm5lbE51bWJlciwgb3V0cHV0RmlsdGVyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDZWE2MDhDaGFubmVsKTtcblxuICAgICAgICB0aGlzLmNoTnIgPSBjaGFubmVsTnVtYmVyO1xuICAgICAgICB0aGlzLm91dHB1dEZpbHRlciA9IG91dHB1dEZpbHRlcjtcbiAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy52ZXJib3NlID0gMDtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XG4gICAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XG4gICAgICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LnJvd3NbTlJfUk9XUyAtIDFdO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDsgLy8gS2VlcHMgdHJhY2sgb2Ygd2hlcmUgYSBjdWUgc3RhcnRlZC5cbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2VhNjA4Q2hhbm5lbCwgW3tcbiAgICAgICAga2V5OiAncmVzZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4ucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LnJvd3NbTlJfUk9XUyAtIDFdO1xuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdEN1ZUVuZFRpbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRIYW5kbGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhhbmRsZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRGaWx0ZXI7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldEhhbmRsZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SGFuZGxlcihuZXdIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlciA9IG5ld0hhbmRsZXI7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldFBBQycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQQUMocGFjRGF0YSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQQUMocGFjRGF0YSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldEJrZ0RhdGEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QmtnRGF0YShia2dEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldE1vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TW9kZShuZXdNb2RlKSB7XG4gICAgICAgICAgICBpZiAobmV3TW9kZSA9PT0gdGhpcy5tb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnTU9ERT0nICsgbmV3TW9kZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubW9kZSAhPT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpbnNlcnRDaGFycycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRDaGFycyhjaGFycykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4uaW5zZXJ0Q2hhcihjaGFyc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2NyZWVuID0gdGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPyAnRElTUCcgOiAnTk9OX0RJU1AnO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsIHNjcmVlbiArICc6ICcgKyB0aGlzLndyaXRlU2NyZWVuLmdldERpc3BsYXlUZXh0KHRydWUpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BBSU5ULU9OJyB8fCB0aGlzLm1vZGUgPT09ICdNT0RFX1JPTEwtVVAnKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnVEVYVCcsICdESVNQTEFZRUQ6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCh0cnVlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NjUkNMJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNjUkNMKCkge1xuICAgICAgICAgICAgLy8gUmVzdW1lIENhcHRpb24gTG9hZGluZyAoc3dpdGNoIG1vZGUgdG8gUG9wIE9uKVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSQ0wgLSBSZXN1bWUgQ2FwdGlvbiBMb2FkaW5nJyk7XG4gICAgICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfUE9QLU9OJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NjQlMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2NCUygpIHtcbiAgICAgICAgICAgIC8vIEJhY2tTcGFjZVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdCUyAtIEJhY2tTcGFjZScpO1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfVEVYVCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuLmJhY2tTcGFjZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NjQU9GJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNjQU9GKCkge1xuICAgICAgICAgICAgLy8gUmVzZXJ2ZWQgKGZvcm1lcmx5IEFsYXJtIE9mZilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2NBT04nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2NBT04oKSB7XG4gICAgICAgICAgICAvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NjREVSJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNjREVSKCkge1xuICAgICAgICAgICAgLy8gRGVsZXRlIHRvIEVuZCBvZiBSb3dcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnREVSLSBEZWxldGUgdG8gRW5kIG9mIFJvdycpO1xuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5jbGVhclRvRW5kT2ZSb3coKTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjY1JVJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNjUlUobnJSb3dzKSB7XG4gICAgICAgICAgICAvL1JvbGwtVXAgQ2FwdGlvbnMtMiwzLG9yIDQgUm93c1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSVSgnICsgbnJSb3dzICsgJykgLSBSb2xsIFVwJyk7XG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfUk9MTC1VUCcpO1xuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRSb2xsVXBSb3dzKG5yUm93cyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NjRk9OJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNjRk9OKCkge1xuICAgICAgICAgICAgLy9GbGFzaCBPblxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdGT04gLSBGbGFzaCBPbicpO1xuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oeyBmbGFzaDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2NSREMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2NSREMoKSB7XG4gICAgICAgICAgICAvLyBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcgKHN3aXRjaCBtb2RlIHRvIFBhaW50T24pXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JEQyAtIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZycpO1xuICAgICAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BBSU5ULU9OJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NjVFInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2NUUigpIHtcbiAgICAgICAgICAgIC8vIFRleHQgUmVzdGFydCBpbiB0ZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1RSJyk7XG4gICAgICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjY1JURCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjY1JURCgpIHtcbiAgICAgICAgICAgIC8vIFJlc3VtZSBUZXh0IERpc3BsYXkgaW4gVGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSVEQnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NjRURNJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNjRURNKCkge1xuICAgICAgICAgICAgLy8gRXJhc2UgRGlzcGxheWVkIE1lbW9yeVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdFRE0gLSBFcmFzZSBEaXNwbGF5ZWQgTWVtb3J5Jyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NjQ1InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2NDUigpIHtcbiAgICAgICAgICAgIC8vIENhcnJpYWdlIFJldHVyblxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnQ1IgLSBDYXJyaWFnZSBSZXR1cm4nKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4ucm9sbFVwKCk7XG4gICAgICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2NFTk0nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2NFTk0oKSB7XG4gICAgICAgICAgICAvL0VyYXNlIE5vbi1EaXNwbGF5ZWQgTWVtb3J5XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0VOTSAtIEVyYXNlIE5vbi1kaXNwbGF5ZWQgTWVtb3J5Jyk7XG4gICAgICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjY0VPQycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjY0VPQygpIHtcbiAgICAgICAgICAgIC8vRW5kIG9mIENhcHRpb24gKEZsaXAgTWVtb3JpZXMpXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0VPQyAtIEVuZCBPZiBDYXB0aW9uJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSB0bXA7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCAnRElTUDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NjVE8nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2NUTyhuckNvbHMpIHtcbiAgICAgICAgICAgIC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnVE8oJyArIG5yQ29scyArICcpIC0gVGFiIE9mZnNldCcpO1xuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5tb3ZlQ3Vyc29yKG5yQ29scyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NjTUlEUk9XJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNjTUlEUk9XKHNlY29uZEJ5dGUpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIE1JRFJPVyBjb21tYW5kXG4gICAgICAgICAgICB2YXIgc3R5bGVzID0geyBmbGFzaDogZmFsc2UgfTtcbiAgICAgICAgICAgIHN0eWxlcy51bmRlcmxpbmUgPSBzZWNvbmRCeXRlICUgMiA9PT0gMTtcbiAgICAgICAgICAgIHN0eWxlcy5pdGFsaWNzID0gc2Vjb25kQnl0ZSA+PSAweDJlO1xuICAgICAgICAgICAgaWYgKCFzdHlsZXMuaXRhbGljcykge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvckluZGV4ID0gTWF0aC5mbG9vcihzZWNvbmRCeXRlIC8gMikgLSAweDEwO1xuICAgICAgICAgICAgICAgIHZhciBjb2xvcnMgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnXTtcbiAgICAgICAgICAgICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9IGNvbG9yc1tjb2xvckluZGV4XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdNSURST1c6ICcgKyBKU09OLnN0cmluZ2lmeShzdHlsZXMpKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHN0eWxlcyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ291dHB1dERhdGFVcGRhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb3V0cHV0RGF0YVVwZGF0ZSgpIHtcbiAgICAgICAgICAgIHZhciB0ID0gbG9nZ2VyLnRpbWU7XG4gICAgICAgICAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci51cGRhdGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLnVwZGF0ZURhdGEodCwgdGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdWVTdGFydFRpbWUgPT09IG51bGwgJiYgIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBvZiBhIG5ldyBjdWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZXF1YWxzKHRoaXMubGFzdE91dHB1dFNjcmVlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHQsIHRoaXMubGFzdE91dHB1dFNjcmVlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSA/IG51bGwgOiB0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5jb3B5KHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY3VlU3BsaXRBdFRpbWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3VlU3BsaXRBdFRpbWUodCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDZWE2MDhDaGFubmVsO1xufSgpO1xuXG52YXIgQ2VhNjA4UGFyc2VyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENlYTYwOFBhcnNlcihmaWVsZCwgb3V0MSwgb3V0Mikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2VhNjA4UGFyc2VyKTtcblxuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQgfHwgMTtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gW291dDEsIG91dDJdO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gW25ldyBDZWE2MDhDaGFubmVsKDEsIG91dDEpLCBuZXcgQ2VhNjA4Q2hhbm5lbCgyLCBvdXQyKV07XG4gICAgICAgIHRoaXMuY3VyckNoTnIgPSAtMTsgLy8gV2lsbCBiZSAxIG9yIDJcbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7IC8vIEZpcnN0IGJ5dGUgb2YgbGFzdCBjb21tYW5kXG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsOyAvLyBTZWNvbmQgYnl0ZSBvZiBsYXN0IGNvbW1hbmRcbiAgICAgICAgdGhpcy5idWZmZXJlZERhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMgPSB7ICdwYWRkaW5nJzogMCwgJ2NoYXInOiAwLCAnY21kJzogMCwgJ290aGVyJzogMCB9O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDZWE2MDhQYXJzZXIsIFt7XG4gICAgICAgIGtleTogJ2dldEhhbmRsZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGFuZGxlcihpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbaW5kZXhdLmdldEhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0SGFuZGxlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIYW5kbGVyKGluZGV4LCBuZXdIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzW2luZGV4XS5zZXRIYW5kbGVyKG5ld0hhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBkYXRhIGZvciB0aW1lIHQgaW4gZm9ybXMgb2YgbGlzdCBvZiBieXRlcyAodW5zaWduZWQgaW50cykuIFRoZSBieXRlcyBhcmUgdHJlYXRlZCBhcyBwYWlycy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZERhdGEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRGF0YSh0LCBieXRlTGlzdCkge1xuICAgICAgICAgICAgdmFyIGNtZEZvdW5kLFxuICAgICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgICAgYixcbiAgICAgICAgICAgICAgICBjaGFyc0ZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHRoaXMubGFzdFRpbWUgPSB0O1xuICAgICAgICAgICAgbG9nZ2VyLnNldFRpbWUodCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZUxpc3QubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBhID0gYnl0ZUxpc3RbaV0gJiAweDdmO1xuICAgICAgICAgICAgICAgIGIgPSBieXRlTGlzdFtpICsgMV0gJiAweDdmO1xuICAgICAgICAgICAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMucGFkZGluZyArPSAyO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdEQVRBJywgJ1snICsgbnVtQXJyYXlUb0hleEFycmF5KFtieXRlTGlzdFtpXSwgYnl0ZUxpc3RbaSArIDFdXSkgKyAnXSAtPiAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQ21kKGEsIGIpO1xuICAgICAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlTWlkcm93KGEsIGIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZVBBQyhhLCBiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyhhLCBiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc0ZvdW5kID0gdGhpcy5wYXJzZUNoYXJzKGEsIGIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnNGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VyckNoTnIgJiYgdGhpcy5jdXJyQ2hOciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW3RoaXMuY3VyckNoTnIgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmluc2VydENoYXJzKGNoYXJzRm91bmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdXQVJOSU5HJywgJ05vIGNoYW5uZWwgZm91bmQgeWV0LiBURVhULU1PREU/Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLmNtZCArPSAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhcnNGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5jaGFyICs9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMub3RoZXIgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdDb3VsZG5cXCd0IHBhcnNlIGNsZWFuZWQgZGF0YSAnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnIG9yaWc6ICcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpICsgMV1dKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlIENvbW1hbmQuXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBhIGNvbW1hbmQgd2FzIGZvdW5kXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwYXJzZUNtZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUNtZChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgY2hOciA9IG51bGw7XG5cbiAgICAgICAgICAgIHZhciBjb25kMSA9IChhID09PSAweDE0IHx8IGEgPT09IDB4MUMpICYmIDB4MjAgPD0gYiAmJiBiIDw9IDB4MkY7XG4gICAgICAgICAgICB2YXIgY29uZDIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFGKSAmJiAweDIxIDw9IGIgJiYgYiA8PSAweDIzO1xuICAgICAgICAgICAgaWYgKCEoY29uZDEgfHwgY29uZDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYSA9PT0gdGhpcy5sYXN0Q21kQSAmJiBiID09PSB0aGlzLmxhc3RDbWRCKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7IC8vIFJlcGVhdGVkIGNvbW1hbmRzIGFyZSBkcm9wcGVkIChvbmNlKVxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ1JlcGVhdGVkIGNvbW1hbmQgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpIGlzIGRyb3BwZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxNykge1xuICAgICAgICAgICAgICAgIGNoTnIgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaE5yID0gMjsgLy8gKGEgPT09IDB4MUMgfHwgYT09PSAweDFmKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOciAtIDFdO1xuXG4gICAgICAgICAgICBpZiAoYSA9PT0gMHgxNCB8fCBhID09PSAweDFDKSB7XG4gICAgICAgICAgICAgICAgaWYgKGIgPT09IDB4MjApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JDTCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNjQlMoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jY0FPRigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMykge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNjQU9OKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NERVIoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JVKDIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNikge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNjUlUoMyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI3KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSg0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jY0ZPTigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNjUkRDKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJBKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NUUigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyQikge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNjUlREKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJDKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NFRE0oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jY0NSKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NFTk0oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jY0VPQygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9hID09IDB4MTcgfHwgYSA9PSAweDFGXG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1RPKGIgLSAweDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdENtZEEgPSBhO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQiA9IGI7XG4gICAgICAgICAgICB0aGlzLmN1cnJDaE5yID0gY2hOcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlIG1pZHJvdyBzdHlsaW5nIGNvbW1hbmRcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwYXJzZU1pZHJvdycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU1pZHJvdyhhLCBiKSB7XG4gICAgICAgICAgICB2YXIgY2hOciA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmICgoYSA9PT0gMHgxMSB8fCBhID09PSAweDE5KSAmJiAweDIwIDw9IGIgJiYgYiA8PSAweDJmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IDB4MTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hOciA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hOciA9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaE5yICE9PSB0aGlzLmN1cnJDaE5yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ01pc21hdGNoIGNoYW5uZWwgaW4gbWlkcm93IHBhcnNpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOciAtIDFdO1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NNSURST1coYik7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnTUlEUk9XICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZSBQcmVhYmxlIEFjY2VzcyBDb2RlcyAoVGFibGUgNTMpLlxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGVsbHMgaWYgUEFDIGZvdW5kXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwYXJzZVBBQycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVBBQyhhLCBiKSB7XG5cbiAgICAgICAgICAgIHZhciBjaE5yID0gbnVsbDtcbiAgICAgICAgICAgIHZhciByb3cgPSBudWxsO1xuXG4gICAgICAgICAgICB2YXIgY2FzZTEgPSAoMHgxMSA8PSBhICYmIGEgPD0gMHgxNyB8fCAweDE5IDw9IGEgJiYgYSA8PSAweDFGKSAmJiAweDQwIDw9IGIgJiYgYiA8PSAweDdGO1xuICAgICAgICAgICAgdmFyIGNhc2UyID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgMHg0MCA8PSBiICYmIGIgPD0gMHg1RjtcbiAgICAgICAgICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hOciA9IGEgPD0gMHgxNyA/IDEgOiAyO1xuXG4gICAgICAgICAgICBpZiAoMHg0MCA8PSBiICYmIGIgPD0gMHg1Rikge1xuICAgICAgICAgICAgICAgIHJvdyA9IGNoTnIgPT09IDEgPyByb3dzTG93Q2gxW2FdIDogcm93c0xvd0NoMlthXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gMHg2MCA8PSBiIDw9IDB4N0ZcbiAgICAgICAgICAgICAgICByb3cgPSBjaE5yID09PSAxID8gcm93c0hpZ2hDaDFbYV0gOiByb3dzSGlnaENoMlthXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYWNEYXRhID0gdGhpcy5pbnRlcnByZXRQQUMocm93LCBiKTtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG4gICAgICAgICAgICBjaGFubmVsLnNldFBBQyhwYWNEYXRhKTtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEEgPSBhO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQiA9IGI7XG4gICAgICAgICAgICB0aGlzLmN1cnJDaE5yID0gY2hOcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVycHJldCB0aGUgc2Vjb25kIGJ5dGUgb2YgdGhlIHBhYywgYW5kIHJldHVybiB0aGUgaW5mb3JtYXRpb24uXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHBhY0RhdGEgd2l0aCBzdHlsZSBwYXJhbWV0ZXJzLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaW50ZXJwcmV0UEFDJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGludGVycHJldFBBQyhyb3csIGJ5dGUpIHtcbiAgICAgICAgICAgIHZhciBwYWNJbmRleCA9IGJ5dGU7XG4gICAgICAgICAgICB2YXIgcGFjRGF0YSA9IHsgY29sb3I6IG51bGwsIGl0YWxpY3M6IGZhbHNlLCBpbmRlbnQ6IG51bGwsIHVuZGVybGluZTogZmFsc2UsIHJvdzogcm93IH07XG5cbiAgICAgICAgICAgIGlmIChieXRlID4gMHg1Rikge1xuICAgICAgICAgICAgICAgIHBhY0luZGV4ID0gYnl0ZSAtIDB4NjA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhY0luZGV4ID0gYnl0ZSAtIDB4NDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWNEYXRhLnVuZGVybGluZSA9IChwYWNJbmRleCAmIDEpID09PSAxO1xuICAgICAgICAgICAgaWYgKHBhY0luZGV4IDw9IDB4ZCkge1xuICAgICAgICAgICAgICAgIHBhY0RhdGEuY29sb3IgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnd2hpdGUnXVtNYXRoLmZsb29yKHBhY0luZGV4IC8gMildO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYWNJbmRleCA8PSAweGYpIHtcbiAgICAgICAgICAgICAgICBwYWNEYXRhLml0YWxpY3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhY0RhdGEuY29sb3IgPSAnd2hpdGUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYWNEYXRhLmluZGVudCA9IE1hdGguZmxvb3IoKHBhY0luZGV4IC0gMHgxMCkgLyAyKSAqIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFjRGF0YTsgLy8gTm90ZSB0aGF0IHJvdyBoYXMgemVybyBvZmZzZXQuIFRoZSBzcGVjIHVzZXMgMS5cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIDEgdG8gMiBjb2RlcyBjb3JyZXNwb25kaW5nIHRvIGNoYXJzLCBpZiBmb3VuZC4gbnVsbCBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwYXJzZUNoYXJzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlQ2hhcnMoYSwgYikge1xuXG4gICAgICAgICAgICB2YXIgY2hhbm5lbE5yID0gbnVsbCxcbiAgICAgICAgICAgICAgICBjaGFyQ29kZXMgPSBudWxsLFxuICAgICAgICAgICAgICAgIGNoYXJDb2RlMSA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChhID49IDB4MTkpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsTnIgPSAyO1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlMSA9IGEgLSA4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsTnIgPSAxO1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlMSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoMHgxMSA8PSBjaGFyQ29kZTEgJiYgY2hhckNvZGUxIDw9IDB4MTMpIHtcbiAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIHZhciBvbmVDb2RlID0gYjtcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUxID09PSAweDExKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uZUNvZGUgPSBiICsgMHg1MDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMikge1xuICAgICAgICAgICAgICAgICAgICBvbmVDb2RlID0gYiArIDB4NzA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1NwZWNpYWwgY2hhciBcXCcnICsgZ2V0Q2hhckZvckJ5dGUob25lQ29kZSkgKyAnXFwnIGluIGNoYW5uZWwgJyArIGNoYW5uZWxOcik7XG4gICAgICAgICAgICAgICAgY2hhckNvZGVzID0gW29uZUNvZGVdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgweDIwIDw9IGEgJiYgYSA8PSAweDdmKSB7XG4gICAgICAgICAgICAgICAgY2hhckNvZGVzID0gYiA9PT0gMCA/IFthXSA6IFthLCBiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFyQ29kZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdDaGFyIGNvZGVzID0gICcgKyBoZXhDb2Rlcy5qb2luKCcsJykpO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoYXJDb2RlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIFBhcnNlIGV4dGVuZGVkIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcyB3ZWxsIGFzIG5ldyBmb3JlZ3JvdW5kIGNvbG9yIGJsYWNrLlxuICAgICAgICAqIEByZXR1cm5ze0Jvb2xlYW59IFRlbGxzIGlmIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcmUgZm91bmRcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBia2dEYXRhLCBpbmRleCwgY2hOciwgY2hhbm5lbDtcblxuICAgICAgICAgICAgdmFyIGNhc2UxID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgMHgyMCA8PSBiICYmIGIgPD0gMHgyZjtcbiAgICAgICAgICAgIHZhciBjYXNlMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MWYpICYmIDB4MmQgPD0gYiAmJiBiIDw9IDB4MmY7XG4gICAgICAgICAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBia2dEYXRhID0ge307XG4gICAgICAgICAgICBpZiAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChiIC0gMHgyMCkgLyAyKTtcbiAgICAgICAgICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kQ29sb3JzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoYiAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmtnRGF0YS5iYWNrZ3JvdW5kICsgJ19zZW1pJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgICAgICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBia2dEYXRhLmZvcmVncm91bmQgPSAnYmxhY2snO1xuICAgICAgICAgICAgICAgIGlmIChiID09PSAweDJmKSB7XG4gICAgICAgICAgICAgICAgICAgIGJrZ0RhdGEudW5kZXJsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaE5yID0gYSA8IDB4MTggPyAxIDogMjtcbiAgICAgICAgICAgIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnIgLSAxXTtcbiAgICAgICAgICAgIGNoYW5uZWwuc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldCBzdGF0ZSBvZiBwYXJzZXIgYW5kIGl0cyBjaGFubmVscy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5yZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZ2dlciB0aGUgZ2VuZXJhdGlvbiBvZiBhIGN1ZSwgYW5kIHRoZSBzdGFydCBvZiBhIG5ldyBvbmUgaWYgZGlzcGxheVNjcmVlbnMgYXJlIG5vdCBlbXB0eS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2N1ZVNwbGl0QXRUaW1lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGN1ZVNwbGl0QXRUaW1lKHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbaV0uY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENlYTYwOFBhcnNlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2VhNjA4UGFyc2VyO1xuXG59LHt9XSw0ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfdnR0cGFyc2VyID0gX2RlcmVxXyg1Myk7XG5cbnZhciBDdWVzID0ge1xuXG4gIG5ld0N1ZTogZnVuY3Rpb24gbmV3Q3VlKHRyYWNrLCBzdGFydFRpbWUsIGVuZFRpbWUsIGNhcHRpb25TY3JlZW4pIHtcbiAgICB2YXIgcm93O1xuICAgIHZhciBjdWU7XG4gICAgdmFyIGluZGVudGluZztcbiAgICB2YXIgaW5kZW50O1xuICAgIHZhciB0ZXh0O1xuICAgIHZhciBWVFRDdWUgPSB3aW5kb3cuVlRUQ3VlIHx8IHdpbmRvdy5UZXh0VHJhY2tDdWU7XG5cbiAgICBmb3IgKHZhciByID0gMDsgciA8IGNhcHRpb25TY3JlZW4ucm93cy5sZW5ndGg7IHIrKykge1xuICAgICAgcm93ID0gY2FwdGlvblNjcmVlbi5yb3dzW3JdO1xuICAgICAgaW5kZW50aW5nID0gdHJ1ZTtcbiAgICAgIGluZGVudCA9IDA7XG4gICAgICB0ZXh0ID0gJyc7XG5cbiAgICAgIGlmICghcm93LmlzRW1wdHkoKSkge1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHJvdy5jaGFycy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgIGlmIChyb3cuY2hhcnNbY10udWNoYXIubWF0Y2goL1xccy8pICYmIGluZGVudGluZykge1xuICAgICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHQgKz0gcm93LmNoYXJzW2NdLnVjaGFyO1xuICAgICAgICAgICAgaW5kZW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vVG8gYmUgdXNlZCBmb3IgY2xlYW5pbmctdXAgb3JwaGFuZWQgcm9sbC11cCBjYXB0aW9uc1xuICAgICAgICByb3cuY3VlU3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICBjdWUgPSBuZXcgVlRUQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgKDAsIF92dHRwYXJzZXIuZml4TGluZUJyZWFrcykodGV4dC50cmltKCkpKTtcblxuICAgICAgICBpZiAoaW5kZW50ID49IDE2KSB7XG4gICAgICAgICAgaW5kZW50LS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWVFRDdWUubGluZSBnZXQncyBmbGFrZXkgd2hlbiB1c2luZyBjb250cm9scywgc28gbGV0J3Mgbm93IGluY2x1ZGUgbGluZSAxMyYxNFxuICAgICAgICAvLyBhbHNvLCBkcm9wIGxpbmUgMSBzaW5jZSBpdCdzIHRvIGNsb3NlIHRvIHRoZSB0b3BcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8vKSkge1xuICAgICAgICAgIGN1ZS5saW5lID0gciArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VlLmxpbmUgPSByID4gNyA/IHIgLSAyIDogciArIDE7XG4gICAgICAgIH1cbiAgICAgICAgY3VlLmFsaWduID0gJ2xlZnQnO1xuICAgICAgICAvLyBDbGFtcCB0aGUgcG9zaXRpb24gYmV0d2VlbiAwIGFuZCAxMDAgLSBpZiBvdXQgb2YgdGhlc2UgYm91bmRzLCBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gYW5kIGNhcHRpb25zIGJyZWFrXG4gICAgICAgIGN1ZS5wb3NpdGlvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgMTAwICogKGluZGVudCAvIDMyKSArIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvLykgPyA1MCA6IDApKSk7XG4gICAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN1ZXM7XG5cbn0se1wiNTNcIjo1M31dLDQ5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKlxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxuICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICovXG5cbnZhciBFV01BID0gZnVuY3Rpb24gKCkge1xuXG4gIC8vICBBYm91dCBoYWxmIG9mIHRoZSBlc3RpbWF0ZWQgdmFsdWUgd2lsbCBiZSBmcm9tIHRoZSBsYXN0IHxoYWxmTGlmZXwgc2FtcGxlcyBieSB3ZWlnaHQuXG4gIGZ1bmN0aW9uIEVXTUEoaGFsZkxpZmUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRVdNQSk7XG5cbiAgICAvLyBMYXJnZXIgdmFsdWVzIG9mIGFscGhhIGV4cGlyZSBoaXN0b3JpY2FsIGRhdGEgbW9yZSBzbG93bHkuXG4gICAgdGhpcy5hbHBoYV8gPSBoYWxmTGlmZSA/IE1hdGguZXhwKE1hdGgubG9nKDAuNSkgLyBoYWxmTGlmZSkgOiAwO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gMDtcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRVdNQSwgW3tcbiAgICBrZXk6IFwic2FtcGxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhbXBsZSh3ZWlnaHQsIHZhbHVlKSB7XG4gICAgICB2YXIgYWRqQWxwaGEgPSBNYXRoLnBvdyh0aGlzLmFscGhhXywgd2VpZ2h0KTtcbiAgICAgIHRoaXMuZXN0aW1hdGVfID0gdmFsdWUgKiAoMSAtIGFkakFscGhhKSArIGFkakFscGhhICogdGhpcy5lc3RpbWF0ZV87XG4gICAgICB0aGlzLnRvdGFsV2VpZ2h0XyArPSB3ZWlnaHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRvdGFsV2VpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRvdGFsV2VpZ2h0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudG90YWxXZWlnaHRfO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFc3RpbWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFc3RpbWF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmFscGhhXykge1xuICAgICAgICB2YXIgemVyb0ZhY3RvciA9IDEgLSBNYXRoLnBvdyh0aGlzLmFscGhhXywgdGhpcy50b3RhbFdlaWdodF8pO1xuICAgICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV8gLyB6ZXJvRmFjdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFV01BO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBFV01BO1xuXG59LHt9XSw1MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBmYWtlTG9nZ2VyID0ge1xuICB0cmFjZTogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGxvZzogbm9vcCxcbiAgd2Fybjogbm9vcCxcbiAgaW5mbzogbm9vcCxcbiAgZXJyb3I6IG5vb3Bcbn07XG5cbnZhciBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG5cbi8qZ2xvYmFscyBzZWxmOiBmYWxzZSAqL1xuXG4vL2xldCBsYXN0Q2FsbFRpbWU7XG4vLyBmdW5jdGlvbiBmb3JtYXRNc2dXaXRoVGltZUluZm8odHlwZSwgbXNnKSB7XG4vLyAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4vLyAgIGNvbnN0IGRpZmYgPSBsYXN0Q2FsbFRpbWUgPyAnKycgKyAobm93IC0gbGFzdENhbGxUaW1lKSA6ICcwJztcbi8vICAgbGFzdENhbGxUaW1lID0gbm93O1xuLy8gICBtc2cgPSAobmV3IERhdGUobm93KSkudG9JU09TdHJpbmcoKSArICcgfCBbJyArICB0eXBlICsgJ10gPiAnICsgbXNnICsgJyAoICcgKyBkaWZmICsgJyBtcyApJztcbi8vICAgcmV0dXJuIG1zZztcbi8vIH1cblxuZnVuY3Rpb24gZm9ybWF0TXNnKHR5cGUsIG1zZykge1xuICBtc2cgPSAnWycgKyB0eXBlICsgJ10gPiAnICsgbXNnO1xuICByZXR1cm4gbXNnO1xufVxuXG5mdW5jdGlvbiBjb25zb2xlUHJpbnRGbih0eXBlKSB7XG4gIHZhciBmdW5jID0gc2VsZi5jb25zb2xlW3R5cGVdO1xuICBpZiAoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJnc1swXSkge1xuICAgICAgICBhcmdzWzBdID0gZm9ybWF0TXNnKHR5cGUsIGFyZ3NbMF0pO1xuICAgICAgfVxuICAgICAgZnVuYy5hcHBseShzZWxmLmNvbnNvbGUsIGFyZ3MpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIG5vb3A7XG59XG5cbmZ1bmN0aW9uIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhkZWJ1Z0NvbmZpZykge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmN0aW9ucyA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBmdW5jdGlvbnNbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICBmdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGV4cG9ydGVkTG9nZ2VyW3R5cGVdID0gZGVidWdDb25maWdbdHlwZV0gPyBkZWJ1Z0NvbmZpZ1t0eXBlXS5iaW5kKGRlYnVnQ29uZmlnKSA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xuICB9KTtcbn1cblxudmFyIGVuYWJsZUxvZ3MgPSBleHBvcnRzLmVuYWJsZUxvZ3MgPSBmdW5jdGlvbiBlbmFibGVMb2dzKGRlYnVnQ29uZmlnKSB7XG4gIGlmIChkZWJ1Z0NvbmZpZyA9PT0gdHJ1ZSB8fCAodHlwZW9mIGRlYnVnQ29uZmlnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkZWJ1Z0NvbmZpZykpID09PSAnb2JqZWN0Jykge1xuICAgIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhkZWJ1Z0NvbmZpZyxcbiAgICAvLyBSZW1vdmUgb3V0IGZyb20gbGlzdCBoZXJlIHRvIGhhcmQtZGlzYWJsZSBhIGxvZy1sZXZlbFxuICAgIC8vJ3RyYWNlJyxcbiAgICAnZGVidWcnLCAnbG9nJywgJ2luZm8nLCAnd2FybicsICdlcnJvcicpO1xuICAgIC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3QgYWxsb3cgdG8gdXNlIGJpbmQgb24gY29uc29sZSBvYmplY3QgYW55d2F5XG4gICAgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCBpZiBuZWVkZWRcbiAgICB0cnkge1xuICAgICAgZXhwb3J0ZWRMb2dnZXIubG9nKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gIH1cbn07XG5cbnZhciBsb2dnZXIgPSBleHBvcnRzLmxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuXG59LHt9XSw1MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogIFRpbWVSYW5nZXMgdG8gc3RyaW5nIGhlbHBlclxuICovXG5cbnZhciBUaW1lUmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUaW1lUmFuZ2VzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lUmFuZ2VzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUaW1lUmFuZ2VzLCBudWxsLCBbe1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcocikge1xuICAgICAgdmFyIGxvZyA9ICcnLFxuICAgICAgICAgIGxlbiA9IHIubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsb2cgKz0gJ1snICsgci5zdGFydChpKS50b0ZpeGVkKDMpICsgJywnICsgci5lbmQoaSkudG9GaXhlZCgzKSArICddJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2c7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRpbWVSYW5nZXM7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRpbWVSYW5nZXM7XG5cbn0se31dLDUyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVlRUQ3VlKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5WVFRDdWU7XG4gIH1cblxuICB2YXIgYXV0b0tleXdvcmQgPSAnYXV0byc7XG4gIHZhciBkaXJlY3Rpb25TZXR0aW5nID0ge1xuICAgICcnOiB0cnVlLFxuICAgIGxyOiB0cnVlLFxuICAgIHJsOiB0cnVlXG4gIH07XG4gIHZhciBhbGlnblNldHRpbmcgPSB7XG4gICAgc3RhcnQ6IHRydWUsXG4gICAgbWlkZGxlOiB0cnVlLFxuICAgIGVuZDogdHJ1ZSxcbiAgICBsZWZ0OiB0cnVlLFxuICAgIHJpZ2h0OiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZGlyID0gZGlyZWN0aW9uU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgICByZXR1cm4gZGlyID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEFsaWduU2V0dGluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBhbGlnbiA9IGFsaWduU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgICByZXR1cm4gYWxpZ24gPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQob2JqKSB7XG4gICAgdmFyIGkgPSAxO1xuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29iaiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29iaikge1xuICAgICAgICBvYmpbcF0gPSBjb2JqW3BdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0KSB7XG4gICAgdmFyIGN1ZSA9IHRoaXM7XG4gICAgdmFyIGlzSUU4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoL01TSUVcXHM4XFwuMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICAgKTtcbiAgICB9KCk7XG4gICAgdmFyIGJhc2VPYmogPSB7fTtcblxuICAgIGlmIChpc0lFOCkge1xuICAgICAgY3VlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VPYmouZW51bWVyYWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hpbSBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBwcm9wZXJ0aWVzLiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgaW5cbiAgICAgKiB0aGUgc3BlYy5cbiAgICAgKi9cblxuICAgIC8vIExldHMgdXMga25vdyB3aGVuIHRoZSBWVFRDdWUncyBkYXRhIGhhcyBjaGFuZ2VkIGluIHN1Y2ggYSB3YXkgdGhhdCB3ZSBuZWVkXG4gICAgLy8gdG8gcmVjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlLiBUaGlzIGxldHMgdXMgY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZVxuICAgIC8vIGxhemlseS5cbiAgICBjdWUuaGFzQmVlblJlc2V0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBWVFRDdWUgYW5kIFRleHRUcmFja0N1ZSBwcm9wZXJ0aWVzXG4gICAgICogaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2VidnR0LyN2dHRjdWUtaW50ZXJmYWNlXG4gICAgICovXG5cbiAgICB2YXIgX2lkID0gJyc7XG4gICAgdmFyIF9wYXVzZU9uRXhpdCA9IGZhbHNlO1xuICAgIHZhciBfc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgIHZhciBfZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgdmFyIF90ZXh0ID0gdGV4dDtcbiAgICB2YXIgX3JlZ2lvbiA9IG51bGw7XG4gICAgdmFyIF92ZXJ0aWNhbCA9ICcnO1xuICAgIHZhciBfc25hcFRvTGluZXMgPSB0cnVlO1xuICAgIHZhciBfbGluZSA9ICdhdXRvJztcbiAgICB2YXIgX2xpbmVBbGlnbiA9ICdzdGFydCc7XG4gICAgdmFyIF9wb3NpdGlvbiA9IDUwO1xuICAgIHZhciBfcG9zaXRpb25BbGlnbiA9ICdtaWRkbGUnO1xuICAgIHZhciBfc2l6ZSA9IDUwO1xuICAgIHZhciBfYWxpZ24gPSAnbWlkZGxlJztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdpZCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfaWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX2lkID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncGF1c2VPbkV4aXQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3BhdXNlT25FeGl0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9wYXVzZU9uRXhpdCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3N0YXJ0VGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfc3RhcnRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RhcnQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBfc3RhcnRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnZW5kVGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZW5kVGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuZCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIF9lbmRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndGV4dCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfdGV4dDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfdGV4dCA9ICcnICsgdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncmVnaW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdpb247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX3JlZ2lvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3ZlcnRpY2FsJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF92ZXJ0aWNhbDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgLy8gSGF2ZSB0byBjaGVjayBmb3IgZmFsc2UgYmVjYXVzZSB0aGUgc2V0dGluZyBhbiBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgIGlmIChzZXR0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF92ZXJ0aWNhbCA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc25hcFRvTGluZXMnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3NuYXBUb0xpbmVzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9zbmFwVG9MaW5lcyA9ICEhdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfbGluZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gYXV0b0tleXdvcmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgbnVtYmVyIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2xpbmVBbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZUFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwb3NpdGlvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfcG9zaXRpb247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zaXRpb24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwb3NpdGlvbkFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbkFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9wb3NpdGlvbkFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzaXplJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpemUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2FsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9hbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfYWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogT3RoZXIgPHRyYWNrPiBzcGVjIGRlZmluZWQgcHJvcGVydGllc1xuICAgICAqL1xuXG4gICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLXZpZGVvLWVsZW1lbnQuaHRtbCN0ZXh0LXRyYWNrLWN1ZS1kaXNwbGF5LXN0YXRlXG4gICAgY3VlLmRpc3BsYXlTdGF0ZSA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc0lFOCkge1xuICAgICAgcmV0dXJuIGN1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVlRUQ3VlIG1ldGhvZHNcbiAgICovXG5cbiAgVlRUQ3VlLnByb3RvdHlwZS5nZXRDdWVBc0hUTUwgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQXNzdW1lIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlIGlzIG9uIHRoZSBnbG9iYWwuXG4gICAgdmFyIFdlYlZUVCA9IHdpbmRvdy5XZWJWVFQ7XG4gICAgcmV0dXJuIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlKHdpbmRvdywgdGhpcy50ZXh0KTtcbiAgfTtcblxuICByZXR1cm4gVlRUQ3VlO1xufSgpO1xuXG59LHt9XSw1MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZpeExpbmVCcmVha3MgPSB1bmRlZmluZWQ7XG5cbnZhciBfdnR0Y3VlID0gX2RlcmVxXyg1Mik7XG5cbnZhciBfdnR0Y3VlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Z0dGN1ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBTdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24gU3RyaW5nRGVjb2RlcigpIHtcbiAgcmV0dXJuIHtcbiAgICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIC0gZXhwZWN0ZWQgc3RyaW5nIGRhdGEuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSk7XG4gICAgfVxuICB9O1xufTsgLypcbiAgICAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzL2Jsb2IvbWFzdGVyL2Rpc3QvdnR0LmpzI0wxNzE2XG4gICAgKi9cblxuZnVuY3Rpb24gVlRUUGFyc2VyKCkge1xuICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgdGhpcy5zdGF0ZSA9ICdJTklUSUFMJztcbiAgdGhpcy5idWZmZXIgPSAnJztcbiAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoKTtcbiAgdGhpcy5yZWdpb25MaXN0ID0gW107XG59XG5cbi8vIFRyeSB0byBwYXJzZSBpbnB1dCBhcyBhIHRpbWUgc3RhbXAuXG5mdW5jdGlvbiBwYXJzZVRpbWVTdGFtcChpbnB1dCkge1xuXG4gIGZ1bmN0aW9uIGNvbXB1dGVTZWNvbmRzKGgsIG0sIHMsIGYpIHtcbiAgICByZXR1cm4gKGggfCAwKSAqIDM2MDAgKyAobSB8IDApICogNjAgKyAocyB8IDApICsgKGYgfCAwKSAvIDEwMDA7XG4gIH1cblxuICB2YXIgbSA9IGlucHV0Lm1hdGNoKC9eKFxcZCspOihcXGR7Mn0pKDpcXGR7Mn0pP1xcLihcXGR7M30pLyk7XG4gIGlmICghbSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKG1bM10pIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc106W3NlY29uZHNdLlttaWxsaXNlY29uZHNdXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIG1bM10ucmVwbGFjZSgnOicsICcnKSwgbVs0XSk7XG4gIH0gZWxzZSBpZiAobVsxXSA+IDU5KSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdLlttaWxsaXNlY29uZHNdXG4gICAgLy8gRmlyc3QgcG9zaXRpb24gaXMgaG91cnMgYXMgaXQncyBvdmVyIDU5LlxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCAwLCBtWzRdKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcygwLCBtWzFdLCBtWzJdLCBtWzRdKTtcbiAgfVxufVxuXG4vLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3Rcbi8vIGFzc2lnbm1lbnQgdG8gYSBzcGVjaWZpYyBrZXkuXG5mdW5jdGlvbiBTZXR0aW5ncygpIHtcbiAgdGhpcy52YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG5TZXR0aW5ncy5wcm90b3R5cGUgPSB7XG4gIC8vIE9ubHkgYWNjZXB0IHRoZSBmaXJzdCBhc3NpZ25tZW50IHRvIGFueSBrZXkuXG4gIHNldDogZnVuY3Rpb24gc2V0KGssIHYpIHtcbiAgICBpZiAoIXRoaXMuZ2V0KGspICYmIHYgIT09ICcnKSB7XG4gICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XG4gICAgfVxuICB9LFxuICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciBhIGtleSwgb3IgYSBkZWZhdWx0IHZhbHVlLlxuICAvLyBJZiAnZGVmYXVsdEtleScgaXMgcGFzc2VkIHRoZW4gJ2RmbHQnIGlzIGFzc3VtZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGhcbiAgLy8gYSBudW1iZXIgb2YgcG9zc2libGUgZGVmYXVsdCB2YWx1ZXMgYXMgcHJvcGVydGllcyB3aGVyZSAnZGVmYXVsdEtleScgaXNcbiAgLy8gdGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIGNob3Nlbjsgb3RoZXJ3aXNlIGl0J3MgYXNzdW1lZCB0byBiZVxuICAvLyBhIHNpbmdsZSB2YWx1ZS5cbiAgZ2V0OiBmdW5jdGlvbiBnZXQoaywgZGZsdCwgZGVmYXVsdEtleSkge1xuICAgIGlmIChkZWZhdWx0S2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHRbZGVmYXVsdEtleV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdDtcbiAgfSxcbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgdmFsdWUgZm9yIGEga2V5LlxuICBoYXM6IGZ1bmN0aW9uIGhhcyhrKSB7XG4gICAgcmV0dXJuIGsgaW4gdGhpcy52YWx1ZXM7XG4gIH0sXG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIG9uZSBvZiB0aGUgZ2l2ZW4gYWx0ZXJuYXRpdmVzLlxuICBhbHQ6IGZ1bmN0aW9uIGFsdChrLCB2LCBhKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBhLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAodiA9PT0gYVtuXSkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIChzaWduZWQpIGludGVnZXIuXG4gIGludGVnZXI6IGZ1bmN0aW9uIGludGVnZXIoaywgdikge1xuICAgIGlmICgvXi0/XFxkKyQvLnRlc3QodikpIHtcbiAgICAgIC8vIGludGVnZXJcbiAgICAgIHRoaXMuc2V0KGssIHBhcnNlSW50KHYsIDEwKSk7XG4gICAgfVxuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXG4gIHBlcmNlbnQ6IGZ1bmN0aW9uIHBlcmNlbnQoaywgdikge1xuICAgIHZhciBtO1xuICAgIGlmIChtID0gdi5tYXRjaCgvXihbXFxkXXsxLDN9KShcXC5bXFxkXSopPyUkLykpIHtcbiAgICAgIHYgPSBwYXJzZUZsb2F0KHYpO1xuICAgICAgaWYgKHYgPj0gMCAmJiB2IDw9IDEwMCkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxuLy8gaW50ZXJwcmV0ZSBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhpbnB1dCwgY2FsbGJhY2ssIGtleVZhbHVlRGVsaW0sIGdyb3VwRGVsaW0pIHtcbiAgdmFyIGdyb3VwcyA9IGdyb3VwRGVsaW0gPyBpbnB1dC5zcGxpdChncm91cERlbGltKSA6IFtpbnB1dF07XG4gIGZvciAodmFyIGkgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKHR5cGVvZiBncm91cHNbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGt2ID0gZ3JvdXBzW2ldLnNwbGl0KGtleVZhbHVlRGVsaW0pO1xuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgayA9IGt2WzBdO1xuICAgIHZhciB2ID0ga3ZbMV07XG4gICAgY2FsbGJhY2soaywgdik7XG4gIH1cbn1cblxudmFyIGRlZmF1bHRzID0gbmV3IF92dHRjdWUyLmRlZmF1bHQoMCwgMCwgMCk7XG4vLyAnbWlkZGxlJyB3YXMgY2hhbmdlZCB0byAnY2VudGVyJyBpbiB0aGUgc3BlYzogaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJ2dHQvcHVsbC8yNDRcbi8vIENocm9tZSBhbmQgU2FmYXJpIGRvbid0IHlldCBzdXBwb3J0IHRoaXMgY2hhbmdlLCBidXQgRkYgZG9lc1xudmFyIGNlbnRlciA9IGRlZmF1bHRzLmFsaWduID09PSAnbWlkZGxlJyA/ICdtaWRkbGUnIDogJ2NlbnRlcic7XG5cbmZ1bmN0aW9uIHBhcnNlQ3VlKGlucHV0LCBjdWUsIHJlZ2lvbkxpc3QpIHtcbiAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIGlucHV0IGlmIHdlIG5lZWQgdG8gdGhyb3cgYW4gZXJyb3IuXG4gIHZhciBvSW5wdXQgPSBpbnB1dDtcbiAgLy8gNC4xIFdlYlZUVCB0aW1lc3RhbXBcbiAgZnVuY3Rpb24gY29uc3VtZVRpbWVTdGFtcCgpIHtcbiAgICB2YXIgdHMgPSBwYXJzZVRpbWVTdGFtcChpbnB1dCk7XG4gICAgaWYgKHRzID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCB0aW1lc3RhbXA6ICcgKyBvSW5wdXQpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgdGltZSBzdGFtcCBmcm9tIGlucHV0LlxuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlteXFxzYS16QS1aLV0rLywgJycpO1xuICAgIHJldHVybiB0cztcbiAgfVxuXG4gIC8vIDQuNC4yIFdlYlZUVCBjdWUgc2V0dGluZ3NcbiAgZnVuY3Rpb24gY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpIHtcbiAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcblxuICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICBjYXNlICdyZWdpb24nOlxuICAgICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgcmVnaW9uIHdlIHBhcnNlZCB3aXRoIHRoZSBzYW1lIHJlZ2lvbiBpZC5cbiAgICAgICAgICBmb3IgKHZhciBpID0gcmVnaW9uTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHJlZ2lvbkxpc3RbaV0uaWQgPT09IHYpIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3Muc2V0KGssIHJlZ2lvbkxpc3RbaV0ucmVnaW9uKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsncmwnLCAnbHInXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICAgIHZhciB2YWxzID0gdi5zcGxpdCgnLCcpLFxuICAgICAgICAgICAgICB2YWxzMCA9IHZhbHNbMF07XG4gICAgICAgICAgc2V0dGluZ3MuaW50ZWdlcihrLCB2YWxzMCk7XG4gICAgICAgICAgaWYgKHNldHRpbmdzLnBlcmNlbnQoaywgdmFsczApKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zZXQoJ3NuYXBUb0xpbmVzJywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdmFsczAsIFsnYXV0byddKTtcbiAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmFsdCgnbGluZUFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCddKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgICB2YWxzID0gdi5zcGxpdCgnLCcpO1xuICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSk7XG4gICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hbHQoJ3Bvc2l0aW9uQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xpbmUtbGVmdCcsICdsaW5lLXJpZ2h0JywgJ2F1dG8nXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaXplJzpcbiAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhbGlnbic6XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGVmdCcsICdyaWdodCddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LCAvOi8sIC9cXHMvKTtcblxuICAgIC8vIEFwcGx5IGRlZmF1bHQgdmFsdWVzIGZvciBhbnkgbWlzc2luZyBmaWVsZHMuXG4gICAgY3VlLnJlZ2lvbiA9IHNldHRpbmdzLmdldCgncmVnaW9uJywgbnVsbCk7XG4gICAgY3VlLnZlcnRpY2FsID0gc2V0dGluZ3MuZ2V0KCd2ZXJ0aWNhbCcsICcnKTtcbiAgICB2YXIgbGluZSA9IHNldHRpbmdzLmdldCgnbGluZScsICdhdXRvJyk7XG4gICAgaWYgKGxpbmUgPT09ICdhdXRvJyAmJiBkZWZhdWx0cy5saW5lID09PSAtMSkge1xuICAgICAgLy8gc2V0IG51bWVyaWMgbGluZSBudW1iZXIgZm9yIFNhZmFyaVxuICAgICAgbGluZSA9IC0xO1xuICAgIH1cbiAgICBjdWUubGluZSA9IGxpbmU7XG4gICAgY3VlLmxpbmVBbGlnbiA9IHNldHRpbmdzLmdldCgnbGluZUFsaWduJywgJ3N0YXJ0Jyk7XG4gICAgY3VlLnNuYXBUb0xpbmVzID0gc2V0dGluZ3MuZ2V0KCdzbmFwVG9MaW5lcycsIHRydWUpO1xuICAgIGN1ZS5zaXplID0gc2V0dGluZ3MuZ2V0KCdzaXplJywgMTAwKTtcbiAgICBjdWUuYWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2FsaWduJywgY2VudGVyKTtcbiAgICB2YXIgcG9zaXRpb24gPSBzZXR0aW5ncy5nZXQoJ3Bvc2l0aW9uJywgJ2F1dG8nKTtcbiAgICBpZiAocG9zaXRpb24gPT09ICdhdXRvJyAmJiBkZWZhdWx0cy5wb3NpdGlvbiA9PT0gNTApIHtcbiAgICAgIC8vIHNldCBudW1lcmljIHBvc2l0aW9uIGZvciBTYWZhcmlcbiAgICAgIHBvc2l0aW9uID0gY3VlLmFsaWduID09PSAnc3RhcnQnIHx8IGN1ZS5hbGlnbiA9PT0gJ2xlZnQnID8gMCA6IGN1ZS5hbGlnbiA9PT0gJ2VuZCcgfHwgY3VlLmFsaWduID09PSAncmlnaHQnID8gMTAwIDogNTA7XG4gICAgfVxuICAgIGN1ZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbiAgfVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHRpbWluZ3MuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGN1ZS5zdGFydFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7IC8vICgxKSBjb2xsZWN0IGN1ZSBzdGFydCB0aW1lXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGlmIChpbnB1dC5zdWJzdHIoMCwgMykgIT09ICctLT4nKSB7XG4gICAgLy8gKDMpIG5leHQgY2hhcmFjdGVycyBtdXN0IG1hdGNoICctLT4nXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgXFwnLS0+XFwnKTogJyArIG9JbnB1dCk7XG4gIH1cbiAgaW5wdXQgPSBpbnB1dC5zdWJzdHIoMyk7XG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGN1ZS5lbmRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAvLyAoNSkgY29sbGVjdCBjdWUgZW5kIHRpbWVcblxuICAvLyA0LjEgV2ViVlRUIGN1ZSBzZXR0aW5ncyBsaXN0LlxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjb25zdW1lQ3VlU2V0dGluZ3MoaW5wdXQsIGN1ZSk7XG59XG5cbmZ1bmN0aW9uIGZpeExpbmVCcmVha3MoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoLzxicig/OiBcXC8pPz4vZ2ksICdcXG4nKTtcbn1cblxuVlRUUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBkYXRhIHRoZW4gd2Ugd29uJ3QgZGVjb2RlIGl0LCBidXQgd2lsbCBqdXN0IHRyeSB0byBwYXJzZVxuICAgIC8vIHdoYXRldmVyIGlzIGluIGJ1ZmZlciBhbHJlYWR5LiBUaGlzIG1heSBvY2N1ciBpbiBjaXJjdW1zdGFuY2VzLCBmb3JcbiAgICAvLyBleGFtcGxlIHdoZW4gZmx1c2goKSBpcyBjYWxsZWQuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGRhdGEgdGhhdCB3ZSByZWNlaXZlZC5cbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoZGF0YSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lKCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IHNlbGYuYnVmZmVyO1xuICAgICAgdmFyIHBvcyA9IDA7XG5cbiAgICAgIGJ1ZmZlciA9IGZpeExpbmVCcmVha3MoYnVmZmVyKTtcblxuICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gYnVmZmVyLnN1YnN0cigwLCBwb3MpO1xuICAgICAgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIGVhcmx5IGluIGNhc2Ugd2UgZmFpbCBiZWxvdy5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xccicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXG4nKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgc2VsZi5idWZmZXIgPSBidWZmZXIuc3Vic3RyKHBvcyk7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICAvLyAzLjIgV2ViVlRUIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcihpbnB1dCkge1xuICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgICBjYXNlICdSZWdpb24nOlxuICAgICAgICAgICAgLy8gMy4zIFdlYlZUVCByZWdpb24gbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3BhcnNlIHJlZ2lvbicsIHYpO1xuICAgICAgICAgICAgLy9wYXJzZVJlZ2lvbih2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LCAvOi8pO1xuICAgIH1cblxuICAgIC8vIDUuMSBXZWJWVFQgZmlsZSBwYXJzaW5nLlxuICAgIHRyeSB7XG4gICAgICB2YXIgbGluZTtcbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnSU5JVElBTCcpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuXG4gICAgICAgIHZhciBtID0gbGluZS5tYXRjaCgvXldFQlZUVChbIFxcdF0uKik/JC8pO1xuICAgICAgICBpZiAoIW0gfHwgIW1bMF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zdGF0ZSA9ICdIRUFERVInO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChzZWxmLmJ1ZmZlcikge1xuICAgICAgICAvLyBXZSBjYW4ndCBwYXJzZSBhIGxpbmUgdW50aWwgd2UgaGF2ZSB0aGUgZnVsbCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbHJlYWR5Q29sbGVjdGVkTGluZSkge1xuICAgICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChzZWxmLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSAnSEVBREVSJzpcbiAgICAgICAgICAgIC8vIDEzLTE4IC0gQWxsb3cgYSBoZWFkZXIgKG1ldGFkYXRhKSB1bmRlciB0aGUgV0VCVlRUIGxpbmUuXG4gICAgICAgICAgICBpZiAoLzovLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIC8vIEFuIGVtcHR5IGxpbmUgdGVybWluYXRlcyB0aGUgaGVhZGVyIGFuZCBzdGFydHMgdGhlIGJvZHkgKGN1ZXMpLlxuICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ05PVEUnOlxuICAgICAgICAgICAgLy8gSWdub3JlIE5PVEUgYmxvY2tzLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnSUQnOlxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICAgIGlmICgvXk5PVEUoJHxbIFxcdF0pLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnTk9URSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMTktMjkgLSBBbGxvdyBhbnkgbnVtYmVyIG9mIGxpbmUgdGVybWluYXRvcnMsIHRoZW4gaW5pdGlhbGl6ZSBuZXcgY3VlIHZhbHVlcy5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuY3VlID0gbmV3IF92dHRjdWUyLmRlZmF1bHQoMCwgMCwgJycpO1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdDVUUnO1xuICAgICAgICAgICAgLy8gMzAtMzkgLSBDaGVjayBpZiBzZWxmIGxpbmUgY29udGFpbnMgYW4gb3B0aW9uYWwgaWRlbnRpZmllciBvciB0aW1pbmcgZGF0YS5cbiAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJy0tPicpID09PSAtMSkge1xuICAgICAgICAgICAgICBzZWxmLmN1ZS5pZCA9IGxpbmU7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIFByb2Nlc3MgbGluZSBhcyBzdGFydCBvZiBhIGN1ZS5cbiAgICAgICAgICAvKmZhbGxzIHRocm91Z2gqL1xuICAgICAgICAgIGNhc2UgJ0NVRSc6XG4gICAgICAgICAgICAvLyA0MCAtIENvbGxlY3QgY3VlIHRpbWluZ3MgYW5kIHNldHRpbmdzLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcGFyc2VDdWUobGluZSwgc2VsZi5jdWUsIHNlbGYucmVnaW9uTGlzdCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgYW4gZXJyb3IgaWdub3JlIHJlc3Qgb2YgdGhlIGN1ZS5cbiAgICAgICAgICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0JBRENVRSc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdDVUVURVhUJztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ0NVRVRFWFQnOlxuICAgICAgICAgICAgdmFyIGhhc1N1YnN0cmluZyA9IGxpbmUuaW5kZXhPZignLS0+JykgIT09IC0xO1xuICAgICAgICAgICAgLy8gMzQgLSBJZiB3ZSBoYXZlIGFuIGVtcHR5IGxpbmUgdGhlbiByZXBvcnQgdGhlIGN1ZS5cbiAgICAgICAgICAgIC8vIDM1IC0gSWYgd2UgaGF2ZSB0aGUgc3BlY2lhbCBzdWJzdHJpbmcgJy0tPicgdGhlbiByZXBvcnQgdGhlIGN1ZSxcbiAgICAgICAgICAgIC8vIGJ1dCBkbyBub3QgY29sbGVjdCB0aGUgbGluZSBhcyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgIC8vIG9uZSBhcyBhIG5ldyBjdWUuXG4gICAgICAgICAgICBpZiAoIWxpbmUgfHwgaGFzU3Vic3RyaW5nICYmIChhbHJlYWR5Q29sbGVjdGVkTGluZSA9IHRydWUpKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIHBhcnNpbmcgc2VsZiBjdWUuXG4gICAgICAgICAgICAgIGlmIChzZWxmLm9uY3VlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jdWUudGV4dCkge1xuICAgICAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9ICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jdWUudGV4dCArPSBsaW5lO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnQkFEQ1VFJzpcbiAgICAgICAgICAgIC8vIEJBRENVRVxuICAgICAgICAgICAgLy8gNTQtNjIgLSBDb2xsZWN0IGFuZCBkaXNjYXJkIHRoZSByZW1haW5pbmcgY3VlLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGFyc2luZyBhIGN1ZSwgcmVwb3J0IHdoYXQgd2UgaGF2ZS5cbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnQ1VFVEVYVCcgJiYgc2VsZi5jdWUgJiYgc2VsZi5vbmN1ZSkge1xuICAgICAgICBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgIC8vIEVudGVyIEJBRFdFQlZUVCBzdGF0ZSBpZiBoZWFkZXIgd2FzIG5vdCBwYXJzZWQgY29ycmVjdGx5IG90aGVyd2lzZVxuICAgICAgLy8gYW5vdGhlciBleGNlcHRpb24gb2NjdXJyZWQgc28gZW50ZXIgQkFEQ1VFIHN0YXRlLlxuICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJyA/ICdCQURXRUJWVFQnIDogJ0JBRENVRSc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBmbHVzaDogZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoKTtcbiAgICAgIC8vIFN5bnRoZXNpemUgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjdWUgb3IgcmVnaW9uLlxuICAgICAgaWYgKHNlbGYuY3VlIHx8IHNlbGYuc3RhdGUgPT09ICdIRUFERVInKSB7XG4gICAgICAgIHNlbGYuYnVmZmVyICs9ICdcXG5cXG4nO1xuICAgICAgICBzZWxmLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSd2ZSBmbHVzaGVkLCBwYXJzZWQsIGFuZCB3ZSdyZSBzdGlsbCBvbiB0aGUgSU5JVElBTCBzdGF0ZSB0aGVuXG4gICAgICAvLyB0aGF0IG1lYW5zIHdlIGRvbid0IGhhdmUgZW5vdWdoIG9mIHRoZSBzdHJlYW0gdG8gcGFyc2UgdGhlIGZpcnN0XG4gICAgICAvLyBsaW5lLlxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGlmIChzZWxmLm9uZmx1c2gpIHtcbiAgICAgIHNlbGYub25mbHVzaCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuZXhwb3J0cy5maXhMaW5lQnJlYWtzID0gZml4TGluZUJyZWFrcztcbmV4cG9ydHMuZGVmYXVsdCA9IFZUVFBhcnNlcjtcblxufSx7XCI1MlwiOjUyfV0sNTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Z0dHBhcnNlciA9IF9kZXJlcV8oNTMpO1xuXG52YXIgX3Z0dHBhcnNlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92dHRwYXJzZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY3VlU3RyaW5nMm1pbGxpcyA9IGZ1bmN0aW9uIGN1ZVN0cmluZzJtaWxsaXModGltZVN0cmluZykge1xuICAgIHZhciB0cyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC0zKSk7XG4gICAgdmFyIHNlY3MgPSBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigtNiwgMikpO1xuICAgIHZhciBtaW5zID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTksIDIpKTtcbiAgICB2YXIgaG91cnMgPSB0aW1lU3RyaW5nLmxlbmd0aCA+IDkgPyBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigwLCB0aW1lU3RyaW5nLmluZGV4T2YoJzonKSkpIDogMDtcblxuICAgIGlmIChpc05hTih0cykgfHwgaXNOYU4oc2VjcykgfHwgaXNOYU4obWlucykgfHwgaXNOYU4oaG91cnMpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB0cyArPSAxMDAwICogc2VjcztcbiAgICB0cyArPSA2MCAqIDEwMDAgKiBtaW5zO1xuICAgIHRzICs9IDYwICogNjAgKiAxMDAwICogaG91cnM7XG5cbiAgICByZXR1cm4gdHM7XG59O1xuXG52YXIgY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpIHtcbiAgICB2YXIgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgICB2YXIgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGlzY29udGludWl0eSBvciBjdWVzIGhhdmUgYmVlbiBwcm9jZXNzZWQgc2luY2UgdGhlIGxhc3QgZGlzY29udGludWl0eVxuICAgIC8vIE9mZnNldCA9IGN1cnJlbnQgZGlzY29udGludWl0eSB0aW1lXG4gICAgaWYgKCFwcmV2Q0MgfHwgIXByZXZDQy5uZXcgJiYgY3VyckNDLm5ldykge1xuICAgICAgICB2dHRDQ3MuY2NPZmZzZXQgPSB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0ID0gY3VyckNDLnN0YXJ0O1xuICAgICAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGVyZSBoYXZlIGJlZW4gZGlzY29udGludWl0aWVzIHNpbmNlIGN1ZXMgd2VyZSBsYXN0IHBhcnNlZC5cbiAgICAvLyBPZmZzZXQgPSB0aW1lIGVsYXBzZWRcbiAgICB3aGlsZSAocHJldkNDICYmIHByZXZDQy5uZXcpIHtcbiAgICAgICAgdnR0Q0NzLmNjT2Zmc2V0ICs9IGN1cnJDQy5zdGFydCAtIHByZXZDQy5zdGFydDtcbiAgICAgICAgY3VyckNDLm5ldyA9IGZhbHNlO1xuICAgICAgICBjdXJyQ0MgPSBwcmV2Q0M7XG4gICAgICAgIHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcbiAgICB9XG5cbiAgICB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0ID0gcHJlc2VudGF0aW9uVGltZTtcbn07XG5cbnZhciBXZWJWVFRQYXJzZXIgPSB7XG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHZ0dEJ5dGVBcnJheSwgc3luY1BUUywgdnR0Q0NzLCBjYywgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgICAgICAgLy8gQ29udmVydCBieXRlQXJyYXkgaW50byBzdHJpbmcsIHJlcGxhY2luZyBhbnkgc29tZXdoYXQgZXhvdGljIGxpbmVmZWVkcyB3aXRoIFwiXFxuXCIsIHRoZW4gc3BsaXQgb24gdGhhdCBjaGFyYWN0ZXIuXG4gICAgICAgIHZhciByZSA9IC9cXHJcXG58XFxuXFxyfFxcbnxcXHIvZztcbiAgICAgICAgdmFyIHZ0dExpbmVzID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSh2dHRCeXRlQXJyYXkpKS50cmltKCkucmVwbGFjZShyZSwgJ1xcbicpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgdmFyIGN1ZVRpbWUgPSAnMDA6MDAuMDAwJztcbiAgICAgICAgdmFyIG1wZWdUcyA9IDA7XG4gICAgICAgIHZhciBsb2NhbFRpbWUgPSAwO1xuICAgICAgICB2YXIgcHJlc2VudGF0aW9uVGltZSA9IDA7XG4gICAgICAgIHZhciBjdWVzID0gW107XG4gICAgICAgIHZhciBwYXJzaW5nRXJyb3IgPSB2b2lkIDA7XG4gICAgICAgIHZhciBpbkhlYWRlciA9IHRydWU7XG4gICAgICAgIC8vIGxldCBWVFRDdWUgPSBWVFRDdWUgfHwgd2luZG93LlRleHRUcmFja0N1ZTtcblxuICAgICAgICAvLyBDcmVhdGUgcGFyc2VyIG9iamVjdCB1c2luZyBWVFRDdWUgd2l0aCBUZXh0VHJhY2tDdWUgZmFsbGJhY2sgb24gY2VydGFpbiBicm93c2Vycy5cbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBfdnR0cGFyc2VyMi5kZWZhdWx0KCk7XG5cbiAgICAgICAgcGFyc2VyLm9uY3VlID0gZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgICAgICAgLy8gQWRqdXN0IGN1ZSB0aW1pbmc7IGNsYW1wIGN1ZXMgdG8gc3RhcnQgbm8gZWFybGllciB0aGFuIC0gYW5kIGRyb3AgY3VlcyB0aGF0IGRvbid0IGVuZCBhZnRlciAtIDAgb24gdGltZWxpbmUuXG4gICAgICAgICAgICB2YXIgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgICAgICAgICAgIHZhciBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQ7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvZmZzZXRzIGZvciBuZXcgZGlzY29udGludWl0aWVzXG4gICAgICAgICAgICBpZiAoY3VyckNDICYmIGN1cnJDQy5uZXcpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbG9jYWwgdGltZSBpcyBwcm92aWRlZCwgb2Zmc2V0ID0gZGlzY29udGludWl0eSBzdGFydCB0aW1lIC0gbG9jYWwgdGltZVxuICAgICAgICAgICAgICAgICAgICBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXNlbnRhdGlvblRpbWUgJiYgIWxvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgTVBFR1RTIGJ1dCBubyBMT0NBTCB0aW1lLCBvZmZzZXQgPSBwcmVzZW50YXRpb24gdGltZSArIGRpc2NvbnRpbnVpdHkgb2Zmc2V0XG4gICAgICAgICAgICAgICAgY3VlT2Zmc2V0ID0gcHJlc2VudGF0aW9uVGltZSArIHZ0dENDcy5jY09mZnNldCAtIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1ZS5zdGFydFRpbWUgKz0gY3VlT2Zmc2V0IC0gbG9jYWxUaW1lO1xuICAgICAgICAgICAgY3VlLmVuZFRpbWUgKz0gY3VlT2Zmc2V0IC0gbG9jYWxUaW1lO1xuXG4gICAgICAgICAgICAvLyBGaXggZW5jb2Rpbmcgb2Ygc3BlY2lhbCBjaGFyYWN0ZXJzLiBUT0RPOiBUZXN0IHdpdGggYWxsIHNvcnRzIG9mIHdlaXJkIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICBjdWUudGV4dCA9IGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoY3VlLnRleHQpKTtcbiAgICAgICAgICAgIGlmIChjdWUuZW5kVGltZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjdWVzLnB1c2goY3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBwYXJzZXIub25wYXJzaW5nZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcGFyc2luZ0Vycm9yID0gZTtcbiAgICAgICAgfTtcblxuICAgICAgICBwYXJzZXIub25mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChwYXJzaW5nRXJyb3IgJiYgZXJyb3JDYWxsQmFjaykge1xuICAgICAgICAgICAgICAgIGVycm9yQ2FsbEJhY2socGFyc2luZ0Vycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsQmFjayhjdWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHbyB0aHJvdWdoIGNvbnRlbnRzIGxpbmUgYnkgbGluZS5cbiAgICAgICAgdnR0TGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgaWYgKGluSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgWC1USU1FU1RBTVAtTUFQIGluIGhlYWRlci5cbiAgICAgICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdYLVRJTUVTVEFNUC1NQVA9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25jZSBmb3VuZCwgbm8gbW9yZSBhcmUgYWxsb3dlZCBhbnl3YXksIHNvIHN0b3Agc2VhcmNoaW5nLlxuICAgICAgICAgICAgICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IExPQ0FMIGFuZCBNUEVHVFMuXG4gICAgICAgICAgICAgICAgICAgIGxpbmUuc3Vic3RyKDE2KS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcC5zdGFydHNXaXRoKCdMT0NBTDonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ZVRpbWUgPSB0aW1lc3RhbXAuc3Vic3RyKDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lc3RhbXAuc3RhcnRzV2l0aCgnTVBFR1RTOicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBlZ1RzID0gcGFyc2VJbnQodGltZXN0YW1wLnN1YnN0cig3KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHN1YnRpdGxlIG9mZnNldCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzeW5jIFBUUyBpcyBsZXNzIHRoYW4gemVybywgd2UgaGF2ZSBhIDMzLWJpdCB3cmFwYXJvdW5kLCB3aGljaCBpcyBmaXhlZCBieSBhZGRpbmcgMl4zMyA9IDg1ODk5MzQ1OTIuXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW5jUFRTID0gc3luY1BUUyA8IDAgPyBzeW5jUFRTICsgODU4OTkzNDU5MiA6IHN5bmNQVFM7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGp1c3QgTVBFR1RTIGJ5IHN5bmMgUFRTLlxuICAgICAgICAgICAgICAgICAgICAgICAgbXBlZ1RzIC09IHN5bmNQVFM7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGN1ZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsVGltZSA9IGN1ZVN0cmluZzJtaWxsaXMoY3VlVGltZSkgLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBNUEVHVFMgdG8gc2Vjb25kcyBmcm9tIDkwa0h6LlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudGF0aW9uVGltZSA9IG1wZWdUcyAvIDkwMDAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxUaW1lID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcignTWFsZm9ybWVkIFgtVElNRVNUQU1QLU1BUDogJyArIGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoJ01hbGZvcm1lZCBYLVRJTUVTVEFNUC1NQVA6ICcgKyBsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gd2l0aG91dCBwYXJzaW5nIFgtVElNRVNUQU1QLU1BUCBsaW5lLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIGxpbmUgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgIHBhcnNlci5wYXJzZShsaW5lICsgJ1xcbicpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwYXJzZXIuZmx1c2goKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlZUVFBhcnNlcjtcblxufSx7XCI1M1wiOjUzfV0sNTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpOyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBYSFIgYmFzZWQgbG9nZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFhockxvYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWGhyTG9hZGVyKGNvbmZpZykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBYaHJMb2FkZXIpO1xuXG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcueGhyU2V0dXApIHtcbiAgICAgIHRoaXMueGhyU2V0dXAgPSBjb25maWcueGhyU2V0dXA7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFhockxvYWRlciwgW3tcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhYm9ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgdmFyIGxvYWRlciA9IHRoaXMubG9hZGVyO1xuICAgICAgaWYgKGxvYWRlciAmJiBsb2FkZXIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBudWxsO1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XG4gICAgICB0aGlzLnJldHJ5VGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgdGhpcy5zdGF0cyA9IHsgdHJlcXVlc3Q6IHBlcmZvcm1hbmNlLm5vdygpLCByZXRyeTogMCB9O1xuICAgICAgdGhpcy5yZXRyeURlbGF5ID0gY29uZmlnLnJldHJ5RGVsYXk7XG4gICAgICB0aGlzLmxvYWRJbnRlcm5hbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRJbnRlcm5hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRJbnRlcm5hbCgpIHtcbiAgICAgIHZhciB4aHIsXG4gICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgaWYgKHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgeGhyID0gdGhpcy5sb2FkZXIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhociA9IHRoaXMubG9hZGVyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB9XG5cbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLnJlYWR5c3RhdGVjaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5sb2FkcHJvZ3Jlc3MuYmluZCh0aGlzKTtcblxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcblxuICAgICAgaWYgKGNvbnRleHQucmFuZ2VFbmQpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyAoY29udGV4dC5yYW5nZUVuZCAtIDEpKTtcbiAgICAgIH1cbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBjb250ZXh0LnJlc3BvbnNlVHlwZTtcbiAgICAgIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgICBzdGF0cy50Zmlyc3QgPSAwO1xuICAgICAgc3RhdHMubG9hZGVkID0gMDtcbiAgICAgIGlmICh0aGlzLnhoclNldHVwKSB7XG4gICAgICAgIHRoaXMueGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICB9XG4gICAgICAvLyBzZXR1cCB0aW1lb3V0IGJlZm9yZSB3ZSBwZXJmb3JtIHJlcXVlc3RcbiAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIHRoaXMuY29uZmlnLnRpbWVvdXQpO1xuICAgICAgeGhyLnNlbmQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWFkeXN0YXRlY2hhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZShldmVudCkge1xuICAgICAgdmFyIHhociA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlLFxuICAgICAgICAgIHN0YXRzID0gdGhpcy5zdGF0cyxcbiAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAvLyBkb24ndCBwcm9jZWVkIGlmIHhociBoYXMgYmVlbiBhYm9ydGVkXG4gICAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vID49IEhFQURFUlNfUkVDRUlWRURcbiAgICAgIGlmIChyZWFkeVN0YXRlID49IDIpIHtcbiAgICAgICAgLy8gY2xlYXIgeGhyIHRpbWVvdXQgYW5kIHJlYXJtIGl0IGlmIHJlYWR5U3RhdGUgbGVzcyB0aGFuIDRcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgaWYgKHN0YXRzLnRmaXJzdCA9PT0gMCkge1xuICAgICAgICAgIHN0YXRzLnRmaXJzdCA9IE1hdGgubWF4KHBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy50cmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICB2YXIgc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgICAgICAvLyBodHRwIHN0YXR1cyBiZXR3ZWVuIDIwMCB0byAyOTkgYXJlIGFsbCBzdWNjZXNzZnVsXG4gICAgICAgICAgaWYgKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICBzdGF0cy50bG9hZCA9IE1hdGgubWF4KHN0YXRzLnRmaXJzdCwgcGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbGVuID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRzLmxvYWRlZCA9IHN0YXRzLnRvdGFsID0gbGVuO1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0geyB1cmw6IHhoci5yZXNwb25zZVVSTCwgZGF0YTogZGF0YSB9O1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIG1heCBuYiBvZiByZXRyaWVzIHJlYWNoZWQgb3IgaWYgaHR0cCBzdGF0dXMgYmV0d2VlbiA0MDAgYW5kIDQ5OSAoc3VjaCBlcnJvciBjYW5ub3QgYmUgcmVjb3ZlcmVkLCByZXRyeWluZyBpcyB1c2VsZXNzKSwgcmV0dXJuIGVycm9yXG4gICAgICAgICAgICBpZiAoc3RhdHMucmV0cnkgPj0gY29uZmlnLm1heFJldHJ5IHx8IHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNDk5KSB7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmVycm9yKHN0YXR1cyArICcgd2hpbGUgbG9hZGluZyAnICsgY29udGV4dC51cmwpO1xuICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yKHsgY29kZTogc3RhdHVzLCB0ZXh0OiB4aHIuc3RhdHVzVGV4dCB9LCBjb250ZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJldHJ5XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oc3RhdHVzICsgJyB3aGlsZSBsb2FkaW5nICcgKyBjb250ZXh0LnVybCArICcsIHJldHJ5aW5nIGluICcgKyB0aGlzLnJldHJ5RGVsYXkgKyAnLi4uJyk7XG4gICAgICAgICAgICAgIC8vIGFib3J0cyBhbmQgcmVzZXRzIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAvLyBzY2hlZHVsZSByZXRyeVxuICAgICAgICAgICAgICB0aGlzLnJldHJ5VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9hZEludGVybmFsLmJpbmQodGhpcyksIHRoaXMucmV0cnlEZWxheSk7XG4gICAgICAgICAgICAgIC8vIHNldCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgICAgICAgIHRoaXMucmV0cnlEZWxheSA9IE1hdGgubWluKDIgKiB0aGlzLnJldHJ5RGVsYXksIGNvbmZpZy5tYXhSZXRyeURlbGF5KTtcbiAgICAgICAgICAgICAgc3RhdHMucmV0cnkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcmVhZHlTdGF0ZSA+PSAyIEFORCByZWFkeVN0YXRlICE9PTQgKHJlYWR5U3RhdGUgPSBIRUFERVJTX1JFQ0VJVkVEIHx8IExPQURJTkcpIHJlYXJtIHRpbWVvdXQgYXMgeGhyIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkdGltZW91dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWR0aW1lb3V0KCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIud2FybigndGltZW91dCB3aGlsZSBsb2FkaW5nICcgKyB0aGlzLmNvbnRleHQudXJsKTtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uVGltZW91dCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRwcm9ncmVzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRwcm9ncmVzcyhldmVudCkge1xuICAgICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICAgIHN0YXRzLmxvYWRlZCA9IGV2ZW50LmxvYWRlZDtcbiAgICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgICB9XG4gICAgICB2YXIgb25Qcm9ncmVzcyA9IHRoaXMuY2FsbGJhY2tzLm9uUHJvZ3Jlc3M7XG4gICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAvLyBsYXN0IGFyZ3MgaXMgdG8gcHJvdmlkZSBvbiBwcm9ncmVzcyBkYXRhXG4gICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIHRoaXMuY29udGV4dCwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFhockxvYWRlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gWGhyTG9hZGVyO1xuXG59LHtcIjUwXCI6NTB9XX0se30sWzM4XSkoMzgpXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhscy5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9obHMuanMvZGlzdC9obHMuanNcbi8vIG1vZHVsZSBpZCA9IDM1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCIvLyB0aGUgd2hhdHdnLWZldGNoIHBvbHlmaWxsIGluc3RhbGxzIHRoZSBmZXRjaCgpIGZ1bmN0aW9uXG4vLyBvbiB0aGUgZ2xvYmFsIG9iamVjdCAod2luZG93IG9yIHNlbGYpXG4vL1xuLy8gUmV0dXJuIHRoYXQgYXMgdGhlIGV4cG9ydCBmb3IgdXNlIGluIFdlYnBhY2ssIEJyb3dzZXJpZnkgZXRjLlxucmVxdWlyZSgnd2hhdHdnLWZldGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHNlbGYuZmV0Y2guYmluZChzZWxmKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pc29tb3JwaGljLWZldGNoL2ZldGNoLW5wbS1icm93c2VyaWZ5LmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDIgMyA0IiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNiBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpKTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY2xhc3NuYW1lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAyIDMgNCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL2NvbnRhaW5lcidcclxuaW1wb3J0IE1lbnVJdGVtIGZyb20gJy4vbWVudUl0ZW0nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJcIj5cclxuICAgICAgICAgICAgICAgIDxDb250YWluZXIgZmxleD17dHJ1ZX0+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiL3N0YXRpYy9sb2dvLnN2Z1wiLz4gICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1lbnVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPE1lbnVJdGVtPuazqOWGjDwvTWVudUl0ZW0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxNZW51SXRlbT7nmbvlvZU8L01lbnVJdGVtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TWVudUl0ZW0+5YWz5LqOPC9NZW51SXRlbT5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvQ29udGFpbmVyPlxyXG5cclxuICAgICAgICAgICAgICAgIDxzdHlsZSBqc3g+e2BcclxuICAgICAgICAgICAgICAgICAgICAuaGVhZGVyIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDQwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICMwMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6LWluZGV4OiA5OTk5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAuaGVhZGVyIGltZyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXgtaGVpZ2h0OiAxMDAlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDBweDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbnRhaW5lciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDUwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC5tZW51IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBgfTwvc3R5bGU+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvaGVhZGVyLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vY29udGFpbmVyJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm1lbnUtaXRlbVwiPlxyXG4gICAgICAgICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XHJcblxyXG4gICAgICAgICAgICAgICAgPHN0eWxlIGpzeD57YFxyXG4gICAgICAgICAgICAgICAgICAgIC5tZW51LWl0ZW0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogI2ZmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogNXB4IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgLjFzIGxpbmVhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAuMXMgbGluZWFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDIwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLm1lbnUtaXRlbTphZnRlciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAjNmZiOTAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAubWVudS1pdGVtOmhvdmVyIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogLjc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYH08L3N0eWxlPlxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvbWVudUl0ZW0uanMiLCIoZnVuY3Rpb24oc2VsZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gc2VsZixcbiAgICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gc2VsZiAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXVxuXG4gICAgdmFyIGlzRGF0YVZpZXcgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICAgIH1cblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG5cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXVxuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSsnLCcrdmFsdWUgOiB2YWx1ZVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChuYW1lKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7IGl0ZW1zLnB1c2godmFsdWUpIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzXG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpXG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpXG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG5cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KVxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7IGJvZHk6IHRoaXMuX2JvZHlJbml0IH0pXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gICAgcmF3SGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gICAgdGhpcy5zdGF0dXMgPSAnc3RhdHVzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiAyMDBcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snXG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfVxuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfVxuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnNcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdFxuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2VcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgfSlcbiAgfVxuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3doYXR3Zy1mZXRjaC9mZXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAyIDMgNCJdLCJzb3VyY2VSb290IjoiIn0="}