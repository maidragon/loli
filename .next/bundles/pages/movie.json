{"component":"module.exports =\nwebpackJsonp([6],{\n\n/***/ 10:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _getPrototypeOf = __webpack_require__(2);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(3);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(4);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(6);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _style = __webpack_require__(7);\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _classnames = __webpack_require__(34);\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _class = function (_React$Component) {\n    (0, _inherits3.default)(_class, _React$Component);\n\n    function _class(props) {\n        (0, _classCallCheck3.default)(this, _class);\n\n        return (0, _possibleConstructorReturn3.default)(this, (_class.__proto__ || (0, _getPrototypeOf2.default)(_class)).call(this, props));\n    }\n\n    (0, _createClass3.default)(_class, [{\n        key: 'render',\n        value: function render() {\n            var containerClass = (0, _classnames2.default)({\n                'container': true,\n                'flex': this.props.flex,\n                'small': this.props.small\n            });\n            return _react2.default.createElement('div', { className: containerClass, 'data-jsx': 4159862121\n            }, this.props.children, _react2.default.createElement(_style2.default, {\n                styleId: 4159862121,\n                css: '.container.small[data-jsx=\"4159862121\"] {width: 1050px;}.container[data-jsx=\"4159862121\"] {height: 100%;margin: 0 auto;}.container.flex[data-jsx=\"4159862121\"] {display:-webkit-flex; display:flex;justify-content: space-between;}@media screen and (min-height: 630px) and (min-width: 1294px) {.container[data-jsx=\"4159862121\"] {width: 1066px;}}@media screen and (min-height: 870px) and (min-width: 1320px) {.container[data-jsx=\"4159862121\"] {width: 1280px;}}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHNcXGNvbnRhaW5lci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFrQjRCLEFBQ1UseUNBQ0EsY0FDakIsQ0FDVyxtQ0FDSyxhQUNFLGVBQ2xCLENBQ2dCLHdDQUNDLG1DQUNpQiwrQkFDbEMsQ0FDOEQsK0RBQy9DLG1DQUNNLGNBQ2pCLENBQ0osQ0FDOEQsK0RBQy9DLG1DQUNNLGNBQ2pCLENBQ0oiLCJmaWxlIjoiY29tcG9uZW50c1xcY29udGFpbmVyLmpzIiwic291cmNlUm9vdCI6IkM6L1VzZXJzL0FiYWlqdW4vRG9jdW1lbnRzL0dpdEh1Yi9sb2xpIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lckNsYXNzID0gY2xhc3NOYW1lcyh7XHJcbiAgICAgICAgICAgICdjb250YWluZXInOiB0cnVlLFxyXG4gICAgICAgICAgICAnZmxleCc6IHRoaXMucHJvcHMuZmxleCxcclxuICAgICAgICAgICAgJ3NtYWxsJzogdGhpcy5wcm9wcy5zbWFsbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjb250YWluZXJDbGFzc30+XHJcbiAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDxzdHlsZSBqc3g+e2BcclxuICAgICAgICAgICAgICAgICAgICAuY29udGFpbmVyLnNtYWxsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwNTBweDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbnRhaW5lciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC5jb250YWluZXIuZmxleCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi1oZWlnaHQ6IDYzMHB4KSBhbmQgKG1pbi13aWR0aDogMTI5NHB4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb250YWluZXIge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwNjZweDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLWhlaWdodDogODcwcHgpIGFuZCAobWluLXdpZHRoOiAxMzIwcHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRhaW5lciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTI4MHB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYH08L3N0eWxlPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn0iXX0= */\\n/*@ sourceURL=components\\\\container.js */'\n            }));\n        }\n    }]);\n\n    return _class;\n}(_react2.default.Component);\n\nexports.default = _class;\n\n ;(function register() { /* react-hot-loader/webpack */ if (process.env.NODE_ENV !== 'production') { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\components\\\\container.js\"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\components\\\\container.js\"); } } })();\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n\n/***/ 17:\n/***/ (function(module, exports, __webpack_require__) {\n\n// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\n__webpack_require__(42);\nmodule.exports = self.fetch.bind(self);\n\n\n/***/ }),\n\n/***/ 268:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process, __resourceQuery) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _getPrototypeOf = __webpack_require__(2);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _regenerator = __webpack_require__(15);\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = __webpack_require__(14);\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _classCallCheck2 = __webpack_require__(3);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(6);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _createClass2 = __webpack_require__(4);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _inherits2 = __webpack_require__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _style = __webpack_require__(7);\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _link = __webpack_require__(12);\n\nvar _link2 = _interopRequireDefault(_link);\n\n__webpack_require__(17);\n\nvar _hls = __webpack_require__(364);\n\nvar _hls2 = _interopRequireDefault(_hls);\n\nvar _head = __webpack_require__(51);\n\nvar _head2 = _interopRequireDefault(_head);\n\nvar _header = __webpack_require__(40);\n\nvar _header2 = _interopRequireDefault(_header);\n\nvar _container = __webpack_require__(10);\n\nvar _container2 = _interopRequireDefault(_container);\n\nvar _tool = __webpack_require__(57);\n\nvar _tool2 = _interopRequireDefault(_tool);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _class = function (_React$Component) {\n    (0, _inherits3.default)(_class, _React$Component);\n\n    (0, _createClass3.default)(_class, [{\n        key: 'componentWillMount',\n        value: function () {\n            var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {\n                var uid, token, res, res2, data, info, video, hls, m3u8Url;\n                return _regenerator2.default.wrap(function _callee$(_context) {\n                    while (1) {\n                        switch (_context.prev = _context.next) {\n                            case 0:\n                                uid = localStorage.getItem(\"userid\");\n                                token = localStorage.getItem(\"token\");\n\n                                // 直接从 url 进入组件\n\n                                if (uid == null || token == null) {\n                                    (0, _tool2.default)();\n                                    uid = localStorage.getItem(\"userid\");\n                                    token = localStorage.getItem(\"token\");\n                                }\n\n                                _context.next = 5;\n                                return fetch('https://loliapi.com/play/' + this.props.id + '?uid=' + uid + '&token=' + token);\n\n                            case 5:\n                                res = _context.sent;\n                                _context.next = 8;\n                                return fetch('https://loliapi.com/info/' + this.props.id);\n\n                            case 8:\n                                res2 = _context.sent;\n                                _context.next = 11;\n                                return res.json();\n\n                            case 11:\n                                data = _context.sent;\n                                _context.next = 14;\n                                return res2.json();\n\n                            case 14:\n                                info = _context.sent;\n\n                                if (!(data.Result == 0)) {\n                                    _context.next = 25;\n                                    break;\n                                }\n\n                                // 认证已过期, 需要重新认证\n                                (0, _tool2.default)();\n                                uid = localStorage.getItem(\"userid\");\n                                token = localStorage.getItem(\"token\");\n\n                                // 重新认证后发请求\n                                _context.next = 21;\n                                return fetch('https://loliapi.com/play/' + this.props.id + '?uid=' + uid + '&token=' + token);\n\n                            case 21:\n                                res = _context.sent;\n                                _context.next = 24;\n                                return res.json();\n\n                            case 24:\n                                data = _context.sent;\n\n                            case 25:\n\n                                this.setState({ url: data.Message });\n                                this.setState({ info: info.Message });\n\n                                if (_hls2.default.isSupported()) {\n                                    video = document.querySelector('.test');\n                                    hls = new _hls2.default();\n                                    // var m3u8Url = decodeURIComponent(\"https://loliapi.com/cors/\" + this.state.url);\n\n                                    m3u8Url = this.state.url;\n\n                                    hls.loadSource(m3u8Url);\n                                    hls.attachMedia(video);\n                                    hls.on(_hls2.default.Events.MANIFEST_PARSED, function () {\n                                        video.play();\n                                    });\n                                }\n\n                            case 28:\n                            case 'end':\n                                return _context.stop();\n                        }\n                    }\n                }, _callee, this);\n            }));\n\n            function componentWillMount() {\n                return _ref.apply(this, arguments);\n            }\n\n            return componentWillMount;\n        }()\n    }], [{\n        key: 'getInitialProps',\n        value: function () {\n            var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(_ref3) {\n                var id = _ref3.query.id;\n                return _regenerator2.default.wrap(function _callee2$(_context2) {\n                    while (1) {\n                        switch (_context2.prev = _context2.next) {\n                            case 0:\n                                return _context2.abrupt('return', { id: id });\n\n                            case 1:\n                            case 'end':\n                                return _context2.stop();\n                        }\n                    }\n                }, _callee2, this);\n            }));\n\n            function getInitialProps(_x) {\n                return _ref2.apply(this, arguments);\n            }\n\n            return getInitialProps;\n        }()\n    }]);\n\n    function _class(props) {\n        (0, _classCallCheck3.default)(this, _class);\n\n        var _this = (0, _possibleConstructorReturn3.default)(this, (_class.__proto__ || (0, _getPrototypeOf2.default)(_class)).call(this, props));\n\n        _this.state = { url: \"\", info: {} };\n        return _this;\n    }\n\n    (0, _createClass3.default)(_class, [{\n        key: 'render',\n        value: function render() {\n            return _react2.default.createElement('div', { className: 'movie', 'data-jsx': 3448864484\n            }, _react2.default.createElement(_head2.default, null, _react2.default.createElement('title', {\n                'data-jsx': 3448864484\n            }, this.state.info.Name), _react2.default.createElement('meta', { charSet: 'utf-8', 'data-jsx': 3448864484\n            }), _react2.default.createElement('link', { rel: 'stylesheet', href: '/static/global.css', 'data-jsx': 3448864484\n            })), _react2.default.createElement(_header2.default, null), _react2.default.createElement('div', { className: 'mask', 'data-jsx': 3448864484\n            }, _react2.default.createElement(_container2.default, { flex: true }, _react2.default.createElement('video', { className: 'test', 'data-jsx': 3448864484\n            }))), _react2.default.createElement(_style2.default, {\n                styleId: 3448864484,\n                css: '.test[data-jsx=\"3448864484\"] {display: block;height: 100%;margin: 0 auto;}.mask[data-jsx=\"3448864484\"] {background: #000;}@media screen and (min-height: 630px) and (min-width: 1294px) {.mask[data-jsx=\"3448864484\"] {height: 480px;}}@media screen and (min-height: 870px) and (min-width: 1320px) {.mask[data-jsx=\"3448864484\"] {height: 720px;}}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzXFxtb3ZpZS5qcz9lbnRyeSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE4RTRCLEFBQ0QsOEJBQ1ksZUFDRixhQUNFLGVBQ2xCLENBQ00sOEJBQ2MsaUJBQ3BCLENBQzhELCtEQUNwRCw4QkFDVyxjQUNqQixDQUNKLENBQzhELCtEQUNwRCw4QkFDVyxjQUNqQixDQUNKIiwiZmlsZSI6InBhZ2VzXFxtb3ZpZS5qcz9lbnRyeSIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9BYmFpanVuL0RvY3VtZW50cy9HaXRIdWIvbG9saSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcclxuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJ1xyXG5pbXBvcnQgJ2lzb21vcnBoaWMtZmV0Y2gnXHJcbmltcG9ydCBIbHMgZnJvbSAnaGxzLmpzJ1xyXG5pbXBvcnQgSGVhZCBmcm9tICduZXh0L2hlYWQnXHJcbmltcG9ydCBIZWFkZXIgZnJvbSAnLi4vY29tcG9uZW50cy9oZWFkZXInXHJcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vY29tcG9uZW50cy9jb250YWluZXInXHJcbmltcG9ydCB2ZXJpZnkgZnJvbSAnLi4vbGliL3Rvb2wnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBzdGF0aWMgYXN5bmMgZ2V0SW5pdGlhbFByb3BzICh7IHF1ZXJ5OiB7IGlkIH0gfSkge1xyXG4gICAgICAgIHJldHVybiB7aWQ6IGlkfVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcclxuICAgICAgICBsZXQgdWlkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ1c2VyaWRcIik7XHJcbiAgICAgICAgbGV0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlblwiKTtcclxuXHJcbiAgICAgICAgLy8g55u05o6l5LuOIHVybCDov5vlhaXnu4Tku7ZcclxuICAgICAgICBpZiAodWlkID09IG51bGwgfHwgdG9rZW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2ZXJpZnkoKTtcclxuICAgICAgICAgICAgdWlkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ1c2VyaWRcIik7XHJcbiAgICAgICAgICAgIHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlblwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByZXMgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9sb2xpYXBpLmNvbS9wbGF5LyR7dGhpcy5wcm9wcy5pZH0/dWlkPSR7dWlkfSZ0b2tlbj0ke3Rva2VufWApO1xyXG4gICAgICAgIGxldCByZXMyID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vbG9saWFwaS5jb20vaW5mby8ke3RoaXMucHJvcHMuaWR9YCk7XHJcbiAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xyXG4gICAgICAgIGxldCBpbmZvID0gYXdhaXQgcmVzMi5qc29uKCk7XHJcblxyXG4gICAgICAgIGlmIChkYXRhLlJlc3VsdCA9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIOiupOivgeW3sui/h+acnywg6ZyA6KaB6YeN5paw6K6k6K+BXHJcbiAgICAgICAgICAgIHZlcmlmeSgpO1xyXG4gICAgICAgICAgICB1aWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInVzZXJpZFwiKTtcclxuICAgICAgICAgICAgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VuXCIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8g6YeN5paw6K6k6K+B5ZCO5Y+R6K+35rGCXHJcbiAgICAgICAgICAgIHJlcyA9IGF3YWl0IGZldGNoKGBodHRwczovL2xvbGlhcGkuY29tL3BsYXkvJHt0aGlzLnByb3BzLmlkfT91aWQ9JHt1aWR9JnRva2VuPSR7dG9rZW59YCk7XHJcbiAgICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dXJsOiBkYXRhLk1lc3NhZ2V9KTtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtpbmZvOiBpbmZvLk1lc3NhZ2V9KTtcclxuXHJcbiAgICAgICAgaWYoSGxzLmlzU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICAgICAgdmFyIHZpZGVvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRlc3QnKTtcclxuICAgICAgICAgICAgdmFyIGhscyA9IG5ldyBIbHMoKTtcclxuICAgICAgICAgICAgLy8gdmFyIG0zdThVcmwgPSBkZWNvZGVVUklDb21wb25lbnQoXCJodHRwczovL2xvbGlhcGkuY29tL2NvcnMvXCIgKyB0aGlzLnN0YXRlLnVybCk7XHJcbiAgICAgICAgICAgIHZhciBtM3U4VXJsID0gdGhpcy5zdGF0ZS51cmw7XHJcbiAgICAgICAgICAgIGhscy5sb2FkU291cmNlKG0zdThVcmwpO1xyXG4gICAgICAgICAgICBobHMuYXR0YWNoTWVkaWEodmlkZW8pO1xyXG4gICAgICAgICAgICBobHMub24oSGxzLkV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgdmlkZW8ucGxheSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IgKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7dXJsOiBcIlwiLCBpbmZvOiB7fX07XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW92aWVcIj5cclxuICAgICAgICAgICAgICAgIDxIZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0aXRsZT57dGhpcy5zdGF0ZS5pbmZvLk5hbWV9PC90aXRsZT5cclxuICAgICAgICAgICAgICAgICAgICA8bWV0YSBjaGFyU2V0PSd1dGYtOCcgLz5cclxuICAgICAgICAgICAgICAgICAgICA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgaHJlZj1cIi9zdGF0aWMvZ2xvYmFsLmNzc1wiIC8+XHJcbiAgICAgICAgICAgICAgICA8L0hlYWQ+XHJcblxyXG4gICAgICAgICAgICAgICAgPEhlYWRlci8+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1hc2tcIj5cclxuICAgICAgICAgICAgICAgICAgICA8Q29udGFpbmVyIGZsZXg9e3RydWV9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dmlkZW8gY2xhc3NOYW1lPVwidGVzdFwiPjwvdmlkZW8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Db250YWluZXI+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgPHN0eWxlIGpzeD57YFxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXN0IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXNrIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogIzAwMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi1oZWlnaHQ6IDYzMHB4KSBhbmQgKG1pbi13aWR0aDogMTI5NHB4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXNrIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogNDgwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi1oZWlnaHQ6IDg3MHB4KSBhbmQgKG1pbi13aWR0aDogMTMyMHB4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXNrIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogNzIwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBgfTwvc3R5bGU+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIClcclxuICAgIH1cclxufSJdfQ== */\\n/*@ sourceURL=pages\\\\movie.js?entry */'\n            }));\n        }\n    }]);\n\n    return _class;\n}(_react2.default.Component);\n\nexports.default = _class;\n\n ;(function register() { /* react-hot-loader/webpack */ if (process.env.NODE_ENV !== 'production') { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\pages\\\\movie.js\"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\pages\\\\movie.js\"); } } })();\n    (function (Component, route) {\n      if (false) return\n      if (false) return\n\n      var qs = __webpack_require__(29)\n      var params = qs.parse(__resourceQuery.slice(1))\n      if (params.entry == null) return\n\n      module.hot.accept()\n      Component.__route = route\n\n      if (module.hot.status() === 'idle') return\n\n      var components = next.router.components\n      for (var r in components) {\n        if (!components.hasOwnProperty(r)) continue\n\n        if (components[r].Component.__route === route) {\n          next.router.update(r, Component)\n        }\n      }\n    })(module.exports.default || module.exports, \"/movie\")\n  \n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), \"?entry\"))\n\n/***/ }),\n\n/***/ 34:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2016 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tclasses.push(classNames.apply(null, arg));\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t\t\treturn classNames;\n\t\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n\n\n/***/ }),\n\n/***/ 364:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar require;var require;(function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Hls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],2:[function(_dereq_,module,exports){\n/* jshint ignore:start */\r\n(function(root) { \r\n/* jshint ignore:end */\r\n\r\n  var HASH_SPLIT = /^([^#]*)(.*)$/;\r\n  var QUERY_SPLIT = /^([^\\?]*)(.*)$/;\r\n  var DOMAIN_SPLIT = /^(([a-z]+:\\/\\/)?[^:\\/]+(?::[0-9]+)?)?(\\/?.*)$/i;\r\n\r\n  var URLToolkit = {\r\n    // build an absolute URL from a relative one using the provided baseURL\r\n    // if relativeURL is an absolute URL it will be returned as is.\r\n    buildAbsoluteURL: function(baseURL, relativeURL) {\r\n      // remove any remaining space and CRLF\r\n      relativeURL = relativeURL.trim();\r\n      if (/^[a-z]+:/i.test(relativeURL)) {\r\n        // complete url, not relative\r\n        return relativeURL;\r\n      }\r\n\r\n      var relativeURLQuery = null;\r\n      var relativeURLHash = null;\r\n\r\n      var relativeURLHashSplit = HASH_SPLIT.exec(relativeURL);\r\n      if (relativeURLHashSplit) {\r\n        relativeURLHash = relativeURLHashSplit[2];\r\n        relativeURL = relativeURLHashSplit[1];\r\n      }\r\n      var relativeURLQuerySplit = QUERY_SPLIT.exec(relativeURL);\r\n      if (relativeURLQuerySplit) {\r\n        relativeURLQuery = relativeURLQuerySplit[2];\r\n        relativeURL = relativeURLQuerySplit[1];\r\n      }\r\n\r\n      var baseURLHashSplit = HASH_SPLIT.exec(baseURL);\r\n      if (baseURLHashSplit) {\r\n        baseURL = baseURLHashSplit[1];\r\n      }\r\n      var baseURLQuerySplit = QUERY_SPLIT.exec(baseURL);\r\n      if (baseURLQuerySplit) {\r\n        baseURL = baseURLQuerySplit[1];\r\n      }\r\n\r\n      var baseURLDomainSplit = DOMAIN_SPLIT.exec(baseURL);\r\n      if (!baseURLDomainSplit) {\r\n        throw new Error('Error trying to parse base URL.');\r\n      }\r\n      \r\n      // e.g. 'http://', 'https://', ''\r\n      var baseURLProtocol = baseURLDomainSplit[2] || '';\r\n      // e.g. 'http://example.com', '//example.com', 'example.com', ''\r\n      var baseURLProtocolDomain = baseURLDomainSplit[1] || '';\r\n      // e.g. '/a/b/c/playlist.m3u8', 'a/b/c/playlist.m3u8'\r\n      var baseURLPath = baseURLDomainSplit[3];\r\n      if (baseURLPath.indexOf('/') !== 0 && baseURLProtocolDomain !== '') {\r\n        // this handles a base url of http://example.com (missing last slash)\r\n        baseURLPath = '/'+baseURLPath;\r\n      }\r\n\r\n      var builtURL = null;\r\n      if (/^\\/\\//.test(relativeURL)) {\r\n        // relative url starts wth '//' so copy protocol (which may be '' if baseUrl didn't provide one)\r\n        builtURL = baseURLProtocol+URLToolkit.buildAbsolutePath('', relativeURL.substring(2));\r\n      }\r\n      else if (/^\\//.test(relativeURL)) {\r\n        // relative url starts with '/' so start from root of domain\r\n        builtURL = baseURLProtocolDomain+'/'+URLToolkit.buildAbsolutePath('', relativeURL.substring(1));\r\n      }\r\n      else {\r\n        builtURL = URLToolkit.buildAbsolutePath(baseURLProtocolDomain+baseURLPath, relativeURL);\r\n      }\r\n\r\n      // put the query and hash parts back\r\n      if (relativeURLQuery) {\r\n        builtURL += relativeURLQuery;\r\n      }\r\n      if (relativeURLHash) {\r\n        builtURL += relativeURLHash;\r\n      }\r\n      return builtURL;\r\n    },\r\n\r\n    // build an absolute path using the provided basePath\r\n    // adapted from https://developer.mozilla.org/en-US/docs/Web/API/document/cookie#Using_relative_URLs_in_the_path_parameter\r\n    // this does not handle the case where relativePath is \"/\" or \"//\". These cases should be handled outside this.\r\n    buildAbsolutePath: function(basePath, relativePath) {\r\n      var sRelPath = relativePath;\r\n      var nUpLn, sDir = '', sPath = basePath.replace(/[^\\/]*$/, sRelPath.replace(/(\\/|^)(?:\\.?\\/+)+/g, '$1'));\r\n      for (var nEnd, nStart = 0; nEnd = sPath.indexOf('/../', nStart), nEnd > -1; nStart = nEnd + nUpLn) {\r\n        nUpLn = /^\\/(?:\\.\\.\\/)*/.exec(sPath.slice(nEnd))[0].length;\r\n        sDir = (sDir + sPath.substring(nStart, nEnd)).replace(new RegExp('(?:\\\\\\/+[^\\\\\\/]*){0,' + ((nUpLn - 1) / 3) + '}$'), '/');\r\n      }\r\n      return sDir + sPath.substr(nStart);\r\n    }\r\n  };\r\n\r\n/* jshint ignore:start */\r\n  if(typeof exports === 'object' && typeof module === 'object')\r\n    module.exports = URLToolkit;\r\n  else if(typeof define === 'function' && define.amd)\r\n    define([], function() { return URLToolkit; });\r\n  else if(typeof exports === 'object')\r\n    exports[\"URLToolkit\"] = URLToolkit;\r\n  else\r\n    root[\"URLToolkit\"] = URLToolkit;\r\n})(this);\r\n/* jshint ignore:end */\r\n\n},{}],3:[function(_dereq_,module,exports){\nvar bundleFn = arguments[3];\nvar sources = arguments[4];\nvar cache = arguments[5];\n\nvar stringify = JSON.stringify;\n\nmodule.exports = function (fn, options) {\n    var wkey;\n    var cacheKeys = Object.keys(cache);\n\n    for (var i = 0, l = cacheKeys.length; i < l; i++) {\n        var key = cacheKeys[i];\n        var exp = cache[key].exports;\n        // Using babel as a transpiler to use esmodule, the export will always\n        // be an object with the default export as a property of it. To ensure\n        // the existing api and babel esmodule exports are both supported we\n        // check for both\n        if (exp === fn || exp && exp.default === fn) {\n            wkey = key;\n            break;\n        }\n    }\n\n    if (!wkey) {\n        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n        var wcache = {};\n        for (var i = 0, l = cacheKeys.length; i < l; i++) {\n            var key = cacheKeys[i];\n            wcache[key] = key;\n        }\n        sources[wkey] = [\n            Function(['require','module','exports'], '(' + fn + ')(self)'),\n            wcache\n        ];\n    }\n    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n\n    var scache = {}; scache[wkey] = wkey;\n    sources[skey] = [\n        Function(['require'], (\n            // try to call default if defined to also support babel esmodule\n            // exports\n            'var f = require(' + stringify(wkey) + ');' +\n            '(f.default ? f.default : f)(self);'\n        )),\n        scache\n    ];\n\n    var workerSources = {};\n    resolveSources(skey);\n\n    function resolveSources(key) {\n        workerSources[key] = true;\n\n        for (var depPath in sources[key][1]) {\n            var depKey = sources[key][1][depPath];\n            if (!workerSources[depKey]) {\n                resolveSources(depKey);\n            }\n        }\n    }\n\n    var src = '(' + bundleFn + ')({'\n        + Object.keys(workerSources).map(function (key) {\n            return stringify(key) + ':['\n                + sources[key][0]\n                + ',' + stringify(sources[key][1]) + ']'\n            ;\n        }).join(',')\n        + '},{},[' + stringify(skey) + '])'\n    ;\n\n    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n    var blob = new Blob([src], { type: 'text/javascript' });\n    if (options && options.bare) { return blob; }\n    var workerUrl = URL.createObjectURL(blob);\n    var worker = new Worker(workerUrl);\n    worker.objectURL = workerUrl;\n    return worker;\n};\n\n},{}],4:[function(_dereq_,module,exports){\n/**\n * HLS config\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n      value: true\n});\nexports.hlsDefaultConfig = undefined;\n\nvar _abrController = _dereq_(5);\n\nvar _abrController2 = _interopRequireDefault(_abrController);\n\nvar _bufferController = _dereq_(8);\n\nvar _bufferController2 = _interopRequireDefault(_bufferController);\n\nvar _capLevelController = _dereq_(9);\n\nvar _capLevelController2 = _interopRequireDefault(_capLevelController);\n\nvar _fpsController = _dereq_(11);\n\nvar _fpsController2 = _interopRequireDefault(_fpsController);\n\nvar _xhrLoader = _dereq_(55);\n\nvar _xhrLoader2 = _interopRequireDefault(_xhrLoader);\n\nvar _audioTrackController = _dereq_(7);\n\nvar _audioTrackController2 = _interopRequireDefault(_audioTrackController);\n\nvar _audioStreamController = _dereq_(6);\n\nvar _audioStreamController2 = _interopRequireDefault(_audioStreamController);\n\nvar _cues = _dereq_(48);\n\nvar _cues2 = _interopRequireDefault(_cues);\n\nvar _timelineController = _dereq_(16);\n\nvar _timelineController2 = _interopRequireDefault(_timelineController);\n\nvar _subtitleTrackController = _dereq_(15);\n\nvar _subtitleTrackController2 = _interopRequireDefault(_subtitleTrackController);\n\nvar _subtitleStreamController = _dereq_(14);\n\nvar _subtitleStreamController2 = _interopRequireDefault(_subtitleStreamController);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//#endif\n\n//#endif\n\n//#if subtitle\n\n//import FetchLoader from './utils/fetch-loader';\n//#if altaudio\nvar hlsDefaultConfig = exports.hlsDefaultConfig = {\n      autoStartLoad: true, // used by stream-controller\n      startPosition: -1, // used by stream-controller\n      defaultAudioCodec: undefined, // used by stream-controller\n      debug: false, // used by logger\n      capLevelOnFPSDrop: false, // used by fps-controller\n      capLevelToPlayerSize: false, // used by cap-level-controller\n      initialLiveManifestSize: 1, // used by stream-controller\n      maxBufferLength: 30, // used by stream-controller\n      maxBufferSize: 60 * 1000 * 1000, // used by stream-controller\n      maxBufferHole: 0.5, // used by stream-controller\n      maxSeekHole: 2, // used by stream-controller\n      lowBufferWatchdogPeriod: 0.5, // used by stream-controller\n      highBufferWatchdogPeriod: 3, // used by stream-controller\n      nudgeOffset: 0.1, // used by stream-controller\n      nudgeMaxRetry: 3, // used by stream-controller\n      maxFragLookUpTolerance: 0.2, // used by stream-controller\n      liveSyncDurationCount: 3, // used by stream-controller\n      liveMaxLatencyDurationCount: Infinity, // used by stream-controller\n      liveSyncDuration: undefined, // used by stream-controller\n      liveMaxLatencyDuration: undefined, // used by stream-controller\n      maxMaxBufferLength: 600, // used by stream-controller\n      enableWorker: true, // used by demuxer\n      enableSoftwareAES: true, // used by decrypter\n      manifestLoadingTimeOut: 10000, // used by playlist-loader\n      manifestLoadingMaxRetry: 1, // used by playlist-loader\n      manifestLoadingRetryDelay: 1000, // used by playlist-loader\n      manifestLoadingMaxRetryTimeout: 64000, // used by playlist-loader\n      startLevel: undefined, // used by level-controller\n      levelLoadingTimeOut: 10000, // used by playlist-loader\n      levelLoadingMaxRetry: 4, // used by playlist-loader\n      levelLoadingRetryDelay: 1000, // used by playlist-loader\n      levelLoadingMaxRetryTimeout: 64000, // used by playlist-loader\n      fragLoadingTimeOut: 20000, // used by fragment-loader\n      fragLoadingMaxRetry: 6, // used by fragment-loader\n      fragLoadingRetryDelay: 1000, // used by fragment-loader\n      fragLoadingMaxRetryTimeout: 64000, // used by fragment-loader\n      fragLoadingLoopThreshold: 3, // used by stream-controller\n      startFragPrefetch: false, // used by stream-controller\n      fpsDroppedMonitoringPeriod: 5000, // used by fps-controller\n      fpsDroppedMonitoringThreshold: 0.2, // used by fps-controller\n      appendErrorMaxRetry: 3, // used by buffer-controller\n      loader: _xhrLoader2.default,\n      //loader: FetchLoader,\n      fLoader: undefined,\n      pLoader: undefined,\n      xhrSetup: undefined,\n      fetchSetup: undefined,\n      abrController: _abrController2.default,\n      bufferController: _bufferController2.default,\n      capLevelController: _capLevelController2.default,\n      fpsController: _fpsController2.default,\n      //#if altaudio\n      audioStreamController: _audioStreamController2.default,\n      audioTrackController: _audioTrackController2.default,\n      //#endif\n      //#if subtitle\n      subtitleStreamController: _subtitleStreamController2.default,\n      subtitleTrackController: _subtitleTrackController2.default,\n      timelineController: _timelineController2.default,\n      cueHandler: _cues2.default,\n      enableCEA708Captions: true, // used by timeline-controller\n      enableWebVTT: true, // used by timeline-controller\n      //#endif\n      stretchShortVideoTrack: false, // used by mp4-remuxer\n      forceKeyFrameOnDiscontinuity: true, // used by ts-demuxer\n      abrEwmaFastLive: 3, // used by abr-controller\n      abrEwmaSlowLive: 9, // used by abr-controller\n      abrEwmaFastVoD: 3, // used by abr-controller\n      abrEwmaSlowVoD: 9, // used by abr-controller\n      abrEwmaDefaultEstimate: 5e5, // 500 kbps  // used by abr-controller\n      abrBandWidthFactor: 0.95, // used by abr-controller\n      abrBandWidthUpFactor: 0.7, // used by abr-controller\n      abrMaxWithRealBitrate: false, // used by abr-controller\n      maxStarvationDelay: 4, // used by abr-controller\n      maxLoadingDelay: 4, // used by abr-controller\n      minAutoBitrate: 0 // used by hls\n};\n\n},{\"11\":11,\"14\":14,\"15\":15,\"16\":16,\"48\":48,\"5\":5,\"55\":55,\"6\":6,\"7\":7,\"8\":8,\"9\":9}],5:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _bufferHelper = _dereq_(35);\n\nvar _bufferHelper2 = _interopRequireDefault(_bufferHelper);\n\nvar _errors = _dereq_(31);\n\nvar _logger = _dereq_(50);\n\nvar _ewmaBandwidthEstimator = _dereq_(10);\n\nvar _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar AbrController = function (_EventHandler) {\n  _inherits(AbrController, _EventHandler);\n\n  function AbrController(hls) {\n    _classCallCheck(this, AbrController);\n\n    var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.FRAG_BUFFERED, _events2.default.ERROR));\n\n    _this.lastLoadedFragLevel = 0;\n    _this._nextAutoLevel = -1;\n    _this.hls = hls;\n    _this.onCheck = _this._abandonRulesCheck.bind(_this);\n    return _this;\n  }\n\n  _createClass(AbrController, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.clearTimer();\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n  }, {\n    key: 'onFragLoading',\n    value: function onFragLoading(data) {\n      var frag = data.frag;\n      if (frag.type === 'main') {\n        if (!this.timer) {\n          this.timer = setInterval(this.onCheck, 100);\n        }\n        // lazy init of bw Estimator, rationale is that we use different params for Live/VoD\n        // so we need to wait for stream manifest / playlist type to instantiate it.\n        if (!this._bwEstimator) {\n          var hls = this.hls,\n              level = data.frag.level,\n              isLive = hls.levels[level].details.live,\n              config = hls.config,\n              ewmaFast = void 0,\n              ewmaSlow = void 0;\n\n          if (isLive) {\n            ewmaFast = config.abrEwmaFastLive;\n            ewmaSlow = config.abrEwmaSlowLive;\n          } else {\n            ewmaFast = config.abrEwmaFastVoD;\n            ewmaSlow = config.abrEwmaSlowVoD;\n          }\n          this._bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);\n        }\n        this.fragCurrent = frag;\n      }\n    }\n  }, {\n    key: '_abandonRulesCheck',\n    value: function _abandonRulesCheck() {\n      /*\n        monitor fragment retrieval time...\n        we compute expected time of arrival of the complete fragment.\n        we compare it to expected time of buffer starvation\n      */\n      var hls = this.hls,\n          v = hls.media,\n          frag = this.fragCurrent,\n          loader = frag.loader,\n          minAutoLevel = hls.minAutoLevel;\n\n      // if loader has been destroyed or loading has been aborted, stop timer and return\n      if (!loader || loader.stats && loader.stats.aborted) {\n        _logger.logger.warn('frag loader destroy or aborted, disarm abandonRules');\n        this.clearTimer();\n        return;\n      }\n      var stats = loader.stats;\n      /* only monitor frag retrieval time if\n      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */\n      if (v && (!v.paused && v.playbackRate !== 0 || !v.readyState) && frag.autoLevel && frag.level) {\n        var requestDelay = performance.now() - stats.trequest,\n            playbackRate = Math.abs(v.playbackRate);\n        // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate\n        if (requestDelay > 500 * frag.duration / playbackRate) {\n          var levels = hls.levels,\n              loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),\n              // byte/s; at least 1 byte/s to avoid division by zero\n          // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size\n          level = levels[frag.level],\n              levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate,\n              expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)),\n              pos = v.currentTime,\n              fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,\n              bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos) / playbackRate;\n          // consider emergency switch down only if we have less than 2 frag buffered AND\n          // time to finish loading current fragment is bigger than buffer starvation delay\n          // ie if we risk buffer starvation if bw does not increase quickly\n          if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {\n            var fragLevelNextLoadedDelay = void 0,\n                nextLoadLevel = void 0;\n            // lets iterate through lower level and try to find the biggest one that could avoid rebuffering\n            // we start from current level - 1 and we step down , until we find a matching level\n            for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n              // compute time to load next fragment at lower level\n              // 0.8 : consider only 80% of current bw to be conservative\n              // 8 = bits per byte (bps/Bps)\n              var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;\n              fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);\n              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {\n                // we found a lower level that be rebuffering free with current estimated bw !\n                break;\n              }\n            }\n            // only emergency switch down if it takes less time to load new fragment at lowest level instead\n            // of finishing loading current one ...\n            if (fragLevelNextLoadedDelay < fragLoadedDelay) {\n              _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']<fragLoadedDelay[' + (frag.level - 1) + '];bufferStarvationDelay:' + fragLevelNextLoadedDelay.toFixed(1) + '<' + fragLoadedDelay.toFixed(1) + ':' + bufferStarvationDelay.toFixed(1));\n              // force next load level in auto mode\n              hls.nextLoadLevel = nextLoadLevel;\n              // update bw estimate for this fragment before cancelling load (this will help reducing the bw)\n              this._bwEstimator.sample(requestDelay, stats.loaded);\n              //abort fragment loading\n              loader.abort();\n              // stop abandon rules timer\n              this.clearTimer();\n              hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: 'onFragLoaded',\n    value: function onFragLoaded(data) {\n      var frag = data.frag;\n      if (frag.type === 'main' && !isNaN(frag.sn)) {\n        // stop monitoring bw once frag loaded\n        this.clearTimer();\n        // store level id after successful fragment load\n        this.lastLoadedFragLevel = frag.level;\n        // reset forced auto level value so that next level will be selected\n        this._nextAutoLevel = -1;\n\n        // compute level average bitrate\n        if (this.hls.config.abrMaxWithRealBitrate) {\n          var level = this.hls.levels[frag.level];\n          var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;\n          var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;\n          level.loaded = { bytes: loadedBytes, duration: loadedDuration };\n          level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n        }\n        // if fragment has been loaded to perform a bitrate test,\n        if (data.frag.bitrateTest) {\n          var stats = data.stats;\n          stats.tparsed = stats.tbuffered = stats.tload;\n          this.onFragBuffered(data);\n        }\n      }\n    }\n  }, {\n    key: 'onFragBuffered',\n    value: function onFragBuffered(data) {\n      var stats = data.stats,\n          frag = data.frag;\n      // only update stats on first frag buffering\n      // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly\n      // and leading to wrong bw estimation\n      // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)\n      if (stats.aborted !== true && frag.loadCounter === 1 && frag.type === 'main' && !isNaN(frag.sn) && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {\n        // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached\n        // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached\n        // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation\n        var fragLoadingProcessingMs = stats.tparsed - stats.trequest;\n        _logger.logger.log('latency/loading/parsing/append/kbps:' + Math.round(stats.tfirst - stats.trequest) + '/' + Math.round(stats.tload - stats.tfirst) + '/' + Math.round(stats.tparsed - stats.tload) + '/' + Math.round(stats.tbuffered - stats.tparsed) + '/' + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));\n        this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);\n        // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration\n        if (frag.bitrateTest) {\n          this.bitrateTestDelay = fragLoadingProcessingMs / 1000;\n        } else {\n          this.bitrateTestDelay = 0;\n        }\n      }\n    }\n  }, {\n    key: 'onError',\n    value: function onError(data) {\n      // stop timer in case of frag loading error\n      switch (data.details) {\n        case _errors.ErrorDetails.FRAG_LOAD_ERROR:\n        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:\n          this.clearTimer();\n          break;\n        default:\n          break;\n      }\n    }\n  }, {\n    key: 'clearTimer',\n    value: function clearTimer() {\n      if (this.timer) {\n        clearInterval(this.timer);\n        this.timer = null;\n      }\n    }\n\n    // return next auto level\n\n  }, {\n    key: '_findBestLevel',\n    value: function _findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {\n      for (var i = maxAutoLevel; i >= minAutoLevel; i--) {\n        var levelInfo = levels[i],\n            levelDetails = levelInfo.details,\n            avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,\n            live = levelDetails ? levelDetails.live : false,\n            adjustedbw = void 0;\n        // follow algorithm captured from stagefright :\n        // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n        // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n        // consider only 80% of the available bandwidth, but if we are switching up,\n        // be even more conservative (70%) to avoid overestimating and immediately\n        // switching back.\n        if (i <= currentLevel) {\n          adjustedbw = bwFactor * currentBw;\n        } else {\n          adjustedbw = bwUpFactor * currentBw;\n        }\n        var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate,\n            fetchDuration = bitrate * avgDuration / adjustedbw;\n\n        _logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);\n        // if adjusted bw is greater than level bitrate AND\n        if (adjustedbw > bitrate && (\n        // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n        !fetchDuration || live || fetchDuration < maxFetchDuration)) {\n          // as we are looping from highest to lowest, this will return the best achievable quality level\n\n          return i;\n        }\n      }\n      // not enough time budget even with quality level 0 ... rebuffering might happen\n      return -1;\n    }\n  }, {\n    key: 'nextAutoLevel',\n    get: function get() {\n      var forcedAutoLevel = this._nextAutoLevel;\n      var bwEstimator = this._bwEstimator;\n      // in case next auto level has been forced, and bw not available or not reliable, return forced value\n      if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {\n        return forcedAutoLevel;\n      }\n      // compute next level using ABR logic\n      var nextABRAutoLevel = this._nextABRAutoLevel;\n      // if forced auto level has been defined, use it to cap ABR computed quality level\n      if (forcedAutoLevel !== -1) {\n        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);\n      }\n      return nextABRAutoLevel;\n    },\n    set: function set(nextLevel) {\n      this._nextAutoLevel = nextLevel;\n    }\n  }, {\n    key: '_nextABRAutoLevel',\n    get: function get() {\n      var hls = this.hls,\n          maxAutoLevel = hls.maxAutoLevel,\n          levels = hls.levels,\n          config = hls.config,\n          minAutoLevel = hls.minAutoLevel;\n      var v = hls.media,\n          currentLevel = this.lastLoadedFragLevel,\n          currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,\n          pos = v ? v.currentTime : 0,\n\n      // playbackRate is the absolute value of the playback rate; if v.playbackRate is 0, we use 1 to load as\n      // if we're playing back at the normal rate.\n      playbackRate = v && v.playbackRate !== 0 ? Math.abs(v.playbackRate) : 1.0,\n          avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,\n\n      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n      bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, config.maxBufferHole).end - pos) / playbackRate;\n\n      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n      var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);\n      if (bestLevel >= 0) {\n        return bestLevel;\n      } else {\n        _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');\n        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering\n        // if no matching level found, logic will return 0\n        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay,\n            bwFactor = config.abrBandWidthFactor,\n            bwUpFactor = config.abrBandWidthUpFactor;\n        if (bufferStarvationDelay === 0) {\n          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n          var bitrateTestDelay = this.bitrateTestDelay;\n          if (bitrateTestDelay) {\n            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n            // max video loading delay used in  automatic start level selection :\n            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n            // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n            var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n            maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n            _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');\n            // don't use conservative factor on bitrate test\n            bwFactor = bwUpFactor = 1;\n          }\n        }\n        bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);\n        return Math.max(bestLevel, 0);\n      }\n    }\n  }]);\n\n  return AbrController;\n}(_eventHandler2.default);\n\nexports.default = AbrController;\n\n},{\"10\":10,\"31\":31,\"32\":32,\"33\":33,\"35\":35,\"50\":50}],6:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _binarySearch = _dereq_(46);\n\nvar _binarySearch2 = _interopRequireDefault(_binarySearch);\n\nvar _bufferHelper = _dereq_(35);\n\nvar _bufferHelper2 = _interopRequireDefault(_bufferHelper);\n\nvar _demuxer = _dereq_(25);\n\nvar _demuxer2 = _interopRequireDefault(_demuxer);\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _levelHelper = _dereq_(36);\n\nvar _levelHelper2 = _interopRequireDefault(_levelHelper);\n\nvar _timeRanges = _dereq_(51);\n\nvar _timeRanges2 = _interopRequireDefault(_timeRanges);\n\nvar _errors = _dereq_(31);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar State = {\n  STOPPED: 'STOPPED',\n  STARTING: 'STARTING',\n  IDLE: 'IDLE',\n  PAUSED: 'PAUSED',\n  KEY_LOADING: 'KEY_LOADING',\n  FRAG_LOADING: 'FRAG_LOADING',\n  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n  WAITING_TRACK: 'WAITING_TRACK',\n  PARSING: 'PARSING',\n  PARSED: 'PARSED',\n  BUFFER_FLUSHING: 'BUFFER_FLUSHING',\n  ENDED: 'ENDED',\n  ERROR: 'ERROR',\n  WAITING_INIT_PTS: 'WAITING_INIT_PTS'\n};\n\nvar AudioStreamController = function (_EventHandler) {\n  _inherits(AudioStreamController, _EventHandler);\n\n  function AudioStreamController(hls) {\n    _classCallCheck(this, AudioStreamController);\n\n    var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.INIT_PTS_FOUND));\n\n    _this.config = hls.config;\n    _this.audioCodecSwap = false;\n    _this.ticks = 0;\n    _this._state = State.STOPPED;\n    _this.ontick = _this.tick.bind(_this);\n    _this.initPTS = [];\n    _this.waitingFragment = null;\n    return _this;\n  }\n\n  _createClass(AudioStreamController, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.stopLoad();\n      if (this.timer) {\n        clearInterval(this.timer);\n        this.timer = null;\n      }\n      _eventHandler2.default.prototype.destroy.call(this);\n      this.state = State.STOPPED;\n    }\n\n    //Signal that video PTS was found\n\n  }, {\n    key: 'onInitPtsFound',\n    value: function onInitPtsFound(data) {\n      var demuxerId = data.id,\n          cc = data.frag.cc,\n          initPTS = data.initPTS;\n      if (demuxerId === 'main') {\n        //Always update the new INIT PTS\n        //Can change due level switch\n        this.initPTS[cc] = initPTS;\n        _logger.logger.log('InitPTS for cc:' + cc + ' found from video track:' + initPTS);\n\n        //If we are waiting we need to demux/remux the waiting frag\n        //With the new initPTS\n        if (this.state === State.WAITING_INIT_PTS) {\n          _logger.logger.log('sending pending audio frag to demuxer');\n          this.state = State.FRAG_LOADING;\n          //We have audio frag waiting or video pts\n          //Let process it\n          this.onFragLoaded(this.waitingFragment);\n          //Lets clean the waiting frag\n          this.waitingFragment = null;\n        }\n      }\n    }\n  }, {\n    key: 'startLoad',\n    value: function startLoad(startPosition) {\n      if (this.tracks) {\n        var lastCurrentTime = this.lastCurrentTime;\n        this.stopLoad();\n        if (!this.timer) {\n          this.timer = setInterval(this.ontick, 100);\n        }\n        this.fragLoadError = 0;\n        if (lastCurrentTime > 0 && startPosition === -1) {\n          _logger.logger.log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));\n          this.state = State.IDLE;\n        } else {\n          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;\n          this.state = State.STARTING;\n        }\n        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;\n        this.tick();\n      } else {\n        this.startPosition = startPosition;\n        this.state = State.STOPPED;\n      }\n    }\n  }, {\n    key: 'stopLoad',\n    value: function stopLoad() {\n      var frag = this.fragCurrent;\n      if (frag) {\n        if (frag.loader) {\n          frag.loader.abort();\n        }\n        this.fragCurrent = null;\n      }\n      this.fragPrevious = null;\n      if (this.demuxer) {\n        this.demuxer.destroy();\n        this.demuxer = null;\n      }\n      this.state = State.STOPPED;\n    }\n  }, {\n    key: 'tick',\n    value: function tick() {\n      this.ticks++;\n      if (this.ticks === 1) {\n        this.doTick();\n        if (this.ticks > 1) {\n          setTimeout(this.tick, 1);\n        }\n        this.ticks = 0;\n      }\n    }\n  }, {\n    key: 'doTick',\n    value: function doTick() {\n      var _this2 = this;\n\n      var pos,\n          track,\n          trackDetails,\n          hls = this.hls,\n          config = hls.config;\n      //logger.log('audioStream:' + this.state);\n      var now;\n      var retryDate;\n      var isSeeking;\n\n      var _ret = function () {\n        switch (_this2.state) {\n          case State.ERROR:\n          //don't do anything in error state to avoid breaking further ...\n          case State.PAUSED:\n          //don't do anything in paused state either ...\n          case State.BUFFER_FLUSHING:\n            break;\n          case State.STARTING:\n            _this2.state = State.WAITING_TRACK;\n            _this2.loadedmetadata = false;\n            break;\n          case State.IDLE:\n            var tracks = _this2.tracks;\n            // audio tracks not received => exit loop\n            if (!tracks) {\n              break;\n            }\n            // if video not attached AND\n            // start fragment already requested OR start frag prefetch disable\n            // exit loop\n            // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n            if (!_this2.media && (_this2.startFragRequested || !config.startFragPrefetch)) {\n              break;\n            }\n            // determine next candidate fragment to be loaded, based on current position and\n            //  end of buffer position\n            // if we have not yet loaded any fragment, start loading from start position\n            if (_this2.loadedmetadata) {\n              pos = _this2.media.currentTime;\n            } else {\n              pos = _this2.nextLoadPosition;\n            }\n            var media = _this2.mediaBuffer ? _this2.mediaBuffer : _this2.media,\n                bufferInfo = _bufferHelper2.default.bufferInfo(media, pos, config.maxBufferHole),\n                bufferLen = bufferInfo.len,\n                bufferEnd = bufferInfo.end,\n                fragPrevious = _this2.fragPrevious,\n                maxBufLen = config.maxMaxBufferLength,\n                audioSwitch = _this2.audioSwitch,\n                trackId = _this2.trackId;\n\n            // if buffer length is less than maxBufLen try to load a new fragment\n            if (bufferLen < maxBufLen && trackId < tracks.length) {\n              trackDetails = tracks[trackId].details;\n              // if track info not retrieved yet, switch state and wait for track retrieval\n              if (typeof trackDetails === 'undefined') {\n                _this2.state = State.WAITING_TRACK;\n                break;\n              }\n\n              // we just got done loading the final fragment, check if we need to finalize media stream\n              if (!audioSwitch && !trackDetails.live && fragPrevious && fragPrevious.sn === trackDetails.endSN) {\n                // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos\n                // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching\n                // between different renditions. using half frag duration should help cope with these cases.\n                if (!_this2.media.seeking || _this2.media.duration - bufferEnd < fragPrevious.duration / 2) {\n                  // Finalize the media stream\n                  _this2.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });\n                  _this2.state = State.ENDED;\n                  break;\n                }\n              }\n\n              // find fragment index, contiguous with end of buffer position\n              var fragments = trackDetails.fragments,\n                  fragLen = fragments.length,\n                  start = fragments[0].start,\n                  end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,\n                  frag = void 0;\n\n              // When switching audio track, reload audio as close as possible to currentTime\n              if (audioSwitch) {\n                if (trackDetails.live && !trackDetails.PTSKnown) {\n                  _logger.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');\n                  bufferEnd = 0;\n                } else {\n                  bufferEnd = pos;\n                  // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime\n                  if (trackDetails.PTSKnown && pos < start) {\n                    // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start\n                    if (bufferInfo.end > start || bufferInfo.nextStart) {\n                      _logger.logger.log('alt audio track ahead of main track, seek to start of alt audio track');\n                      _this2.media.currentTime = start + 0.05;\n                    } else {\n                      return {\n                        v: void 0\n                      };\n                    }\n                  }\n                }\n              }\n              if (trackDetails.initSegment && !trackDetails.initSegment.data) {\n                frag = trackDetails.initSegment;\n              }\n              // if bufferEnd before start of playlist, load first fragment\n              else if (bufferEnd <= start) {\n                  frag = fragments[0];\n                  if (trackDetails.live && frag.loadIdx && frag.loadIdx === _this2.fragLoadIdx) {\n                    // we just loaded this first fragment, and we are still lagging behind the start of the live playlist\n                    // let's force seek to start\n                    var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;\n                    _logger.logger.log('no alt audio available @currentTime:' + _this2.media.currentTime + ', seeking @' + (nextBuffered + 0.05));\n                    _this2.media.currentTime = nextBuffered + 0.05;\n                    return {\n                      v: void 0\n                    };\n                  }\n                } else {\n                  (function () {\n                    var foundFrag = void 0;\n                    var maxFragLookUpTolerance = config.maxFragLookUpTolerance;\n                    var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;\n                    var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {\n                      // offset should be within fragment boundary - config.maxFragLookUpTolerance\n                      // this is to cope with situations like\n                      // bufferEnd = 9.991\n                      // frag[Ø] : [0,10]\n                      // frag[1] : [10,20]\n                      // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n                      //              frag start               frag start+duration\n                      //                  |-----------------------------|\n                      //              <--->                         <--->\n                      //  ...--------><-----------------------------><---------....\n                      // previous frag         matching fragment         next frag\n                      //  return -1             return 0                 return 1\n                      //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n                      // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n                      var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);\n                      if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n                        return 1;\n                      } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n                      else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n                          return -1;\n                        }\n                      return 0;\n                    };\n\n                    if (bufferEnd < end) {\n                      if (bufferEnd > end - maxFragLookUpTolerance) {\n                        maxFragLookUpTolerance = 0;\n                      }\n                      // Prefer the next fragment if it's within tolerance\n                      if (fragNext && !fragmentWithinToleranceTest(fragNext)) {\n                        foundFrag = fragNext;\n                      } else {\n                        foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);\n                      }\n                    } else {\n                      // reach end of playlist\n                      foundFrag = fragments[fragLen - 1];\n                    }\n                    if (foundFrag) {\n                      frag = foundFrag;\n                      start = foundFrag.start;\n                      //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);\n                      if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {\n                        if (frag.sn < trackDetails.endSN) {\n                          frag = fragments[frag.sn + 1 - trackDetails.startSN];\n                          _logger.logger.log('SN just loaded, load next one: ' + frag.sn);\n                        } else {\n                          frag = null;\n                        }\n                      }\n                    }\n                  })();\n                }\n              if (frag) {\n                //logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));\n                if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {\n                  _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId);\n                  _this2.state = State.KEY_LOADING;\n                  hls.trigger(_events2.default.KEY_LOADING, { frag: frag });\n                } else {\n                  _logger.logger.log('Loading ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));\n                  // ensure that we are not reloading the same fragments in loop ...\n                  if (_this2.fragLoadIdx !== undefined) {\n                    _this2.fragLoadIdx++;\n                  } else {\n                    _this2.fragLoadIdx = 0;\n                  }\n                  if (frag.loadCounter) {\n                    frag.loadCounter++;\n                    var maxThreshold = config.fragLoadingLoopThreshold;\n                    // if this frag has already been loaded 3 times, and if it has been reloaded recently\n                    if (frag.loadCounter > maxThreshold && Math.abs(_this2.fragLoadIdx - frag.loadIdx) < maxThreshold) {\n                      hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });\n                      return {\n                        v: void 0\n                      };\n                    }\n                  } else {\n                    frag.loadCounter = 1;\n                  }\n                  frag.loadIdx = _this2.fragLoadIdx;\n                  _this2.fragCurrent = frag;\n                  _this2.startFragRequested = true;\n                  if (!isNaN(frag.sn)) {\n                    _this2.nextLoadPosition = frag.start + frag.duration;\n                  }\n                  hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });\n                  _this2.state = State.FRAG_LOADING;\n                }\n              }\n            }\n            break;\n          case State.WAITING_TRACK:\n            track = _this2.tracks[_this2.trackId];\n            // check if playlist is already loaded\n            if (track && track.details) {\n              _this2.state = State.IDLE;\n            }\n            break;\n          case State.FRAG_LOADING_WAITING_RETRY:\n            now = performance.now();\n            retryDate = _this2.retryDate;\n\n            media = _this2.media;\n            isSeeking = media && media.seeking;\n            // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n\n            if (!retryDate || now >= retryDate || isSeeking) {\n              _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');\n              _this2.state = State.IDLE;\n            }\n            break;\n          case State.WAITING_INIT_PTS:\n          case State.STOPPED:\n          case State.FRAG_LOADING:\n          case State.PARSING:\n          case State.PARSED:\n          case State.ENDED:\n            break;\n          default:\n            break;\n        }\n      }();\n\n      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n    }\n  }, {\n    key: 'onMediaAttached',\n    value: function onMediaAttached(data) {\n      var media = this.media = this.mediaBuffer = data.media;\n      this.onvseeking = this.onMediaSeeking.bind(this);\n      this.onvended = this.onMediaEnded.bind(this);\n      media.addEventListener('seeking', this.onvseeking);\n      media.addEventListener('ended', this.onvended);\n      var config = this.config;\n      if (this.tracks && config.autoStartLoad) {\n        this.startLoad(config.startPosition);\n      }\n    }\n  }, {\n    key: 'onMediaDetaching',\n    value: function onMediaDetaching() {\n      var media = this.media;\n      if (media && media.ended) {\n        _logger.logger.log('MSE detaching and video ended, reset startPosition');\n        this.startPosition = this.lastCurrentTime = 0;\n      }\n\n      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery\n      var tracks = this.tracks;\n      if (tracks) {\n        // reset fragment load counter\n        tracks.forEach(function (track) {\n          if (track.details) {\n            track.details.fragments.forEach(function (fragment) {\n              fragment.loadCounter = undefined;\n            });\n          }\n        });\n      }\n      // remove video listeners\n      if (media) {\n        media.removeEventListener('seeking', this.onvseeking);\n        media.removeEventListener('ended', this.onvended);\n        this.onvseeking = this.onvseeked = this.onvended = null;\n      }\n      this.media = this.mediaBuffer = null;\n      this.loadedmetadata = false;\n      this.stopLoad();\n    }\n  }, {\n    key: 'onMediaSeeking',\n    value: function onMediaSeeking() {\n      if (this.state === State.ENDED) {\n        // switch to IDLE state to check for potential new fragment\n        this.state = State.IDLE;\n      }\n      if (this.media) {\n        this.lastCurrentTime = this.media.currentTime;\n      }\n      // avoid reporting fragment loop loading error in case user is seeking several times on same position\n      if (this.fragLoadIdx !== undefined) {\n        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;\n      }\n      // tick to speed up processing\n      this.tick();\n    }\n  }, {\n    key: 'onMediaEnded',\n    value: function onMediaEnded() {\n      // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n      this.startPosition = this.lastCurrentTime = 0;\n    }\n  }, {\n    key: 'onAudioTracksUpdated',\n    value: function onAudioTracksUpdated(data) {\n      _logger.logger.log('audio tracks updated');\n      this.tracks = data.audioTracks;\n    }\n  }, {\n    key: 'onAudioTrackSwitching',\n    value: function onAudioTrackSwitching(data) {\n      // if any URL found on new audio track, it is an alternate audio track\n      var altAudio = !!data.url;\n      this.trackId = data.id;\n      this.state = State.IDLE;\n\n      this.fragCurrent = null;\n      this.state = State.PAUSED;\n      this.waitingFragment = null;\n      // destroy useless demuxer when switching audio to main\n      if (!altAudio) {\n        if (this.demuxer) {\n          this.demuxer.destroy();\n          this.demuxer = null;\n        }\n      } else {\n        // switching to audio track, start timer if not already started\n        if (!this.timer) {\n          this.timer = setInterval(this.ontick, 100);\n        }\n      }\n\n      //should we switch tracks ?\n      if (altAudio) {\n        this.audioSwitch = true;\n        //main audio track are handled by stream-controller, just do something if switching to alt audio track\n        this.state = State.IDLE;\n        // increase fragment load Index to avoid frag loop loading error after buffer flush\n        if (this.fragLoadIdx !== undefined) {\n          this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;\n        }\n      }\n      this.tick();\n    }\n  }, {\n    key: 'onAudioTrackLoaded',\n    value: function onAudioTrackLoaded(data) {\n      var newDetails = data.details,\n          trackId = data.id,\n          track = this.tracks[trackId],\n          duration = newDetails.totalduration,\n          sliding = 0;\n\n      _logger.logger.log('track ' + trackId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);\n\n      if (newDetails.live) {\n        var curDetails = track.details;\n        if (curDetails && newDetails.fragments.length > 0) {\n          // we already have details for that level, merge them\n          _levelHelper2.default.mergeDetails(curDetails, newDetails);\n          sliding = newDetails.fragments[0].start;\n          // TODO\n          //this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);\n          if (newDetails.PTSKnown) {\n            _logger.logger.log('live audio playlist sliding:' + sliding.toFixed(3));\n          } else {\n            _logger.logger.log('live audio playlist - outdated PTS, unknown sliding');\n          }\n        } else {\n          newDetails.PTSKnown = false;\n          _logger.logger.log('live audio playlist - first load, unknown sliding');\n        }\n      } else {\n        newDetails.PTSKnown = false;\n      }\n      track.details = newDetails;\n\n      // compute start position\n      if (!this.startFragRequested) {\n        // compute start position if set to -1. use it straight away if value is defined\n        if (this.startPosition === -1) {\n          // first, check if start time offset has been set in playlist, if yes, use this value\n          var startTimeOffset = newDetails.startTimeOffset;\n          if (!isNaN(startTimeOffset)) {\n            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);\n            this.startPosition = startTimeOffset;\n          } else {\n            this.startPosition = 0;\n          }\n        }\n        this.nextLoadPosition = this.startPosition;\n      }\n      // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment\n      if (this.state === State.WAITING_TRACK) {\n        this.state = State.IDLE;\n      }\n      //trigger handler right now\n      this.tick();\n    }\n  }, {\n    key: 'onKeyLoaded',\n    value: function onKeyLoaded() {\n      if (this.state === State.KEY_LOADING) {\n        this.state = State.IDLE;\n        this.tick();\n      }\n    }\n  }, {\n    key: 'onFragLoaded',\n    value: function onFragLoaded(data) {\n      var fragCurrent = this.fragCurrent,\n          fragLoaded = data.frag;\n      if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'audio' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {\n        var track = this.tracks[this.trackId],\n            details = track.details,\n            duration = details.totalduration,\n            trackId = fragCurrent.level,\n            sn = fragCurrent.sn,\n            cc = fragCurrent.cc,\n            audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2',\n            stats = this.stats = data.stats;\n        if (sn === 'initSegment') {\n          this.state = State.IDLE;\n\n          stats.tparsed = stats.tbuffered = performance.now();\n          details.initSegment.data = data.payload;\n          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' });\n          this.tick();\n        } else {\n          this.state = State.PARSING;\n          // transmux the MPEG-TS data to ISO-BMFF segments\n          this.appended = false;\n          if (!this.demuxer) {\n            this.demuxer = new _demuxer2.default(this.hls, 'audio');\n          }\n          //Check if we have video initPTS\n          // If not we need to wait for it\n          var initPTS = this.initPTS[cc];\n          var initSegmentData = details.initSegment ? details.initSegment.data : [];\n          if (initSegmentData || initPTS !== undefined) {\n            this.pendingBuffering = true;\n            _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);\n            // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n            var accurateTimeOffset = false; //details.PTSKnown || !details.live;\n            this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);\n          } else {\n            _logger.logger.log('unknown video PTS for continuity counter ' + cc + ', waiting for video PTS before demuxing audio frag ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);\n            this.waitingFragment = data;\n            this.state = State.WAITING_INIT_PTS;\n          }\n        }\n      }\n      this.fragLoadError = 0;\n    }\n  }, {\n    key: 'onFragParsingInitSegment',\n    value: function onFragParsingInitSegment(data) {\n      var fragCurrent = this.fragCurrent;\n      var fragNew = data.frag;\n      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {\n        var tracks = data.tracks,\n            track = void 0;\n\n        // delete any video track found on audio demuxer\n        if (tracks.video) {\n          delete tracks.video;\n        }\n\n        // include levelCodec in audio and video tracks\n        track = tracks.audio;\n        if (track) {\n          track.levelCodec = 'mp4a.40.2';\n          track.id = data.id;\n          this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);\n          _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');\n          var initSegment = track.initSegment;\n          if (initSegment) {\n            var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };\n            if (this.audioSwitch) {\n              this.pendingData = [appendObj];\n            } else {\n              this.appended = true;\n              // arm pending Buffering flag before appending a segment\n              this.pendingBuffering = true;\n              this.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);\n            }\n          }\n          //trigger handler right now\n          this.tick();\n        }\n      }\n    }\n  }, {\n    key: 'onFragParsingData',\n    value: function onFragParsingData(data) {\n      var _this3 = this;\n\n      var fragCurrent = this.fragCurrent;\n      var fragNew = data.frag;\n      if (fragCurrent && data.id === 'audio' && data.type === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {\n        (function () {\n          var trackId = _this3.trackId,\n              track = _this3.tracks[trackId],\n              hls = _this3.hls;\n\n          if (isNaN(data.endPTS)) {\n            data.endPTS = data.startPTS + fragCurrent.duration;\n            data.endDTS = data.startDTS + fragCurrent.duration;\n          }\n\n          _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);\n          _levelHelper2.default.updateFragPTSDTS(track.details, fragCurrent.sn, data.startPTS, data.endPTS);\n\n          var audioSwitch = _this3.audioSwitch,\n              media = _this3.media,\n              appendOnBufferFlush = false;\n          //Only flush audio from old audio tracks when PTS is known on new audio track\n          if (audioSwitch && media) {\n            if (media.readyState) {\n              var currentTime = media.currentTime;\n              _logger.logger.log('switching audio track : currentTime:' + currentTime);\n              if (currentTime >= data.startPTS) {\n                _logger.logger.log('switching audio track : flushing all audio');\n                _this3.state = State.BUFFER_FLUSHING;\n                hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });\n                appendOnBufferFlush = true;\n                //Lets announce that the initial audio track switch flush occur\n                _this3.audioSwitch = false;\n                hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });\n              }\n            } else {\n              //Lets announce that the initial audio track switch flush occur\n              _this3.audioSwitch = false;\n              hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });\n            }\n          }\n\n          var pendingData = _this3.pendingData;\n          if (!_this3.audioSwitch) {\n            [data.data1, data.data2].forEach(function (buffer) {\n              if (buffer && buffer.length) {\n                pendingData.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });\n              }\n            });\n            if (!appendOnBufferFlush && pendingData.length) {\n              pendingData.forEach(function (appendObj) {\n                // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)\n                // in that case it is useless to append following segments\n                if (_this3.state === State.PARSING) {\n                  // arm pending Buffering flag before appending a segment\n                  _this3.pendingBuffering = true;\n                  _this3.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);\n                }\n              });\n              _this3.pendingData = [];\n              _this3.appended = true;\n            }\n          }\n          //trigger handler right now\n          _this3.tick();\n        })();\n      }\n    }\n  }, {\n    key: 'onFragParsed',\n    value: function onFragParsed(data) {\n      var fragCurrent = this.fragCurrent;\n      var fragNew = data.frag;\n      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {\n        this.stats.tparsed = performance.now();\n        this.state = State.PARSED;\n        this._checkAppendedParsed();\n      }\n    }\n  }, {\n    key: 'onBufferCreated',\n    value: function onBufferCreated(data) {\n      var audioTrack = data.tracks.audio;\n      if (audioTrack) {\n        this.mediaBuffer = audioTrack.buffer;\n        this.loadedmetadata = true;\n      }\n    }\n  }, {\n    key: 'onBufferAppended',\n    value: function onBufferAppended(data) {\n      if (data.parent === 'audio') {\n        var state = this.state;\n        if (state === State.PARSING || state === State.PARSED) {\n          // check if all buffers have been appended\n          this.pendingBuffering = data.pending > 0;\n          this._checkAppendedParsed();\n        }\n      }\n    }\n  }, {\n    key: '_checkAppendedParsed',\n    value: function _checkAppendedParsed() {\n      //trigger handler right now\n      if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {\n        var frag = this.fragCurrent,\n            stats = this.stats,\n            hls = this.hls;\n        if (frag) {\n          this.fragPrevious = frag;\n          stats.tbuffered = performance.now();\n          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });\n          var media = this.mediaBuffer ? this.mediaBuffer : this.media;\n          _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));\n          if (this.audioSwitch && this.appended) {\n            this.audioSwitch = false;\n            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: this.trackId });\n          }\n          this.state = State.IDLE;\n        }\n        this.tick();\n      }\n    }\n  }, {\n    key: 'onError',\n    value: function onError(data) {\n      var frag = data.frag;\n      // don't handle frag error not related to audio fragment\n      if (frag && frag.type !== 'audio') {\n        return;\n      }\n      switch (data.details) {\n        case _errors.ErrorDetails.FRAG_LOAD_ERROR:\n        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:\n          if (!data.fatal) {\n            var loadError = this.fragLoadError;\n            if (loadError) {\n              loadError++;\n            } else {\n              loadError = 1;\n            }\n            var config = this.config;\n            if (loadError <= config.fragLoadingMaxRetry) {\n              this.fragLoadError = loadError;\n              // reset load counter to avoid frag loop loading error\n              frag.loadCounter = 0;\n              // exponential backoff capped to config.fragLoadingMaxRetryTimeout\n              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);\n              _logger.logger.warn('audioStreamController: frag loading failed, retry in ' + delay + ' ms');\n              this.retryDate = performance.now() + delay;\n              // retry loading state\n              this.state = State.FRAG_LOADING_WAITING_RETRY;\n            } else {\n              _logger.logger.error('audioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');\n              // redispatch same error but with fatal set to true\n              data.fatal = true;\n              this.hls.trigger(_events2.default.ERROR, data);\n              this.state = State.ERROR;\n            }\n          }\n          break;\n        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:\n        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n        case _errors.ErrorDetails.KEY_LOAD_ERROR:\n        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:\n          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received\n          if (this.state !== State.ERROR) {\n            // if fatal error, stop processing, otherwise move to IDLE to retry loading\n            this.state = data.fatal ? State.ERROR : State.IDLE;\n            _logger.logger.warn('audioStreamController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');\n          }\n          break;\n        case _errors.ErrorDetails.BUFFER_FULL_ERROR:\n          // if in appending state\n          if (data.parent === 'audio' && (this.state === State.PARSING || this.state === State.PARSED)) {\n            var media = this.mediaBuffer,\n                currentTime = this.media.currentTime,\n                mediaBuffered = media && _bufferHelper2.default.isBuffered(media, currentTime) && _bufferHelper2.default.isBuffered(media, currentTime + 0.5);\n            // reduce max buf len if current position is buffered\n            if (mediaBuffered) {\n              var _config = this.config;\n              if (_config.maxMaxBufferLength >= _config.maxBufferLength) {\n                // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n                _config.maxMaxBufferLength /= 2;\n                _logger.logger.warn('audio:reduce max buffer length to ' + _config.maxMaxBufferLength + 's');\n                // increase fragment load Index to avoid frag loop loading error after buffer flush\n                this.fragLoadIdx += 2 * _config.fragLoadingLoopThreshold;\n              }\n              this.state = State.IDLE;\n            } else {\n              // current position is not buffered, but browser is still complaining about buffer full error\n              // this happens on IE/Edge, refer to https://github.com/dailymotion/hls.js/pull/708\n              // in that case flush the whole audio buffer to recover\n              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush audio buffer');\n              this.fragCurrent = null;\n              // flush everything\n              this.state = State.BUFFER_FLUSHING;\n              this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });\n            }\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }, {\n    key: 'onBufferFlushed',\n    value: function onBufferFlushed() {\n      var _this4 = this;\n\n      var pendingData = this.pendingData;\n      if (pendingData && pendingData.length) {\n        _logger.logger.log('appending pending audio data on Buffer Flushed');\n        pendingData.forEach(function (appendObj) {\n          _this4.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);\n        });\n        this.appended = true;\n        this.pendingData = [];\n        this.state = State.PARSED;\n      } else {\n        // move to IDLE once flush complete. this should trigger new fragment loading\n        this.state = State.IDLE;\n        // reset reference to frag\n        this.fragPrevious = null;\n        this.tick();\n      }\n    }\n  }, {\n    key: 'state',\n    set: function set(nextState) {\n      if (this.state !== nextState) {\n        var previousState = this.state;\n        this._state = nextState;\n        _logger.logger.log('audio stream:' + previousState + '->' + nextState);\n      }\n    },\n    get: function get() {\n      return this._state;\n    }\n  }]);\n\n  return AudioStreamController;\n}(_eventHandler2.default);\n\nexports.default = AudioStreamController;\n\n},{\"25\":25,\"31\":31,\"32\":32,\"33\":33,\"35\":35,\"36\":36,\"46\":46,\"50\":50,\"51\":51}],7:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar AudioTrackController = function (_EventHandler) {\n  _inherits(AudioTrackController, _EventHandler);\n\n  function AudioTrackController(hls) {\n    _classCallCheck(this, AudioTrackController);\n\n    var _this = _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.AUDIO_TRACK_LOADED));\n\n    _this.ticks = 0;\n    _this.ontick = _this.tick.bind(_this);\n    return _this;\n  }\n\n  _createClass(AudioTrackController, [{\n    key: 'destroy',\n    value: function destroy() {\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n  }, {\n    key: 'tick',\n    value: function tick() {\n      this.ticks++;\n      if (this.ticks === 1) {\n        this.doTick();\n        if (this.ticks > 1) {\n          setTimeout(this.tick, 1);\n        }\n        this.ticks = 0;\n      }\n    }\n  }, {\n    key: 'doTick',\n    value: function doTick() {\n      this.updateTrack(this.trackId);\n    }\n  }, {\n    key: 'onManifestLoading',\n    value: function onManifestLoading() {\n      // reset audio tracks on manifest loading\n      this.tracks = [];\n      this.trackId = -1;\n    }\n  }, {\n    key: 'onManifestLoaded',\n    value: function onManifestLoaded(data) {\n      var _this2 = this;\n\n      var tracks = data.audioTracks || [];\n      var defaultFound = false;\n      this.tracks = tracks;\n      this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });\n      // loop through available audio tracks and autoselect default if needed\n      var id = 0;\n      tracks.forEach(function (track) {\n        if (track.default) {\n          _this2.audioTrack = id;\n          defaultFound = true;\n          return;\n        }\n        id++;\n      });\n      if (defaultFound === false && tracks.length) {\n        _logger.logger.log('no default audio track defined, use first audio track as default');\n        this.audioTrack = 0;\n      }\n    }\n  }, {\n    key: 'onAudioTrackLoaded',\n    value: function onAudioTrackLoaded(data) {\n      if (data.id < this.tracks.length) {\n        _logger.logger.log('audioTrack ' + data.id + ' loaded');\n        this.tracks[data.id].details = data.details;\n        // check if current playlist is a live playlist\n        if (data.details.live && !this.timer) {\n          // if live playlist we will have to reload it periodically\n          // set reload period to playlist target duration\n          this.timer = setInterval(this.ontick, 1000 * data.details.targetduration);\n        }\n        if (!data.details.live && this.timer) {\n          // playlist is not live and timer is armed : stopping it\n          clearInterval(this.timer);\n          this.timer = null;\n        }\n      }\n    }\n\n    /** get alternate audio tracks list from playlist **/\n\n  }, {\n    key: 'setAudioTrackInternal',\n    value: function setAudioTrackInternal(newId) {\n      // check if level idx is valid\n      if (newId >= 0 && newId < this.tracks.length) {\n        // stopping live reloading timer if any\n        if (this.timer) {\n          clearInterval(this.timer);\n          this.timer = null;\n        }\n        this.trackId = newId;\n        _logger.logger.log('switching to audioTrack ' + newId);\n        var audioTrack = this.tracks[newId],\n            hls = this.hls,\n            type = audioTrack.type,\n            url = audioTrack.url,\n            eventObj = { id: newId, type: type, url: url };\n        // keep AUDIO_TRACK_SWITCH for legacy reason\n        hls.trigger(_events2.default.AUDIO_TRACK_SWITCH, eventObj);\n        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHING, eventObj);\n        // check if we need to load playlist for this audio Track\n        var details = audioTrack.details;\n        if (url && (details === undefined || details.live === true)) {\n          // track not retrieved yet, or live playlist we need to (re)load it\n          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);\n          hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });\n        }\n      }\n    }\n  }, {\n    key: 'updateTrack',\n    value: function updateTrack(newId) {\n      // check if level idx is valid\n      if (newId >= 0 && newId < this.tracks.length) {\n        // stopping live reloading timer if any\n        if (this.timer) {\n          clearInterval(this.timer);\n          this.timer = null;\n        }\n        this.trackId = newId;\n        _logger.logger.log('updating audioTrack ' + newId);\n        var audioTrack = this.tracks[newId],\n            url = audioTrack.url;\n        // check if we need to load playlist for this audio Track\n        var details = audioTrack.details;\n        if (url && (details === undefined || details.live === true)) {\n          // track not retrieved yet, or live playlist we need to (re)load it\n          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);\n          this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });\n        }\n      }\n    }\n  }, {\n    key: 'audioTracks',\n    get: function get() {\n      return this.tracks;\n    }\n\n    /** get index of the selected audio track (index in audio track lists) **/\n\n  }, {\n    key: 'audioTrack',\n    get: function get() {\n      return this.trackId;\n    }\n\n    /** select an audio track, based on its index in audio track lists**/\n    ,\n    set: function set(audioTrackId) {\n      if (this.trackId !== audioTrackId || this.tracks[audioTrackId].details === undefined) {\n        this.setAudioTrackInternal(audioTrackId);\n      }\n    }\n  }]);\n\n  return AudioTrackController;\n}(_eventHandler2.default);\n\nexports.default = AudioTrackController;\n\n},{\"32\":32,\"33\":33,\"50\":50}],8:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _logger = _dereq_(50);\n\nvar _errors = _dereq_(31);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar BufferController = function (_EventHandler) {\n  _inherits(BufferController, _EventHandler);\n\n  function BufferController(hls) {\n    _classCallCheck(this, BufferController);\n\n    // the value that we have set mediasource.duration to\n    // (the actual duration may be tweaked slighly by the browser)\n    var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_PTS_UPDATED, _events2.default.LEVEL_UPDATED));\n\n    _this._msDuration = null;\n    // the value that we want to set mediaSource.duration to\n    _this._levelDuration = null;\n\n    // Source Buffer listeners\n    _this.onsbue = _this.onSBUpdateEnd.bind(_this);\n    _this.onsbe = _this.onSBUpdateError.bind(_this);\n    _this.pendingTracks = {};\n    _this.tracks = {};\n    return _this;\n  }\n\n  _createClass(BufferController, [{\n    key: 'destroy',\n    value: function destroy() {\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n  }, {\n    key: 'onLevelPtsUpdated',\n    value: function onLevelPtsUpdated(data) {\n      var type = data.type;\n      var audioTrack = this.tracks.audio;\n\n      // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n      // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n      // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue\n      // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`\n      // event if SB is in updating state.\n      // More info here: https://github.com/dailymotion/hls.js/issues/332#issuecomment-257986486\n\n      if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') {\n        // Chrome audio mp3 track\n        var audioBuffer = this.sourceBuffer.audio;\n        var delta = Math.abs(audioBuffer.timestampOffset - data.start);\n\n        // adjust timestamp offset if time delta is greater than 100ms\n        if (delta > 0.1) {\n          var updating = audioBuffer.updating;\n\n          try {\n            audioBuffer.abort();\n          } catch (err) {\n            updating = true;\n            _logger.logger.warn('can not abort audio buffer: ' + err);\n          }\n\n          if (!updating) {\n            _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);\n            audioBuffer.timestampOffset = data.start;\n          } else {\n            this.audioTimestampOffset = data.start;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'onManifestParsed',\n    value: function onManifestParsed(data) {\n      var audioExpected = data.audio,\n          videoExpected = data.video,\n          sourceBufferNb = 0;\n      // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n      // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n      // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n      // it will contain the expected nb of source buffers, no need to compute it\n      if (data.altAudio && (audioExpected || videoExpected)) {\n        sourceBufferNb = (audioExpected ? 1 : 0) + (videoExpected ? 1 : 0);\n        _logger.logger.log(sourceBufferNb + ' sourceBuffer(s) expected');\n      }\n      this.sourceBufferNb = sourceBufferNb;\n    }\n  }, {\n    key: 'onMediaAttaching',\n    value: function onMediaAttaching(data) {\n      var media = this.media = data.media;\n      if (media) {\n        // setup the media source\n        var ms = this.mediaSource = new MediaSource();\n        //Media Source listeners\n        this.onmso = this.onMediaSourceOpen.bind(this);\n        this.onmse = this.onMediaSourceEnded.bind(this);\n        this.onmsc = this.onMediaSourceClose.bind(this);\n        ms.addEventListener('sourceopen', this.onmso);\n        ms.addEventListener('sourceended', this.onmse);\n        ms.addEventListener('sourceclose', this.onmsc);\n        // link video and media Source\n        media.src = URL.createObjectURL(ms);\n      }\n    }\n  }, {\n    key: 'onMediaDetaching',\n    value: function onMediaDetaching() {\n      _logger.logger.log('media source detaching');\n      var ms = this.mediaSource;\n      if (ms) {\n        if (ms.readyState === 'open') {\n          try {\n            // endOfStream could trigger exception if any sourcebuffer is in updating state\n            // we don't really care about checking sourcebuffer state here,\n            // as we are anyway detaching the MediaSource\n            // let's just avoid this exception to propagate\n            ms.endOfStream();\n          } catch (err) {\n            _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');\n          }\n        }\n        ms.removeEventListener('sourceopen', this.onmso);\n        ms.removeEventListener('sourceended', this.onmse);\n        ms.removeEventListener('sourceclose', this.onmsc);\n\n        // Detach properly the MediaSource from the HTMLMediaElement as\n        // suggested in https://github.com/w3c/media-source/issues/53.\n        if (this.media) {\n          URL.revokeObjectURL(this.media.src);\n          this.media.removeAttribute('src');\n          this.media.load();\n        }\n\n        this.mediaSource = null;\n        this.media = null;\n        this.pendingTracks = {};\n        this.tracks = {};\n        this.sourceBuffer = {};\n        this.flushRange = [];\n        this.segments = [];\n        this.appended = 0;\n      }\n      this.onmso = this.onmse = this.onmsc = null;\n      this.hls.trigger(_events2.default.MEDIA_DETACHED);\n    }\n  }, {\n    key: 'onMediaSourceOpen',\n    value: function onMediaSourceOpen() {\n      _logger.logger.log('media source opened');\n      this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });\n      var mediaSource = this.mediaSource;\n      if (mediaSource) {\n        // once received, don't listen anymore to sourceopen event\n        mediaSource.removeEventListener('sourceopen', this.onmso);\n      }\n      this.checkPendingTracks();\n    }\n  }, {\n    key: 'checkPendingTracks',\n    value: function checkPendingTracks() {\n      // if any buffer codecs pending, check if we have enough to create sourceBuffers\n      var pendingTracks = this.pendingTracks,\n          pendingTracksNb = Object.keys(pendingTracks).length;\n      // if any pending tracks and (if nb of pending tracks gt or equal than expected nb or if unknown expected nb)\n      if (pendingTracksNb && (this.sourceBufferNb <= pendingTracksNb || this.sourceBufferNb === 0)) {\n        // ok, let's create them now !\n        this.createSourceBuffers(pendingTracks);\n        this.pendingTracks = {};\n        // append any pending segments now !\n        this.doAppending();\n      }\n    }\n  }, {\n    key: 'onMediaSourceClose',\n    value: function onMediaSourceClose() {\n      _logger.logger.log('media source closed');\n    }\n  }, {\n    key: 'onMediaSourceEnded',\n    value: function onMediaSourceEnded() {\n      _logger.logger.log('media source ended');\n    }\n  }, {\n    key: 'onSBUpdateEnd',\n    value: function onSBUpdateEnd() {\n      // update timestampOffset\n      if (this.audioTimestampOffset) {\n        var audioBuffer = this.sourceBuffer.audio;\n        _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + this.audioTimestampOffset);\n        audioBuffer.timestampOffset = this.audioTimestampOffset;\n        delete this.audioTimestampOffset;\n      }\n\n      if (this._needsFlush) {\n        this.doFlush();\n      }\n\n      if (this._needsEos) {\n        this.checkEos();\n      }\n      this.appending = false;\n      var parent = this.parent;\n      // count nb of pending segments waiting for appending on this sourcebuffer\n      var pending = this.segments.reduce(function (counter, segment) {\n        return segment.parent === parent ? counter + 1 : counter;\n      }, 0);\n      this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: parent, pending: pending });\n\n      // don't append in flushing mode\n      if (!this._needsFlush) {\n        this.doAppending();\n      }\n\n      this.updateMediaElementDuration();\n    }\n  }, {\n    key: 'onSBUpdateError',\n    value: function onSBUpdateError(event) {\n      _logger.logger.error('sourceBuffer error:' + event);\n      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n      // this error might not always be fatal (it is fatal if decode error is set, in that case\n      // it will be followed by a mediaElement error ...)\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });\n      // we don't need to do more than that, as accordin to the spec, updateend will be fired just after\n    }\n  }, {\n    key: 'onBufferReset',\n    value: function onBufferReset() {\n      var sourceBuffer = this.sourceBuffer;\n      for (var type in sourceBuffer) {\n        var sb = sourceBuffer[type];\n        try {\n          this.mediaSource.removeSourceBuffer(sb);\n          sb.removeEventListener('updateend', this.onsbue);\n          sb.removeEventListener('error', this.onsbe);\n        } catch (err) {}\n      }\n      this.sourceBuffer = {};\n      this.flushRange = [];\n      this.segments = [];\n      this.appended = 0;\n    }\n  }, {\n    key: 'onBufferCodecs',\n    value: function onBufferCodecs(tracks) {\n      // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks\n      // if sourcebuffers already created, do nothing ...\n      if (Object.keys(this.sourceBuffer).length === 0) {\n        for (var trackName in tracks) {\n          this.pendingTracks[trackName] = tracks[trackName];\n        }\n        var mediaSource = this.mediaSource;\n        if (mediaSource && mediaSource.readyState === 'open') {\n          // try to create sourcebuffers if mediasource opened\n          this.checkPendingTracks();\n        }\n      }\n    }\n  }, {\n    key: 'createSourceBuffers',\n    value: function createSourceBuffers(tracks) {\n      var sourceBuffer = this.sourceBuffer,\n          mediaSource = this.mediaSource;\n\n      for (var trackName in tracks) {\n        if (!sourceBuffer[trackName]) {\n          var track = tracks[trackName];\n          // use levelCodec as first priority\n          var codec = track.levelCodec || track.codec;\n          var mimeType = track.container + ';codecs=' + codec;\n          _logger.logger.log('creating sourceBuffer(' + mimeType + ')');\n          try {\n            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);\n            sb.addEventListener('updateend', this.onsbue);\n            sb.addEventListener('error', this.onsbe);\n            this.tracks[trackName] = { codec: codec, container: track.container };\n            track.buffer = sb;\n          } catch (err) {\n            _logger.logger.error('error while trying to add sourceBuffer:' + err.message);\n            this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });\n          }\n        }\n      }\n      this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });\n    }\n  }, {\n    key: 'onBufferAppending',\n    value: function onBufferAppending(data) {\n      if (!this._needsFlush) {\n        if (!this.segments) {\n          this.segments = [data];\n        } else {\n          this.segments.push(data);\n        }\n        this.doAppending();\n      }\n    }\n  }, {\n    key: 'onBufferAppendFail',\n    value: function onBufferAppendFail(data) {\n      _logger.logger.error('sourceBuffer error:', data.event);\n      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n      // this error might not always be fatal (it is fatal if decode error is set, in that case\n      // it will be followed by a mediaElement error ...)\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });\n    }\n\n    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()\n\n  }, {\n    key: 'onBufferEos',\n    value: function onBufferEos(data) {\n      var sb = this.sourceBuffer;\n      var dataType = data.type;\n      for (var type in sb) {\n        if (!dataType || type === dataType) {\n          if (!sb[type].ended) {\n            sb[type].ended = true;\n            _logger.logger.log(type + ' sourceBuffer now EOS');\n          }\n        }\n      }\n      this.checkEos();\n    }\n\n    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.\n\n  }, {\n    key: 'checkEos',\n    value: function checkEos() {\n      var sb = this.sourceBuffer,\n          mediaSource = this.mediaSource;\n      if (!mediaSource || mediaSource.readyState !== 'open') {\n        this._needsEos = false;\n        return;\n      }\n      for (var type in sb) {\n        var sbobj = sb[type];\n        if (!sbobj.ended) {\n          return;\n        }\n        if (sbobj.updating) {\n          this._needsEos = true;\n          return;\n        }\n      }\n      _logger.logger.log('all media data available, signal endOfStream() to MediaSource and stop loading fragment');\n      //Notify the media element that it now has all of the media data\n      try {\n        mediaSource.endOfStream();\n      } catch (e) {\n        _logger.logger.warn('exception while calling mediaSource.endOfStream()');\n      }\n      this._needsEos = false;\n    }\n  }, {\n    key: 'onBufferFlushing',\n    value: function onBufferFlushing(data) {\n      this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });\n      // attempt flush immediatly\n      this.flushBufferCounter = 0;\n      this.doFlush();\n    }\n  }, {\n    key: 'onLevelUpdated',\n    value: function onLevelUpdated(event) {\n      var details = event.details;\n      if (details.fragments.length === 0) {\n        return;\n      }\n      this._levelDuration = details.totalduration + details.fragments[0].start;\n      this.updateMediaElementDuration();\n    }\n\n    // https://github.com/dailymotion/hls.js/issues/355\n\n  }, {\n    key: 'updateMediaElementDuration',\n    value: function updateMediaElementDuration() {\n      var media = this.media,\n          mediaSource = this.mediaSource,\n          sourceBuffer = this.sourceBuffer,\n          levelDuration = this._levelDuration;\n      if (levelDuration === null || !media || !mediaSource || !sourceBuffer || media.readyState === 0 || mediaSource.readyState !== 'open') {\n        return;\n      }\n      for (var type in sourceBuffer) {\n        if (sourceBuffer[type].updating) {\n          // can't set duration whilst a buffer is updating\n          return;\n        }\n      }\n      if (this._msDuration === null) {\n        // initialise to the value that the media source is reporting\n        this._msDuration = mediaSource.duration;\n      }\n      var duration = media.duration;\n      // levelDuration was the last value we set.\n      // not using mediaSource.duration as the browser may tweak this value\n      // only update mediasource duration if its value increase, this is to avoid\n      // flushing already buffered portion when switching between quality level\n      if (levelDuration > this._msDuration && levelDuration > duration || duration === Infinity || isNaN(duration)) {\n        _logger.logger.log('Updating mediasource duration to ' + levelDuration.toFixed(3));\n        this._msDuration = mediaSource.duration = levelDuration;\n      }\n    }\n  }, {\n    key: 'doFlush',\n    value: function doFlush() {\n      // loop through all buffer ranges to flush\n      while (this.flushRange.length) {\n        var range = this.flushRange[0];\n        // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer\n        if (this.flushBuffer(range.start, range.end, range.type)) {\n          // range flushed, remove from flush array\n          this.flushRange.shift();\n          this.flushBufferCounter = 0;\n        } else {\n          this._needsFlush = true;\n          // avoid looping, wait for SB update end to retrigger a flush\n          return;\n        }\n      }\n      if (this.flushRange.length === 0) {\n        // everything flushed\n        this._needsFlush = false;\n\n        // let's recompute this.appended, which is used to avoid flush looping\n        var appended = 0;\n        var sourceBuffer = this.sourceBuffer;\n        try {\n          for (var type in sourceBuffer) {\n            appended += sourceBuffer[type].buffered.length;\n          }\n        } catch (error) {\n          // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource\n          // this is harmess at this stage, catch this to avoid reporting an internal exception\n          _logger.logger.error('error while accessing sourceBuffer.buffered');\n        }\n        this.appended = appended;\n        this.hls.trigger(_events2.default.BUFFER_FLUSHED);\n      }\n    }\n  }, {\n    key: 'doAppending',\n    value: function doAppending() {\n      var hls = this.hls,\n          sourceBuffer = this.sourceBuffer,\n          segments = this.segments;\n      if (Object.keys(sourceBuffer).length) {\n        if (this.media.error) {\n          this.segments = [];\n          _logger.logger.error('trying to append although a media error occured, flush segment and abort');\n          return;\n        }\n        if (this.appending) {\n          //logger.log(`sb appending in progress`);\n          return;\n        }\n        if (segments && segments.length) {\n          var segment = segments.shift();\n          try {\n            var type = segment.type,\n                sb = sourceBuffer[type];\n            if (sb) {\n              if (!sb.updating) {\n                // reset sourceBuffer ended flag before appending segment\n                sb.ended = false;\n                //logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);\n                this.parent = segment.parent;\n                sb.appendBuffer(segment.data);\n                this.appendError = 0;\n                this.appended++;\n                this.appending = true;\n              } else {\n                segments.unshift(segment);\n              }\n            } else {\n              // in case we don't have any source buffer matching with this segment type,\n              // it means that Mediasource fails to create sourcebuffer\n              // discard this segment, and trigger update end\n              this.onSBUpdateEnd();\n            }\n          } catch (err) {\n            // in case any error occured while appending, put back segment in segments table\n            _logger.logger.error('error while trying to append buffer:' + err.message);\n            segments.unshift(segment);\n            var event = { type: _errors.ErrorTypes.MEDIA_ERROR, parent: segment.parent };\n            if (err.code !== 22) {\n              if (this.appendError) {\n                this.appendError++;\n              } else {\n                this.appendError = 1;\n              }\n              event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;\n              /* with UHD content, we could get loop of quota exceeded error until\n                browser is able to evict some data from sourcebuffer. retrying help recovering this\n              */\n              if (this.appendError > hls.config.appendErrorMaxRetry) {\n                _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');\n                segments = [];\n                event.fatal = true;\n                hls.trigger(_events2.default.ERROR, event);\n                return;\n              } else {\n                event.fatal = false;\n                hls.trigger(_events2.default.ERROR, event);\n              }\n            } else {\n              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n              // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n              this.segments = [];\n              event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;\n              event.fatal = false;\n              hls.trigger(_events2.default.ERROR, event);\n              return;\n            }\n          }\n        }\n      }\n    }\n\n    /*\n      flush specified buffered range,\n      return true once range has been flushed.\n      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end\n    */\n\n  }, {\n    key: 'flushBuffer',\n    value: function flushBuffer(startOffset, endOffset, typeIn) {\n      var sb,\n          i,\n          bufStart,\n          bufEnd,\n          flushStart,\n          flushEnd,\n          sourceBuffer = this.sourceBuffer;\n      if (Object.keys(sourceBuffer).length) {\n        _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime.toFixed(3) + '/' + startOffset + '/' + endOffset);\n        // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments\n        if (this.flushBufferCounter < this.appended) {\n          for (var type in sourceBuffer) {\n            // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one\n            // if no, let's flush all sourcebuffers\n            if (typeIn && type !== typeIn) {\n              continue;\n            }\n            sb = sourceBuffer[type];\n            // we are going to flush buffer, mark source buffer as 'not ended'\n            sb.ended = false;\n            if (!sb.updating) {\n              try {\n                for (i = 0; i < sb.buffered.length; i++) {\n                  bufStart = sb.buffered.start(i);\n                  bufEnd = sb.buffered.end(i);\n                  // workaround firefox not able to properly flush multiple buffered range.\n                  if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && endOffset === Number.POSITIVE_INFINITY) {\n                    flushStart = startOffset;\n                    flushEnd = endOffset;\n                  } else {\n                    flushStart = Math.max(bufStart, startOffset);\n                    flushEnd = Math.min(bufEnd, endOffset);\n                  }\n                  /* sometimes sourcebuffer.remove() does not flush\n                     the exact expected time range.\n                     to avoid rounding issues/infinite loop,\n                     only flush buffer range of length greater than 500ms.\n                  */\n                  if (Math.min(flushEnd, bufEnd) - flushStart > 0.5) {\n                    this.flushBufferCounter++;\n                    _logger.logger.log('flush ' + type + ' [' + flushStart + ',' + flushEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);\n                    sb.remove(flushStart, flushEnd);\n                    return false;\n                  }\n                }\n              } catch (e) {\n                _logger.logger.warn('exception while accessing sourcebuffer, it might have been removed from MediaSource');\n              }\n            } else {\n              //logger.log('abort ' + type + ' append in progress');\n              // this will abort any appending in progress\n              //sb.abort();\n              _logger.logger.warn('cannot flush, sb updating in progress');\n              return false;\n            }\n          }\n        } else {\n          _logger.logger.warn('abort flushing too many retries');\n        }\n        _logger.logger.log('buffer flushed');\n      }\n      // everything flushed !\n      return true;\n    }\n  }]);\n\n  return BufferController;\n}(_eventHandler2.default);\n\nexports.default = BufferController;\n\n},{\"31\":31,\"32\":32,\"33\":33,\"50\":50}],9:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar CapLevelController = function (_EventHandler) {\n  _inherits(CapLevelController, _EventHandler);\n\n  function CapLevelController(hls) {\n    _classCallCheck(this, CapLevelController);\n\n    return _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED));\n  }\n\n  _createClass(CapLevelController, [{\n    key: 'destroy',\n    value: function destroy() {\n      if (this.hls.config.capLevelToPlayerSize) {\n        this.media = this.restrictedLevels = null;\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        if (this.timer) {\n          this.timer = clearInterval(this.timer);\n        }\n      }\n    }\n  }, {\n    key: 'onFpsDropLevelCapping',\n    value: function onFpsDropLevelCapping(data) {\n      if (!this.restrictedLevels) {\n        this.restrictedLevels = [];\n      }\n      if (!this.isLevelRestricted(data.droppedLevel)) {\n        this.restrictedLevels.push(data.droppedLevel);\n      }\n    }\n  }, {\n    key: 'onMediaAttaching',\n    value: function onMediaAttaching(data) {\n      this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n    }\n  }, {\n    key: 'onManifestParsed',\n    value: function onManifestParsed(data) {\n      var hls = this.hls;\n      if (hls.config.capLevelToPlayerSize) {\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        this.levels = data.levels;\n        hls.firstLevel = this.getMaxLevel(data.firstLevel);\n        clearInterval(this.timer);\n        this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);\n        this.detectPlayerSize();\n      }\n    }\n  }, {\n    key: 'detectPlayerSize',\n    value: function detectPlayerSize() {\n      if (this.media) {\n        var levelsLength = this.levels ? this.levels.length : 0;\n        if (levelsLength) {\n          var hls = this.hls;\n          hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);\n          if (hls.autoLevelCapping > this.autoLevelCapping) {\n            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n            // usually happen when the user go to the fullscreen mode.\n            hls.streamController.nextLevelSwitch();\n          }\n          this.autoLevelCapping = hls.autoLevelCapping;\n        }\n      }\n    }\n\n    /*\n    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n    */\n\n  }, {\n    key: 'getMaxLevel',\n    value: function getMaxLevel(capLevelIndex) {\n      var result = 0,\n          i = void 0,\n          level = void 0,\n          mWidth = this.mediaWidth,\n          mHeight = this.mediaHeight,\n          lWidth = 0,\n          lHeight = 0;\n\n      for (i = 0; i <= capLevelIndex; i++) {\n        level = this.levels[i];\n        if (this.isLevelRestricted(i)) {\n          break;\n        }\n        result = i;\n        lWidth = level.width;\n        lHeight = level.height;\n        if (mWidth <= lWidth || mHeight <= lHeight) {\n          break;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: 'isLevelRestricted',\n    value: function isLevelRestricted(level) {\n      return this.restrictedLevels && this.restrictedLevels.indexOf(level) !== -1 ? true : false;\n    }\n  }, {\n    key: 'contentScaleFactor',\n    get: function get() {\n      var pixelRatio = 1;\n      try {\n        pixelRatio = window.devicePixelRatio;\n      } catch (e) {}\n      return pixelRatio;\n    }\n  }, {\n    key: 'mediaWidth',\n    get: function get() {\n      var width = void 0;\n      var media = this.media;\n      if (media) {\n        width = media.width || media.clientWidth || media.offsetWidth;\n        width *= this.contentScaleFactor;\n      }\n      return width;\n    }\n  }, {\n    key: 'mediaHeight',\n    get: function get() {\n      var height = void 0;\n      var media = this.media;\n      if (media) {\n        height = media.height || media.clientHeight || media.offsetHeight;\n        height *= this.contentScaleFactor;\n      }\n      return height;\n    }\n  }]);\n\n  return CapLevelController;\n}(_eventHandler2.default);\n\nexports.default = CapLevelController;\n\n},{\"32\":32,\"33\":33}],10:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _ewma = _dereq_(49);\n\nvar _ewma2 = _interopRequireDefault(_ewma);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EwmaBandWidthEstimator = function () {\n  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {\n    _classCallCheck(this, EwmaBandWidthEstimator);\n\n    this.hls = hls;\n    this.defaultEstimate_ = defaultEstimate;\n    this.minWeight_ = 0.001;\n    this.minDelayMs_ = 50;\n    this.slow_ = new _ewma2.default(slow);\n    this.fast_ = new _ewma2.default(fast);\n  }\n\n  _createClass(EwmaBandWidthEstimator, [{\n    key: 'sample',\n    value: function sample(durationMs, numBytes) {\n      durationMs = Math.max(durationMs, this.minDelayMs_);\n      var bandwidth = 8000 * numBytes / durationMs,\n\n      //console.log('instant bw:'+ Math.round(bandwidth));\n      // we weight sample using loading duration....\n      weight = durationMs / 1000;\n      this.fast_.sample(weight, bandwidth);\n      this.slow_.sample(weight, bandwidth);\n    }\n  }, {\n    key: 'canEstimate',\n    value: function canEstimate() {\n      var fast = this.fast_;\n      return fast && fast.getTotalWeight() >= this.minWeight_;\n    }\n  }, {\n    key: 'getEstimate',\n    value: function getEstimate() {\n      if (this.canEstimate()) {\n        //console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n        //console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n        // Take the minimum of these two estimates.  This should have the effect of\n        // adapting down quickly, but up more slowly.\n        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n      } else {\n        return this.defaultEstimate_;\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {}\n  }]);\n\n  return EwmaBandWidthEstimator;\n}();\n\nexports.default = EwmaBandWidthEstimator;\n\n},{\"49\":49}],11:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar FPSController = function (_EventHandler) {\n  _inherits(FPSController, _EventHandler);\n\n  function FPSController(hls) {\n    _classCallCheck(this, FPSController);\n\n    return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));\n  }\n\n  _createClass(FPSController, [{\n    key: 'destroy',\n    value: function destroy() {\n      if (this.timer) {\n        clearInterval(this.timer);\n      }\n      this.isVideoPlaybackQualityAvailable = false;\n    }\n  }, {\n    key: 'onMediaAttaching',\n    value: function onMediaAttaching(data) {\n      var config = this.hls.config;\n      if (config.capLevelOnFPSDrop) {\n        var video = this.video = data.media instanceof HTMLVideoElement ? data.media : null;\n        if (typeof video.getVideoPlaybackQuality === 'function') {\n          this.isVideoPlaybackQualityAvailable = true;\n        }\n        clearInterval(this.timer);\n        this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n      }\n    }\n  }, {\n    key: 'checkFPS',\n    value: function checkFPS(video, decodedFrames, droppedFrames) {\n      var currentTime = performance.now();\n      if (decodedFrames) {\n        if (this.lastTime) {\n          var currentPeriod = currentTime - this.lastTime,\n              currentDropped = droppedFrames - this.lastDroppedFrames,\n              currentDecoded = decodedFrames - this.lastDecodedFrames,\n              droppedFPS = 1000 * currentDropped / currentPeriod,\n              hls = this.hls;\n          hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });\n          if (droppedFPS > 0) {\n            //logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n            if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n              var currentLevel = hls.currentLevel;\n              _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n              if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n                currentLevel = currentLevel - 1;\n                hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls.currentLevel });\n                hls.autoLevelCapping = currentLevel;\n                hls.streamController.nextLevelSwitch();\n              }\n            }\n          }\n        }\n        this.lastTime = currentTime;\n        this.lastDroppedFrames = droppedFrames;\n        this.lastDecodedFrames = decodedFrames;\n      }\n    }\n  }, {\n    key: 'checkFPSInterval',\n    value: function checkFPSInterval() {\n      var video = this.video;\n      if (video) {\n        if (this.isVideoPlaybackQualityAvailable) {\n          var videoPlaybackQuality = video.getVideoPlaybackQuality();\n          this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n        } else {\n          this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n        }\n      }\n    }\n  }]);\n\n  return FPSController;\n}(_eventHandler2.default);\n\nexports.default = FPSController;\n\n},{\"32\":32,\"33\":33,\"50\":50}],12:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _logger = _dereq_(50);\n\nvar _errors = _dereq_(31);\n\nvar _bufferHelper = _dereq_(35);\n\nvar _bufferHelper2 = _interopRequireDefault(_bufferHelper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar LevelController = function (_EventHandler) {\n  _inherits(LevelController, _EventHandler);\n\n  function LevelController(hls) {\n    _classCallCheck(this, LevelController);\n\n    var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.FRAG_LOADED, _events2.default.ERROR));\n\n    _this.ontick = _this.tick.bind(_this);\n    _this._manualLevel = -1;\n    return _this;\n  }\n\n  _createClass(LevelController, [{\n    key: 'destroy',\n    value: function destroy() {\n      if (this.timer) {\n        clearTimeout(this.timer);\n        this.timer = null;\n      }\n      this._manualLevel = -1;\n    }\n  }, {\n    key: 'startLoad',\n    value: function startLoad() {\n      this.canload = true;\n      var levels = this._levels;\n      // clean up live level details to force reload them, and reset load errors\n      if (levels) {\n        levels.forEach(function (level) {\n          level.loadError = 0;\n          var levelDetails = level.details;\n          if (levelDetails && levelDetails.live) {\n            level.details = undefined;\n          }\n        });\n      }\n      // speed up live playlist refresh if timer exists\n      if (this.timer) {\n        this.tick();\n      }\n    }\n  }, {\n    key: 'stopLoad',\n    value: function stopLoad() {\n      this.canload = false;\n    }\n  }, {\n    key: 'onManifestLoaded',\n    value: function onManifestLoaded(data) {\n      var levels0 = [],\n          levels = [],\n          bitrateStart,\n          bitrateSet = {},\n          videoCodecFound = false,\n          audioCodecFound = false,\n          hls = this.hls,\n          brokenmp4inmp3 = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),\n          checkSupported = function checkSupported(type, codec) {\n        return MediaSource.isTypeSupported(type + '/mp4;codecs=' + codec);\n      };\n\n      // regroup redundant level together\n      data.levels.forEach(function (level) {\n        if (level.videoCodec) {\n          videoCodecFound = true;\n        }\n        // erase audio codec info if browser does not support mp4a.40.34. demuxer will autodetect codec and fallback to mpeg/audio\n        if (brokenmp4inmp3 && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {\n          level.audioCodec = undefined;\n        }\n        if (level.audioCodec || level.attrs && level.attrs.AUDIO) {\n          audioCodecFound = true;\n        }\n        var redundantLevelId = bitrateSet[level.bitrate];\n        if (redundantLevelId === undefined) {\n          bitrateSet[level.bitrate] = levels0.length;\n          level.url = [level.url];\n          level.urlId = 0;\n          levels0.push(level);\n        } else {\n          levels0[redundantLevelId].url.push(level.url);\n        }\n      });\n\n      // remove audio-only level if we also have levels with audio+video codecs signalled\n      if (videoCodecFound && audioCodecFound) {\n        levels0.forEach(function (level) {\n          if (level.videoCodec) {\n            levels.push(level);\n          }\n        });\n      } else {\n        levels = levels0;\n      }\n      // only keep level with supported audio/video codecs\n      levels = levels.filter(function (level) {\n        var audioCodec = level.audioCodec,\n            videoCodec = level.videoCodec;\n        return (!audioCodec || checkSupported('audio', audioCodec)) && (!videoCodec || checkSupported('video', videoCodec));\n      });\n\n      if (levels.length) {\n        // start bitrate is the first bitrate of the manifest\n        bitrateStart = levels[0].bitrate;\n        // sort level on bitrate\n        levels.sort(function (a, b) {\n          return a.bitrate - b.bitrate;\n        });\n        this._levels = levels;\n        // find index of first level in sorted levels\n        for (var i = 0; i < levels.length; i++) {\n          if (levels[i].bitrate === bitrateStart) {\n            this._firstLevel = i;\n            _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);\n            break;\n          }\n        }\n        hls.trigger(_events2.default.MANIFEST_PARSED, { levels: levels, firstLevel: this._firstLevel, stats: data.stats, audio: audioCodecFound, video: videoCodecFound, altAudio: data.audioTracks.length > 0 });\n      } else {\n        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: true, url: hls.url, reason: 'no level with compatible codecs found in manifest' });\n      }\n      return;\n    }\n  }, {\n    key: 'setLevelInternal',\n    value: function setLevelInternal(newLevel) {\n      var levels = this._levels;\n      var hls = this.hls;\n      // check if level idx is valid\n      if (newLevel >= 0 && newLevel < levels.length) {\n        // stopping live reloading timer if any\n        if (this.timer) {\n          clearTimeout(this.timer);\n          this.timer = null;\n        }\n        if (this._level !== newLevel) {\n          _logger.logger.log('switching to level ' + newLevel);\n          this._level = newLevel;\n          var levelProperties = levels[newLevel];\n          levelProperties.level = newLevel;\n          // LEVEL_SWITCH to be deprecated in next major release\n          hls.trigger(_events2.default.LEVEL_SWITCH, levelProperties);\n          hls.trigger(_events2.default.LEVEL_SWITCHING, levelProperties);\n        }\n        var level = levels[newLevel],\n            levelDetails = level.details;\n        // check if we need to load playlist for this level\n        if (!levelDetails || levelDetails.live === true) {\n          // level not retrieved yet, or live playlist we need to (re)load it\n          var urlId = level.urlId;\n          hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });\n        }\n      } else {\n        // invalid level id given, trigger error\n        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR, level: newLevel, fatal: false, reason: 'invalid level idx' });\n      }\n    }\n  }, {\n    key: 'onError',\n    value: function onError(data) {\n      if (data.fatal) {\n        return;\n      }\n\n      var details = data.details,\n          hls = this.hls,\n          levelId = void 0,\n          level = void 0,\n          levelError = false;\n      // try to recover not fatal errors\n      switch (details) {\n        case _errors.ErrorDetails.FRAG_LOAD_ERROR:\n        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:\n        case _errors.ErrorDetails.KEY_LOAD_ERROR:\n        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:\n          levelId = data.frag.level;\n          break;\n        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:\n        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n          levelId = data.context.level;\n          levelError = true;\n          break;\n        case _errors.ErrorDetails.REMUX_ALLOC_ERROR:\n          levelId = data.level;\n          break;\n        default:\n          break;\n      }\n      /* try to switch to a redundant stream if any available.\n       * if no redundant stream available, emergency switch down (if in auto mode and current level not 0)\n       * otherwise, we cannot recover this network error ...\n       */\n      if (levelId !== undefined) {\n        level = this._levels[levelId];\n        if (!level.loadError) {\n          level.loadError = 1;\n        } else {\n          level.loadError++;\n        }\n        // if any redundant streams available and if we haven't try them all (level.loadError is reseted on successful frag/level load.\n        // if level.loadError reaches nbRedundantLevel it means that we tried them all, no hope  => let's switch down\n        var nbRedundantLevel = level.url.length;\n        if (nbRedundantLevel > 1 && level.loadError < nbRedundantLevel) {\n          level.urlId = (level.urlId + 1) % nbRedundantLevel;\n          level.details = undefined;\n          _logger.logger.warn('level controller,' + details + ' for level ' + levelId + ': switching to redundant stream id ' + level.urlId);\n        } else {\n          // we could try to recover if in auto mode and current level not lowest level (0)\n          var recoverable = this._manualLevel === -1 && levelId;\n          if (recoverable) {\n            _logger.logger.warn('level controller,' + details + ': switch-down for next fragment');\n            hls.nextAutoLevel = Math.max(0, levelId - 1);\n          } else if (level && level.details && level.details.live) {\n            _logger.logger.warn('level controller,' + details + ' on live stream, discard');\n            if (levelError) {\n              // reset this._level so that another call to set level() will retrigger a frag load\n              this._level = undefined;\n            }\n            // other errors are handled by stream controller\n          } else if (details === _errors.ErrorDetails.LEVEL_LOAD_ERROR || details === _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT) {\n            var media = hls.media,\n\n            // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n            mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);\n            if (mediaBuffered) {\n              var retryDelay = hls.config.levelLoadingRetryDelay;\n              _logger.logger.warn('level controller,' + details + ', but media buffered, retry in ' + retryDelay + 'ms');\n              this.timer = setTimeout(this.ontick, retryDelay);\n            } else {\n              _logger.logger.error('cannot recover ' + details + ' error');\n              this._level = undefined;\n              // stopping live reloading timer if any\n              if (this.timer) {\n                clearTimeout(this.timer);\n                this.timer = null;\n              }\n              // redispatch same error but with fatal set to true\n              data.fatal = true;\n              hls.trigger(_events2.default.ERROR, data);\n            }\n          }\n        }\n      }\n    }\n\n    // reset level load error counter on successful frag loaded\n\n  }, {\n    key: 'onFragLoaded',\n    value: function onFragLoaded(data) {\n      var fragLoaded = data.frag;\n      if (fragLoaded && fragLoaded.type === 'main') {\n        var level = this._levels[fragLoaded.level];\n        if (level) {\n          level.loadError = 0;\n        }\n      }\n    }\n  }, {\n    key: 'onLevelLoaded',\n    value: function onLevelLoaded(data) {\n      var levelId = data.level;\n      // only process level loaded events matching with expected level\n      if (levelId === this._level) {\n        var curLevel = this._levels[levelId];\n        // reset level load error counter on successful level loaded\n        curLevel.loadError = 0;\n        var newDetails = data.details;\n        // if current playlist is a live playlist, arm a timer to reload it\n        if (newDetails.live) {\n          var reloadInterval = 1000 * (newDetails.averagetargetduration ? newDetails.averagetargetduration : newDetails.targetduration),\n              curDetails = curLevel.details;\n          if (curDetails && newDetails.endSN === curDetails.endSN) {\n            // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n            // changed then it MUST wait for a period of one-half the target\n            // duration before retrying.\n            reloadInterval /= 2;\n            _logger.logger.log('same live playlist, reload twice faster');\n          }\n          // decrement reloadInterval with level loading delay\n          reloadInterval -= performance.now() - data.stats.trequest;\n          // in any case, don't reload more than every second\n          reloadInterval = Math.max(1000, Math.round(reloadInterval));\n          _logger.logger.log('live playlist, reload in ' + reloadInterval + ' ms');\n          this.timer = setTimeout(this.ontick, reloadInterval);\n        } else {\n          this.timer = null;\n        }\n      }\n    }\n  }, {\n    key: 'tick',\n    value: function tick() {\n      var levelId = this._level;\n      if (levelId !== undefined && this.canload) {\n        var level = this._levels[levelId],\n            urlId = level.urlId;\n        this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: levelId, id: urlId });\n      }\n    }\n  }, {\n    key: 'levels',\n    get: function get() {\n      return this._levels;\n    }\n  }, {\n    key: 'level',\n    get: function get() {\n      return this._level;\n    },\n    set: function set(newLevel) {\n      var levels = this._levels;\n      if (levels && levels.length > newLevel) {\n        if (this._level !== newLevel || levels[newLevel].details === undefined) {\n          this.setLevelInternal(newLevel);\n        }\n      }\n    }\n  }, {\n    key: 'manualLevel',\n    get: function get() {\n      return this._manualLevel;\n    },\n    set: function set(newLevel) {\n      this._manualLevel = newLevel;\n      if (this._startLevel === undefined) {\n        this._startLevel = newLevel;\n      }\n      if (newLevel !== -1) {\n        this.level = newLevel;\n      }\n    }\n  }, {\n    key: 'firstLevel',\n    get: function get() {\n      return this._firstLevel;\n    },\n    set: function set(newLevel) {\n      this._firstLevel = newLevel;\n    }\n  }, {\n    key: 'startLevel',\n    get: function get() {\n      // hls.startLevel takes precedence over config.startLevel\n      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)\n      if (this._startLevel === undefined) {\n        var configStartLevel = this.hls.config.startLevel;\n        if (configStartLevel !== undefined) {\n          return configStartLevel;\n        } else {\n          return this._firstLevel;\n        }\n      } else {\n        return this._startLevel;\n      }\n    },\n    set: function set(newLevel) {\n      this._startLevel = newLevel;\n    }\n  }, {\n    key: 'nextLoadLevel',\n    get: function get() {\n      if (this._manualLevel !== -1) {\n        return this._manualLevel;\n      } else {\n        return this.hls.nextAutoLevel;\n      }\n    },\n    set: function set(nextLevel) {\n      this.level = nextLevel;\n      if (this._manualLevel === -1) {\n        this.hls.nextAutoLevel = nextLevel;\n      }\n    }\n  }]);\n\n  return LevelController;\n}(_eventHandler2.default);\n\nexports.default = LevelController;\n\n},{\"31\":31,\"32\":32,\"33\":33,\"35\":35,\"50\":50}],13:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _binarySearch = _dereq_(46);\n\nvar _binarySearch2 = _interopRequireDefault(_binarySearch);\n\nvar _bufferHelper = _dereq_(35);\n\nvar _bufferHelper2 = _interopRequireDefault(_bufferHelper);\n\nvar _demuxer = _dereq_(25);\n\nvar _demuxer2 = _interopRequireDefault(_demuxer);\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _levelHelper = _dereq_(36);\n\nvar _levelHelper2 = _interopRequireDefault(_levelHelper);\n\nvar _timeRanges = _dereq_(51);\n\nvar _timeRanges2 = _interopRequireDefault(_timeRanges);\n\nvar _errors = _dereq_(31);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar State = {\n  STOPPED: 'STOPPED',\n  IDLE: 'IDLE',\n  KEY_LOADING: 'KEY_LOADING',\n  FRAG_LOADING: 'FRAG_LOADING',\n  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n  WAITING_LEVEL: 'WAITING_LEVEL',\n  PARSING: 'PARSING',\n  PARSED: 'PARSED',\n  BUFFER_FLUSHING: 'BUFFER_FLUSHING',\n  ENDED: 'ENDED',\n  ERROR: 'ERROR'\n};\n\nvar StreamController = function (_EventHandler) {\n  _inherits(StreamController, _EventHandler);\n\n  function StreamController(hls) {\n    _classCallCheck(this, StreamController);\n\n    var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));\n\n    _this.config = hls.config;\n    _this.audioCodecSwap = false;\n    _this.ticks = 0;\n    _this._state = State.STOPPED;\n    _this.ontick = _this.tick.bind(_this);\n    return _this;\n  }\n\n  _createClass(StreamController, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.stopLoad();\n      if (this.timer) {\n        clearInterval(this.timer);\n        this.timer = null;\n      }\n      _eventHandler2.default.prototype.destroy.call(this);\n      this.state = State.STOPPED;\n    }\n  }, {\n    key: 'startLoad',\n    value: function startLoad(startPosition) {\n      if (this.levels) {\n        var lastCurrentTime = this.lastCurrentTime,\n            hls = this.hls;\n        this.stopLoad();\n        if (!this.timer) {\n          this.timer = setInterval(this.ontick, 100);\n        }\n        this.level = -1;\n        this.fragLoadError = 0;\n        if (!this.startFragRequested) {\n          // determine load level\n          var startLevel = hls.startLevel;\n          if (startLevel === -1) {\n            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n            startLevel = 0;\n            this.bitrateTest = true;\n          }\n          // set new level to playlist loader : this will trigger start level load\n          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n          this.level = hls.nextLoadLevel = startLevel;\n          this.loadedmetadata = false;\n        }\n        // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n        if (lastCurrentTime > 0 && startPosition === -1) {\n          _logger.logger.log('override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));\n          startPosition = lastCurrentTime;\n        }\n        this.state = State.IDLE;\n        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n        this.tick();\n      } else {\n        _logger.logger.warn('cannot start loading as manifest not parsed yet');\n        this.state = State.STOPPED;\n      }\n    }\n  }, {\n    key: 'stopLoad',\n    value: function stopLoad() {\n      var frag = this.fragCurrent;\n      if (frag) {\n        if (frag.loader) {\n          frag.loader.abort();\n        }\n        this.fragCurrent = null;\n      }\n      this.fragPrevious = null;\n      if (this.demuxer) {\n        this.demuxer.destroy();\n        this.demuxer = null;\n      }\n      this.state = State.STOPPED;\n    }\n  }, {\n    key: 'tick',\n    value: function tick() {\n      this.ticks++;\n      if (this.ticks === 1) {\n        this.doTick();\n        if (this.ticks > 1) {\n          setTimeout(this.tick, 1);\n        }\n        this.ticks = 0;\n      }\n    }\n  }, {\n    key: 'doTick',\n    value: function doTick() {\n      switch (this.state) {\n        case State.ERROR:\n          //don't do anything in error state to avoid breaking further ...\n          break;\n        case State.BUFFER_FLUSHING:\n          // in buffer flushing state, reset fragLoadError counter\n          this.fragLoadError = 0;\n          break;\n        case State.IDLE:\n          // when this returns false there was an error and we shall return immediatly\n          // from current tick\n          if (!this._doTickIdle()) {\n            return;\n          }\n          break;\n        case State.WAITING_LEVEL:\n          var level = this.levels[this.level];\n          // check if playlist is already loaded\n          if (level && level.details) {\n            this.state = State.IDLE;\n          }\n          break;\n        case State.FRAG_LOADING_WAITING_RETRY:\n          var now = performance.now();\n          var retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || this.media && this.media.seeking) {\n            _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');\n            this.state = State.IDLE;\n          }\n          break;\n        case State.ERROR:\n        case State.STOPPED:\n        case State.FRAG_LOADING:\n        case State.PARSING:\n        case State.PARSED:\n        case State.ENDED:\n          break;\n        default:\n          break;\n      }\n      // check buffer\n      this._checkBuffer();\n      // check/update current fragment\n      this._checkFragmentChanged();\n    }\n\n    // Ironically the \"idle\" state is the on we do the most logic in it seems ....\n    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently\n    //       played segment, or on pause/play/seek instead of naively checking every 100ms?\n\n  }, {\n    key: '_doTickIdle',\n    value: function _doTickIdle() {\n      var hls = this.hls,\n          config = hls.config,\n          media = this.media;\n\n      // if video not attached AND\n      // start fragment already requested OR start frag prefetch disable\n      // exit loop\n      // => if start level loaded and media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n      if (this.levelLastLoaded !== undefined && !media && (this.startFragRequested || !config.startFragPrefetch)) {\n        return true;\n      }\n\n      // if we have not yet loaded any fragment, start loading from start position\n      var pos = void 0;\n      if (this.loadedmetadata) {\n        pos = media.currentTime;\n      } else {\n        pos = this.nextLoadPosition;\n      }\n      // determine next load level\n      var level = hls.nextLoadLevel,\n          levelInfo = this.levels[level],\n          levelBitrate = levelInfo.bitrate,\n          maxBufLen = void 0;\n\n      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n      if (levelBitrate) {\n        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n      } else {\n        maxBufLen = config.maxBufferLength;\n      }\n      maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);\n\n      // determine next candidate fragment to be loaded, based on current position and end of buffer position\n      // ensure up to `config.maxMaxBufferLength` of buffer upfront\n\n      var bufferInfo = _bufferHelper2.default.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),\n          bufferLen = bufferInfo.len;\n      // Stay idle if we are still with buffer margins\n      if (bufferLen >= maxBufLen) {\n        return true;\n      }\n\n      // if buffer length is less than maxBufLen try to load a new fragment ...\n      _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');\n\n      // set next load level : this will trigger a playlist load if needed\n      this.level = hls.nextLoadLevel = level;\n\n      var levelDetails = levelInfo.details;\n      // if level info not retrieved yet, switch state and wait for level retrieval\n      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n      if (typeof levelDetails === 'undefined' || levelDetails.live && this.levelLastLoaded !== level) {\n        this.state = State.WAITING_LEVEL;\n        return true;\n      }\n\n      // we just got done loading the final fragment, check if we need to finalize media stream\n      var fragPrevious = this.fragPrevious;\n      if (!levelDetails.live && fragPrevious && fragPrevious.sn === levelDetails.endSN) {\n        // if everything (almost) til the end is buffered, let's signal eos\n        // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference\n        // using half frag duration should help cope with these cases.\n        // also cope with almost zero last frag duration (max last frag duration with 200ms) refer to https://github.com/dailymotion/hls.js/pull/657\n        if (media.duration - Math.max(bufferInfo.end, fragPrevious.start) <= Math.max(0.2, fragPrevious.duration / 2)) {\n          // Finalize the media stream\n          var data = {};\n          if (this.altAudio) {\n            data.type = 'video';\n          }\n          this.hls.trigger(_events2.default.BUFFER_EOS, data);\n          this.state = State.ENDED;\n          return true;\n        }\n      }\n\n      // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)\n      return this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);\n    }\n  }, {\n    key: '_fetchPayloadOrEos',\n    value: function _fetchPayloadOrEos(pos, bufferInfo, levelDetails) {\n      var fragPrevious = this.fragPrevious,\n          level = this.level,\n          fragments = levelDetails.fragments,\n          fragLen = fragments.length;\n\n      // empty playlist\n      if (fragLen === 0) {\n        return false;\n      }\n\n      // find fragment index, contiguous with end of buffer position\n      var start = fragments[0].start,\n          end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,\n          bufferEnd = bufferInfo.end,\n          frag = void 0;\n\n      if (levelDetails.initSegment && !levelDetails.initSegment.data) {\n        frag = levelDetails.initSegment;\n      } else {\n        // in case of live playlist we need to ensure that requested position is not located before playlist start\n        if (levelDetails.live) {\n          var initialLiveManifestSize = this.config.initialLiveManifestSize;\n          if (fragLen < initialLiveManifestSize) {\n            _logger.logger.warn('Can not start playback of a level, reason: not enough fragments ' + fragLen + ' < ' + initialLiveManifestSize);\n            return false;\n          }\n\n          frag = this._ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen);\n          // if it explicitely returns null don't load any fragment and exit function now\n          if (frag === null) {\n            return false;\n          }\n        } else {\n          // VoD playlist: if bufferEnd before start of playlist, load first fragment\n          if (bufferEnd < start) {\n            frag = fragments[0];\n          }\n        }\n      }\n      if (!frag) {\n        frag = this._findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails);\n      }\n      if (frag) {\n        return this._loadFragmentOrKey(frag, level, levelDetails, pos, bufferEnd);\n      }\n      return true;\n    }\n  }, {\n    key: '_ensureFragmentAtLivePoint',\n    value: function _ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen) {\n      var config = this.hls.config,\n          media = this.media;\n\n      var frag = void 0;\n\n      // check if requested position is within seekable boundaries :\n      //logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);\n      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n\n      if (bufferEnd < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {\n        var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);\n        _logger.logger.log('buffer end: ' + bufferEnd.toFixed(3) + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));\n        bufferEnd = liveSyncPosition;\n        if (media && media.readyState && media.duration > liveSyncPosition) {\n          media.currentTime = liveSyncPosition;\n        }\n      }\n\n      // if end of buffer greater than live edge, don't load any fragment\n      // this could happen if live playlist intermittently slides in the past.\n      // level 1 loaded [182580161,182580167]\n      // level 1 loaded [182580162,182580169]\n      // Loading 182580168 of [182580162 ,182580169],level 1 ..\n      // Loading 182580169 of [182580162 ,182580169],level 1 ..\n      // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168\n      // level 1 loaded [182580164,182580171]\n      //\n      // don't return null in case media not loaded yet (readystate === 0)\n      if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {\n        return null;\n      }\n\n      if (this.startFragRequested && !levelDetails.PTSKnown) {\n        /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...\n           try to load frag matching with next SN.\n           even if SN are not synchronized between playlists, loading this frag will help us\n           compute playlist sliding and find the right one after in case it was not the right consecutive one */\n        if (fragPrevious) {\n          var targetSN = fragPrevious.sn + 1;\n          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n            frag = fragments[targetSN - levelDetails.startSN];\n            _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);\n          }\n        }\n        if (!frag) {\n          /* we have no idea about which fragment should be loaded.\n             so let's load mid fragment. it will help computing playlist sliding and find the right one\n          */\n          frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];\n          _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);\n        }\n      }\n      return frag;\n    }\n  }, {\n    key: '_findFragment',\n    value: function _findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails) {\n      var config = this.hls.config;\n      var frag = void 0;\n      var foundFrag = void 0;\n      var maxFragLookUpTolerance = config.maxFragLookUpTolerance;\n      var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;\n      var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {\n        // offset should be within fragment boundary - config.maxFragLookUpTolerance\n        // this is to cope with situations like\n        // bufferEnd = 9.991\n        // frag[Ø] : [0,10]\n        // frag[1] : [10,20]\n        // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n        //              frag start               frag start+duration\n        //                  |-----------------------------|\n        //              <--->                         <--->\n        //  ...--------><-----------------------------><---------....\n        // previous frag         matching fragment         next frag\n        //  return -1             return 0                 return 1\n        //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n        // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n        var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);\n        if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n          return 1;\n        } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n        else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n            return -1;\n          }\n        return 0;\n      };\n\n      if (bufferEnd < end) {\n        if (bufferEnd > end - maxFragLookUpTolerance) {\n          maxFragLookUpTolerance = 0;\n        }\n        // Prefer the next fragment if it's within tolerance\n        if (fragNext && !fragmentWithinToleranceTest(fragNext)) {\n          foundFrag = fragNext;\n        } else {\n          foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);\n        }\n      } else {\n        // reach end of playlist\n        foundFrag = fragments[fragLen - 1];\n      }\n      if (foundFrag) {\n        frag = foundFrag;\n        var curSNIdx = frag.sn - levelDetails.startSN;\n        var sameLevel = fragPrevious && frag.level === fragPrevious.level;\n        var prevFrag = fragments[curSNIdx - 1];\n        var nextFrag = fragments[curSNIdx + 1];\n        //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);\n        if (sameLevel && frag.sn === fragPrevious.sn) {\n          if (frag.sn < levelDetails.endSN) {\n            var deltaPTS = fragPrevious.deltaPTS;\n            // if there is a significant delta between audio and video, larger than max allowed hole,\n            // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)\n            // let's try to load previous fragment again to get last keyframe\n            // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)\n            if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {\n              frag = prevFrag;\n              _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');\n              // decrement previous frag load counter to avoid frag loop loading error when next fragment will get reloaded\n              fragPrevious.loadCounter--;\n            } else {\n              frag = nextFrag;\n              _logger.logger.log('SN just loaded, load next one: ' + frag.sn);\n            }\n          } else {\n            frag = null;\n          }\n        } else if (frag.dropped && !sameLevel) {\n          // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes\n          if (nextFrag && nextFrag.backtracked) {\n            _logger.logger.warn('Already backtracked from fragment ' + (curSNIdx + 1) + ', will not backtrack to fragment ' + curSNIdx + '. Loading fragment ' + (curSNIdx + 1));\n            frag = nextFrag;\n          } else {\n            // If a fragment has dropped frames and it's in a different level/sequence, load the previous fragment to try and find the keyframe\n            // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment\n            _logger.logger.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');\n            frag.dropped = 0;\n            if (prevFrag && prevFrag.loadCounter) {\n              prevFrag.loadCounter--;\n              frag = prevFrag;\n            } else {\n              frag = null;\n            }\n          }\n        }\n      }\n      return frag;\n    }\n  }, {\n    key: '_loadFragmentOrKey',\n    value: function _loadFragmentOrKey(frag, level, levelDetails, pos, bufferEnd) {\n      var hls = this.hls,\n          config = hls.config;\n\n      //logger.log('loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));\n      if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {\n        _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);\n        this.state = State.KEY_LOADING;\n        hls.trigger(_events2.default.KEY_LOADING, { frag: frag });\n      } else {\n        _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos.toFixed(3) + ',bufferEnd:' + bufferEnd.toFixed(3));\n        // ensure that we are not reloading the same fragments in loop ...\n        if (this.fragLoadIdx !== undefined) {\n          this.fragLoadIdx++;\n        } else {\n          this.fragLoadIdx = 0;\n        }\n        if (frag.loadCounter) {\n          frag.loadCounter++;\n          var maxThreshold = config.fragLoadingLoopThreshold;\n          // if this frag has already been loaded 3 times, and if it has been reloaded recently\n          if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {\n            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });\n            return false;\n          }\n        } else {\n          frag.loadCounter = 1;\n        }\n        frag.loadIdx = this.fragLoadIdx;\n        this.fragCurrent = frag;\n        this.startFragRequested = true;\n        if (!isNaN(frag.sn)) {\n          this.nextLoadPosition = frag.start + frag.duration;\n        }\n        frag.autoLevel = hls.autoLevelEnabled;\n        frag.bitrateTest = this.bitrateTest;\n        hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });\n        // lazy demuxer init, as this could take some time ... do it during frag loading\n        if (!this.demuxer) {\n          this.demuxer = new _demuxer2.default(hls, 'main');\n        }\n        this.state = State.FRAG_LOADING;\n        return true;\n      }\n    }\n  }, {\n    key: 'getBufferRange',\n    value: function getBufferRange(position) {\n      return _binarySearch2.default.search(this.bufferRange, function (range) {\n        if (position < range.start) {\n          return -1;\n        } else if (position > range.end) {\n          return 1;\n        }\n        return 0;\n      });\n    }\n  }, {\n    key: 'followingBufferRange',\n    value: function followingBufferRange(range) {\n      if (range) {\n        // try to get range of next fragment (500ms after this range)\n        return this.getBufferRange(range.end + 0.5);\n      }\n      return null;\n    }\n  }, {\n    key: '_checkFragmentChanged',\n    value: function _checkFragmentChanged() {\n      var rangeCurrent,\n          currentTime,\n          video = this.media;\n      if (video && video.readyState && video.seeking === false) {\n        currentTime = video.currentTime;\n        /* if video element is in seeked state, currentTime can only increase.\n          (assuming that playback rate is positive ...)\n          As sometimes currentTime jumps back to zero after a\n          media decode error, check this, to avoid seeking back to\n          wrong position after a media decode error\n        */\n        if (currentTime > video.playbackRate * this.lastCurrentTime) {\n          this.lastCurrentTime = currentTime;\n        }\n        if (_bufferHelper2.default.isBuffered(video, currentTime)) {\n          rangeCurrent = this.getBufferRange(currentTime);\n        } else if (_bufferHelper2.default.isBuffered(video, currentTime + 0.1)) {\n          /* ensure that FRAG_CHANGED event is triggered at startup,\n            when first video frame is displayed and playback is paused.\n            add a tolerance of 100ms, in case current position is not buffered,\n            check if current pos+100ms is buffered and use that buffer range\n            for FRAG_CHANGED event reporting */\n          rangeCurrent = this.getBufferRange(currentTime + 0.1);\n        }\n        if (rangeCurrent) {\n          var fragPlaying = rangeCurrent.frag;\n          if (fragPlaying !== this.fragPlaying) {\n            this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });\n            var fragPlayingLevel = fragPlaying.level;\n            if (!this.fragPlaying || this.fragPlaying.level !== fragPlayingLevel) {\n              this.hls.trigger(_events2.default.LEVEL_SWITCHED, { level: fragPlayingLevel });\n            }\n            this.fragPlaying = fragPlaying;\n          }\n        }\n      }\n    }\n\n    /*\n      on immediate level switch :\n       - pause playback if playing\n       - cancel any pending load request\n       - and trigger a buffer flush\n    */\n\n  }, {\n    key: 'immediateLevelSwitch',\n    value: function immediateLevelSwitch() {\n      _logger.logger.log('immediateLevelSwitch');\n      if (!this.immediateSwitch) {\n        this.immediateSwitch = true;\n        var media = this.media,\n            previouslyPaused = void 0;\n        if (media) {\n          previouslyPaused = media.paused;\n          media.pause();\n        } else {\n          // don't restart playback after instant level switch in case media not attached\n          previouslyPaused = true;\n        }\n        this.previouslyPaused = previouslyPaused;\n      }\n      var fragCurrent = this.fragCurrent;\n      if (fragCurrent && fragCurrent.loader) {\n        fragCurrent.loader.abort();\n      }\n      this.fragCurrent = null;\n      // increase fragment load Index to avoid frag loop loading error after buffer flush\n      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;\n      // flush everything\n      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n    }\n\n    /*\n       on immediate level switch end, after new fragment has been buffered :\n        - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)\n        - resume the playback if needed\n    */\n\n  }, {\n    key: 'immediateLevelSwitchEnd',\n    value: function immediateLevelSwitchEnd() {\n      var media = this.media;\n      if (media && media.buffered.length) {\n        this.immediateSwitch = false;\n        if (_bufferHelper2.default.isBuffered(media, media.currentTime)) {\n          // only nudge if currentTime is buffered\n          media.currentTime -= 0.0001;\n        }\n        if (!this.previouslyPaused) {\n          media.play();\n        }\n      }\n    }\n  }, {\n    key: 'nextLevelSwitch',\n    value: function nextLevelSwitch() {\n      /* try to switch ASAP without breaking video playback :\n         in order to ensure smooth but quick level switching,\n        we need to find the next flushable buffer range\n        we should take into account new segment fetch time\n      */\n      var media = this.media;\n      // ensure that media is defined and that metadata are available (to retrieve currentTime)\n      if (media && media.readyState) {\n        var fetchdelay = void 0,\n            currentRange = void 0,\n            nextRange = void 0;\n        // increase fragment load Index to avoid frag loop loading error after buffer flush\n        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;\n        currentRange = this.getBufferRange(media.currentTime);\n        if (currentRange && currentRange.start > 1) {\n          // flush buffer preceding current fragment (flush until current fragment start offset)\n          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n          this.flushMainBuffer(0, currentRange.start - 1);\n        }\n        if (!media.paused) {\n          // add a safety delay of 1s\n          var nextLevelId = this.hls.nextLoadLevel,\n              nextLevel = this.levels[nextLevelId],\n              fragLastKbps = this.fragLastKbps;\n          if (fragLastKbps && this.fragCurrent) {\n            fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;\n          } else {\n            fetchdelay = 0;\n          }\n        } else {\n          fetchdelay = 0;\n        }\n        //logger.log('fetchdelay:'+fetchdelay);\n        // find buffer range that will be reached once new fragment will be fetched\n        nextRange = this.getBufferRange(media.currentTime + fetchdelay);\n        if (nextRange) {\n          // we can flush buffer range following this one without stalling playback\n          nextRange = this.followingBufferRange(nextRange);\n          if (nextRange) {\n            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n            var fragCurrent = this.fragCurrent;\n            if (fragCurrent && fragCurrent.loader) {\n              fragCurrent.loader.abort();\n            }\n            this.fragCurrent = null;\n            // flush position is the start position of this new buffer\n            this.flushMainBuffer(nextRange.start, Number.POSITIVE_INFINITY);\n          }\n        }\n      }\n    }\n  }, {\n    key: 'flushMainBuffer',\n    value: function flushMainBuffer(startOffset, endOffset) {\n      this.state = State.BUFFER_FLUSHING;\n      var flushScope = { startOffset: startOffset, endOffset: endOffset };\n      // if alternate audio tracks are used, only flush video, otherwise flush everything\n      if (this.altAudio) {\n        flushScope.type = 'video';\n      }\n      this.hls.trigger(_events2.default.BUFFER_FLUSHING, flushScope);\n    }\n  }, {\n    key: 'onMediaAttached',\n    value: function onMediaAttached(data) {\n      var media = this.media = this.mediaBuffer = data.media;\n      this.onvseeking = this.onMediaSeeking.bind(this);\n      this.onvseeked = this.onMediaSeeked.bind(this);\n      this.onvended = this.onMediaEnded.bind(this);\n      media.addEventListener('seeking', this.onvseeking);\n      media.addEventListener('seeked', this.onvseeked);\n      media.addEventListener('ended', this.onvended);\n      var config = this.config;\n      if (this.levels && config.autoStartLoad) {\n        this.hls.startLoad(config.startPosition);\n      }\n    }\n  }, {\n    key: 'onMediaDetaching',\n    value: function onMediaDetaching() {\n      var media = this.media;\n      if (media && media.ended) {\n        _logger.logger.log('MSE detaching and video ended, reset startPosition');\n        this.startPosition = this.lastCurrentTime = 0;\n      }\n\n      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery\n      var levels = this.levels;\n      if (levels) {\n        // reset fragment load counter\n        levels.forEach(function (level) {\n          if (level.details) {\n            level.details.fragments.forEach(function (fragment) {\n              fragment.loadCounter = undefined;\n              fragment.backtracked = undefined;\n            });\n          }\n        });\n      }\n      // remove video listeners\n      if (media) {\n        media.removeEventListener('seeking', this.onvseeking);\n        media.removeEventListener('seeked', this.onvseeked);\n        media.removeEventListener('ended', this.onvended);\n        this.onvseeking = this.onvseeked = this.onvended = null;\n      }\n      this.media = this.mediaBuffer = null;\n      this.loadedmetadata = false;\n      this.stopLoad();\n    }\n  }, {\n    key: 'onMediaSeeking',\n    value: function onMediaSeeking() {\n      var media = this.media,\n          currentTime = media ? media.currentTime : undefined,\n          config = this.config;\n      _logger.logger.log('media seeking to ' + currentTime.toFixed(3));\n      if (this.state === State.FRAG_LOADING) {\n        var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;\n        var bufferInfo = _bufferHelper2.default.bufferInfo(mediaBuffer, currentTime, this.config.maxBufferHole),\n            fragCurrent = this.fragCurrent;\n        // check if we are seeking to a unbuffered area AND if frag loading is in progress\n        if (bufferInfo.len === 0 && fragCurrent) {\n          var tolerance = config.maxFragLookUpTolerance,\n              fragStartOffset = fragCurrent.start - tolerance,\n              fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n          // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything\n          if (currentTime < fragStartOffset || currentTime > fragEndOffset) {\n            if (fragCurrent.loader) {\n              _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');\n              fragCurrent.loader.abort();\n            }\n            this.fragCurrent = null;\n            this.fragPrevious = null;\n            // switch to IDLE state to load new fragment\n            this.state = State.IDLE;\n          } else {\n            _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');\n          }\n        }\n      } else if (this.state === State.ENDED) {\n        // switch to IDLE state to check for potential new fragment\n        this.state = State.IDLE;\n      }\n      if (media) {\n        this.lastCurrentTime = currentTime;\n      }\n      // avoid reporting fragment loop loading error in case user is seeking several times on same position\n      if (this.state !== State.FRAG_LOADING && this.fragLoadIdx !== undefined) {\n        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;\n      }\n      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n      if (!this.loadedmetadata) {\n        this.nextLoadPosition = this.startPosition = currentTime;\n      }\n      // tick to speed up processing\n      this.tick();\n    }\n  }, {\n    key: 'onMediaSeeked',\n    value: function onMediaSeeked() {\n      _logger.logger.log('media seeked to ' + this.media.currentTime.toFixed(3));\n      // tick to speed up FRAGMENT_PLAYING triggering\n      this.tick();\n    }\n  }, {\n    key: 'onMediaEnded',\n    value: function onMediaEnded() {\n      _logger.logger.log('media ended');\n      // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n      this.startPosition = this.lastCurrentTime = 0;\n    }\n  }, {\n    key: 'onManifestLoading',\n    value: function onManifestLoading() {\n      // reset buffer on manifest loading\n      _logger.logger.log('trigger BUFFER_RESET');\n      this.hls.trigger(_events2.default.BUFFER_RESET);\n      this.bufferRange = [];\n      this.stalled = false;\n      this.startPosition = this.lastCurrentTime = 0;\n    }\n  }, {\n    key: 'onManifestParsed',\n    value: function onManifestParsed(data) {\n      var aac = false,\n          heaac = false,\n          codec;\n      data.levels.forEach(function (level) {\n        // detect if we have different kind of audio codecs used amongst playlists\n        codec = level.audioCodec;\n        if (codec) {\n          if (codec.indexOf('mp4a.40.2') !== -1) {\n            aac = true;\n          }\n          if (codec.indexOf('mp4a.40.5') !== -1) {\n            heaac = true;\n          }\n        }\n      });\n      this.audioCodecSwitch = aac && heaac;\n      if (this.audioCodecSwitch) {\n        _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n      }\n      this.levels = data.levels;\n      this.startLevelLoaded = false;\n      this.startFragRequested = false;\n      var config = this.config;\n      if (config.autoStartLoad) {\n        this.hls.startLoad(config.startPosition);\n      }\n    }\n  }, {\n    key: 'onLevelLoaded',\n    value: function onLevelLoaded(data) {\n      var newDetails = data.details,\n          newLevelId = data.level,\n          curLevel = this.levels[newLevelId],\n          duration = newDetails.totalduration,\n          sliding = 0;\n\n      _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);\n      this.levelLastLoaded = newLevelId;\n\n      if (newDetails.live) {\n        var curDetails = curLevel.details;\n        if (curDetails && newDetails.fragments.length > 0) {\n          // we already have details for that level, merge them\n          _levelHelper2.default.mergeDetails(curDetails, newDetails);\n          sliding = newDetails.fragments[0].start;\n          this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);\n          if (newDetails.PTSKnown) {\n            _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));\n          } else {\n            _logger.logger.log('live playlist - outdated PTS, unknown sliding');\n          }\n        } else {\n          newDetails.PTSKnown = false;\n          _logger.logger.log('live playlist - first load, unknown sliding');\n        }\n      } else {\n        newDetails.PTSKnown = false;\n      }\n      // override level info\n      curLevel.details = newDetails;\n      this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });\n\n      if (this.startFragRequested === false) {\n        // compute start position if set to -1. use it straight away if value is defined\n        if (this.startPosition === -1 || this.lastCurrentTime === -1) {\n          // first, check if start time offset has been set in playlist, if yes, use this value\n          var startTimeOffset = newDetails.startTimeOffset;\n          if (!isNaN(startTimeOffset)) {\n            if (startTimeOffset < 0) {\n              _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');\n              startTimeOffset = sliding + duration + startTimeOffset;\n            }\n            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);\n            this.startPosition = startTimeOffset;\n          } else {\n            // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)\n            if (newDetails.live) {\n              this.startPosition = this.computeLivePosition(sliding, newDetails);\n              _logger.logger.log('configure startPosition to ' + this.startPosition);\n            } else {\n              this.startPosition = 0;\n            }\n          }\n          this.lastCurrentTime = this.startPosition;\n        }\n        this.nextLoadPosition = this.startPosition;\n      }\n      // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment\n      if (this.state === State.WAITING_LEVEL) {\n        this.state = State.IDLE;\n      }\n      //trigger handler right now\n      this.tick();\n    }\n  }, {\n    key: 'onKeyLoaded',\n    value: function onKeyLoaded() {\n      if (this.state === State.KEY_LOADING) {\n        this.state = State.IDLE;\n        this.tick();\n      }\n    }\n  }, {\n    key: 'onFragLoaded',\n    value: function onFragLoaded(data) {\n      var fragCurrent = this.fragCurrent,\n          fragLoaded = data.frag;\n      if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'main' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {\n        var stats = data.stats,\n            currentLevel = this.levels[fragCurrent.level],\n            details = currentLevel.details;\n        _logger.logger.log('Loaded  ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.level);\n        // reset frag bitrate test in any case after frag loaded event\n        this.bitrateTest = false;\n        this.stats = stats;\n        // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0\n        // then this means that we should be able to load a fragment at a higher quality level\n        if (fragLoaded.bitrateTest === true && this.hls.nextLoadLevel) {\n          // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo\n          this.state = State.IDLE;\n          this.startFragRequested = false;\n          stats.tparsed = stats.tbuffered = performance.now();\n          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });\n          this.tick();\n        } else if (fragLoaded.sn === 'initSegment') {\n          this.state = State.IDLE;\n          stats.tparsed = stats.tbuffered = performance.now();\n          details.initSegment.data = data.payload;\n          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });\n          this.tick();\n        } else {\n          this.state = State.PARSING;\n          // transmux the MPEG-TS data to ISO-BMFF segments\n          var duration = details.totalduration,\n              level = fragCurrent.level,\n              sn = fragCurrent.sn,\n              audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n          if (this.audioCodecSwap) {\n            _logger.logger.log('swapping playlist audio codec');\n            if (audioCodec === undefined) {\n              audioCodec = this.lastAudioCodec;\n            }\n            if (audioCodec) {\n              if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n                audioCodec = 'mp4a.40.2';\n              } else {\n                audioCodec = 'mp4a.40.5';\n              }\n            }\n          }\n          this.pendingBuffering = true;\n          this.appended = false;\n          _logger.logger.log('Parsing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + level + ', cc ' + fragCurrent.cc);\n          var demuxer = this.demuxer;\n          if (!demuxer) {\n            demuxer = this.demuxer = new _demuxer2.default(this.hls, 'main');\n          }\n          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)\n          var media = this.media;\n          var mediaSeeking = media && media.seeking;\n          var accurateTimeOffset = !mediaSeeking && (details.PTSKnown || !details.live);\n          var initSegmentData = details.initSegment ? details.initSegment.data : [];\n          demuxer.push(data.payload, initSegmentData, audioCodec, currentLevel.videoCodec, fragCurrent, duration, accurateTimeOffset, undefined);\n        }\n      }\n      this.fragLoadError = 0;\n    }\n  }, {\n    key: 'onFragParsingInitSegment',\n    value: function onFragParsingInitSegment(data) {\n      var fragCurrent = this.fragCurrent;\n      var fragNew = data.frag;\n      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {\n        var tracks = data.tracks,\n            trackName,\n            track;\n\n        // if audio track is expected to come from audio stream controller, discard any coming from main\n        if (tracks.audio && this.altAudio) {\n          delete tracks.audio;\n        }\n        // include levelCodec in audio and video tracks\n        track = tracks.audio;\n        if (track) {\n          var audioCodec = this.levels[this.level].audioCodec,\n              ua = navigator.userAgent.toLowerCase();\n          if (audioCodec && this.audioCodecSwap) {\n            _logger.logger.log('swapping playlist audio codec');\n            if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n              audioCodec = 'mp4a.40.2';\n            } else {\n              audioCodec = 'mp4a.40.5';\n            }\n          }\n          // in case AAC and HE-AAC audio codecs are signalled in manifest\n          // force HE-AAC , as it seems that most browsers prefers that way,\n          // except for mono streams OR on FF\n          // these conditions might need to be reviewed ...\n          if (this.audioCodecSwitch) {\n            // don't force HE-AAC if mono stream\n            if (track.metadata.channelCount !== 1 &&\n            // don't force HE-AAC if firefox\n            ua.indexOf('firefox') === -1) {\n              audioCodec = 'mp4a.40.5';\n            }\n          }\n          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n          if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') {\n            // Exclude mpeg audio\n            audioCodec = 'mp4a.40.2';\n            _logger.logger.log('Android: force audio codec to ' + audioCodec);\n          }\n          track.levelCodec = audioCodec;\n          track.id = data.id;\n        }\n        track = tracks.video;\n        if (track) {\n          track.levelCodec = this.levels[this.level].videoCodec;\n          track.id = data.id;\n        }\n\n        // if remuxer specify that a unique track needs to generated,\n        // let's merge all tracks together\n        if (data.unique) {\n          var mergedTrack = {\n            codec: '',\n            levelCodec: ''\n          };\n          for (trackName in data.tracks) {\n            track = tracks[trackName];\n            mergedTrack.container = track.container;\n            if (mergedTrack.codec) {\n              mergedTrack.codec += ',';\n              mergedTrack.levelCodec += ',';\n            }\n            if (track.codec) {\n              mergedTrack.codec += track.codec;\n            }\n            if (track.levelCodec) {\n              mergedTrack.levelCodec += track.levelCodec;\n            }\n          }\n          tracks = { audiovideo: mergedTrack };\n        }\n        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);\n        // loop through tracks that are going to be provided to bufferController\n        for (trackName in tracks) {\n          track = tracks[trackName];\n          _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');\n          var initSegment = track.initSegment;\n          if (initSegment) {\n            this.appended = true;\n            // arm pending Buffering flag before appending a segment\n            this.pendingBuffering = true;\n            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });\n          }\n        }\n        //trigger handler right now\n        this.tick();\n      }\n    }\n  }, {\n    key: 'onFragParsingData',\n    value: function onFragParsingData(data) {\n      var _this2 = this;\n\n      var fragCurrent = this.fragCurrent;\n      var fragNew = data.frag;\n      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller\n      this.state === State.PARSING) {\n        var level = this.levels[this.level],\n            frag = fragCurrent;\n        if (isNaN(data.endPTS)) {\n          data.endPTS = data.startPTS + fragCurrent.duration;\n          data.endDTS = data.startDTS + fragCurrent.duration;\n        }\n\n        _logger.logger.log('Parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));\n\n        // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)\n        if (data.type === 'video') {\n          frag.dropped = data.dropped;\n          if (frag.dropped) {\n            if (!frag.backtracked) {\n              // Return back to the IDLE state without appending to buffer\n              // Causes findFragments to backtrack a segment and find the keyframe\n              // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment\n              frag.backtracked = true;\n              this.nextLoadPosition = data.startPTS;\n              this.state = State.IDLE;\n              this.tick();\n              return;\n            } else {\n              _logger.logger.warn('Already backtracked on this fragment, appending with the gap');\n            }\n          } else {\n            // Only reset the backtracked flag if we've loaded the frag without any dropped frames\n            frag.backtracked = false;\n          }\n        }\n\n        var drift = _levelHelper2.default.updateFragPTSDTS(level.details, frag.sn, data.startPTS, data.endPTS, data.startDTS, data.endDTS),\n            hls = this.hls;\n        hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });\n\n        // has remuxer dropped video frames located before first keyframe ?\n        [data.data1, data.data2].forEach(function (buffer) {\n          // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)\n          // in that case it is useless to append following segments\n          if (buffer && buffer.length && _this2.state === State.PARSING) {\n            _this2.appended = true;\n            // arm pending Buffering flag before appending a segment\n            _this2.pendingBuffering = true;\n            hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });\n          }\n        });\n        //trigger handler right now\n        this.tick();\n      }\n    }\n  }, {\n    key: 'onFragParsed',\n    value: function onFragParsed(data) {\n      var fragCurrent = this.fragCurrent;\n      var fragNew = data.frag;\n      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {\n        this.stats.tparsed = performance.now();\n        this.state = State.PARSED;\n        this._checkAppendedParsed();\n      }\n    }\n  }, {\n    key: 'onAudioTrackSwitching',\n    value: function onAudioTrackSwitching(data) {\n      // if any URL found on new audio track, it is an alternate audio track\n      var altAudio = !!data.url,\n          trackId = data.id;\n      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n      // don't do anything if we switch to alt audio: audio stream controller is handling it.\n      // we will just have to change buffer scheduling on audioTrackSwitched\n      if (!altAudio) {\n        if (this.mediaBuffer !== this.media) {\n          _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');\n          this.mediaBuffer = this.media;\n          var fragCurrent = this.fragCurrent;\n          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n          if (fragCurrent.loader) {\n            _logger.logger.log('switching to main audio track, cancel main fragment load');\n            fragCurrent.loader.abort();\n          }\n          this.fragCurrent = null;\n          this.fragPrevious = null;\n          // destroy demuxer to force init segment generation (following audio switch)\n          if (this.demuxer) {\n            this.demuxer.destroy();\n            this.demuxer = null;\n          }\n          // switch to IDLE state to load new fragment\n          this.state = State.IDLE;\n        }\n        var hls = this.hls;\n        // switching to main audio, flush all audio and trigger track switched\n        hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });\n        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });\n        this.altAudio = false;\n      }\n    }\n  }, {\n    key: 'onAudioTrackSwitched',\n    value: function onAudioTrackSwitched(data) {\n      var trackId = data.id,\n          altAudio = !!this.hls.audioTracks[trackId].url;\n      if (altAudio) {\n        var videoBuffer = this.videoBuffer;\n        // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n        if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n          _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');\n          this.mediaBuffer = videoBuffer;\n        }\n      }\n      this.altAudio = altAudio;\n      this.tick();\n    }\n  }, {\n    key: 'onBufferCreated',\n    value: function onBufferCreated(data) {\n      var tracks = data.tracks,\n          mediaTrack = void 0,\n          name = void 0,\n          alternate = false;\n      for (var type in tracks) {\n        var track = tracks[type];\n        if (track.id === 'main') {\n          name = type;\n          mediaTrack = track;\n          // keep video source buffer reference\n          if (type === 'video') {\n            this.videoBuffer = tracks[type].buffer;\n          }\n        } else {\n          alternate = true;\n        }\n      }\n      if (alternate && mediaTrack) {\n        _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');\n        this.mediaBuffer = mediaTrack.buffer;\n      } else {\n        this.mediaBuffer = this.media;\n      }\n    }\n  }, {\n    key: 'onBufferAppended',\n    value: function onBufferAppended(data) {\n      if (data.parent === 'main') {\n        var state = this.state;\n        if (state === State.PARSING || state === State.PARSED) {\n          // check if all buffers have been appended\n          this.pendingBuffering = data.pending > 0;\n          this._checkAppendedParsed();\n        }\n      }\n    }\n  }, {\n    key: '_checkAppendedParsed',\n    value: function _checkAppendedParsed() {\n      var _this3 = this;\n\n      //trigger handler right now\n      if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {\n        var frag = this.fragCurrent;\n        if (frag) {\n          (function () {\n            var media = _this3.mediaBuffer ? _this3.mediaBuffer : _this3.media;\n            _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));\n            // filter potentially evicted bufferRange. this is to avoid memleak on live streams\n            var bufferRange = _this3.bufferRange.filter(function (range) {\n              return _bufferHelper2.default.isBuffered(media, (range.start + range.end) / 2);\n            });\n            // push new range\n            bufferRange.push({ type: frag.type, start: frag.startPTS, end: frag.endPTS, frag: frag });\n            // sort, as we use BinarySearch for lookup in getBufferRange ...\n            _this3.bufferRange = bufferRange.sort(function (a, b) {\n              return a.start - b.start;\n            });\n            _this3.fragPrevious = frag;\n            var stats = _this3.stats;\n            stats.tbuffered = performance.now();\n            // we should get rid of this.fragLastKbps\n            _this3.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));\n            _this3.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });\n            _this3.state = State.IDLE;\n          })();\n        }\n        this.tick();\n      }\n    }\n  }, {\n    key: 'onError',\n    value: function onError(data) {\n      var frag = data.frag || this.fragCurrent;\n      // don't handle frag error not related to main fragment\n      if (frag && frag.type !== 'main') {\n        return;\n      }\n      var media = this.media,\n\n      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n      mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);\n      switch (data.details) {\n        case _errors.ErrorDetails.FRAG_LOAD_ERROR:\n        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case _errors.ErrorDetails.KEY_LOAD_ERROR:\n        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:\n          if (!data.fatal) {\n            var loadError = this.fragLoadError;\n            if (loadError) {\n              loadError++;\n            } else {\n              loadError = 1;\n            }\n            var config = this.config;\n            // keep retrying / don't raise fatal network error if current position is buffered or if in automode with current level not 0\n            if (loadError <= config.fragLoadingMaxRetry || mediaBuffered || frag.autoLevel && frag.level) {\n              this.fragLoadError = loadError;\n              // reset load counter to avoid frag loop loading error\n              frag.loadCounter = 0;\n              // exponential backoff capped to config.fragLoadingMaxRetryTimeout\n              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);\n              _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');\n              this.retryDate = performance.now() + delay;\n              // retry loading state\n              // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n              // in that case, reset startFragRequested flag\n              if (!this.loadedmetadata) {\n                this.startFragRequested = false;\n                this.nextLoadPosition = this.startPosition;\n              }\n              this.state = State.FRAG_LOADING_WAITING_RETRY;\n            } else {\n              _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');\n              // redispatch same error but with fatal set to true\n              data.fatal = true;\n              this.hls.trigger(_events2.default.ERROR, data);\n              this.state = State.ERROR;\n            }\n          }\n          break;\n        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:\n          if (!data.fatal) {\n            // if buffer is not empty\n            if (mediaBuffered) {\n              // try to reduce max buffer length : rationale is that we could get\n              // frag loop loading error because of buffer eviction\n              this._reduceMaxBufferLength(frag.duration);\n              this.state = State.IDLE;\n            } else {\n              // buffer empty. report as fatal if in manual mode or if lowest level.\n              // level controller takes care of emergency switch down logic\n              if (!frag.autoLevel || frag.level === 0) {\n                // redispatch same error but with fatal set to true\n                data.fatal = true;\n                this.hls.trigger(_events2.default.ERROR, data);\n                this.state = State.ERROR;\n              }\n            }\n          }\n          break;\n        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:\n        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n          if (this.state !== State.ERROR) {\n            if (data.fatal) {\n              // if fatal error, stop processing\n              this.state = State.ERROR;\n              _logger.logger.warn('streamController: ' + data.details + ',switch to ' + this.state + ' state ...');\n            } else {\n              // in cas of non fatal error while waiting level load to be completed, switch back to IDLE\n              if (this.state === State.WAITING_LEVEL) {\n                this.state = State.IDLE;\n              }\n            }\n          }\n          break;\n        case _errors.ErrorDetails.BUFFER_FULL_ERROR:\n          // if in appending state\n          if (data.parent === 'main' && (this.state === State.PARSING || this.state === State.PARSED)) {\n            // reduce max buf len if current position is buffered\n            if (mediaBuffered) {\n              this._reduceMaxBufferLength(this.config.maxBufferLength);\n              this.state = State.IDLE;\n            } else {\n              // current position is not buffered, but browser is still complaining about buffer full error\n              // this happens on IE/Edge, refer to https://github.com/dailymotion/hls.js/pull/708\n              // in that case flush the whole buffer to recover\n              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');\n              this.fragCurrent = null;\n              // flush everything\n              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n            }\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }, {\n    key: '_reduceMaxBufferLength',\n    value: function _reduceMaxBufferLength(minLength) {\n      var config = this.config;\n      if (config.maxMaxBufferLength >= minLength) {\n        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n        config.maxMaxBufferLength /= 2;\n        _logger.logger.warn('main:reduce max buffer length to ' + config.maxMaxBufferLength + 's');\n        // increase fragment load Index to avoid frag loop loading error after buffer flush\n        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;\n      }\n    }\n  }, {\n    key: '_checkBuffer',\n    value: function _checkBuffer() {\n      var media = this.media;\n      // if ready state different from HAVE_NOTHING (numeric value 0), we are allowed to seek\n      if (media && media.readyState) {\n        var currentTime = media.currentTime,\n            mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media,\n            buffered = mediaBuffer.buffered;\n        // adjust currentTime to start position on loaded metadata\n        if (!this.loadedmetadata && buffered.length && !media.seeking) {\n          this.loadedmetadata = true;\n          // only adjust currentTime if different from startPosition or if startPosition not buffered\n          // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n          var startPosition = this.startPosition,\n              startPositionBuffered = _bufferHelper2.default.isBuffered(mediaBuffer, startPosition);\n          // if currentTime not matching with expected startPosition or startPosition not buffered\n          if (currentTime !== startPosition || !startPositionBuffered) {\n            _logger.logger.log('target start position:' + startPosition);\n            // if startPosition not buffered, let's seek to buffered.start(0)\n            if (!startPositionBuffered) {\n              startPosition = buffered.start(0);\n              _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition);\n            }\n            _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + startPosition);\n            media.currentTime = startPosition;\n          }\n        } else if (this.immediateSwitch) {\n          this.immediateLevelSwitchEnd();\n        } else {\n          var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, 0),\n              expectedPlaying = !(media.paused || // not playing when media is paused\n          media.ended || // not playing when media is ended\n          media.buffered.length === 0),\n              // not playing if nothing buffered\n          jumpThreshold = 0.5,\n              // tolerance needed as some browsers stalls playback before reaching buffered range end\n          playheadMoving = currentTime !== this.lastCurrentTime,\n              config = this.config;\n\n          if (playheadMoving) {\n            // played moving, but was previously stalled => now not stuck anymore\n            if (this.stallReported) {\n              _logger.logger.warn('playback not stuck anymore @' + currentTime + ', after ' + Math.round(performance.now() - this.stalled) + 'ms');\n              this.stallReported = false;\n            }\n            this.stalled = undefined;\n            this.nudgeRetry = 0;\n          } else {\n            // playhead not moving\n            if (expectedPlaying) {\n              // playhead not moving BUT media expected to play\n              var tnow = performance.now();\n              var hls = this.hls;\n              if (!this.stalled) {\n                // stall just detected, store current time\n                this.stalled = tnow;\n                this.stallReported = false;\n              } else {\n                // playback already stalled, check stalling duration\n                // if stalling for more than a given threshold, let's try to recover\n                var stalledDuration = tnow - this.stalled;\n                var bufferLen = bufferInfo.len;\n                var nudgeRetry = this.nudgeRetry || 0;\n                // have we reached stall deadline ?\n                if (bufferLen <= jumpThreshold && stalledDuration > config.lowBufferWatchdogPeriod * 1000) {\n                  // report stalled error once\n                  if (!this.stallReported) {\n                    this.stallReported = true;\n                    _logger.logger.warn('playback stalling in low buffer @' + currentTime);\n                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false, buffer: bufferLen });\n                  }\n                  // if buffer len is below threshold, try to jump to start of next buffer range if close\n                  // no buffer available @ currentTime, check if next buffer is close (within a config.maxSeekHole second range)\n                  var nextBufferStart = bufferInfo.nextStart,\n                      delta = nextBufferStart - currentTime;\n                  if (nextBufferStart && delta < config.maxSeekHole && delta > 0) {\n                    this.nudgeRetry = ++nudgeRetry;\n                    var nudgeOffset = nudgeRetry * config.nudgeOffset;\n                    // next buffer is close ! adjust currentTime to nextBufferStart\n                    // this will ensure effective video decoding\n                    _logger.logger.log('adjust currentTime from ' + media.currentTime + ' to next buffered @ ' + nextBufferStart + ' + nudge ' + nudgeOffset);\n                    media.currentTime = nextBufferStart + nudgeOffset;\n                    // reset stalled so to rearm watchdog timer\n                    this.stalled = undefined;\n                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE, fatal: false, hole: nextBufferStart + nudgeOffset - currentTime });\n                  }\n                } else if (bufferLen > jumpThreshold && stalledDuration > config.highBufferWatchdogPeriod * 1000) {\n                  // report stalled error once\n                  if (!this.stallReported) {\n                    this.stallReported = true;\n                    _logger.logger.warn('playback stalling in high buffer @' + currentTime);\n                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false, buffer: bufferLen });\n                  }\n                  // reset stalled so to rearm watchdog timer\n                  this.stalled = undefined;\n                  this.nudgeRetry = ++nudgeRetry;\n                  if (nudgeRetry < config.nudgeMaxRetry) {\n                    var _currentTime = media.currentTime;\n                    var targetTime = _currentTime + nudgeRetry * config.nudgeOffset;\n                    _logger.logger.log('adjust currentTime from ' + _currentTime + ' to ' + targetTime);\n                    // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n                    media.currentTime = targetTime;\n                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_NUDGE_ON_STALL, fatal: false });\n                  } else {\n                    _logger.logger.error('still stuck in high buffer @' + currentTime + ' after ' + config.nudgeMaxRetry + ', raise fatal error');\n                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: true });\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: 'onFragLoadEmergencyAborted',\n    value: function onFragLoadEmergencyAborted() {\n      this.state = State.IDLE;\n      // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n      // in that case, reset startFragRequested flag\n      if (!this.loadedmetadata) {\n        this.startFragRequested = false;\n        this.nextLoadPosition = this.startPosition;\n      }\n      this.tick();\n    }\n  }, {\n    key: 'onBufferFlushed',\n    value: function onBufferFlushed() {\n      /* after successful buffer flushing, filter flushed fragments from bufferRange\n        use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)\n      */\n      var media = this.mediaBuffer ? this.mediaBuffer : this.media;\n      this.bufferRange = this.bufferRange.filter(function (range) {\n        return _bufferHelper2.default.isBuffered(media, (range.start + range.end) / 2);\n      });\n\n      // increase fragment load Index to avoid frag loop loading error after buffer flush\n      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;\n      // move to IDLE once flush complete. this should trigger new fragment loading\n      this.state = State.IDLE;\n      // reset reference to frag\n      this.fragPrevious = null;\n    }\n  }, {\n    key: 'swapAudioCodec',\n    value: function swapAudioCodec() {\n      this.audioCodecSwap = !this.audioCodecSwap;\n    }\n  }, {\n    key: 'computeLivePosition',\n    value: function computeLivePosition(sliding, levelDetails) {\n      var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;\n      return sliding + Math.max(0, levelDetails.totalduration - targetLatency);\n    }\n  }, {\n    key: 'state',\n    set: function set(nextState) {\n      if (this.state !== nextState) {\n        var previousState = this.state;\n        this._state = nextState;\n        _logger.logger.log('main stream:' + previousState + '->' + nextState);\n        this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });\n      }\n    },\n    get: function get() {\n      return this._state;\n    }\n  }, {\n    key: 'currentLevel',\n    get: function get() {\n      var media = this.media;\n      if (media) {\n        var range = this.getBufferRange(media.currentTime);\n        if (range) {\n          return range.frag.level;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: 'nextBufferRange',\n    get: function get() {\n      var media = this.media;\n      if (media) {\n        // first get end range of current fragment\n        return this.followingBufferRange(this.getBufferRange(media.currentTime));\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: 'nextLevel',\n    get: function get() {\n      var range = this.nextBufferRange;\n      if (range) {\n        return range.frag.level;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'liveSyncPosition',\n    get: function get() {\n      return this._liveSyncPosition;\n    },\n    set: function set(value) {\n      this._liveSyncPosition = value;\n    }\n  }]);\n\n  return StreamController;\n}(_eventHandler2.default);\n\nexports.default = StreamController;\n\n},{\"25\":25,\"31\":31,\"32\":32,\"33\":33,\"35\":35,\"36\":36,\"46\":46,\"50\":50,\"51\":51}],14:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Subtitle Stream Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar SubtitleStreamController = function (_EventHandler) {\n  _inherits(SubtitleStreamController, _EventHandler);\n\n  function SubtitleStreamController(hls) {\n    _classCallCheck(this, SubtitleStreamController);\n\n    var _this = _possibleConstructorReturn(this, (SubtitleStreamController.__proto__ || Object.getPrototypeOf(SubtitleStreamController)).call(this, hls, _events2.default.ERROR, _events2.default.SUBTITLE_TRACKS_UPDATED, _events2.default.SUBTITLE_TRACK_SWITCH, _events2.default.SUBTITLE_TRACK_LOADED, _events2.default.SUBTITLE_FRAG_PROCESSED));\n\n    _this.config = hls.config;\n    _this.vttFragSNsProcessed = {};\n    _this.vttFragQueues = undefined;\n    _this.currentlyProcessing = null;\n    _this.currentTrackId = -1;\n    return _this;\n  }\n\n  _createClass(SubtitleStreamController, [{\n    key: 'destroy',\n    value: function destroy() {\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n\n    // Remove all queued items and create a new, empty queue for each track.\n\n  }, {\n    key: 'clearVttFragQueues',\n    value: function clearVttFragQueues() {\n      var _this2 = this;\n\n      this.vttFragQueues = {};\n      this.tracks.forEach(function (track) {\n        _this2.vttFragQueues[track.id] = [];\n      });\n    }\n\n    // If no frag is being processed and queue isn't empty, initiate processing of next frag in line.\n\n  }, {\n    key: 'nextFrag',\n    value: function nextFrag() {\n      if (this.currentlyProcessing === null && this.currentTrackId > -1 && this.vttFragQueues[this.currentTrackId].length) {\n        var frag = this.currentlyProcessing = this.vttFragQueues[this.currentTrackId].shift();\n        this.hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });\n      }\n    }\n\n    // When fragment has finished processing, add sn to list of completed if successful.\n\n  }, {\n    key: 'onSubtitleFragProcessed',\n    value: function onSubtitleFragProcessed(data) {\n      if (data.success) {\n        this.vttFragSNsProcessed[data.frag.trackId].push(data.frag.sn);\n      }\n      this.currentlyProcessing = null;\n      this.nextFrag();\n    }\n\n    // If something goes wrong, procede to next frag, if we were processing one.\n\n  }, {\n    key: 'onError',\n    value: function onError(data) {\n      var frag = data.frag;\n      // don't handle frag error not related to subtitle fragment\n      if (frag && frag.type !== 'subtitle') {\n        return;\n      }\n      if (this.currentlyProcessing) {\n        this.currentlyProcessing = null;\n        this.nextFrag();\n      }\n    }\n\n    // Got all new subtitle tracks.\n\n  }, {\n    key: 'onSubtitleTracksUpdated',\n    value: function onSubtitleTracksUpdated(data) {\n      var _this3 = this;\n\n      _logger.logger.log('subtitle tracks updated');\n      this.tracks = data.subtitleTracks;\n      this.clearVttFragQueues();\n      this.vttFragSNsProcessed = {};\n      this.tracks.forEach(function (track) {\n        _this3.vttFragSNsProcessed[track.id] = [];\n      });\n    }\n  }, {\n    key: 'onSubtitleTrackSwitch',\n    value: function onSubtitleTrackSwitch(data) {\n      this.currentTrackId = data.id;\n      this.clearVttFragQueues();\n    }\n\n    // Got a new set of subtitle fragments.\n\n  }, {\n    key: 'onSubtitleTrackLoaded',\n    value: function onSubtitleTrackLoaded(data) {\n      var processedFragSNs = this.vttFragSNsProcessed[data.id],\n          fragQueue = this.vttFragQueues[data.id],\n          currentFragSN = !!this.currentlyProcessing ? this.currentlyProcessing.sn : -1;\n\n      var alreadyProcessed = function alreadyProcessed(frag) {\n        return processedFragSNs.indexOf(frag.sn) > -1;\n      };\n\n      var alreadyInQueue = function alreadyInQueue(frag) {\n        return fragQueue.some(function (fragInQueue) {\n          return fragInQueue.sn === frag.sn;\n        });\n      };\n\n      // Add all fragments that haven't been, aren't currently being and aren't waiting to be processed, to queue.\n      data.details.fragments.forEach(function (frag) {\n        if (!(alreadyProcessed(frag) || frag.sn === currentFragSN || alreadyInQueue(frag))) {\n          // Frags don't know their subtitle track ID, so let's just add that...\n          frag.trackId = data.id;\n          fragQueue.push(frag);\n        }\n      });\n\n      this.nextFrag();\n    }\n  }]);\n\n  return SubtitleStreamController;\n}(_eventHandler2.default);\n\nexports.default = SubtitleStreamController;\n\n},{\"32\":32,\"33\":33,\"50\":50}],15:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar SubtitleTrackController = function (_EventHandler) {\n  _inherits(SubtitleTrackController, _EventHandler);\n\n  function SubtitleTrackController(hls) {\n    _classCallCheck(this, SubtitleTrackController);\n\n    var _this = _possibleConstructorReturn(this, (SubtitleTrackController.__proto__ || Object.getPrototypeOf(SubtitleTrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.SUBTITLE_TRACK_LOADED));\n\n    _this.tracks = [];\n    _this.trackId = -1;\n    _this.media = undefined;\n    return _this;\n  }\n\n  _createClass(SubtitleTrackController, [{\n    key: 'destroy',\n    value: function destroy() {\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n\n    // Listen for subtitle track change, then extract the current track ID.\n\n  }, {\n    key: 'onMediaAttached',\n    value: function onMediaAttached(data) {\n      var _this2 = this;\n\n      this.media = data.media;\n      if (!this.media) {\n        return;\n      }\n\n      this.media.textTracks.addEventListener('change', function () {\n        // Media is undefined when switching streams via loadSource()\n        if (!_this2.media) {\n          return;\n        }\n\n        var trackId = -1;\n        var tracks = _this2.media.textTracks;\n        for (var id = 0; id < tracks.length; id++) {\n          if (tracks[id].mode === 'showing') {\n            trackId = id;\n          }\n        }\n        // Setting current subtitleTrack will invoke code.\n        _this2.subtitleTrack = trackId;\n      });\n    }\n  }, {\n    key: 'onMediaDetaching',\n    value: function onMediaDetaching() {\n      // TODO: Remove event listeners.\n      this.media = undefined;\n    }\n\n    // Reset subtitle tracks on manifest loading\n\n  }, {\n    key: 'onManifestLoading',\n    value: function onManifestLoading() {\n      this.tracks = [];\n      this.trackId = -1;\n    }\n\n    // Fired whenever a new manifest is loaded.\n\n  }, {\n    key: 'onManifestLoaded',\n    value: function onManifestLoaded(data) {\n      var _this3 = this;\n\n      var tracks = data.subtitles || [];\n      var defaultFound = false;\n      this.tracks = tracks;\n      this.trackId = -1;\n      this.hls.trigger(_events2.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });\n\n      // loop through available subtitle tracks and autoselect default if needed\n      // TODO: improve selection logic to handle forced, etc\n      tracks.forEach(function (track) {\n        if (track.default) {\n          _this3.subtitleTrack = track.id;\n          defaultFound = true;\n        }\n      });\n    }\n\n    // Trigger subtitle track playlist reload.\n\n  }, {\n    key: 'onTick',\n    value: function onTick() {\n      var trackId = this.trackId;\n      var subtitleTrack = this.tracks[trackId];\n      if (!subtitleTrack) {\n        return;\n      }\n\n      var details = subtitleTrack.details;\n      // check if we need to load playlist for this subtitle Track\n      if (details === undefined || details.live === true) {\n        // track not retrieved yet, or live playlist we need to (re)load it\n        _logger.logger.log('(re)loading playlist for subtitle track ' + trackId);\n        this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: trackId });\n      }\n    }\n  }, {\n    key: 'onSubtitleTrackLoaded',\n    value: function onSubtitleTrackLoaded(data) {\n      var _this4 = this;\n\n      if (data.id < this.tracks.length) {\n        _logger.logger.log('subtitle track ' + data.id + ' loaded');\n        this.tracks[data.id].details = data.details;\n        // check if current playlist is a live playlist\n        if (data.details.live && !this.timer) {\n          // if live playlist we will have to reload it periodically\n          // set reload period to playlist target duration\n          this.timer = setInterval(function () {\n            _this4.onTick();\n          }, 1000 * data.details.targetduration, this);\n        }\n        if (!data.details.live && this.timer) {\n          // playlist is not live and timer is armed : stopping it\n          clearInterval(this.timer);\n          this.timer = null;\n        }\n      }\n    }\n\n    /** get alternate subtitle tracks list from playlist **/\n\n  }, {\n    key: 'setSubtitleTrackInternal',\n    value: function setSubtitleTrackInternal(newId) {\n      // check if level idx is valid\n      if (newId >= 0 && newId < this.tracks.length) {\n        // stopping live reloading timer if any\n        if (this.timer) {\n          clearInterval(this.timer);\n          this.timer = null;\n        }\n        this.trackId = newId;\n        _logger.logger.log('switching to subtitle track ' + newId);\n        var subtitleTrack = this.tracks[newId];\n        this.hls.trigger(_events2.default.SUBTITLE_TRACK_SWITCH, { id: newId });\n        // check if we need to load playlist for this subtitle Track\n        var details = subtitleTrack.details;\n        if (details === undefined || details.live === true) {\n          // track not retrieved yet, or live playlist we need to (re)load it\n          _logger.logger.log('(re)loading playlist for subtitle track ' + newId);\n          this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: newId });\n        }\n      }\n    }\n  }, {\n    key: 'subtitleTracks',\n    get: function get() {\n      return this.tracks;\n    }\n\n    /** get index of the selected subtitle track (index in subtitle track lists) **/\n\n  }, {\n    key: 'subtitleTrack',\n    get: function get() {\n      return this.trackId;\n    }\n\n    /** select a subtitle track, based on its index in subtitle track lists**/\n    ,\n    set: function set(subtitleTrackId) {\n      if (this.trackId !== subtitleTrackId) {\n        // || this.tracks[subtitleTrackId].details === undefined) {\n        this.setSubtitleTrackInternal(subtitleTrackId);\n      }\n    }\n  }]);\n\n  return SubtitleTrackController;\n}(_eventHandler2.default);\n\nexports.default = SubtitleTrackController;\n\n},{\"32\":32,\"33\":33,\"50\":50}],16:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _cea608Parser = _dereq_(47);\n\nvar _cea608Parser2 = _interopRequireDefault(_cea608Parser);\n\nvar _webvttParser = _dereq_(54);\n\nvar _webvttParser2 = _interopRequireDefault(_webvttParser);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nfunction clearCurrentCues(track) {\n  if (track && track.cues) {\n    while (track.cues.length > 0) {\n      track.removeCue(track.cues[0]);\n    }\n  }\n}\n\nfunction reuseVttTextTrack(inUseTrack, manifestTrack) {\n  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);\n}\n\nfunction intersection(x1, x2, y1, y2) {\n  return Math.min(x2, y2) - Math.max(x1, y1);\n}\n\nvar TimelineController = function (_EventHandler) {\n  _inherits(TimelineController, _EventHandler);\n\n  function TimelineController(hls) {\n    _classCallCheck(this, TimelineController);\n\n    var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCHING, _events2.default.INIT_PTS_FOUND));\n\n    _this.hls = hls;\n    _this.config = hls.config;\n    _this.enabled = true;\n    _this.Cues = hls.config.cueHandler;\n    _this.textTracks = [];\n    _this.tracks = [];\n    _this.unparsedVttFrags = [];\n    _this.initPTS = undefined;\n    _this.cueRanges = [];\n\n    if (_this.config.enableCEA708Captions) {\n      var self = _this;\n      var sendAddTrackEvent = function sendAddTrackEvent(track, media) {\n        var e = null;\n        try {\n          e = new window.Event('addtrack');\n        } catch (err) {\n          //for IE11\n          e = document.createEvent('Event');\n          e.initEvent('addtrack', false, false);\n        }\n        e.track = track;\n        media.dispatchEvent(e);\n      };\n\n      var channel1 = {\n        'newCue': function newCue(startTime, endTime, screen) {\n          if (!self.textTrack1) {\n            //Enable reuse of existing text track.\n            var existingTrack1 = self.getExistingTrack('1');\n            if (!existingTrack1) {\n              self.textTrack1 = self.createTextTrack('captions', 'English', 'en');\n              self.textTrack1.textTrack1 = true;\n            } else {\n              self.textTrack1 = existingTrack1;\n              self.clearCurrentCues(self.textTrack1);\n\n              sendAddTrackEvent(self.textTrack1, self.media);\n            }\n          }\n          self.addCues('textTrack1', startTime, endTime, screen);\n        }\n      };\n\n      var channel2 = {\n        'newCue': function newCue(startTime, endTime, screen) {\n          if (!self.textTrack2) {\n            //Enable reuse of existing text track.\n            var existingTrack2 = self.getExistingTrack('2');\n            if (!existingTrack2) {\n              self.textTrack2 = self.createTextTrack('captions', 'Spanish', 'es');\n              self.textTrack2.textTrack2 = true;\n            } else {\n              self.textTrack2 = existingTrack2;\n\n              sendAddTrackEvent(self.textTrack2, self.media);\n            }\n          }\n          self.addCues('textTrack2', startTime, endTime, screen);\n        }\n      };\n\n      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);\n    }\n    return _this;\n  }\n\n  _createClass(TimelineController, [{\n    key: 'addCues',\n    value: function addCues(channel, startTime, endTime, screen) {\n      // skip cues which overlap more than 50% with previously parsed time ranges\n      var ranges = this.cueRanges;\n      var merged = false;\n      for (var i = ranges.length; i--;) {\n        var cueRange = ranges[i];\n        var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);\n        if (overlap >= 0) {\n          cueRange[0] = Math.min(cueRange[0], startTime);\n          cueRange[1] = Math.max(cueRange[1], endTime);\n          merged = true;\n          if (overlap / (endTime - startTime) > 0.5) {\n            return;\n          }\n        }\n      }\n      if (!merged) {\n        ranges.push([startTime, endTime]);\n      }\n      this.Cues.newCue(this[channel], startTime, endTime, screen);\n    }\n\n    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n\n  }, {\n    key: 'onInitPtsFound',\n    value: function onInitPtsFound(data) {\n      var _this2 = this;\n\n      if (typeof this.initPTS === 'undefined') {\n        this.initPTS = data.initPTS;\n      }\n\n      // Due to asynchrony, initial PTS may arrive later than the first VTT fragments are loaded.\n      // Parse any unparsed fragments upon receiving the initial PTS.\n      if (this.unparsedVttFrags.length) {\n        this.unparsedVttFrags.forEach(function (frag) {\n          _this2.onFragLoaded(frag);\n        });\n        this.unparsedVttFrags = [];\n      }\n    }\n  }, {\n    key: 'getExistingTrack',\n    value: function getExistingTrack(channelNumber) {\n      var media = this.media;\n      if (media) {\n        for (var i = 0; i < media.textTracks.length; i++) {\n          var textTrack = media.textTracks[i];\n          var propName = 'textTrack' + channelNumber;\n          if (textTrack[propName] === true) {\n            return textTrack;\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: 'createTextTrack',\n    value: function createTextTrack(kind, label, lang) {\n      if (this.media) {\n        return this.media.addTextTrack(kind, label, lang);\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n  }, {\n    key: 'onMediaAttaching',\n    value: function onMediaAttaching(data) {\n      this.media = data.media;\n    }\n  }, {\n    key: 'onMediaDetaching',\n    value: function onMediaDetaching() {\n      clearCurrentCues(this.textTrack1);\n      clearCurrentCues(this.textTrack2);\n    }\n  }, {\n    key: 'onManifestLoading',\n    value: function onManifestLoading() {\n      this.lastSn = -1; // Detect discontiguity in fragment parsing\n      this.prevCC = -1;\n      this.vttCCs = { ccOffset: 0, presentationOffset: 0 }; // Detect discontinuity in subtitle manifests\n    }\n  }, {\n    key: 'onManifestLoaded',\n    value: function onManifestLoaded(data) {\n      var _this3 = this;\n\n      this.textTracks = [];\n      this.unparsedVttFrags = this.unparsedVttFrags || [];\n      this.initPTS = undefined;\n      this.cueRanges = [];\n\n      if (this.config.enableWebVTT) {\n        (function () {\n          _this3.tracks = data.subtitles || [];\n          var inUseTracks = _this3.media ? _this3.media.textTracks : [];\n\n          _this3.tracks.forEach(function (track, index) {\n            var textTrack = void 0;\n            var inUseTrack = inUseTracks[index];\n            // Reuse tracks with the same label, but do not reuse 608/708 tracks\n            if (reuseVttTextTrack(inUseTrack, track)) {\n              textTrack = inUseTrack;\n            } else {\n              textTrack = _this3.createTextTrack('subtitles', track.name, track.lang);\n            }\n            textTrack.mode = track.default ? 'showing' : 'hidden';\n            _this3.textTracks.push(textTrack);\n          });\n        })();\n      }\n    }\n  }, {\n    key: 'onLevelSwitching',\n    value: function onLevelSwitching() {\n      this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';\n    }\n  }, {\n    key: 'onFragLoaded',\n    value: function onFragLoaded(data) {\n      var _this4 = this;\n\n      var frag = data.frag,\n          payload = data.payload;\n      if (frag.type === 'main') {\n        var sn = frag.sn;\n        // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack\n        if (sn !== this.lastSn + 1) {\n          this.cea608Parser.reset();\n        }\n        this.lastSn = sn;\n      }\n      // If fragment is subtitle type, parse as WebVTT.\n      else if (frag.type === 'subtitle') {\n          if (payload.byteLength) {\n            var _ret2 = function () {\n              // We need an initial synchronisation PTS. Store fragments as long as none has arrived.\n              if (typeof _this4.initPTS === 'undefined') {\n                _this4.unparsedVttFrags.push(data);\n                return {\n                  v: void 0\n                };\n              }\n              var vttCCs = _this4.vttCCs;\n              if (!vttCCs[frag.cc]) {\n                vttCCs[frag.cc] = { start: frag.start, prevCC: _this4.prevCC, new: true };\n                _this4.prevCC = frag.cc;\n              }\n              var textTracks = _this4.textTracks,\n                  hls = _this4.hls;\n\n              // Parse the WebVTT file contents.\n              _webvttParser2.default.parse(payload, _this4.initPTS, vttCCs, frag.cc, function (cues) {\n                // Add cues and trigger event with success true.\n                cues.forEach(function (cue) {\n                  textTracks[frag.trackId].addCue(cue);\n                });\n                hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });\n              }, function (e) {\n                // Something went wrong while parsing. Trigger event with success false.\n                _logger.logger.log('Failed to parse VTT cue: ' + e);\n                hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });\n              });\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n          } else {\n            // In case there is no payload, finish unsuccessfully.\n            this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });\n          }\n        }\n    }\n  }, {\n    key: 'onFragParsingUserdata',\n    value: function onFragParsingUserdata(data) {\n      // push all of the CEA-708 messages into the interpreter\n      // immediately. It will create the proper timestamps based on our PTS value\n      if (this.enabled && this.config.enableCEA708Captions) {\n        for (var i = 0; i < data.samples.length; i++) {\n          var ccdatas = this.extractCea608Data(data.samples[i].bytes);\n          this.cea608Parser.addData(data.samples[i].pts, ccdatas);\n        }\n      }\n    }\n  }, {\n    key: 'extractCea608Data',\n    value: function extractCea608Data(byteArray) {\n      var count = byteArray[0] & 31;\n      var position = 2;\n      var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;\n      var actualCCBytes = [];\n\n      for (var j = 0; j < count; j++) {\n        tmpByte = byteArray[position++];\n        ccbyte1 = 0x7F & byteArray[position++];\n        ccbyte2 = 0x7F & byteArray[position++];\n        ccValid = (4 & tmpByte) !== 0;\n        ccType = 3 & tmpByte;\n\n        if (ccbyte1 === 0 && ccbyte2 === 0) {\n          continue;\n        }\n\n        if (ccValid) {\n          if (ccType === 0) // || ccType === 1\n            {\n              actualCCBytes.push(ccbyte1);\n              actualCCBytes.push(ccbyte2);\n            }\n        }\n      }\n      return actualCCBytes;\n    }\n  }]);\n\n  return TimelineController;\n}(_eventHandler2.default);\n\nexports.default = TimelineController;\n\n},{\"32\":32,\"33\":33,\"47\":47,\"50\":50,\"54\":54}],17:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AESCrypto = function () {\n  function AESCrypto(subtle, iv) {\n    _classCallCheck(this, AESCrypto);\n\n    this.subtle = subtle;\n    this.aesIV = iv;\n  }\n\n  _createClass(AESCrypto, [{\n    key: 'decrypt',\n    value: function decrypt(data, key) {\n      return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);\n    }\n  }]);\n\n  return AESCrypto;\n}();\n\nexports.default = AESCrypto;\n\n},{}],18:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AESDecryptor = function () {\n  function AESDecryptor() {\n    _classCallCheck(this, AESDecryptor);\n\n    // Static after running initTable\n    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n    this.subMix = [];\n    this.subMix[0] = new Uint32Array(256);\n    this.subMix[1] = new Uint32Array(256);\n    this.subMix[2] = new Uint32Array(256);\n    this.subMix[3] = new Uint32Array(256);\n\n    this.invSubMix = [];\n    this.invSubMix[0] = new Uint32Array(256);\n    this.invSubMix[1] = new Uint32Array(256);\n    this.invSubMix[2] = new Uint32Array(256);\n    this.invSubMix[3] = new Uint32Array(256);\n\n    this.sBox = new Uint32Array(256);\n    this.invSBox = new Uint32Array(256);\n\n    // Changes during runtime\n    this.key = new Uint32Array(0);\n\n    this.initTable();\n  }\n\n  // Using view.getUint32() also swaps the byte order.\n\n\n  _createClass(AESDecryptor, [{\n    key: 'uint8ArrayToUint32Array_',\n    value: function uint8ArrayToUint32Array_(arrayBuffer) {\n      var view = new DataView(arrayBuffer);\n      var newArray = new Uint32Array(4);\n      for (var i = 0; i < newArray.length; i++) {\n        newArray[i] = view.getUint32(i * 4);\n      }\n      return newArray;\n    }\n  }, {\n    key: 'initTable',\n    value: function initTable() {\n      var sBox = this.sBox;\n      var invSBox = this.invSBox;\n      var subMix0 = this.subMix[0];\n      var subMix1 = this.subMix[1];\n      var subMix2 = this.subMix[2];\n      var subMix3 = this.subMix[3];\n      var invSubMix0 = this.invSubMix[0];\n      var invSubMix1 = this.invSubMix[1];\n      var invSubMix2 = this.invSubMix[2];\n      var invSubMix3 = this.invSubMix[3];\n\n      var d = new Uint32Array(256);\n      var x = 0;\n      var xi = 0;\n      var i = 0;\n      for (i = 0; i < 256; i++) {\n        if (i < 128) {\n          d[i] = i << 1;\n        } else {\n          d[i] = i << 1 ^ 0x11b;\n        }\n      }\n\n      for (i = 0; i < 256; i++) {\n        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n        sBox[x] = sx;\n        invSBox[sx] = x;\n\n        // Compute multiplication\n        var x2 = d[x];\n        var x4 = d[x2];\n        var x8 = d[x4];\n\n        // Compute sub/invSub bytes, mix columns tables\n        var t = d[sx] * 0x101 ^ sx * 0x1010100;\n        subMix0[x] = t << 24 | t >>> 8;\n        subMix1[x] = t << 16 | t >>> 16;\n        subMix2[x] = t << 8 | t >>> 24;\n        subMix3[x] = t;\n\n        // Compute inv sub bytes, inv mix columns tables\n        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n        invSubMix0[sx] = t << 24 | t >>> 8;\n        invSubMix1[sx] = t << 16 | t >>> 16;\n        invSubMix2[sx] = t << 8 | t >>> 24;\n        invSubMix3[sx] = t;\n\n        // Compute next counter\n        if (!x) {\n          x = xi = 1;\n        } else {\n          x = x2 ^ d[d[d[x8 ^ x2]]];\n          xi ^= d[d[xi]];\n        }\n      }\n    }\n  }, {\n    key: 'expandKey',\n    value: function expandKey(keyBuffer) {\n      // convert keyBuffer to Uint32Array\n      var key = this.uint8ArrayToUint32Array_(keyBuffer);\n      var sameKey = true;\n      var offset = 0;\n\n      while (offset < key.length && sameKey) {\n        sameKey = key[offset] === this.key[offset];\n        offset++;\n      }\n\n      if (sameKey) {\n        return;\n      }\n\n      this.key = key;\n      var keySize = this.keySize = key.length;\n\n      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n        throw new Error('Invalid aes key size=' + keySize);\n      }\n\n      var ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n      var ksRow = void 0;\n      var invKsRow = void 0;\n\n      var keySchedule = this.keySchedule = new Uint32Array(this.ksRows);\n      var invKeySchedule = this.invKeySchedule = new Uint32Array(this.ksRows);\n      var sbox = this.sBox;\n      var rcon = this.rcon;\n\n      var invSubMix0 = this.invSubMix[0];\n      var invSubMix1 = this.invSubMix[1];\n      var invSubMix2 = this.invSubMix[2];\n      var invSubMix3 = this.invSubMix[3];\n\n      var prev = void 0;\n      var t = void 0;\n\n      for (ksRow = 0; ksRow < ksRows; ksRow++) {\n        if (ksRow < keySize) {\n          prev = keySchedule[ksRow] = key[ksRow];\n          continue;\n        }\n        t = prev;\n\n        if (ksRow % keySize === 0) {\n          // Rot word\n          t = t << 8 | t >>> 24;\n\n          // Sub word\n          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n\n          // Mix Rcon\n          t ^= rcon[ksRow / keySize | 0] << 24;\n        } else if (keySize > 6 && ksRow % keySize === 4) {\n          // Sub word\n          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n        }\n\n        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n      }\n\n      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n        ksRow = ksRows - invKsRow;\n        if (invKsRow & 3) {\n          t = keySchedule[ksRow];\n        } else {\n          t = keySchedule[ksRow - 4];\n        }\n\n        if (invKsRow < 4 || ksRow <= 4) {\n          invKeySchedule[invKsRow] = t;\n        } else {\n          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n        }\n\n        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n      }\n    }\n\n    // Adding this as a method greatly improves performance.\n\n  }, {\n    key: 'networkToHostOrderSwap',\n    value: function networkToHostOrderSwap(word) {\n      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n    }\n  }, {\n    key: 'decrypt',\n    value: function decrypt(inputArrayBuffer, offset, aesIV) {\n      var nRounds = this.keySize + 6;\n      var invKeySchedule = this.invKeySchedule;\n      var invSBOX = this.invSBox;\n\n      var invSubMix0 = this.invSubMix[0];\n      var invSubMix1 = this.invSubMix[1];\n      var invSubMix2 = this.invSubMix[2];\n      var invSubMix3 = this.invSubMix[3];\n\n      var initVector = this.uint8ArrayToUint32Array_(aesIV);\n      var initVector0 = initVector[0];\n      var initVector1 = initVector[1];\n      var initVector2 = initVector[2];\n      var initVector3 = initVector[3];\n\n      var inputInt32 = new Int32Array(inputArrayBuffer);\n      var outputInt32 = new Int32Array(inputInt32.length);\n\n      var t0 = void 0,\n          t1 = void 0,\n          t2 = void 0,\n          t3 = void 0;\n      var s0 = void 0,\n          s1 = void 0,\n          s2 = void 0,\n          s3 = void 0;\n      var inputWords0 = void 0,\n          inputWords1 = void 0,\n          inputWords2 = void 0,\n          inputWords3 = void 0;\n\n      var ksRow, i;\n\n      while (offset < inputInt32.length) {\n        inputWords0 = this.networkToHostOrderSwap(inputInt32[offset]);\n        inputWords1 = this.networkToHostOrderSwap(inputInt32[offset + 1]);\n        inputWords2 = this.networkToHostOrderSwap(inputInt32[offset + 2]);\n        inputWords3 = this.networkToHostOrderSwap(inputInt32[offset + 3]);\n\n        s0 = inputWords0 ^ invKeySchedule[0];\n        s1 = inputWords3 ^ invKeySchedule[1];\n        s2 = inputWords2 ^ invKeySchedule[2];\n        s3 = inputWords1 ^ invKeySchedule[3];\n\n        ksRow = 4;\n\n        // Iterate through the rounds of decryption\n        for (i = 1; i < nRounds; i++) {\n          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n          // Update state\n          s0 = t0;\n          s1 = t1;\n          s2 = t2;\n          s3 = t3;\n\n          ksRow = ksRow + 4;\n        }\n\n        // Shift rows, sub bytes, add round key\n        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n        ksRow = ksRow + 3;\n\n        // Write\n        outputInt32[offset] = this.networkToHostOrderSwap(t0 ^ initVector0);\n        outputInt32[offset + 1] = this.networkToHostOrderSwap(t3 ^ initVector1);\n        outputInt32[offset + 2] = this.networkToHostOrderSwap(t2 ^ initVector2);\n        outputInt32[offset + 3] = this.networkToHostOrderSwap(t1 ^ initVector3);\n\n        // reset initVector to last 4 unsigned int\n        initVector0 = inputWords0;\n        initVector1 = inputWords1;\n        initVector2 = inputWords2;\n        initVector3 = inputWords3;\n\n        offset = offset + 4;\n      }\n\n      return outputInt32.buffer;\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.key = undefined;\n      this.keySize = undefined;\n      this.ksRows = undefined;\n\n      this.sBox = undefined;\n      this.invSBox = undefined;\n      this.subMix = undefined;\n      this.invSubMix = undefined;\n      this.keySchedule = undefined;\n      this.invKeySchedule = undefined;\n\n      this.rcon = undefined;\n    }\n  }]);\n\n  return AESDecryptor;\n}();\n\nexports.default = AESDecryptor;\n\n},{}],19:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aesCrypto = _dereq_(17);\n\nvar _aesCrypto2 = _interopRequireDefault(_aesCrypto);\n\nvar _fastAesKey = _dereq_(20);\n\nvar _fastAesKey2 = _interopRequireDefault(_fastAesKey);\n\nvar _aesDecryptor = _dereq_(18);\n\nvar _aesDecryptor2 = _interopRequireDefault(_aesDecryptor);\n\nvar _errors = _dereq_(31);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*globals self: false */\n\nvar Decrypter = function () {\n  function Decrypter(observer, config) {\n    _classCallCheck(this, Decrypter);\n\n    this.observer = observer;\n    this.config = config;\n    this.logEnabled = true;\n    try {\n      var browserCrypto = crypto ? crypto : self.crypto;\n      this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n    } catch (e) {}\n    this.disableWebCrypto = !this.subtle;\n  }\n\n  _createClass(Decrypter, [{\n    key: 'isSync',\n    value: function isSync() {\n      return this.disableWebCrypto && this.config.enableSoftwareAES;\n    }\n  }, {\n    key: 'decrypt',\n    value: function decrypt(data, key, iv, callback) {\n      var _this = this;\n\n      if (this.disableWebCrypto && this.config.enableSoftwareAES) {\n        if (this.logEnabled) {\n          _logger.logger.log('JS AES decrypt');\n          this.logEnabled = false;\n        }\n        var decryptor = this.decryptor;\n        if (!decryptor) {\n          this.decryptor = decryptor = new _aesDecryptor2.default();\n        }\n        decryptor.expandKey(key);\n        callback(decryptor.decrypt(data, 0, iv));\n      } else {\n        (function () {\n          if (_this.logEnabled) {\n            _logger.logger.log('WebCrypto AES decrypt');\n            _this.logEnabled = false;\n          }\n          var subtle = _this.subtle;\n          if (_this.key !== key) {\n            _this.key = key;\n            _this.fastAesKey = new _fastAesKey2.default(subtle, key);\n          }\n\n          _this.fastAesKey.expandKey().then(function (aesKey) {\n            // decrypt using web crypto\n            var crypto = new _aesCrypto2.default(subtle, iv);\n            crypto.decrypt(data, aesKey).catch(function (err) {\n              _this.onWebCryptoError(err, data, key, iv, callback);\n            }).then(function (result) {\n              callback(result);\n            });\n          }).catch(function (err) {\n            _this.onWebCryptoError(err, data, key, iv, callback);\n          });\n        })();\n      }\n    }\n  }, {\n    key: 'onWebCryptoError',\n    value: function onWebCryptoError(err, data, key, iv, callback) {\n      if (this.config.enableSoftwareAES) {\n        _logger.logger.log('WebCrypto Error, disable WebCrypto API');\n        this.disableWebCrypto = true;\n        this.logEnabled = true;\n        this.decrypt(data, key, iv, callback);\n      } else {\n        _logger.logger.error('decrypting error : ' + err.message);\n        this.observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      var decryptor = this.decryptor;\n      if (decryptor) {\n        decryptor.destroy();\n        this.decryptor = undefined;\n      }\n    }\n  }]);\n\n  return Decrypter;\n}();\n\nexports.default = Decrypter;\n\n},{\"17\":17,\"18\":18,\"20\":20,\"31\":31,\"50\":50}],20:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FastAESKey = function () {\n  function FastAESKey(subtle, key) {\n    _classCallCheck(this, FastAESKey);\n\n    this.subtle = subtle;\n    this.key = key;\n  }\n\n  _createClass(FastAESKey, [{\n    key: 'expandKey',\n    value: function expandKey() {\n      return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);\n    }\n  }]);\n\n  return FastAESKey;\n}();\n\nexports.default = FastAESKey;\n\n},{}],21:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _adts = _dereq_(22);\n\nvar _adts2 = _interopRequireDefault(_adts);\n\nvar _logger = _dereq_(50);\n\nvar _id = _dereq_(27);\n\nvar _id2 = _interopRequireDefault(_id);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AACDemuxer = function () {\n  function AACDemuxer(observer, remuxer, config) {\n    _classCallCheck(this, AACDemuxer);\n\n    this.observer = observer;\n    this.config = config;\n    this.remuxer = remuxer;\n  }\n\n  _createClass(AACDemuxer, [{\n    key: 'resetInitSegment',\n    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {\n      this._aacTrack = { container: 'audio/adts', type: 'audio', id: -1, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration };\n    }\n  }, {\n    key: 'resetTimeStamp',\n    value: function resetTimeStamp() {}\n  }, {\n    key: 'append',\n\n\n    // feed incoming data to the front of the parsing pipeline\n    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {\n      var track,\n          id3 = new _id2.default(data),\n          pts = 90 * id3.timeStamp,\n          config,\n          frameLength,\n          frameDuration,\n          frameIndex,\n          offset,\n          headerLength,\n          stamp,\n          len,\n          aacSample;\n\n      track = this._aacTrack;\n\n      // look for ADTS header (0xFFFx)\n      for (offset = id3.length, len = data.length; offset < len - 1; offset++) {\n        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {\n          break;\n        }\n      }\n\n      if (!track.audiosamplerate) {\n        config = _adts2.default.getAudioConfig(this.observer, data, offset, track.manifestCodec);\n        track.config = config.config;\n        track.audiosamplerate = config.samplerate;\n        track.channelCount = config.channelCount;\n        track.codec = config.codec;\n        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);\n      }\n      frameIndex = 0;\n      frameDuration = 1024 * 90000 / track.audiosamplerate;\n      while (offset + 5 < len) {\n        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;\n        // retrieve frame size\n        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;\n        frameLength -= headerLength;\n        //stamp = pes.pts;\n\n        if (frameLength > 0 && offset + headerLength + frameLength <= len) {\n          stamp = pts + frameIndex * frameDuration;\n          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);\n          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };\n          track.samples.push(aacSample);\n          track.len += frameLength;\n          offset += frameLength + headerLength;\n          frameIndex++;\n          // look for ADTS header (0xFFFx)\n          for (; offset < len - 1; offset++) {\n            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {\n              break;\n            }\n          }\n        } else {\n          break;\n        }\n      }\n      this.remuxer.remux(track, { samples: [] }, { samples: [{ pts: pts, dts: pts, unit: id3.payload }] }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {}\n  }], [{\n    key: 'probe',\n    value: function probe(data) {\n      // check if data contains ID3 timestamp and ADTS sync worc\n      var id3 = new _id2.default(data),\n          offset,\n          len;\n      if (id3.hasTimeStamp) {\n        // look for ADTS header (0xFFFx)\n        for (offset = id3.length, len = data.length; offset < len - 1; offset++) {\n          if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {\n            //logger.log('ADTS sync word found !');\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n  }]);\n\n  return AACDemuxer;\n}();\n\nexports.default = AACDemuxer;\n\n},{\"22\":22,\"27\":27,\"50\":50}],22:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  ADTS parser helper\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _logger = _dereq_(50);\n\nvar _errors = _dereq_(31);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ADTS = function () {\n  function ADTS() {\n    _classCallCheck(this, ADTS);\n  }\n\n  _createClass(ADTS, null, [{\n    key: 'getAudioConfig',\n    value: function getAudioConfig(observer, data, offset, audioCodec) {\n      var adtsObjectType,\n          // :int\n      adtsSampleingIndex,\n          // :int\n      adtsExtensionSampleingIndex,\n          // :int\n      adtsChanelConfig,\n          // :int\n      config,\n          userAgent = navigator.userAgent.toLowerCase(),\n          manifestCodec = audioCodec,\n          adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n      // byte 2\n      adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;\n      adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;\n      if (adtsSampleingIndex > adtsSampleingRates.length - 1) {\n        observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });\n        return;\n      }\n      adtsChanelConfig = (data[offset + 2] & 0x01) << 2;\n      // byte 3\n      adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;\n      _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);\n      // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n      if (/firefox/i.test(userAgent)) {\n        if (adtsSampleingIndex >= 6) {\n          adtsObjectType = 5;\n          config = new Array(4);\n          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n          // there is a factor 2 between frame sample rate and output sample rate\n          // multiply frequency by 2 (see table below, equivalent to substract 3)\n          adtsExtensionSampleingIndex = adtsSampleingIndex - 3;\n        } else {\n          adtsObjectType = 2;\n          config = new Array(2);\n          adtsExtensionSampleingIndex = adtsSampleingIndex;\n        }\n        // Android : always use AAC\n      } else if (userAgent.indexOf('android') !== -1) {\n        adtsObjectType = 2;\n        config = new Array(2);\n        adtsExtensionSampleingIndex = adtsSampleingIndex;\n      } else {\n        /*  for other browsers (Chrome/Vivaldi/Opera ...)\n            always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n        */\n        adtsObjectType = 5;\n        config = new Array(4);\n        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n        if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {\n          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n          // there is a factor 2 between frame sample rate and output sample rate\n          // multiply frequency by 2 (see table below, equivalent to substract 3)\n          adtsExtensionSampleingIndex = adtsSampleingIndex - 3;\n        } else {\n          // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n          // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n          if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || !audioCodec && adtsChanelConfig === 1) {\n            adtsObjectType = 2;\n            config = new Array(2);\n          }\n          adtsExtensionSampleingIndex = adtsSampleingIndex;\n        }\n      }\n      /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n          ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()\n        Audio Profile / Audio Object Type\n        0: Null\n        1: AAC Main\n        2: AAC LC (Low Complexity)\n        3: AAC SSR (Scalable Sample Rate)\n        4: AAC LTP (Long Term Prediction)\n        5: SBR (Spectral Band Replication)\n        6: AAC Scalable\n       sampling freq\n        0: 96000 Hz\n        1: 88200 Hz\n        2: 64000 Hz\n        3: 48000 Hz\n        4: 44100 Hz\n        5: 32000 Hz\n        6: 24000 Hz\n        7: 22050 Hz\n        8: 16000 Hz\n        9: 12000 Hz\n        10: 11025 Hz\n        11: 8000 Hz\n        12: 7350 Hz\n        13: Reserved\n        14: Reserved\n        15: frequency is written explictly\n        Channel Configurations\n        These are the channel configurations:\n        0: Defined in AOT Specifc Config\n        1: 1 channel: front-center\n        2: 2 channels: front-left, front-right\n      */\n      // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n      config[0] = adtsObjectType << 3;\n      // samplingFrequencyIndex\n      config[0] |= (adtsSampleingIndex & 0x0E) >> 1;\n      config[1] |= (adtsSampleingIndex & 0x01) << 7;\n      // channelConfiguration\n      config[1] |= adtsChanelConfig << 3;\n      if (adtsObjectType === 5) {\n        // adtsExtensionSampleingIndex\n        config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;\n        config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;\n        // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n        config[2] |= 2 << 2;\n        config[3] = 0;\n      }\n      return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType, manifestCodec: manifestCodec };\n    }\n  }]);\n\n  return ADTS;\n}();\n\nexports.default = ADTS;\n\n},{\"31\":31,\"50\":50}],23:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*  inline demuxer.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   probe fragments and instantiate appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _errors = _dereq_(31);\n\nvar _decrypter = _dereq_(19);\n\nvar _decrypter2 = _interopRequireDefault(_decrypter);\n\nvar _aacdemuxer = _dereq_(21);\n\nvar _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);\n\nvar _mp4demuxer = _dereq_(28);\n\nvar _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);\n\nvar _tsdemuxer = _dereq_(30);\n\nvar _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);\n\nvar _mp4Remuxer = _dereq_(43);\n\nvar _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);\n\nvar _passthroughRemuxer = _dereq_(44);\n\nvar _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DemuxerInline = function () {\n  function DemuxerInline(observer, typeSupported, config) {\n    _classCallCheck(this, DemuxerInline);\n\n    this.observer = observer;\n    this.typeSupported = typeSupported;\n    this.config = config;\n  }\n\n  _createClass(DemuxerInline, [{\n    key: 'destroy',\n    value: function destroy() {\n      var demuxer = this.demuxer;\n      if (demuxer) {\n        demuxer.destroy();\n      }\n    }\n  }, {\n    key: 'push',\n    value: function push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {\n      if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {\n        var decrypter = this.decrypter;\n        if (decrypter == null) {\n          decrypter = this.decrypter = new _decrypter2.default(this.observer, this.config);\n        }\n        var localthis = this;\n        // performance.now() not available on WebWorker, at least on Safari Desktop\n        var startTime;\n        try {\n          startTime = performance.now();\n        } catch (error) {\n          startTime = Date.now();\n        }\n        decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {\n          var endTime;\n          try {\n            endTime = performance.now();\n          } catch (error) {\n            endTime = Date.now();\n          }\n          localthis.observer.trigger(_events2.default.FRAG_DECRYPTED, { stats: { tstart: startTime, tdecrypt: endTime } });\n          localthis.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);\n        });\n      } else {\n        this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);\n      }\n    }\n  }, {\n    key: 'pushDecrypted',\n    value: function pushDecrypted(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {\n      var demuxer = this.demuxer;\n      if (!demuxer ||\n      // in case of continuity change, we might switch from content type (AAC container to TS container for example)\n      // so let's check that current demuxer is still valid\n      discontinuity && !this.probe(data)) {\n        var observer = this.observer;\n        var typeSupported = this.typeSupported;\n        var config = this.config;\n        var muxConfig = [{ demux: _tsdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _aacdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp4demuxer2.default, remux: _passthroughRemuxer2.default }];\n\n        // probe for content type\n        for (var i in muxConfig) {\n          var mux = muxConfig[i];\n          var probe = mux.demux.probe;\n          if (probe(data)) {\n            var _remuxer = this.remuxer = new mux.remux(observer, config, typeSupported);\n            demuxer = new mux.demux(observer, _remuxer, config, typeSupported);\n            this.probe = probe;\n            break;\n          }\n        }\n        if (!demuxer) {\n          observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });\n          return;\n        }\n        this.demuxer = demuxer;\n      }\n      var remuxer = this.remuxer;\n\n      if (discontinuity || trackSwitch) {\n        demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);\n        remuxer.resetInitSegment();\n      }\n      if (discontinuity) {\n        demuxer.resetTimeStamp();\n        remuxer.resetTimeStamp(defaultInitPTS);\n      }\n      if (typeof demuxer.setDecryptData === 'function') {\n        demuxer.setDecryptData(decryptdata);\n      }\n      demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);\n    }\n  }]);\n\n  return DemuxerInline;\n}();\n\nexports.default = DemuxerInline;\n\n},{\"19\":19,\"21\":21,\"28\":28,\"30\":30,\"31\":31,\"33\":33,\"43\":43,\"44\":44}],24:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _demuxerInline = _dereq_(23);\n\nvar _demuxerInline2 = _interopRequireDefault(_demuxerInline);\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _logger = _dereq_(50);\n\nvar _events3 = _dereq_(1);\n\nvar _events4 = _interopRequireDefault(_events3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* demuxer web worker.\n *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.\n *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.\n */\n\nvar DemuxerWorker = function DemuxerWorker(self) {\n  // observer setup\n  var observer = new _events4.default();\n  observer.trigger = function trigger(event) {\n    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      data[_key - 1] = arguments[_key];\n    }\n\n    observer.emit.apply(observer, [event, event].concat(data));\n  };\n\n  observer.off = function off(event) {\n    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      data[_key2 - 1] = arguments[_key2];\n    }\n\n    observer.removeListener.apply(observer, [event].concat(data));\n  };\n\n  var forwardMessage = function forwardMessage(ev, data) {\n    self.postMessage({ event: ev, data: data });\n  };\n\n  self.addEventListener('message', function (ev) {\n    var data = ev.data;\n    //console.log('demuxer cmd:' + data.cmd);\n    switch (data.cmd) {\n      case 'init':\n        var config = JSON.parse(data.config);\n        self.demuxer = new _demuxerInline2.default(observer, data.typeSupported, config);\n        try {\n          (0, _logger.enableLogs)(config.debug === true);\n        } catch (err) {\n          console.warn('demuxerWorker: unable to enable logs');\n        }\n        // signal end of worker init\n        forwardMessage('init', null);\n        break;\n      case 'demux':\n        self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);\n        break;\n      default:\n        break;\n    }\n  });\n\n  // forward events to main thread\n  observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);\n  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);\n  observer.on(_events2.default.FRAG_PARSED, forwardMessage);\n  observer.on(_events2.default.ERROR, forwardMessage);\n  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);\n  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);\n  observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);\n\n  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)\n  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {\n    var transferable = [];\n    var message = { event: ev, data: data };\n    if (data.data1) {\n      message.data1 = data.data1.buffer;\n      transferable.push(data.data1.buffer);\n      delete data.data1;\n    }\n    if (data.data2) {\n      message.data2 = data.data2.buffer;\n      transferable.push(data.data2.buffer);\n      delete data.data2;\n    }\n    self.postMessage(message, transferable);\n  });\n};\n\nexports.default = DemuxerWorker;\n\n},{\"1\":1,\"23\":23,\"33\":33,\"50\":50}],25:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _demuxerInline = _dereq_(23);\n\nvar _demuxerInline2 = _interopRequireDefault(_demuxerInline);\n\nvar _demuxerWorker = _dereq_(24);\n\nvar _demuxerWorker2 = _interopRequireDefault(_demuxerWorker);\n\nvar _logger = _dereq_(50);\n\nvar _errors = _dereq_(31);\n\nvar _events3 = _dereq_(1);\n\nvar _events4 = _interopRequireDefault(_events3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Demuxer = function () {\n  function Demuxer(hls, id) {\n    _classCallCheck(this, Demuxer);\n\n    this.hls = hls;\n    this.id = id;\n    // observer setup\n    var observer = this.observer = new _events4.default();\n    var config = hls.config;\n    observer.trigger = function trigger(event) {\n      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        data[_key - 1] = arguments[_key];\n      }\n\n      observer.emit.apply(observer, [event, event].concat(data));\n    };\n\n    observer.off = function off(event) {\n      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        data[_key2 - 1] = arguments[_key2];\n      }\n\n      observer.removeListener.apply(observer, [event].concat(data));\n    };\n\n    var forwardMessage = function (ev, data) {\n      data = data || {};\n      data.frag = this.frag;\n      data.id = this.id;\n      hls.trigger(ev, data);\n    }.bind(this);\n\n    // forward events to main thread\n    observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);\n    observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);\n    observer.on(_events2.default.FRAG_PARSING_DATA, forwardMessage);\n    observer.on(_events2.default.FRAG_PARSED, forwardMessage);\n    observer.on(_events2.default.ERROR, forwardMessage);\n    observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);\n    observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);\n    observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);\n\n    var typeSupported = {\n      mp4: MediaSource.isTypeSupported('video/mp4'),\n      mpeg: MediaSource.isTypeSupported('audio/mpeg'),\n      mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"')\n    };\n    if (config.enableWorker && typeof Worker !== 'undefined') {\n      _logger.logger.log('demuxing in webworker');\n      var w = void 0;\n      try {\n        var work = _dereq_(3);\n        w = this.w = work(_demuxerWorker2.default);\n        this.onwmsg = this.onWorkerMessage.bind(this);\n        w.addEventListener('message', this.onwmsg);\n        w.onerror = function (event) {\n          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });\n        };\n        w.postMessage({ cmd: 'init', typeSupported: typeSupported, id: id, config: JSON.stringify(config) });\n      } catch (err) {\n        _logger.logger.error('error while initializing DemuxerWorker, fallback on DemuxerInline');\n        if (w) {\n          // revoke the Object URL that was used to create demuxer worker, so as not to leak it\n          URL.revokeObjectURL(w.objectURL);\n        }\n        this.demuxer = new _demuxerInline2.default(observer, id, typeSupported, config);\n        this.w = undefined;\n      }\n    } else {\n      this.demuxer = new _demuxerInline2.default(observer, id, typeSupported, config);\n    }\n  }\n\n  _createClass(Demuxer, [{\n    key: 'destroy',\n    value: function destroy() {\n      var w = this.w;\n      if (w) {\n        w.removeEventListener('message', this.onwmsg);\n        w.terminate();\n        this.w = null;\n      } else {\n        var demuxer = this.demuxer;\n        if (demuxer) {\n          demuxer.destroy();\n          this.demuxer = null;\n        }\n      }\n      var observer = this.observer;\n      if (observer) {\n        observer.removeAllListeners();\n        this.observer = null;\n      }\n    }\n  }, {\n    key: 'push',\n    value: function push(data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {\n      var w = this.w;\n      var timeOffset = !isNaN(frag.startDTS) ? frag.startDTS : frag.start;\n      var decryptdata = frag.decryptdata;\n      var lastFrag = this.frag;\n      var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n      var trackSwitch = !(lastFrag && frag.level === lastFrag.level);\n      var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;\n      var contiguous = !discontinuity && !trackSwitch && nextSN;\n      if (discontinuity) {\n        _logger.logger.log(this.id + ':discontinuity detected');\n      }\n      if (trackSwitch) {\n        _logger.logger.log(this.id + ':switch detected');\n      }\n      this.frag = frag;\n      if (w) {\n        // post fragment payload as transferable objects (no copy)\n        w.postMessage({ cmd: 'demux', data: data, decryptdata: decryptdata, initSegment: initSegment, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, discontinuity: discontinuity, trackSwitch: trackSwitch, contiguous: contiguous, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, [data]);\n      } else {\n        var demuxer = this.demuxer;\n        if (demuxer) {\n          demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);\n        }\n      }\n    }\n  }, {\n    key: 'onWorkerMessage',\n    value: function onWorkerMessage(ev) {\n      var data = ev.data,\n          hls = this.hls;\n      //console.log('onWorkerMessage:' + data.event);\n      switch (data.event) {\n        case 'init':\n          // revoke the Object URL that was used to create demuxer worker, so as not to leak it\n          URL.revokeObjectURL(this.w.objectURL);\n          break;\n        // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects\n        case _events2.default.FRAG_PARSING_DATA:\n          data.data.data1 = new Uint8Array(data.data1);\n          if (data.data2) {\n            data.data.data2 = new Uint8Array(data.data2);\n          }\n        /* falls through */\n        default:\n          data.data = data.data || {};\n          data.data.frag = this.frag;\n          data.data.id = this.id;\n          hls.trigger(data.event, data.data);\n          break;\n      }\n    }\n  }]);\n\n  return Demuxer;\n}();\n\nexports.default = Demuxer;\n\n},{\"1\":1,\"23\":23,\"24\":24,\"3\":3,\"31\":31,\"33\":33,\"50\":50}],26:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _logger = _dereq_(50);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ExpGolomb = function () {\n  function ExpGolomb(data) {\n    _classCallCheck(this, ExpGolomb);\n\n    this.data = data;\n    // the number of bytes left to examine in this.data\n    this.bytesAvailable = data.byteLength;\n    // the current word being examined\n    this.word = 0; // :uint\n    // the number of bits left to examine in the current word\n    this.bitsAvailable = 0; // :uint\n  }\n\n  // ():void\n\n\n  _createClass(ExpGolomb, [{\n    key: 'loadWord',\n    value: function loadWord() {\n      var data = this.data,\n          bytesAvailable = this.bytesAvailable,\n          position = data.byteLength - bytesAvailable,\n          workingBytes = new Uint8Array(4),\n          availableBytes = Math.min(4, bytesAvailable);\n      if (availableBytes === 0) {\n        throw new Error('no bytes available');\n      }\n      workingBytes.set(data.subarray(position, position + availableBytes));\n      this.word = new DataView(workingBytes.buffer).getUint32(0);\n      // track the amount of this.data that has been processed\n      this.bitsAvailable = availableBytes * 8;\n      this.bytesAvailable -= availableBytes;\n    }\n\n    // (count:int):void\n\n  }, {\n    key: 'skipBits',\n    value: function skipBits(count) {\n      var skipBytes; // :int\n      if (this.bitsAvailable > count) {\n        this.word <<= count;\n        this.bitsAvailable -= count;\n      } else {\n        count -= this.bitsAvailable;\n        skipBytes = count >> 3;\n        count -= skipBytes >> 3;\n        this.bytesAvailable -= skipBytes;\n        this.loadWord();\n        this.word <<= count;\n        this.bitsAvailable -= count;\n      }\n    }\n\n    // (size:int):uint\n\n  }, {\n    key: 'readBits',\n    value: function readBits(size) {\n      var bits = Math.min(this.bitsAvailable, size),\n          // :uint\n      valu = this.word >>> 32 - bits; // :uint\n      if (size > 32) {\n        _logger.logger.error('Cannot read more than 32 bits at a time');\n      }\n      this.bitsAvailable -= bits;\n      if (this.bitsAvailable > 0) {\n        this.word <<= bits;\n      } else if (this.bytesAvailable > 0) {\n        this.loadWord();\n      }\n      bits = size - bits;\n      if (bits > 0 && this.bitsAvailable) {\n        return valu << bits | this.readBits(bits);\n      } else {\n        return valu;\n      }\n    }\n\n    // ():uint\n\n  }, {\n    key: 'skipLZ',\n    value: function skipLZ() {\n      var leadingZeroCount; // :uint\n      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n        if (0 !== (this.word & 0x80000000 >>> leadingZeroCount)) {\n          // the first bit of working word is 1\n          this.word <<= leadingZeroCount;\n          this.bitsAvailable -= leadingZeroCount;\n          return leadingZeroCount;\n        }\n      }\n      // we exhausted word and still have not found a 1\n      this.loadWord();\n      return leadingZeroCount + this.skipLZ();\n    }\n\n    // ():void\n\n  }, {\n    key: 'skipUEG',\n    value: function skipUEG() {\n      this.skipBits(1 + this.skipLZ());\n    }\n\n    // ():void\n\n  }, {\n    key: 'skipEG',\n    value: function skipEG() {\n      this.skipBits(1 + this.skipLZ());\n    }\n\n    // ():uint\n\n  }, {\n    key: 'readUEG',\n    value: function readUEG() {\n      var clz = this.skipLZ(); // :uint\n      return this.readBits(clz + 1) - 1;\n    }\n\n    // ():int\n\n  }, {\n    key: 'readEG',\n    value: function readEG() {\n      var valu = this.readUEG(); // :int\n      if (0x01 & valu) {\n        // the number is odd if the low order bit is set\n        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n      } else {\n        return -1 * (valu >>> 1); // divide by two then make it negative\n      }\n    }\n\n    // Some convenience functions\n    // :Boolean\n\n  }, {\n    key: 'readBoolean',\n    value: function readBoolean() {\n      return 1 === this.readBits(1);\n    }\n\n    // ():int\n\n  }, {\n    key: 'readUByte',\n    value: function readUByte() {\n      return this.readBits(8);\n    }\n\n    // ():int\n\n  }, {\n    key: 'readUShort',\n    value: function readUShort() {\n      return this.readBits(16);\n    }\n    // ():int\n\n  }, {\n    key: 'readUInt',\n    value: function readUInt() {\n      return this.readBits(32);\n    }\n\n    /**\n     * Advance the ExpGolomb decoder past a scaling list. The scaling\n     * list is optionally transmitted as part of a sequence parameter\n     * set and is not relevant to transmuxing.\n     * @param count {number} the number of entries in this scaling list\n     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n     */\n\n  }, {\n    key: 'skipScalingList',\n    value: function skipScalingList(count) {\n      var lastScale = 8,\n          nextScale = 8,\n          j,\n          deltaScale;\n      for (j = 0; j < count; j++) {\n        if (nextScale !== 0) {\n          deltaScale = this.readEG();\n          nextScale = (lastScale + deltaScale + 256) % 256;\n        }\n        lastScale = nextScale === 0 ? lastScale : nextScale;\n      }\n    }\n\n    /**\n     * Read a sequence parameter set and return some interesting video\n     * properties. A sequence parameter set is the H264 metadata that\n     * describes the properties of upcoming video frames.\n     * @param data {Uint8Array} the bytes of a sequence parameter set\n     * @return {object} an object with configuration parsed from the\n     * sequence parameter set, including the dimensions of the\n     * associated video frames.\n     */\n\n  }, {\n    key: 'readSPS',\n    value: function readSPS() {\n      var frameCropLeftOffset = 0,\n          frameCropRightOffset = 0,\n          frameCropTopOffset = 0,\n          frameCropBottomOffset = 0,\n          profileIdc,\n          profileCompat,\n          levelIdc,\n          numRefFramesInPicOrderCntCycle,\n          picWidthInMbsMinus1,\n          picHeightInMapUnitsMinus1,\n          frameMbsOnlyFlag,\n          scalingListCount,\n          i,\n          readUByte = this.readUByte.bind(this),\n          readBits = this.readBits.bind(this),\n          readUEG = this.readUEG.bind(this),\n          readBoolean = this.readBoolean.bind(this),\n          skipBits = this.skipBits.bind(this),\n          skipEG = this.skipEG.bind(this),\n          skipUEG = this.skipUEG.bind(this),\n          skipScalingList = this.skipScalingList.bind(this);\n\n      readUByte();\n      profileIdc = readUByte(); // profile_idc\n      profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)\n      skipBits(3); // reserved_zero_3bits u(3),\n      levelIdc = readUByte(); //level_idc u(8)\n      skipUEG(); // seq_parameter_set_id\n      // some profiles have more optional data we don't need\n      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n        var chromaFormatIdc = readUEG();\n        if (chromaFormatIdc === 3) {\n          skipBits(1); // separate_colour_plane_flag\n        }\n        skipUEG(); // bit_depth_luma_minus8\n        skipUEG(); // bit_depth_chroma_minus8\n        skipBits(1); // qpprime_y_zero_transform_bypass_flag\n        if (readBoolean()) {\n          // seq_scaling_matrix_present_flag\n          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n          for (i = 0; i < scalingListCount; i++) {\n            if (readBoolean()) {\n              // seq_scaling_list_present_flag[ i ]\n              if (i < 6) {\n                skipScalingList(16);\n              } else {\n                skipScalingList(64);\n              }\n            }\n          }\n        }\n      }\n      skipUEG(); // log2_max_frame_num_minus4\n      var picOrderCntType = readUEG();\n      if (picOrderCntType === 0) {\n        readUEG(); //log2_max_pic_order_cnt_lsb_minus4\n      } else if (picOrderCntType === 1) {\n        skipBits(1); // delta_pic_order_always_zero_flag\n        skipEG(); // offset_for_non_ref_pic\n        skipEG(); // offset_for_top_to_bottom_field\n        numRefFramesInPicOrderCntCycle = readUEG();\n        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n          skipEG(); // offset_for_ref_frame[ i ]\n        }\n      }\n      skipUEG(); // max_num_ref_frames\n      skipBits(1); // gaps_in_frame_num_value_allowed_flag\n      picWidthInMbsMinus1 = readUEG();\n      picHeightInMapUnitsMinus1 = readUEG();\n      frameMbsOnlyFlag = readBits(1);\n      if (frameMbsOnlyFlag === 0) {\n        skipBits(1); // mb_adaptive_frame_field_flag\n      }\n      skipBits(1); // direct_8x8_inference_flag\n      if (readBoolean()) {\n        // frame_cropping_flag\n        frameCropLeftOffset = readUEG();\n        frameCropRightOffset = readUEG();\n        frameCropTopOffset = readUEG();\n        frameCropBottomOffset = readUEG();\n      }\n      var pixelRatio = [1, 1];\n      if (readBoolean()) {\n        // vui_parameters_present_flag\n        if (readBoolean()) {\n          // aspect_ratio_info_present_flag\n          var aspectRatioIdc = readUByte();\n          switch (aspectRatioIdc) {\n            case 1:\n              pixelRatio = [1, 1];break;\n            case 2:\n              pixelRatio = [12, 11];break;\n            case 3:\n              pixelRatio = [10, 11];break;\n            case 4:\n              pixelRatio = [16, 11];break;\n            case 5:\n              pixelRatio = [40, 33];break;\n            case 6:\n              pixelRatio = [24, 11];break;\n            case 7:\n              pixelRatio = [20, 11];break;\n            case 8:\n              pixelRatio = [32, 11];break;\n            case 9:\n              pixelRatio = [80, 33];break;\n            case 10:\n              pixelRatio = [18, 11];break;\n            case 11:\n              pixelRatio = [15, 11];break;\n            case 12:\n              pixelRatio = [64, 33];break;\n            case 13:\n              pixelRatio = [160, 99];break;\n            case 14:\n              pixelRatio = [4, 3];break;\n            case 15:\n              pixelRatio = [3, 2];break;\n            case 16:\n              pixelRatio = [2, 1];break;\n            case 255:\n              {\n                pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n                break;\n              }\n          }\n        }\n      }\n      return {\n        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n        pixelRatio: pixelRatio\n      };\n    }\n  }, {\n    key: 'readSliceType',\n    value: function readSliceType() {\n      // skip NALu type\n      this.readUByte();\n      // discard first_mb_in_slice\n      this.readUEG();\n      // return slice_type\n      return this.readUEG();\n    }\n  }]);\n\n  return ExpGolomb;\n}();\n\nexports.default = ExpGolomb;\n\n},{\"50\":50}],27:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ID3 parser\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _logger = _dereq_(50);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//import Hex from '../utils/hex';\n\nvar ID3 = function () {\n  function ID3(data) {\n    _classCallCheck(this, ID3);\n\n    this._hasTimeStamp = false;\n    var offset = 0,\n        byte1,\n        byte2,\n        byte3,\n        byte4,\n        tagSize,\n        endPos,\n        header,\n        len;\n    do {\n      header = this.readUTF(data, offset, 3);\n      offset += 3;\n      // first check for ID3 header\n      if (header === 'ID3') {\n        // skip 24 bits\n        offset += 3;\n        // retrieve tag(s) length\n        byte1 = data[offset++] & 0x7f;\n        byte2 = data[offset++] & 0x7f;\n        byte3 = data[offset++] & 0x7f;\n        byte4 = data[offset++] & 0x7f;\n        tagSize = (byte1 << 21) + (byte2 << 14) + (byte3 << 7) + byte4;\n        endPos = offset + tagSize;\n        //logger.log(`ID3 tag found, size/end: ${tagSize}/${endPos}`);\n\n        // read ID3 tags\n        this._parseID3Frames(data, offset, endPos);\n        offset = endPos;\n      } else if (header === '3DI') {\n        // http://id3.org/id3v2.4.0-structure chapter 3.4.   ID3v2 footer\n        offset += 7;\n        _logger.logger.log('3DI footer found, end: ' + offset);\n      } else {\n        offset -= 3;\n        len = offset;\n        if (len) {\n          //logger.log(`ID3 len: ${len}`);\n          if (!this.hasTimeStamp) {\n            _logger.logger.warn('ID3 tag found, but no timestamp');\n          }\n          this._length = len;\n          this._payload = data.subarray(0, len);\n        }\n        return;\n      }\n    } while (true);\n  }\n\n  _createClass(ID3, [{\n    key: 'readUTF',\n    value: function readUTF(data, start, len) {\n\n      var result = '',\n          offset = start,\n          end = start + len;\n      do {\n        result += String.fromCharCode(data[offset++]);\n      } while (offset < end);\n      return result;\n    }\n  }, {\n    key: '_parseID3Frames',\n    value: function _parseID3Frames(data, offset, endPos) {\n      var tagId, tagLen, tagStart, tagFlags, timestamp;\n      while (offset + 8 <= endPos) {\n        tagId = this.readUTF(data, offset, 4);\n        offset += 4;\n\n        tagLen = data[offset++] << 24 + data[offset++] << 16 + data[offset++] << 8 + data[offset++];\n\n        tagFlags = data[offset++] << 8 + data[offset++];\n\n        tagStart = offset;\n        //logger.log(\"ID3 tag id:\" + tagId);\n        switch (tagId) {\n          case 'PRIV':\n            //logger.log('parse frame:' + Hex.hexDump(data.subarray(offset,endPos)));\n            // owner should be \"com.apple.streaming.transportStreamTimestamp\"\n            if (this.readUTF(data, offset, 44) === 'com.apple.streaming.transportStreamTimestamp') {\n              offset += 44;\n              // smelling even better ! we found the right descriptor\n              // skip null character (string end) + 3 first bytes\n              offset += 4;\n\n              // timestamp is 33 bit expressed as a big-endian eight-octet number, with the upper 31 bits set to zero.\n              var pts33Bit = data[offset++] & 0x1;\n              this._hasTimeStamp = true;\n\n              timestamp = ((data[offset++] << 23) + (data[offset++] << 15) + (data[offset++] << 7) + data[offset++]) / 45;\n\n              if (pts33Bit) {\n                timestamp += 47721858.84; // 2^32 / 90\n              }\n              timestamp = Math.round(timestamp);\n              _logger.logger.trace('ID3 timestamp found: ' + timestamp);\n              this._timeStamp = timestamp;\n            }\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  }, {\n    key: 'hasTimeStamp',\n    get: function get() {\n      return this._hasTimeStamp;\n    }\n  }, {\n    key: 'timeStamp',\n    get: function get() {\n      return this._timeStamp;\n    }\n  }, {\n    key: 'length',\n    get: function get() {\n      return this._length;\n    }\n  }, {\n    key: 'payload',\n    get: function get() {\n      return this._payload;\n    }\n  }]);\n\n  return ID3;\n}();\n\nexports.default = ID3;\n\n},{\"50\":50}],28:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP4 demuxer\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n//import {logger} from '../utils/logger';\n\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MP4Demuxer = function () {\n  function MP4Demuxer(observer, remuxer) {\n    _classCallCheck(this, MP4Demuxer);\n\n    this.observer = observer;\n    this.remuxer = remuxer;\n  }\n\n  _createClass(MP4Demuxer, [{\n    key: 'resetTimeStamp',\n    value: function resetTimeStamp() {}\n  }, {\n    key: 'resetInitSegment',\n    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {\n      //jshint unused:false\n      var initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);\n      var tracks = {};\n      if (initData.audio) {\n        tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: initSegment };\n      }\n      if (initData.video) {\n        tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: initSegment };\n      }\n      this.observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, { unique: false, tracks: tracks });\n    }\n  }, {\n    key: 'append',\n\n\n    // feed incoming data to the front of the parsing pipeline\n    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {\n      var initData = this.initData;\n      var startDTS = MP4Demuxer.startDTS(initData, data);\n      this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {}\n  }], [{\n    key: 'probe',\n    value: function probe(data) {\n      if (data.length >= 8) {\n        var dataType = MP4Demuxer.bin2str(data.subarray(4, 8));\n        return ['moof', 'ftyp', 'styp'].indexOf(dataType) >= 0;\n      }\n      return false;\n    }\n  }, {\n    key: 'bin2str',\n    value: function bin2str(buffer) {\n      return String.fromCharCode.apply(null, buffer);\n    }\n\n    // Find the data for a box specified by its path\n\n  }, {\n    key: 'findBox',\n    value: function findBox(data, path) {\n      var results = [],\n          i,\n          size,\n          type,\n          end,\n          subresults;\n\n      if (!path.length) {\n        // short-circuit the search for empty paths\n        return null;\n      }\n\n      for (i = 0; i < data.byteLength;) {\n        size = data[i] << 24;\n        size |= data[i + 1] << 16;\n        size |= data[i + 2] << 8;\n        size |= data[i + 3];\n\n        type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));\n\n        end = size > 1 ? i + size : data.byteLength;\n\n        if (type === path[0]) {\n          if (path.length === 1) {\n            // this is the end of the path and we've found the box we were\n            // looking for\n            results.push(data.subarray(i + 8, end));\n          } else {\n            // recursively search for the next box along the path\n            subresults = MP4Demuxer.findBox(data.subarray(i + 8, end), path.slice(1));\n            if (subresults.length) {\n              results = results.concat(subresults);\n            }\n          }\n        }\n        i = end;\n      }\n\n      // we've finished searching all of data\n      return results;\n    }\n\n    /**\n     * Parses an MP4 initialization segment and extracts stream type and\n     * timescale values for any declared tracks. Timescale values indicate the\n     * number of clock ticks per second to assume for time-based values\n     * elsewhere in the MP4.\n     *\n     * To determine the start time of an MP4, you need two pieces of\n     * information: the timescale unit and the earliest base media decode\n     * time. Multiple timescales can be specified within an MP4 but the\n     * base media decode time is always expressed in the timescale from\n     * the media header box for the track:\n     * ```\n     * moov > trak > mdia > mdhd.timescale\n     * moov > trak > mdia > hdlr\n     * ```\n     * @param init {Uint8Array} the bytes of the init segment\n     * @return {object} a hash of track type to timescale values or null if\n     * the init segment is malformed.\n     */\n\n  }, {\n    key: 'parseInitSegment',\n    value: function parseInitSegment(initSegment) {\n      var result = [];\n      var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);\n\n      traks.forEach(function (trak) {\n        var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];\n        if (tkhd) {\n          var version = tkhd[0];\n          var index = version === 0 ? 12 : 20;\n          var trackId = tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3];\n\n          trackId = trackId < 0 ? 4294967296 + trackId : trackId;\n\n          var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];\n          if (mdhd) {\n            version = mdhd[0];\n            index = version === 0 ? 12 : 20;\n            var timescale = mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3];\n\n            var hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];\n            if (hdlr) {\n              var hdlrType = MP4Demuxer.bin2str(hdlr.subarray(8, 12));\n              var type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];\n              if (type) {\n                result[trackId] = { timescale: timescale, type: type };\n                result[type] = { timescale: timescale, id: trackId };\n              }\n            }\n          }\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Determine the base media decode start time, in seconds, for an MP4\n     * fragment. If multiple fragments are specified, the earliest time is\n     * returned.\n     *\n     * The base media decode time can be parsed from track fragment\n     * metadata:\n     * ```\n     * moof > traf > tfdt.baseMediaDecodeTime\n     * ```\n     * It requires the timescale value from the mdhd to interpret.\n     *\n     * @param timescale {object} a hash of track ids to timescale values.\n     * @return {number} the earliest base media decode start time for the\n     * fragment, in seconds\n     */\n\n  }, {\n    key: 'startDTS',\n    value: function startDTS(initData, fragment) {\n      var trafs, baseTimes, result;\n\n      // we need info from two childrend of each track fragment box\n      trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);\n\n      // determine the start times for each track\n      baseTimes = [].concat.apply([], trafs.map(function (traf) {\n        return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {\n          var id, scale, baseTime;\n\n          // get the track id from the tfhd\n          id = tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7];\n          // assume a 90kHz clock if no timescale was specified\n          scale = initData[id].timescale || 90e3;\n\n          // get the base media decode time from the tfdt\n          baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {\n            var version, result;\n\n            version = tfdt[0];\n            result = tfdt[4] << 24 | tfdt[5] << 16 | tfdt[6] << 8 | tfdt[7];\n            if (version === 1) {\n              result *= Math.pow(2, 32);\n              result += tfdt[8] << 24 | tfdt[9] << 16 | tfdt[10] << 8 | tfdt[11];\n            }\n            return result;\n          })[0];\n          baseTime = baseTime || Infinity;\n\n          // convert base time to seconds\n          return baseTime / scale;\n        });\n      }));\n\n      // return the minimum\n      result = Math.min.apply(null, baseTimes);\n      return isFinite(result) ? result : 0;\n    }\n  }]);\n\n  return MP4Demuxer;\n}();\n\nexports.default = MP4Demuxer;\n\n},{\"33\":33}],29:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SAMPLE-AES decrypter\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _decrypter = _dereq_(19);\n\nvar _decrypter2 = _interopRequireDefault(_decrypter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SampleAesDecrypter = function () {\n  function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {\n    _classCallCheck(this, SampleAesDecrypter);\n\n    this.decryptdata = decryptdata;\n    this.discardEPB = discardEPB;\n    this.decrypter = new _decrypter2.default(observer, config);\n  }\n\n  _createClass(SampleAesDecrypter, [{\n    key: 'decryptBuffer',\n    value: function decryptBuffer(encryptedData, callback) {\n      this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);\n    }\n\n    // AAC - encrypt all full 16 bytes blocks starting from offset 16\n\n  }, {\n    key: 'decryptAacSample',\n    value: function decryptAacSample(samples, sampleIndex, callback, sync) {\n      var curUnit = samples[sampleIndex].unit;\n      var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n      var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n\n      var localthis = this;\n      this.decryptBuffer(encryptedBuffer, function (decryptedData) {\n        decryptedData = new Uint8Array(decryptedData);\n        curUnit.set(decryptedData, 16);\n\n        if (!sync) {\n          localthis.decryptAacSamples(samples, sampleIndex + 1, callback);\n        }\n      });\n    }\n  }, {\n    key: 'decryptAacSamples',\n    value: function decryptAacSamples(samples, sampleIndex, callback) {\n      for (;; sampleIndex++) {\n        if (sampleIndex >= samples.length) {\n          callback();\n          return;\n        }\n\n        if (samples[sampleIndex].unit.length < 32) {\n          continue;\n        }\n\n        var sync = this.decrypter.isSync();\n\n        this.decryptAacSample(samples, sampleIndex, callback, sync);\n\n        if (!sync) {\n          return;\n        }\n      }\n    }\n\n    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n\n  }, {\n    key: 'getAvcEncryptedData',\n    value: function getAvcEncryptedData(decodedData) {\n      var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n      var encryptedData = new Int8Array(encryptedDataLen);\n      var outputPos = 0;\n      for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {\n        encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n      }\n      return encryptedData;\n    }\n  }, {\n    key: 'getAvcDecryptedUnit',\n    value: function getAvcDecryptedUnit(decodedData, decryptedData) {\n      decryptedData = new Uint8Array(decryptedData);\n      var inputPos = 0;\n      for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {\n        decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);\n      }\n      return decodedData;\n    }\n  }, {\n    key: 'decryptAvcSample',\n    value: function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {\n      var decodedData = this.discardEPB(curUnit.data);\n      var encryptedData = this.getAvcEncryptedData(decodedData);\n      var localthis = this;\n\n      this.decryptBuffer(encryptedData.buffer, function (decryptedData) {\n        curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);\n\n        if (!sync) {\n          localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n        }\n      });\n    }\n  }, {\n    key: 'decryptAvcSamples',\n    value: function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n      for (;; sampleIndex++, unitIndex = 0) {\n        if (sampleIndex >= samples.length) {\n          callback();\n          return;\n        }\n\n        var curUnits = samples[sampleIndex].units.units;\n        for (;; unitIndex++) {\n          if (unitIndex >= curUnits.length) {\n            break;\n          }\n\n          var curUnit = curUnits[unitIndex];\n          if (curUnit.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n            continue;\n          }\n\n          var sync = this.decrypter.isSync();\n\n          this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);\n\n          if (!sync) {\n            return;\n          }\n        }\n      }\n    }\n  }]);\n\n  return SampleAesDecrypter;\n}();\n\nexports.default = SampleAesDecrypter;\n\n},{\"19\":19}],30:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\n// import Hex from '../utils/hex';\n\n\nvar _adts = _dereq_(22);\n\nvar _adts2 = _interopRequireDefault(_adts);\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _expGolomb = _dereq_(26);\n\nvar _expGolomb2 = _interopRequireDefault(_expGolomb);\n\nvar _sampleAes = _dereq_(29);\n\nvar _sampleAes2 = _interopRequireDefault(_sampleAes);\n\nvar _logger = _dereq_(50);\n\nvar _errors = _dereq_(31);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TSDemuxer = function () {\n  function TSDemuxer(observer, remuxer, config, typeSupported) {\n    _classCallCheck(this, TSDemuxer);\n\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.remuxer = remuxer;\n    this.sampleAes = null;\n  }\n\n  _createClass(TSDemuxer, [{\n    key: 'setDecryptData',\n    value: function setDecryptData(decryptdata) {\n      if (decryptdata != null && decryptdata.key != null && decryptdata.method === 'SAMPLE-AES') {\n        this.sampleAes = new _sampleAes2.default(this.observer, this.config, decryptdata, this.discardEPB);\n      } else {\n        this.sampleAes = null;\n      }\n    }\n  }, {\n    key: 'resetInitSegment',\n    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {\n      this.pmtParsed = false;\n      this._pmtId = -1;\n      this._avcTrack = { container: 'video/mp2t', type: 'video', id: -1, sequenceNumber: 0, samples: [], len: 0, dropped: 0 };\n      this._audioTrack = { container: 'video/mp2t', type: 'audio', id: -1, sequenceNumber: 0, samples: [], len: 0, isAAC: true };\n      this._id3Track = { type: 'id3', id: -1, sequenceNumber: 0, samples: [], len: 0 };\n      this._txtTrack = { type: 'text', id: -1, sequenceNumber: 0, samples: [], len: 0 };\n      // flush any partial content\n      this.aacOverFlow = null;\n      this.aacLastPTS = null;\n      this.avcSample = null;\n      this.audioCodec = audioCodec;\n      this.videoCodec = videoCodec;\n      this._duration = duration;\n    }\n  }, {\n    key: 'resetTimeStamp',\n    value: function resetTimeStamp() {}\n\n    // feed incoming data to the front of the parsing pipeline\n\n  }, {\n    key: 'append',\n    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {\n      var start,\n          len = data.length,\n          stt,\n          pid,\n          atf,\n          offset,\n          pes,\n          unknownPIDs = false;\n      this.contiguous = contiguous;\n      var pmtParsed = this.pmtParsed,\n          avcTrack = this._avcTrack,\n          audioTrack = this._audioTrack,\n          id3Track = this._id3Track,\n          avcId = avcTrack.id,\n          audioId = audioTrack.id,\n          id3Id = id3Track.id,\n          pmtId = this._pmtId,\n          avcData = avcTrack.pesData,\n          audioData = audioTrack.pesData,\n          id3Data = id3Track.pesData,\n          parsePAT = this._parsePAT,\n          parsePMT = this._parsePMT,\n          parsePES = this._parsePES,\n          parseAVCPES = this._parseAVCPES.bind(this),\n          parseAACPES = this._parseAACPES.bind(this),\n          parseMPEGPES = this._parseMPEGPES.bind(this),\n          parseID3PES = this._parseID3PES.bind(this);\n\n      // don't parse last TS packet if incomplete\n      len -= len % 188;\n      // loop through TS packets\n      for (start = 0; start < len; start += 188) {\n        if (data[start] === 0x47) {\n          stt = !!(data[start + 1] & 0x40);\n          // pid is a 13-bit field starting at the last bit of TS[1]\n          pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];\n          atf = (data[start + 3] & 0x30) >> 4;\n          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n          if (atf > 1) {\n            offset = start + 5 + data[start + 4];\n            // continue if there is only adaptation field\n            if (offset === start + 188) {\n              continue;\n            }\n          } else {\n            offset = start + 4;\n          }\n          switch (pid) {\n            case avcId:\n              if (stt) {\n                if (avcData && (pes = parsePES(avcData))) {\n                  parseAVCPES(pes, false);\n                }\n                avcData = { data: [], size: 0 };\n              }\n              if (avcData) {\n                avcData.data.push(data.subarray(offset, start + 188));\n                avcData.size += start + 188 - offset;\n              }\n              break;\n            case audioId:\n              if (stt) {\n                if (audioData && (pes = parsePES(audioData))) {\n                  if (audioTrack.isAAC) {\n                    parseAACPES(pes);\n                  } else {\n                    parseMPEGPES(pes);\n                  }\n                }\n                audioData = { data: [], size: 0 };\n              }\n              if (audioData) {\n                audioData.data.push(data.subarray(offset, start + 188));\n                audioData.size += start + 188 - offset;\n              }\n              break;\n            case id3Id:\n              if (stt) {\n                if (id3Data && (pes = parsePES(id3Data))) {\n                  parseID3PES(pes);\n                }\n                id3Data = { data: [], size: 0 };\n              }\n              if (id3Data) {\n                id3Data.data.push(data.subarray(offset, start + 188));\n                id3Data.size += start + 188 - offset;\n              }\n              break;\n            case 0:\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n              pmtId = this._pmtId = parsePAT(data, offset);\n              break;\n            case pmtId:\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n              var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);\n\n              // only update track id if track PID found while parsing PMT\n              // this is to avoid resetting the PID to -1 in case\n              // track PID transiently disappears from the stream\n              // this could happen in case of transient missing audio samples for example\n              avcId = parsedPIDs.avc;\n              if (avcId > 0) {\n                avcTrack.id = avcId;\n              }\n              audioId = parsedPIDs.audio;\n              if (audioId > 0) {\n                audioTrack.id = audioId;\n                audioTrack.isAAC = parsedPIDs.isAAC;\n              }\n              id3Id = parsedPIDs.id3;\n              if (id3Id > 0) {\n                id3Track.id = id3Id;\n              }\n              if (unknownPIDs && !pmtParsed) {\n                _logger.logger.log('reparse from beginning');\n                unknownPIDs = false;\n                // we set it to -188, the += 188 in the for loop will reset start to 0\n                start = -188;\n              }\n              pmtParsed = this.pmtParsed = true;\n              break;\n            case 17:\n            case 0x1fff:\n              break;\n            default:\n              unknownPIDs = true;\n              break;\n          }\n        } else {\n          this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });\n        }\n      }\n      // try to parse last PES packets\n      if (avcData && (pes = parsePES(avcData))) {\n        parseAVCPES(pes, true);\n        avcTrack.pesData = null;\n      } else {\n        // either avcData null or PES truncated, keep it for next frag parsing\n        avcTrack.pesData = avcData;\n      }\n\n      if (audioData && (pes = parsePES(audioData))) {\n        if (audioTrack.isAAC) {\n          parseAACPES(pes);\n        } else {\n          parseMPEGPES(pes);\n        }\n        audioTrack.pesData = null;\n      } else {\n        if (audioData && audioData.size) {\n          _logger.logger.log('last AAC PES packet truncated,might overlap between fragments');\n        }\n        // either audioData null or PES truncated, keep it for next frag parsing\n        audioTrack.pesData = audioData;\n      }\n\n      if (id3Data && (pes = parsePES(id3Data))) {\n        parseID3PES(pes);\n        id3Track.pesData = null;\n      } else {\n        // either id3Data null or PES truncated, keep it for next frag parsing\n        id3Track.pesData = id3Data;\n      }\n\n      if (this.sampleAes == null) {\n        this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);\n      } else {\n        this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);\n      }\n    }\n  }, {\n    key: 'decryptAndRemux',\n    value: function decryptAndRemux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {\n      var _this = this;\n\n      if (audioTrack.samples && audioTrack.isAAC) {\n        (function () {\n          var localthis = _this;\n          _this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {\n            localthis.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);\n          });\n        })();\n      } else {\n        this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);\n      }\n    }\n  }, {\n    key: 'decryptAndRemuxAvc',\n    value: function decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {\n      var _this2 = this;\n\n      if (videoTrack.samples) {\n        (function () {\n          var localthis = _this2;\n          _this2.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n            localthis.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);\n          });\n        })();\n      } else {\n        this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this._initPTS = this._initDTS = undefined;\n      this._duration = 0;\n    }\n  }, {\n    key: '_parsePAT',\n    value: function _parsePAT(data, offset) {\n      // skip the PSI header and parse the first PMT entry\n      return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];\n      //logger.log('PMT PID:'  + this._pmtId);\n    }\n  }, {\n    key: '_parsePMT',\n    value: function _parsePMT(data, offset, mpegSupported, isSampleAes) {\n      var sectionLength,\n          tableEnd,\n          programInfoLength,\n          pid,\n          result = { audio: -1, avc: -1, id3: -1, isAAC: true };\n      sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n      tableEnd = offset + 3 + sectionLength - 4;\n      // to determine where the table is, we have to figure out how\n      // long the program info descriptors are\n      programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n      // advance the offset to the first entry in the mapping table\n      offset += 12 + programInfoLength;\n      while (offset < tableEnd) {\n        pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];\n        switch (data[offset]) {\n          case 0xcf:\n            // SAMPLE-AES AAC\n            if (!isSampleAes) {\n              _logger.logger.log('unkown stream type:' + data[offset]);\n              break;\n            }\n          /* falls through */\n\n          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n          case 0x0f:\n            //logger.log('AAC PID:'  + pid);\n            if (result.audio === -1) {\n              result.audio = pid;\n            }\n            break;\n\n          // Packetized metadata (ID3)\n          case 0x15:\n            //logger.log('ID3 PID:'  + pid);\n            if (result.id3 === -1) {\n              result.id3 = pid;\n            }\n            break;\n\n          case 0xdb:\n            // SAMPLE-AES AVC\n            if (!isSampleAes) {\n              _logger.logger.log('unkown stream type:' + data[offset]);\n              break;\n            }\n          /* falls through */\n\n          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n          case 0x1b:\n            //logger.log('AVC PID:'  + pid);\n            if (result.avc === -1) {\n              result.avc = pid;\n            }\n            break;\n\n          // ISO/IEC 11172-3 (MPEG-1 audio)\n          // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n          case 0x03:\n          case 0x04:\n            //logger.log('MPEG PID:'  + pid);\n            if (!mpegSupported) {\n              _logger.logger.log('MPEG audio found, not supported in this browser for now');\n            } else if (result.audio === -1) {\n              result.audio = pid;\n              result.isAAC = false;\n            }\n            break;\n\n          case 0x24:\n            _logger.logger.warn('HEVC stream type found, not supported for now');\n            break;\n\n          default:\n            _logger.logger.log('unkown stream type:' + data[offset]);\n            break;\n        }\n        // move to the next table entry\n        // skip past the elementary stream descriptors, if present\n        offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;\n      }\n      return result;\n    }\n  }, {\n    key: '_parsePES',\n    value: function _parsePES(stream) {\n      var i = 0,\n          frag,\n          pesFlags,\n          pesPrefix,\n          pesLen,\n          pesHdrLen,\n          pesData,\n          pesPts,\n          pesDts,\n          payloadStartOffset,\n          data = stream.data;\n      // safety check\n      if (!stream || stream.size === 0) {\n        return null;\n      }\n\n      // we might need up to 19 bytes to read PES header\n      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n      // usually only one merge is needed (and this is rare ...)\n      while (data[0].length < 19 && data.length > 1) {\n        var newData = new Uint8Array(data[0].length + data[1].length);\n        newData.set(data[0]);\n        newData.set(data[1], data[0].length);\n        data[0] = newData;\n        data.splice(1, 1);\n      }\n      //retrieve PTS/DTS from first fragment\n      frag = data[0];\n      pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n      if (pesPrefix === 1) {\n        pesLen = (frag[4] << 8) + frag[5];\n        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n        // minus 6 : PES header size\n        if (pesLen && pesLen > stream.size - 6) {\n          return null;\n        }\n        pesFlags = frag[7];\n        if (pesFlags & 0xC0) {\n          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n              as Bitwise operators treat their operands as a sequence of 32 bits */\n          pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29\n          (frag[10] & 0xFF) * 4194304 + // 1 << 22\n          (frag[11] & 0xFE) * 16384 + // 1 << 14\n          (frag[12] & 0xFF) * 128 + // 1 << 7\n          (frag[13] & 0xFE) / 2;\n          // check if greater than 2^32 -1\n          if (pesPts > 4294967295) {\n            // decrement 2^33\n            pesPts -= 8589934592;\n          }\n          if (pesFlags & 0x40) {\n            pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29\n            (frag[15] & 0xFF) * 4194304 + // 1 << 22\n            (frag[16] & 0xFE) * 16384 + // 1 << 14\n            (frag[17] & 0xFF) * 128 + // 1 << 7\n            (frag[18] & 0xFE) / 2;\n            // check if greater than 2^32 -1\n            if (pesDts > 4294967295) {\n              // decrement 2^33\n              pesDts -= 8589934592;\n            }\n            if (pesPts - pesDts > 60 * 90000) {\n              _logger.logger.warn(Math.round((pesPts - pesDts) / 90000) + 's delta between PTS and DTS, align them');\n              pesPts = pesDts;\n            }\n          } else {\n            pesDts = pesPts;\n          }\n        }\n        pesHdrLen = frag[8];\n        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n        payloadStartOffset = pesHdrLen + 9;\n\n        stream.size -= payloadStartOffset;\n        //reassemble PES packet\n        pesData = new Uint8Array(stream.size);\n        for (var j = 0, dataLen = data.length; j < dataLen; j++) {\n          frag = data[j];\n          var len = frag.byteLength;\n          if (payloadStartOffset) {\n            if (payloadStartOffset > len) {\n              // trim full frag if PES header bigger than frag\n              payloadStartOffset -= len;\n              continue;\n            } else {\n              // trim partial frag if PES header smaller than frag\n              frag = frag.subarray(payloadStartOffset);\n              len -= payloadStartOffset;\n              payloadStartOffset = 0;\n            }\n          }\n          pesData.set(frag, i);\n          i += len;\n        }\n        if (pesLen) {\n          // payload size : remove PES header + PES extension\n          pesLen -= pesHdrLen + 3;\n        }\n        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: 'pushAccesUnit',\n    value: function pushAccesUnit(avcSample, avcTrack) {\n      if (avcSample.units.units.length && avcSample.frame) {\n        // only push AVC sample if starting with a keyframe is not mandatory OR\n        //    if keyframe already found in this fragment OR\n        //       keyframe found in last fragment (track.sps) AND\n        //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous\n        if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (avcTrack.samples.length || this.contiguous)) {\n          avcTrack.samples.push(avcSample);\n        } else {\n          // dropped samples, track it\n          avcTrack.dropped++;\n        }\n      }\n      if (avcSample.debug.length) {\n        _logger.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug + ',' + avcSample.units.length);\n      }\n    }\n  }, {\n    key: '_parseAVCPES',\n    value: function _parseAVCPES(pes, last) {\n      var _this3 = this;\n\n      //logger.log('parse new PES');\n      var track = this._avcTrack,\n          units = this._parseAVCNALu(pes.data),\n          debug = false,\n          expGolombDecoder,\n          avcSample = this.avcSample,\n          push,\n          i;\n      //free pes.data to save up some memory\n      pes.data = null;\n\n      units.forEach(function (unit) {\n        switch (unit.type) {\n          //NDR\n          case 1:\n            push = true;\n            if (debug && avcSample) {\n              avcSample.debug += 'NDR ';\n            }\n            avcSample.frame = true;\n            // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n            var data = unit.data;\n            if (data.length > 4) {\n              var sliceType = new _expGolomb2.default(data).readSliceType();\n              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n              //if (sliceType === 2 || sliceType === 7) {\n              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                avcSample.key = true;\n              }\n            }\n            break;\n          //IDR\n          case 5:\n            push = true;\n            // handle PES not starting with AUD\n            if (!avcSample) {\n              avcSample = _this3.avcSample = _this3._createAVCSample(true, pes.pts, pes.dts, '');\n            }\n            if (debug) {\n              avcSample.debug += 'IDR ';\n            }\n            avcSample.key = true;\n            avcSample.frame = true;\n            break;\n          //SEI\n          case 6:\n            push = true;\n            if (debug && avcSample) {\n              avcSample.debug += 'SEI ';\n            }\n            expGolombDecoder = new _expGolomb2.default(_this3.discardEPB(unit.data));\n\n            // skip frameType\n            expGolombDecoder.readUByte();\n\n            var payloadType = 0;\n            var payloadSize = 0;\n            var endOfCaptions = false;\n            var b = 0;\n\n            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {\n              payloadType = 0;\n              do {\n                b = expGolombDecoder.readUByte();\n                payloadType += b;\n              } while (b === 0xFF);\n\n              // Parse payload size.\n              payloadSize = 0;\n              do {\n                b = expGolombDecoder.readUByte();\n                payloadSize += b;\n              } while (b === 0xFF);\n\n              // TODO: there can be more than one payload in an SEI packet...\n              // TODO: need to read type and size in a while loop to get them all\n              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {\n\n                endOfCaptions = true;\n\n                var countryCode = expGolombDecoder.readUByte();\n\n                if (countryCode === 181) {\n                  var providerCode = expGolombDecoder.readUShort();\n\n                  if (providerCode === 49) {\n                    var userStructure = expGolombDecoder.readUInt();\n\n                    if (userStructure === 0x47413934) {\n                      var userDataType = expGolombDecoder.readUByte();\n\n                      // Raw CEA-608 bytes wrapped in CEA-708 packet\n                      if (userDataType === 3) {\n                        var firstByte = expGolombDecoder.readUByte();\n                        var secondByte = expGolombDecoder.readUByte();\n\n                        var totalCCs = 31 & firstByte;\n                        var byteArray = [firstByte, secondByte];\n\n                        for (i = 0; i < totalCCs; i++) {\n                          // 3 bytes per CC\n                          byteArray.push(expGolombDecoder.readUByte());\n                          byteArray.push(expGolombDecoder.readUByte());\n                          byteArray.push(expGolombDecoder.readUByte());\n                        }\n\n                        _this3._insertSampleInOrder(_this3._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });\n                      }\n                    }\n                  }\n                }\n              } else if (payloadSize < expGolombDecoder.bytesAvailable) {\n                for (i = 0; i < payloadSize; i++) {\n                  expGolombDecoder.readUByte();\n                }\n              }\n            }\n            break;\n          //SPS\n          case 7:\n            push = true;\n            if (debug && avcSample) {\n              avcSample.debug += 'SPS ';\n            }\n            if (!track.sps) {\n              expGolombDecoder = new _expGolomb2.default(unit.data);\n              var config = expGolombDecoder.readSPS();\n              track.width = config.width;\n              track.height = config.height;\n              track.pixelRatio = config.pixelRatio;\n              track.sps = [unit.data];\n              track.duration = _this3._duration;\n              var codecarray = unit.data.subarray(1, 4);\n              var codecstring = 'avc1.';\n              for (i = 0; i < 3; i++) {\n                var h = codecarray[i].toString(16);\n                if (h.length < 2) {\n                  h = '0' + h;\n                }\n                codecstring += h;\n              }\n              track.codec = codecstring;\n            }\n            break;\n          //PPS\n          case 8:\n            push = true;\n            if (debug && avcSample) {\n              avcSample.debug += 'PPS ';\n            }\n            if (!track.pps) {\n              track.pps = [unit.data];\n            }\n            break;\n          // AUD\n          case 9:\n            push = false;\n            if (avcSample) {\n              _this3.pushAccesUnit(avcSample, track);\n            }\n            avcSample = _this3.avcSample = _this3._createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');\n            break;\n          // Filler Data\n          case 12:\n            push = false;\n            break;\n          default:\n            push = false;\n            if (avcSample) {\n              avcSample.debug += 'unknown NAL ' + unit.type + ' ';\n            }\n            break;\n        }\n        if (avcSample && push) {\n          var _units = avcSample.units;\n          _units.units.push(unit);\n        }\n      });\n      // if last PES packet, push samples\n      if (last && avcSample) {\n        this.pushAccesUnit(avcSample, track);\n        this.avcSample = null;\n      }\n    }\n  }, {\n    key: '_createAVCSample',\n    value: function _createAVCSample(key, pts, dts, debug) {\n      return { key: key, pts: pts, dts: dts, units: { units: [], length: 0 }, debug: debug };\n    }\n  }, {\n    key: '_insertSampleInOrder',\n    value: function _insertSampleInOrder(arr, data) {\n      var len = arr.length;\n      if (len > 0) {\n        if (data.pts >= arr[len - 1].pts) {\n          arr.push(data);\n        } else {\n          for (var pos = len - 1; pos >= 0; pos--) {\n            if (data.pts < arr[pos].pts) {\n              arr.splice(pos, 0, data);\n              break;\n            }\n          }\n        }\n      } else {\n        arr.push(data);\n      }\n    }\n  }, {\n    key: '_getLastNalUnit',\n    value: function _getLastNalUnit() {\n      var avcSample = this.avcSample,\n          lastUnit = void 0;\n      // try to fallback to previous sample if current one is empty\n      if (!avcSample || avcSample.units.units.length === 0) {\n        var track = this._avcTrack,\n            samples = track.samples;\n        avcSample = samples[samples.length - 1];\n      }\n      if (avcSample) {\n        var units = avcSample.units.units;\n        lastUnit = units[units.length - 1];\n      }\n      return lastUnit;\n    }\n  }, {\n    key: '_parseAVCNALu',\n    value: function _parseAVCNALu(array) {\n      var i = 0,\n          len = array.byteLength,\n          value,\n          overflow,\n          track = this._avcTrack,\n          state = track.naluState || 0,\n          lastState = state;\n      var units = [],\n          unit,\n          unitType,\n          lastUnitStart = -1,\n          lastUnitType;\n      //logger.log('PES:' + Hex.hexDump(array));\n\n      if (state === -1) {\n        // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n        lastUnitStart = 0;\n        // NALu type is value read from offset 0\n        lastUnitType = array[0] & 0x1f;\n        state = 0;\n        i = 1;\n      }\n\n      while (i < len) {\n        value = array[i++];\n        // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n        if (!state) {\n          state = value ? 0 : 1;\n          continue;\n        }\n        if (state === 1) {\n          state = value ? 0 : 2;\n          continue;\n        }\n        // here we have state either equal to 2 or 3\n        if (!value) {\n          state = 3;\n        } else if (value === 1) {\n          if (lastUnitStart >= 0) {\n            unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };\n            //logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n            units.push(unit);\n          } else {\n            // lastUnitStart is undefined => this is the first start code found in this PES packet\n            // first check if start code delimiter is overlapping between 2 PES packets,\n            // ie it started in last packet (lastState not zero)\n            // and ended at the beginning of this PES packet (i <= 4 - lastState)\n            var lastUnit = this._getLastNalUnit();\n            if (lastUnit) {\n              if (lastState && i <= 4 - lastState) {\n                // start delimiter overlapping between PES packets\n                // strip start delimiter bytes from the end of last NAL unit\n                // check if lastUnit had a state different from zero\n                if (lastUnit.state) {\n                  // strip last bytes\n                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n                }\n              }\n              // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n              overflow = i - state - 1;\n              if (overflow > 0) {\n                //logger.log('first NALU found with overflow:' + overflow);\n                var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);\n                tmp.set(lastUnit.data, 0);\n                tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);\n                lastUnit.data = tmp;\n              }\n            }\n          }\n          // check if we can read unit type\n          if (i < len) {\n            unitType = array[i] & 0x1f;\n            //logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n            lastUnitStart = i;\n            lastUnitType = unitType;\n            state = 0;\n          } else {\n            // not enough byte to read unit type. let's read it on next PES parsing\n            state = -1;\n          }\n        } else {\n          state = 0;\n        }\n      }\n      if (lastUnitStart >= 0 && state >= 0) {\n        unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };\n        units.push(unit);\n        //logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n      }\n      // no NALu found\n      if (units.length === 0) {\n        // append pes.data to previous NAL unit\n        var _lastUnit = this._getLastNalUnit();\n        if (_lastUnit) {\n          var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);\n          _tmp.set(_lastUnit.data, 0);\n          _tmp.set(array, _lastUnit.data.byteLength);\n          _lastUnit.data = _tmp;\n        }\n      }\n      track.naluState = state;\n      return units;\n    }\n\n    /**\n     * remove Emulation Prevention bytes from a RBSP\n     */\n\n  }, {\n    key: 'discardEPB',\n    value: function discardEPB(data) {\n      var length = data.byteLength,\n          EPBPositions = [],\n          i = 1,\n          newLength,\n          newData;\n\n      // Find all `Emulation Prevention Bytes`\n      while (i < length - 2) {\n        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n          EPBPositions.push(i + 2);\n          i += 2;\n        } else {\n          i++;\n        }\n      }\n\n      // If no Emulation Prevention Bytes were found just return the original\n      // array\n      if (EPBPositions.length === 0) {\n        return data;\n      }\n\n      // Create a new array to hold the NAL unit data\n      newLength = length - EPBPositions.length;\n      newData = new Uint8Array(newLength);\n      var sourceIndex = 0;\n\n      for (i = 0; i < newLength; sourceIndex++, i++) {\n        if (sourceIndex === EPBPositions[0]) {\n          // Skip this byte\n          sourceIndex++;\n          // Remove this position index\n          EPBPositions.shift();\n        }\n        newData[i] = data[sourceIndex];\n      }\n      return newData;\n    }\n  }, {\n    key: '_parseAACPES',\n    value: function _parseAACPES(pes) {\n      var track = this._audioTrack,\n          data = pes.data,\n          pts = pes.pts,\n          startOffset = 0,\n          aacOverFlow = this.aacOverFlow,\n          aacLastPTS = this.aacLastPTS,\n          config,\n          frameLength,\n          frameDuration,\n          frameIndex,\n          offset,\n          headerLength,\n          stamp,\n          len,\n          aacSample;\n      if (aacOverFlow) {\n        var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);\n        tmp.set(aacOverFlow, 0);\n        tmp.set(data, aacOverFlow.byteLength);\n        //logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);\n        data = tmp;\n      }\n      // look for ADTS header (0xFFFx)\n      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {\n          break;\n        }\n      }\n      // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n      if (offset) {\n        var reason, fatal;\n        if (offset < len - 1) {\n          reason = 'AAC PES did not start with ADTS header,offset:' + offset;\n          fatal = false;\n        } else {\n          reason = 'no ADTS header found in AAC PES';\n          fatal = true;\n        }\n        _logger.logger.warn('parsing error:' + reason);\n        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });\n        if (fatal) {\n          return;\n        }\n      }\n      if (!track.audiosamplerate) {\n        var audioCodec = this.audioCodec;\n        config = _adts2.default.getAudioConfig(this.observer, data, offset, audioCodec);\n        track.config = config.config;\n        track.audiosamplerate = config.samplerate;\n        track.channelCount = config.channelCount;\n        track.codec = config.codec;\n        track.manifestCodec = config.manifestCodec;\n        track.duration = this._duration;\n        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);\n      }\n      frameIndex = 0;\n      frameDuration = 1024 * 90000 / track.audiosamplerate;\n\n      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n      // first sample PTS should be equal to last sample PTS + frameDuration\n      if (aacOverFlow && aacLastPTS) {\n        var newPTS = aacLastPTS + frameDuration;\n        if (Math.abs(newPTS - pts) > 1) {\n          _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));\n          pts = newPTS;\n        }\n      }\n\n      while (offset + 5 < len) {\n        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;\n        // retrieve frame size\n        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;\n        frameLength -= headerLength;\n        //stamp = pes.pts;\n\n        if (frameLength > 0 && offset + headerLength + frameLength <= len) {\n          stamp = pts + frameIndex * frameDuration;\n          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);\n          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };\n          track.samples.push(aacSample);\n          track.len += frameLength;\n          offset += frameLength + headerLength;\n          frameIndex++;\n          // look for ADTS header (0xFFFx)\n          for (; offset < len - 1; offset++) {\n            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {\n              break;\n            }\n          }\n        } else {\n          break;\n        }\n      }\n      if (offset < len) {\n        aacOverFlow = data.subarray(offset, len);\n        //logger.log(`AAC: overflow detected:${len-offset}`);\n      } else {\n        aacOverFlow = null;\n      }\n      this.aacOverFlow = aacOverFlow;\n      this.aacLastPTS = stamp;\n    }\n  }, {\n    key: '_parseMPEGPES',\n    value: function _parseMPEGPES(pes) {\n      var data = pes.data;\n      var pts = pes.pts;\n      var length = data.length;\n      var frameIndex = 0;\n      var offset = 0;\n      var parsed;\n\n      while (offset < length && (parsed = this._parseMpeg(data, offset, length, frameIndex++, pts)) > 0) {\n        offset += parsed;\n      }\n    }\n  }, {\n    key: '_onMpegFrame',\n    value: function _onMpegFrame(data, bitRate, sampleRate, channelCount, frameIndex, pts) {\n      var frameDuration = 1152 / sampleRate * 1000;\n      var stamp = pts + frameIndex * frameDuration;\n      var track = this._audioTrack;\n\n      track.config = [];\n      track.channelCount = channelCount;\n      track.audiosamplerate = sampleRate;\n      track.duration = this._duration;\n      track.samples.push({ unit: data, pts: stamp, dts: stamp });\n      track.len += data.length;\n    }\n  }, {\n    key: '_onMpegNoise',\n    value: function _onMpegNoise(data) {\n      _logger.logger.warn('mpeg audio has noise: ' + data.length + ' bytes');\n    }\n  }, {\n    key: '_parseMpeg',\n    value: function _parseMpeg(data, start, end, frameIndex, pts) {\n      var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\n      var SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\n\n      if (start + 2 > end) {\n        return -1; // we need at least 2 bytes to detect sync pattern\n      }\n      if (data[start] === 0xFF || (data[start + 1] & 0xE0) === 0xE0) {\n        // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n        if (start + 24 > end) {\n          return -1;\n        }\n        var headerB = data[start + 1] >> 3 & 3;\n        var headerC = data[start + 1] >> 1 & 3;\n        var headerE = data[start + 2] >> 4 & 15;\n        var headerF = data[start + 2] >> 2 & 3;\n        var headerG = !!(data[start + 2] & 2);\n        if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {\n          var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;\n          var bitRate = BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;\n          var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;\n          var sampleRate = SamplingRateMap[columnInSampleRates * 3 + headerF];\n          var padding = headerG ? 1 : 0;\n          var channelCount = data[start + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n          var frameLength = headerC === 3 ? (headerB === 3 ? 12 : 6) * bitRate / sampleRate + padding << 2 : (headerB === 3 ? 144 : 72) * bitRate / sampleRate + padding | 0;\n          if (start + frameLength > end) {\n            return -1;\n          }\n          if (this._onMpegFrame) {\n            this._onMpegFrame(data.subarray(start, start + frameLength), bitRate, sampleRate, channelCount, frameIndex, pts);\n          }\n          return frameLength;\n        }\n      }\n      // noise or ID3, trying to skip\n      var offset = start + 2;\n      while (offset < end) {\n        if (data[offset - 1] === 0xFF && (data[offset] & 0xE0) === 0xE0) {\n          // sync pattern is found\n          if (this._onMpegNoise) {\n            this._onMpegNoise(data.subarray(start, offset - 1));\n          }\n          return offset - start - 1;\n        }\n        offset++;\n      }\n      return -1;\n    }\n  }, {\n    key: '_parseID3PES',\n    value: function _parseID3PES(pes) {\n      this._id3Track.samples.push(pes);\n    }\n  }], [{\n    key: 'probe',\n    value: function probe(data) {\n      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47\n      if (data.length >= 3 * 188 && data[0] === 0x47 && data[188] === 0x47 && data[2 * 188] === 0x47) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }]);\n\n  return TSDemuxer;\n}();\n\nexports.default = TSDemuxer;\n\n},{\"22\":22,\"26\":26,\"29\":29,\"31\":31,\"33\":33,\"50\":50}],31:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ErrorTypes = exports.ErrorTypes = {\n  // Identifier for a network error (loading error / timeout ...)\n  NETWORK_ERROR: 'networkError',\n  // Identifier for a media Error (video/parsing/mediasource error)\n  MEDIA_ERROR: 'mediaError',\n  // Identifier for a mux Error (demuxing/remuxing)\n  MUX_ERROR: 'muxError',\n  // Identifier for all other errors\n  OTHER_ERROR: 'otherError'\n};\n\nvar ErrorDetails = exports.ErrorDetails = {\n  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  MANIFEST_LOAD_ERROR: 'manifestLoadError',\n  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',\n  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}\n  MANIFEST_PARSING_ERROR: 'manifestParsingError',\n  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}\n  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',\n  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  LEVEL_LOAD_ERROR: 'levelLoadError',\n  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',\n  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}\n  LEVEL_SWITCH_ERROR: 'levelSwitchError',\n  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',\n  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',\n  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n  FRAG_LOAD_ERROR: 'fragLoadError',\n  // Identifier for fragment loop loading error - data: { frag : fragment object}\n  FRAG_LOOP_LOADING_ERROR: 'fragLoopLoadingError',\n  // Identifier for fragment load timeout error - data: { frag : fragment object}\n  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',\n  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }\n  FRAG_DECRYPT_ERROR: 'fragDecryptError',\n  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }\n  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release\n  FRAG_PARSING_ERROR: 'fragParsingError',\n  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }\n  REMUX_ALLOC_ERROR: 'remuxAllocError',\n  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n  KEY_LOAD_ERROR: 'keyLoadError',\n  // Identifier for decrypt key load timeout error - data: { frag : fragment object}\n  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',\n  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }\n  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',\n  // Identifier for a buffer append error - data: append error description\n  BUFFER_APPEND_ERROR: 'bufferAppendError',\n  // Identifier for a buffer appending error event - data: appending error description\n  BUFFER_APPENDING_ERROR: 'bufferAppendingError',\n  // Identifier for a buffer stalled error event\n  BUFFER_STALLED_ERROR: 'bufferStalledError',\n  // Identifier for a buffer full event\n  BUFFER_FULL_ERROR: 'bufferFullError',\n  // Identifier for a buffer seek over hole event\n  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',\n  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)\n  BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',\n  // Identifier for an internal exception happening inside hls.js while handling an event\n  INTERNAL_EXCEPTION: 'internalException',\n  // Malformed WebVTT contents\n  WEBVTT_EXCEPTION: 'webVTTException'\n};\n\n},{}],32:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _logger = _dereq_(50);\n\nvar _errors = _dereq_(31);\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EventHandler = function () {\n  function EventHandler(hls) {\n    _classCallCheck(this, EventHandler);\n\n    this.hls = hls;\n    this.onEvent = this.onEvent.bind(this);\n\n    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      events[_key - 1] = arguments[_key];\n    }\n\n    this.handledEvents = events;\n    this.useGenericHandler = true;\n\n    this.registerListeners();\n  }\n\n  _createClass(EventHandler, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.unregisterListeners();\n    }\n  }, {\n    key: 'isEventHandler',\n    value: function isEventHandler() {\n      return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';\n    }\n  }, {\n    key: 'registerListeners',\n    value: function registerListeners() {\n      if (this.isEventHandler()) {\n        this.handledEvents.forEach(function (event) {\n          if (event === 'hlsEventGeneric') {\n            throw new Error('Forbidden event name: ' + event);\n          }\n          this.hls.on(event, this.onEvent);\n        }.bind(this));\n      }\n    }\n  }, {\n    key: 'unregisterListeners',\n    value: function unregisterListeners() {\n      if (this.isEventHandler()) {\n        this.handledEvents.forEach(function (event) {\n          this.hls.off(event, this.onEvent);\n        }.bind(this));\n      }\n    }\n\n    /**\n     * arguments: event (string), data (any)\n     */\n\n  }, {\n    key: 'onEvent',\n    value: function onEvent(event, data) {\n      this.onEventGeneric(event, data);\n    }\n  }, {\n    key: 'onEventGeneric',\n    value: function onEventGeneric(event, data) {\n      var eventToFunction = function eventToFunction(event, data) {\n        var funcName = 'on' + event.replace('hls', '');\n        if (typeof this[funcName] !== 'function') {\n          throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');\n        }\n        return this[funcName].bind(this, data);\n      };\n      try {\n        eventToFunction.call(this, event, data).call();\n      } catch (err) {\n        _logger.logger.error('internal error happened while processing ' + event + ':' + err.message);\n        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });\n      }\n    }\n  }]);\n\n  return EventHandler;\n}();\n\nexports.default = EventHandler;\n\n},{\"31\":31,\"33\":33,\"50\":50}],33:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = {\n  // fired before MediaSource is attaching to media element - data: { media }\n  MEDIA_ATTACHING: 'hlsMediaAttaching',\n  // fired when MediaSource has been succesfully attached to media element - data: { }\n  MEDIA_ATTACHED: 'hlsMediaAttached',\n  // fired before detaching MediaSource from media element - data: { }\n  MEDIA_DETACHING: 'hlsMediaDetaching',\n  // fired when MediaSource has been detached from media element - data: { }\n  MEDIA_DETACHED: 'hlsMediaDetached',\n  // fired when we buffer is going to be resetted\n  BUFFER_RESET: 'hlsBufferReset',\n  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}\n  BUFFER_CODECS: 'hlsBufferCodecs',\n  // fired when sourcebuffers have been created data: { tracks : tracks}\n  BUFFER_CREATED: 'hlsBufferCreated',\n  // fired when we append a segment to the buffer - data: { segment: segment object }\n  BUFFER_APPENDING: 'hlsBufferAppending',\n  // fired when we are done with appending a media segment to the buffer data : { parent : segment parent that triggered BUFFER_APPENDING , pending : nb of segments waiting for appending for this segment parent}\n  BUFFER_APPENDED: 'hlsBufferAppended',\n  // fired when the stream is finished and we want to notify the media buffer that there will be no more data\n  BUFFER_EOS: 'hlsBufferEos',\n  // fired when the media buffer should be flushed - data {startOffset, endOffset}\n  BUFFER_FLUSHING: 'hlsBufferFlushing',\n  // fired when the media has been flushed\n  BUFFER_FLUSHED: 'hlsBufferFlushed',\n  // fired to signal that a manifest loading starts - data: { url : manifestURL}\n  MANIFEST_LOADING: 'hlsManifestLoading',\n  // fired after manifest has been loaded - data: { levels : [available quality levels] , audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}\n  MANIFEST_LOADED: 'hlsManifestLoaded',\n  // fired after manifest has been parsed - data: { levels : [available quality levels] , firstLevel : index of first quality level appearing in Manifest}\n  MANIFEST_PARSED: 'hlsManifestParsed',\n  // fired when a level switch is requested - data: { level : id of new level } // deprecated in favor LEVEL_SWITCHING\n  LEVEL_SWITCH: 'hlsLevelSwitch',\n  // fired when a level switch is requested - data: { level : id of new level }\n  LEVEL_SWITCHING: 'hlsLevelSwitching',\n  // fired when a level switch is effective - data: { level : id of new level }\n  LEVEL_SWITCHED: 'hlsLevelSwitched',\n  // fired when a level playlist loading starts - data: { url : level URL  level : id of level being loaded}\n  LEVEL_LOADING: 'hlsLevelLoading',\n  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }\n  LEVEL_LOADED: 'hlsLevelLoaded',\n  // fired when a level's details have been updated based on previous details, after it has been loaded. - data: { details : levelDetails object, level : id of updated level }\n  LEVEL_UPDATED: 'hlsLevelUpdated',\n  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }\n  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',\n  // fired to notify that audio track lists has been updated data: { audioTracks : audioTracks}\n  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',\n  // fired when an audio track switch occurs - data: {  id : audio track id} // deprecated in favor AUDIO_TRACK_SWITCHING\n  AUDIO_TRACK_SWITCH: 'hlsAudioTrackSwitch',\n  // fired when an audio track switching is requested - data: {  id : audio track id}\n  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',\n  // fired when an audio track switch actually occurs - data: {  id : audio track id}\n  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',\n  // fired when an audio track loading starts - data: { url : audio track URL  id : audio track id}\n  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',\n  // fired when an audio track loading  finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime} }\n  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',\n  // fired to notify that subtitle track lists has been updated data: { subtitleTracks : subtitleTracks}\n  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',\n  // fired when an subtitle track switch occurs - data: {  id : subtitle track id}\n  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',\n  // fired when an subtitle track loading starts - data: { url : subtitle track URL  id : subtitle track id}\n  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',\n  // fired when an subtitle track loading  finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime} }\n  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',\n  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag}\n  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',\n  // fired when the first timestamp is found. - data: { id : demuxer id, initPTS: initPTS , frag : fragment object}\n  INIT_PTS_FOUND: 'hlsInitPtsFound',\n  // fired when a fragment loading starts - data: { frag : fragment object}\n  FRAG_LOADING: 'hlsFragLoading',\n  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded}}\n  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',\n  // Identifier for fragment load aborting for emergency switch down - data: {frag : fragment object}\n  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',\n  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length}}\n  FRAG_LOADED: 'hlsFragLoaded',\n  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, stats : {tstart,tdecrypt} }\n  FRAG_DECRYPTED: 'hlsFragDecrypted',\n  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment}\n  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',\n  // fired when parsing sei text is completed - data: { id : demuxer id, , frag: fragment object, samples : [ sei samples pes ] }\n  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',\n  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }\n  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',\n  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}\n  FRAG_PARSING_DATA: 'hlsFragParsingData',\n  // fired when fragment parsing is completed - data: { id : demuxer id,frag: fragment object }\n  FRAG_PARSED: 'hlsFragParsed',\n  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id,frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length} }\n  FRAG_BUFFERED: 'hlsFragBuffered',\n  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }\n  FRAG_CHANGED: 'hlsFragChanged',\n  // Identifier for a FPS drop event - data: {curentDropped, currentDecoded, totalDroppedFrames}\n  FPS_DROP: 'hlsFpsDrop',\n  //triggered when FPS drop triggers auto level capping - data: {level, droppedlevel}\n  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',\n  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data}\n  ERROR: 'hlsError',\n  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example\n  DESTROYING: 'hlsDestroying',\n  // fired when a decrypt key loading starts - data: { frag : fragment object}\n  KEY_LOADING: 'hlsKeyLoading',\n  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length}}\n  KEY_LOADED: 'hlsKeyLoaded',\n  // fired upon stream controller state transitions - data: {previousState, nextState}\n  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'\n};\n\n},{}],34:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *  AAC helper\n */\n\nvar AAC = function () {\n  function AAC() {\n    _classCallCheck(this, AAC);\n  }\n\n  _createClass(AAC, null, [{\n    key: 'getSilentFrame',\n    value: function getSilentFrame(codec, channelCount) {\n      switch (codec) {\n        case 'mp4a.40.2':\n          if (channelCount === 1) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n          } else if (channelCount === 2) {\n            return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n          } else if (channelCount === 3) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n          } else if (channelCount === 4) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n          } else if (channelCount === 5) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n          } else if (channelCount === 6) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n          }\n          break;\n        // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n        default:\n          if (channelCount === 1) {\n            // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n          } else if (channelCount === 2) {\n            // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n          } else if (channelCount === 3) {\n            // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n          }\n          break;\n      }\n      return null;\n    }\n  }]);\n\n  return AAC;\n}();\n\nexports.default = AAC;\n\n},{}],35:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Buffer Helper class, providing methods dealing buffer length retrieval\n*/\n\nvar BufferHelper = function () {\n  function BufferHelper() {\n    _classCallCheck(this, BufferHelper);\n  }\n\n  _createClass(BufferHelper, null, [{\n    key: \"isBuffered\",\n    value: function isBuffered(media, position) {\n      if (media) {\n        var buffered = media.buffered;\n        for (var i = 0; i < buffered.length; i++) {\n          if (position >= buffered.start(i) && position <= buffered.end(i)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"bufferInfo\",\n    value: function bufferInfo(media, pos, maxHoleDuration) {\n      if (media) {\n        var vbuffered = media.buffered,\n            buffered = [],\n            i;\n        for (i = 0; i < vbuffered.length; i++) {\n          buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });\n        }\n        return this.bufferedInfo(buffered, pos, maxHoleDuration);\n      } else {\n        return { len: 0, start: pos, end: pos, nextStart: undefined };\n      }\n    }\n  }, {\n    key: \"bufferedInfo\",\n    value: function bufferedInfo(buffered, pos, maxHoleDuration) {\n      var buffered2 = [],\n\n      // bufferStart and bufferEnd are buffer boundaries around current video position\n      bufferLen,\n          bufferStart,\n          bufferEnd,\n          bufferStartNext,\n          i;\n      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n      buffered.sort(function (a, b) {\n        var diff = a.start - b.start;\n        if (diff) {\n          return diff;\n        } else {\n          return b.end - a.end;\n        }\n      });\n      // there might be some small holes between buffer time range\n      // consider that holes smaller than maxHoleDuration are irrelevant and build another\n      // buffer time range representations that discards those holes\n      for (i = 0; i < buffered.length; i++) {\n        var buf2len = buffered2.length;\n        if (buf2len) {\n          var buf2end = buffered2[buf2len - 1].end;\n          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n          if (buffered[i].start - buf2end < maxHoleDuration) {\n            // merge overlapping time ranges\n            // update lastRange.end only if smaller than item.end\n            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n            if (buffered[i].end > buf2end) {\n              buffered2[buf2len - 1].end = buffered[i].end;\n            }\n          } else {\n            // big hole\n            buffered2.push(buffered[i]);\n          }\n        } else {\n          // first value\n          buffered2.push(buffered[i]);\n        }\n      }\n      for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {\n        var start = buffered2[i].start,\n            end = buffered2[i].end;\n        //logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n        if (pos + maxHoleDuration >= start && pos < end) {\n          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n          bufferStart = start;\n          bufferEnd = end;\n          bufferLen = bufferEnd - pos;\n        } else if (pos + maxHoleDuration < start) {\n          bufferStartNext = start;\n          break;\n        }\n      }\n      return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };\n    }\n  }]);\n\n  return BufferHelper;\n}();\n\nexports.default = BufferHelper;\n\n},{}],36:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Level Helper class, providing methods dealing with playlist sliding and drift\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _logger = _dereq_(50);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LevelHelper = function () {\n  function LevelHelper() {\n    _classCallCheck(this, LevelHelper);\n  }\n\n  _createClass(LevelHelper, null, [{\n    key: 'mergeDetails',\n    value: function mergeDetails(oldDetails, newDetails) {\n      var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN,\n          end = Math.min(oldDetails.endSN, newDetails.endSN) - newDetails.startSN,\n          delta = newDetails.startSN - oldDetails.startSN,\n          oldfragments = oldDetails.fragments,\n          newfragments = newDetails.fragments,\n          ccOffset = 0,\n          PTSFrag;\n\n      // check if old/new playlists have fragments in common\n      if (end < start) {\n        newDetails.PTSKnown = false;\n        return;\n      }\n      // loop through overlapping SN and update startPTS , cc, and duration if any found\n      for (var i = start; i <= end; i++) {\n        var oldFrag = oldfragments[delta + i],\n            newFrag = newfragments[i];\n        if (newFrag && oldFrag) {\n          ccOffset = oldFrag.cc - newFrag.cc;\n          if (!isNaN(oldFrag.startPTS)) {\n            newFrag.start = newFrag.startPTS = oldFrag.startPTS;\n            newFrag.endPTS = oldFrag.endPTS;\n            newFrag.duration = oldFrag.duration;\n            PTSFrag = newFrag;\n          }\n        }\n      }\n\n      if (ccOffset) {\n        _logger.logger.log('discontinuity sliding from playlist, take drift into account');\n        for (i = 0; i < newfragments.length; i++) {\n          newfragments[i].cc += ccOffset;\n        }\n      }\n\n      // if at least one fragment contains PTS info, recompute PTS information for all fragments\n      if (PTSFrag) {\n        LevelHelper.updateFragPTSDTS(newDetails, PTSFrag.sn, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n      } else {\n        // ensure that delta is within oldfragments range\n        // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n        // in that case we also need to adjust start offset of all fragments\n        if (delta >= 0 && delta < oldfragments.length) {\n          // adjust start by sliding offset\n          var sliding = oldfragments[delta].start;\n          for (i = 0; i < newfragments.length; i++) {\n            newfragments[i].start += sliding;\n          }\n        }\n      }\n      // if we are here, it means we have fragments overlapping between\n      // old and new level. reliable PTS info is thus relying on old level\n      newDetails.PTSKnown = oldDetails.PTSKnown;\n      return;\n    }\n  }, {\n    key: 'updateFragPTSDTS',\n    value: function updateFragPTSDTS(details, sn, startPTS, endPTS, startDTS, endDTS) {\n      var fragIdx, fragments, frag, i;\n      // exit if sn out of range\n      if (!details || sn < details.startSN || sn > details.endSN) {\n        return 0;\n      }\n      fragIdx = sn - details.startSN;\n      fragments = details.fragments;\n      frag = fragments[fragIdx];\n      if (!isNaN(frag.startPTS)) {\n        // delta PTS between audio and video\n        var deltaPTS = Math.abs(frag.startPTS - startPTS);\n        if (isNaN(frag.deltaPTS)) {\n          frag.deltaPTS = deltaPTS;\n        } else {\n          frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n        }\n        startPTS = Math.min(startPTS, frag.startPTS);\n        endPTS = Math.max(endPTS, frag.endPTS);\n        startDTS = Math.min(startDTS, frag.startDTS);\n        endDTS = Math.max(endDTS, frag.endDTS);\n      }\n\n      var drift = startPTS - frag.start;\n\n      frag.start = frag.startPTS = startPTS;\n      frag.endPTS = endPTS;\n      frag.startDTS = startDTS;\n      frag.endDTS = endDTS;\n      frag.duration = endPTS - startPTS;\n      // adjust fragment PTS/duration from seqnum-1 to frag 0\n      for (i = fragIdx; i > 0; i--) {\n        LevelHelper.updatePTS(fragments, i, i - 1);\n      }\n\n      // adjust fragment PTS/duration from seqnum to last frag\n      for (i = fragIdx; i < fragments.length - 1; i++) {\n        LevelHelper.updatePTS(fragments, i, i + 1);\n      }\n      details.PTSKnown = true;\n      //logger.log(`                                            frag start/end:${startPTS.toFixed(3)}/${endPTS.toFixed(3)}`);\n\n      return drift;\n    }\n  }, {\n    key: 'updatePTS',\n    value: function updatePTS(fragments, fromIdx, toIdx) {\n      var fragFrom = fragments[fromIdx],\n          fragTo = fragments[toIdx],\n          fragToPTS = fragTo.startPTS;\n      // if we know startPTS[toIdx]\n      if (!isNaN(fragToPTS)) {\n        // update fragment duration.\n        // it helps to fix drifts between playlist reported duration and fragment real duration\n        if (toIdx > fromIdx) {\n          fragFrom.duration = fragToPTS - fragFrom.start;\n          if (fragFrom.duration < 0) {\n            _logger.logger.warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');\n          }\n        } else {\n          fragTo.duration = fragFrom.start - fragToPTS;\n          if (fragTo.duration < 0) {\n            _logger.logger.warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');\n          }\n        }\n      } else {\n        // we dont know startPTS[toIdx]\n        if (toIdx > fromIdx) {\n          fragTo.start = fragFrom.start + fragFrom.duration;\n        } else {\n          fragTo.start = fragFrom.start - fragTo.duration;\n        }\n      }\n    }\n  }]);\n\n  return LevelHelper;\n}();\n\nexports.default = LevelHelper;\n\n},{\"50\":50}],37:[function(_dereq_,module,exports){\n/**\n * HLS interface\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _errors = _dereq_(31);\n\nvar _playlistLoader = _dereq_(41);\n\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\n\nvar _fragmentLoader = _dereq_(39);\n\nvar _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);\n\nvar _keyLoader = _dereq_(40);\n\nvar _keyLoader2 = _interopRequireDefault(_keyLoader);\n\nvar _streamController = _dereq_(13);\n\nvar _streamController2 = _interopRequireDefault(_streamController);\n\nvar _levelController = _dereq_(12);\n\nvar _levelController2 = _interopRequireDefault(_levelController);\n\nvar _logger = _dereq_(50);\n\nvar _events3 = _dereq_(1);\n\nvar _events4 = _interopRequireDefault(_events3);\n\nvar _config = _dereq_(4);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Hls = function () {\n  _createClass(Hls, null, [{\n    key: 'isSupported',\n    value: function isSupported() {\n      window.MediaSource = window.MediaSource || window.WebKitMediaSource;\n      return window.MediaSource && typeof window.MediaSource.isTypeSupported === 'function' && window.MediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"');\n    }\n  }, {\n    key: 'version',\n    get: function get() {\n      // replaced with browserify-versionify transform\n      return '0.7.2';\n    }\n  }, {\n    key: 'Events',\n    get: function get() {\n      return _events2.default;\n    }\n  }, {\n    key: 'ErrorTypes',\n    get: function get() {\n      return _errors.ErrorTypes;\n    }\n  }, {\n    key: 'ErrorDetails',\n    get: function get() {\n      return _errors.ErrorDetails;\n    }\n  }, {\n    key: 'DefaultConfig',\n    get: function get() {\n      if (!Hls.defaultConfig) {\n        return _config.hlsDefaultConfig;\n      }\n      return Hls.defaultConfig;\n    },\n    set: function set(defaultConfig) {\n      Hls.defaultConfig = defaultConfig;\n    }\n  }]);\n\n  function Hls() {\n    var _this = this;\n\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Hls);\n\n    var defaultConfig = Hls.DefaultConfig;\n\n    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {\n      throw new Error('Illegal hls.js config: don\\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');\n    }\n\n    for (var prop in defaultConfig) {\n      if (prop in config) {\n        continue;\n      }\n      config[prop] = defaultConfig[prop];\n    }\n\n    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {\n      throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be gt \"liveSyncDurationCount\"');\n    }\n\n    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {\n      throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be gt \"liveSyncDuration\"');\n    }\n\n    (0, _logger.enableLogs)(config.debug);\n    this.config = config;\n    this._autoLevelCapping = -1;\n    // observer setup\n    var observer = this.observer = new _events4.default();\n    observer.trigger = function trigger(event) {\n      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        data[_key - 1] = arguments[_key];\n      }\n\n      observer.emit.apply(observer, [event, event].concat(data));\n    };\n\n    observer.off = function off(event) {\n      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        data[_key2 - 1] = arguments[_key2];\n      }\n\n      observer.removeListener.apply(observer, [event].concat(data));\n    };\n    this.on = observer.on.bind(observer);\n    this.off = observer.off.bind(observer);\n    this.trigger = observer.trigger.bind(observer);\n\n    // core controllers and network loaders\n    var abrController = this.abrController = new config.abrController(this);\n    var bufferController = new config.bufferController(this);\n    var capLevelController = new config.capLevelController(this);\n    var fpsController = new config.fpsController(this);\n    var playListLoader = new _playlistLoader2.default(this);\n    var fragmentLoader = new _fragmentLoader2.default(this);\n    var keyLoader = new _keyLoader2.default(this);\n\n    // network controllers\n    var levelController = this.levelController = new _levelController2.default(this);\n    var streamController = this.streamController = new _streamController2.default(this);\n    var networkControllers = [levelController, streamController];\n\n    // optional audio stream controller\n    var Controller = config.audioStreamController;\n    if (Controller) {\n      networkControllers.push(new Controller(this));\n    }\n    this.networkControllers = networkControllers;\n\n    var coreComponents = [playListLoader, fragmentLoader, keyLoader, abrController, bufferController, capLevelController, fpsController];\n\n    // optional audio track and subtitle controller\n    Controller = config.audioTrackController;\n    if (Controller) {\n      var audioTrackController = new Controller(this);\n      this.audioTrackController = audioTrackController;\n      coreComponents.push(audioTrackController);\n    }\n\n    Controller = config.subtitleTrackController;\n    if (Controller) {\n      var subtitleTrackController = new Controller(this);\n      this.subtitleTrackController = subtitleTrackController;\n      coreComponents.push(subtitleTrackController);\n    }\n\n    // optional subtitle controller\n    [config.subtitleStreamController, config.timelineController].forEach(function (Controller) {\n      if (Controller) {\n        coreComponents.push(new Controller(_this));\n      }\n    });\n    this.coreComponents = coreComponents;\n  }\n\n  _createClass(Hls, [{\n    key: 'destroy',\n    value: function destroy() {\n      _logger.logger.log('destroy');\n      this.trigger(_events2.default.DESTROYING);\n      this.detachMedia();\n      this.coreComponents.concat(this.networkControllers).forEach(function (component) {\n        component.destroy();\n      });\n      this.url = null;\n      this.observer.removeAllListeners();\n      this._autoLevelCapping = -1;\n    }\n  }, {\n    key: 'attachMedia',\n    value: function attachMedia(media) {\n      _logger.logger.log('attachMedia');\n      this.media = media;\n      this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });\n    }\n  }, {\n    key: 'detachMedia',\n    value: function detachMedia() {\n      _logger.logger.log('detachMedia');\n      this.trigger(_events2.default.MEDIA_DETACHING);\n      this.media = null;\n    }\n  }, {\n    key: 'loadSource',\n    value: function loadSource(url) {\n      _logger.logger.log('loadSource:' + url);\n      this.url = url;\n      // when attaching to a source URL, trigger a playlist load\n      this.trigger(_events2.default.MANIFEST_LOADING, { url: url });\n    }\n  }, {\n    key: 'startLoad',\n    value: function startLoad() {\n      var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n\n      _logger.logger.log('startLoad(' + startPosition + ')');\n      this.networkControllers.forEach(function (controller) {\n        controller.startLoad(startPosition);\n      });\n    }\n  }, {\n    key: 'stopLoad',\n    value: function stopLoad() {\n      _logger.logger.log('stopLoad');\n      this.networkControllers.forEach(function (controller) {\n        controller.stopLoad();\n      });\n    }\n  }, {\n    key: 'swapAudioCodec',\n    value: function swapAudioCodec() {\n      _logger.logger.log('swapAudioCodec');\n      this.streamController.swapAudioCodec();\n    }\n  }, {\n    key: 'recoverMediaError',\n    value: function recoverMediaError() {\n      _logger.logger.log('recoverMediaError');\n      var media = this.media;\n      this.detachMedia();\n      this.attachMedia(media);\n    }\n\n    /** Return all quality levels **/\n\n  }, {\n    key: 'levels',\n    get: function get() {\n      return this.levelController.levels;\n    }\n\n    /** Return current playback quality level **/\n\n  }, {\n    key: 'currentLevel',\n    get: function get() {\n      return this.streamController.currentLevel;\n    }\n\n    /* set quality level immediately (-1 for automatic level selection) */\n    ,\n    set: function set(newLevel) {\n      _logger.logger.log('set currentLevel:' + newLevel);\n      this.loadLevel = newLevel;\n      this.streamController.immediateLevelSwitch();\n    }\n\n    /** Return next playback quality level (quality level of next fragment) **/\n\n  }, {\n    key: 'nextLevel',\n    get: function get() {\n      return this.streamController.nextLevel;\n    }\n\n    /* set quality level for next fragment (-1 for automatic level selection) */\n    ,\n    set: function set(newLevel) {\n      _logger.logger.log('set nextLevel:' + newLevel);\n      this.levelController.manualLevel = newLevel;\n      this.streamController.nextLevelSwitch();\n    }\n\n    /** Return the quality level of current/last loaded fragment **/\n\n  }, {\n    key: 'loadLevel',\n    get: function get() {\n      return this.levelController.level;\n    }\n\n    /* set quality level for current/next loaded fragment (-1 for automatic level selection) */\n    ,\n    set: function set(newLevel) {\n      _logger.logger.log('set loadLevel:' + newLevel);\n      this.levelController.manualLevel = newLevel;\n    }\n\n    /** Return the quality level of next loaded fragment **/\n\n  }, {\n    key: 'nextLoadLevel',\n    get: function get() {\n      return this.levelController.nextLoadLevel;\n    }\n\n    /** set quality level of next loaded fragment **/\n    ,\n    set: function set(level) {\n      this.levelController.nextLoadLevel = level;\n    }\n\n    /** Return first level (index of first level referenced in manifest)\n    **/\n\n  }, {\n    key: 'firstLevel',\n    get: function get() {\n      return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n    }\n\n    /** set first level (index of first level referenced in manifest)\n    **/\n    ,\n    set: function set(newLevel) {\n      _logger.logger.log('set firstLevel:' + newLevel);\n      this.levelController.firstLevel = newLevel;\n    }\n\n    /** Return start level (level of first fragment that will be played back)\n        if not overrided by user, first level appearing in manifest will be used as start level\n        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)\n    **/\n\n  }, {\n    key: 'startLevel',\n    get: function get() {\n      return this.levelController.startLevel;\n    }\n\n    /** set  start level (level of first fragment that will be played back)\n        if not overrided by user, first level appearing in manifest will be used as start level\n        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)\n    **/\n    ,\n    set: function set(newLevel) {\n      _logger.logger.log('set startLevel:' + newLevel);\n      var hls = this;\n      // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n      if (newLevel !== -1) {\n        newLevel = Math.max(newLevel, hls.minAutoLevel);\n      }\n      hls.levelController.startLevel = newLevel;\n    }\n\n    /** Return the capping/max level value that could be used by automatic level selection algorithm **/\n\n  }, {\n    key: 'autoLevelCapping',\n    get: function get() {\n      return this._autoLevelCapping;\n    }\n\n    /** set the capping/max level value that could be used by automatic level selection algorithm **/\n    ,\n    set: function set(newLevel) {\n      _logger.logger.log('set autoLevelCapping:' + newLevel);\n      this._autoLevelCapping = newLevel;\n    }\n\n    /* check if we are in automatic level selection mode */\n\n  }, {\n    key: 'autoLevelEnabled',\n    get: function get() {\n      return this.levelController.manualLevel === -1;\n    }\n\n    /* return manual level */\n\n  }, {\n    key: 'manualLevel',\n    get: function get() {\n      return this.levelController.manualLevel;\n    }\n\n    /* return min level selectable in auto mode according to config.minAutoBitrate */\n\n  }, {\n    key: 'minAutoLevel',\n    get: function get() {\n      var hls = this,\n          levels = hls.levels,\n          minAutoBitrate = hls.config.minAutoBitrate,\n          len = levels ? levels.length : 0;\n      for (var i = 0; i < len; i++) {\n        var levelNextBitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;\n        if (levelNextBitrate > minAutoBitrate) {\n          return i;\n        }\n      }\n      return 0;\n    }\n\n    /* return max level selectable in auto mode according to autoLevelCapping */\n\n  }, {\n    key: 'maxAutoLevel',\n    get: function get() {\n      var hls = this;\n      var levels = hls.levels;\n      var autoLevelCapping = hls.autoLevelCapping;\n      var maxAutoLevel = void 0;\n      if (autoLevelCapping === -1 && levels && levels.length) {\n        maxAutoLevel = levels.length - 1;\n      } else {\n        maxAutoLevel = autoLevelCapping;\n      }\n      return maxAutoLevel;\n    }\n\n    // return next auto level\n\n  }, {\n    key: 'nextAutoLevel',\n    get: function get() {\n      var hls = this;\n      // ensure next auto level is between  min and max auto level\n      return Math.min(Math.max(hls.abrController.nextAutoLevel, hls.minAutoLevel), hls.maxAutoLevel);\n    }\n\n    // this setter is used to force next auto level\n    // this is useful to force a switch down in auto mode : in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n    // forced value is valid for one fragment. upon succesful frag loading at forced level, this value will be resetted to -1 by ABR controller\n    ,\n    set: function set(nextLevel) {\n      var hls = this;\n      hls.abrController.nextAutoLevel = Math.max(hls.minAutoLevel, nextLevel);\n    }\n\n    /** get alternate audio tracks list from playlist **/\n\n  }, {\n    key: 'audioTracks',\n    get: function get() {\n      var audioTrackController = this.audioTrackController;\n      return audioTrackController ? audioTrackController.audioTracks : [];\n    }\n\n    /** get index of the selected audio track (index in audio track lists) **/\n\n  }, {\n    key: 'audioTrack',\n    get: function get() {\n      var audioTrackController = this.audioTrackController;\n      return audioTrackController ? audioTrackController.audioTrack : -1;\n    }\n\n    /** select an audio track, based on its index in audio track lists**/\n    ,\n    set: function set(audioTrackId) {\n      var audioTrackController = this.audioTrackController;\n      if (audioTrackController) {\n        audioTrackController.audioTrack = audioTrackId;\n      }\n    }\n  }, {\n    key: 'liveSyncPosition',\n    get: function get() {\n      return this.streamController.liveSyncPosition;\n    }\n\n    /** get alternate subtitle tracks list from playlist **/\n\n  }, {\n    key: 'subtitleTracks',\n    get: function get() {\n      var subtitleTrackController = this.subtitleTrackController;\n      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n    }\n\n    /** get index of the selected subtitle track (index in subtitle track lists) **/\n\n  }, {\n    key: 'subtitleTrack',\n    get: function get() {\n      var subtitleTrackController = this.subtitleTrackController;\n      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n    }\n\n    /** select an subtitle track, based on its index in subtitle track lists**/\n    ,\n    set: function set(subtitleTrackId) {\n      var subtitleTrackController = this.subtitleTrackController;\n      if (subtitleTrackController) {\n        subtitleTrackController.subtitleTrack = subtitleTrackId;\n      }\n    }\n  }]);\n\n  return Hls;\n}();\n\nexports.default = Hls;\n\n},{\"1\":1,\"12\":12,\"13\":13,\"31\":31,\"33\":33,\"39\":39,\"4\":4,\"40\":40,\"41\":41,\"50\":50}],38:[function(_dereq_,module,exports){\n'use strict';\n\n// This is mostly for support of the es6 module export\n// syntax with the babel compiler, it looks like it doesnt support\n// function exports like we are used to in node/commonjs\nmodule.exports = _dereq_(37).default;\n\n},{\"37\":37}],39:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _errors = _dereq_(31);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar FragmentLoader = function (_EventHandler) {\n  _inherits(FragmentLoader, _EventHandler);\n\n  function FragmentLoader(hls) {\n    _classCallCheck(this, FragmentLoader);\n\n    var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));\n\n    _this.loaders = {};\n    return _this;\n  }\n\n  _createClass(FragmentLoader, [{\n    key: 'destroy',\n    value: function destroy() {\n      var loaders = this.loaders;\n      for (var loaderName in loaders) {\n        var loader = loaders[loaderName];\n        if (loader) {\n          loader.destroy();\n        }\n      }\n      this.loaders = {};\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n  }, {\n    key: 'onFragLoading',\n    value: function onFragLoading(data) {\n      var frag = data.frag,\n          type = frag.type,\n          loader = this.loaders[type],\n          config = this.hls.config;\n\n      frag.loaded = 0;\n      if (loader) {\n        _logger.logger.warn('abort previous fragment loader for type:' + type);\n        loader.abort();\n      }\n      loader = this.loaders[type] = frag.loader = typeof config.fLoader !== 'undefined' ? new config.fLoader(config) : new config.loader(config);\n\n      var loaderContext = void 0,\n          loaderConfig = void 0,\n          loaderCallbacks = void 0;\n      loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };\n      var start = frag.byteRangeStartOffset,\n          end = frag.byteRangeEndOffset;\n      if (!isNaN(start) && !isNaN(end)) {\n        loaderContext.rangeStart = start;\n        loaderContext.rangeEnd = end;\n      }\n      loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: config.fragLoadingMaxRetryTimeout };\n      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) };\n      loader.load(loaderContext, loaderConfig, loaderCallbacks);\n    }\n  }, {\n    key: 'loadsuccess',\n    value: function loadsuccess(response, stats, context) {\n      var payload = response.data,\n          frag = context.frag;\n      // detach fragment loader on load success\n      frag.loader = undefined;\n      this.loaders[frag.type] = undefined;\n      this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats });\n    }\n  }, {\n    key: 'loaderror',\n    value: function loaderror(response, context) {\n      var loader = context.loader;\n      if (loader) {\n        loader.abort();\n      }\n      this.loaders[context.type] = undefined;\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response });\n    }\n  }, {\n    key: 'loadtimeout',\n    value: function loadtimeout(stats, context) {\n      var loader = context.loader;\n      if (loader) {\n        loader.abort();\n      }\n      this.loaders[context.type] = undefined;\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag });\n    }\n\n    // data will be used for progressive parsing\n\n  }, {\n    key: 'loadprogress',\n    value: function loadprogress(stats, context, data) {\n      // jshint ignore:line\n      var frag = context.frag;\n      frag.loaded = stats.loaded;\n      this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats });\n    }\n  }]);\n\n  return FragmentLoader;\n}(_eventHandler2.default);\n\nexports.default = FragmentLoader;\n\n},{\"31\":31,\"32\":32,\"33\":33,\"50\":50}],40:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _errors = _dereq_(31);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar KeyLoader = function (_EventHandler) {\n  _inherits(KeyLoader, _EventHandler);\n\n  function KeyLoader(hls) {\n    _classCallCheck(this, KeyLoader);\n\n    var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));\n\n    _this.loaders = {};\n    _this.decryptkey = null;\n    _this.decrypturl = null;\n    return _this;\n  }\n\n  _createClass(KeyLoader, [{\n    key: 'destroy',\n    value: function destroy() {\n      for (var loaderName in this.loaders) {\n        var loader = this.loaders[loaderName];\n        if (loader) {\n          loader.destroy();\n        }\n      }\n      this.loaders = {};\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n  }, {\n    key: 'onKeyLoading',\n    value: function onKeyLoading(data) {\n      var frag = data.frag,\n          type = frag.type,\n          loader = this.loaders[type],\n          decryptdata = frag.decryptdata,\n          uri = decryptdata.uri;\n      // if uri is different from previous one or if decrypt key not retrieved yet\n      if (uri !== this.decrypturl || this.decryptkey === null) {\n        var config = this.hls.config;\n\n        if (loader) {\n          _logger.logger.warn('abort previous key loader for type:' + type);\n          loader.abort();\n        }\n        frag.loader = this.loaders[type] = new config.loader(config);\n        this.decrypturl = uri;\n        this.decryptkey = null;\n\n        var loaderContext = void 0,\n            loaderConfig = void 0,\n            loaderCallbacks = void 0;\n        loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };\n        loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: config.fragLoadingMaxRetry, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };\n        loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };\n        frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);\n      } else if (this.decryptkey) {\n        // we already loaded this key, return it\n        decryptdata.key = this.decryptkey;\n        this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });\n      }\n    }\n  }, {\n    key: 'loadsuccess',\n    value: function loadsuccess(response, stats, context) {\n      var frag = context.frag;\n      this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);\n      // detach fragment loader on load success\n      frag.loader = undefined;\n      this.loaders[frag.type] = undefined;\n      this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });\n    }\n  }, {\n    key: 'loaderror',\n    value: function loaderror(response, context) {\n      var frag = context.frag,\n          loader = frag.loader;\n      if (loader) {\n        loader.abort();\n      }\n      this.loaders[context.type] = undefined;\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });\n    }\n  }, {\n    key: 'loadtimeout',\n    value: function loadtimeout(stats, context) {\n      var frag = context.frag,\n          loader = frag.loader;\n      if (loader) {\n        loader.abort();\n      }\n      this.loaders[context.type] = undefined;\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });\n    }\n  }]);\n\n  return KeyLoader;\n}(_eventHandler2.default);\n\nexports.default = KeyLoader;\n\n},{\"31\":31,\"32\":32,\"33\":33,\"50\":50}],41:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Playlist Loader\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _urlToolkit = _dereq_(2);\n\nvar _urlToolkit2 = _interopRequireDefault(_urlToolkit);\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _eventHandler = _dereq_(32);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _errors = _dereq_(31);\n\nvar _attrList = _dereq_(45);\n\nvar _attrList2 = _interopRequireDefault(_attrList);\n\nvar _logger = _dereq_(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// https://regex101.com is your friend\nvar MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\n\\r]*)[\\r\\n]+([^\\r\\n]+)/g;\nvar MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\nvar LEVEL_PLAYLIST_REGEX_FAST = /#EXTINF:(\\d*(?:\\.\\d+)?)(?:,(.*))?|(?!#)(\\S.+)|#EXT-X-BYTERANGE: *(.+)|#EXT-X-PROGRAM-DATE-TIME:(.+)|#.*/g;\nvar LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\\d+))|(?:#EXT-X-(TARGETDURATION): *(\\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\\r?\\n?/;\n\nvar LevelKey = function () {\n  function LevelKey() {\n    _classCallCheck(this, LevelKey);\n\n    this.method = null;\n    this.key = null;\n    this.iv = null;\n    this._uri = null;\n  }\n\n  _createClass(LevelKey, [{\n    key: 'uri',\n    get: function get() {\n      if (!this._uri && this.reluri) {\n        this._uri = _urlToolkit2.default.buildAbsoluteURL(this.baseuri, this.reluri);\n      }\n      return this._uri;\n    }\n  }]);\n\n  return LevelKey;\n}();\n\nvar Fragment = function () {\n  function Fragment() {\n    _classCallCheck(this, Fragment);\n\n    this._url = null;\n    this._byteRange = null;\n    this._decryptdata = null;\n    this.tagList = [];\n  }\n\n  _createClass(Fragment, [{\n    key: 'createInitializationVector',\n\n\n    /**\n     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment\n     * @returns {Uint8Array}\n     */\n    value: function createInitializationVector(segmentNumber) {\n      var uint8View = new Uint8Array(16);\n\n      for (var i = 12; i < 16; i++) {\n        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n      }\n\n      return uint8View;\n    }\n\n    /**\n     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data\n     * @param levelkey - a playlist's encryption info\n     * @param segmentNumber - the fragment's segment number\n     * @returns {*} - an object to be applied as a fragment's decryptdata\n     */\n\n  }, {\n    key: 'fragmentDecryptdataFromLevelkey',\n    value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {\n      var decryptdata = levelkey;\n\n      if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {\n        decryptdata = new LevelKey();\n        decryptdata.method = levelkey.method;\n        decryptdata.baseuri = levelkey.baseuri;\n        decryptdata.reluri = levelkey.reluri;\n        decryptdata.iv = this.createInitializationVector(segmentNumber);\n      }\n\n      return decryptdata;\n    }\n  }, {\n    key: 'cloneObj',\n    value: function cloneObj(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n  }, {\n    key: 'url',\n    get: function get() {\n      if (!this._url && this.relurl) {\n        this._url = _urlToolkit2.default.buildAbsoluteURL(this.baseurl, this.relurl);\n      }\n      return this._url;\n    },\n    set: function set(value) {\n      this._url = value;\n    }\n  }, {\n    key: 'programDateTime',\n    get: function get() {\n      if (!this._programDateTime && this.rawProgramDateTime) {\n        this._programDateTime = new Date(Date.parse(this.rawProgramDateTime));\n      }\n      return this._programDateTime;\n    }\n  }, {\n    key: 'byteRange',\n    get: function get() {\n      if (!this._byteRange) {\n        var byteRange = this._byteRange = [];\n        if (this.rawByteRange) {\n          var params = this.rawByteRange.split('@', 2);\n          if (params.length === 1) {\n            var lastByteRangeEndOffset = this.lastByteRangeEndOffset;\n            byteRange[0] = lastByteRangeEndOffset ? lastByteRangeEndOffset : 0;\n          } else {\n            byteRange[0] = parseInt(params[1]);\n          }\n          byteRange[1] = parseInt(params[0]) + byteRange[0];\n        }\n      }\n      return this._byteRange;\n    }\n  }, {\n    key: 'byteRangeStartOffset',\n    get: function get() {\n      return this.byteRange[0];\n    }\n  }, {\n    key: 'byteRangeEndOffset',\n    get: function get() {\n      return this.byteRange[1];\n    }\n  }, {\n    key: 'decryptdata',\n    get: function get() {\n      if (!this._decryptdata) {\n        this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);\n      }\n      return this._decryptdata;\n    }\n  }]);\n\n  return Fragment;\n}();\n\nvar PlaylistLoader = function (_EventHandler) {\n  _inherits(PlaylistLoader, _EventHandler);\n\n  function PlaylistLoader(hls) {\n    _classCallCheck(this, PlaylistLoader);\n\n    var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING, _events2.default.SUBTITLE_TRACK_LOADING));\n\n    _this.loaders = {};\n    return _this;\n  }\n\n  _createClass(PlaylistLoader, [{\n    key: 'destroy',\n    value: function destroy() {\n      for (var loaderName in this.loaders) {\n        var loader = this.loaders[loaderName];\n        if (loader) {\n          loader.destroy();\n        }\n      }\n      this.loaders = {};\n      _eventHandler2.default.prototype.destroy.call(this);\n    }\n  }, {\n    key: 'onManifestLoading',\n    value: function onManifestLoading(data) {\n      this.load(data.url, { type: 'manifest' });\n    }\n  }, {\n    key: 'onLevelLoading',\n    value: function onLevelLoading(data) {\n      this.load(data.url, { type: 'level', level: data.level, id: data.id });\n    }\n  }, {\n    key: 'onAudioTrackLoading',\n    value: function onAudioTrackLoading(data) {\n      this.load(data.url, { type: 'audioTrack', id: data.id });\n    }\n  }, {\n    key: 'onSubtitleTrackLoading',\n    value: function onSubtitleTrackLoading(data) {\n      this.load(data.url, { type: 'subtitleTrack', id: data.id });\n    }\n  }, {\n    key: 'load',\n    value: function load(url, context) {\n      var loader = this.loaders[context.type];\n      if (loader) {\n        var loaderContext = loader.context;\n        if (loaderContext && loaderContext.url === url) {\n          _logger.logger.trace('playlist request ongoing');\n          return;\n        } else {\n          _logger.logger.warn('abort previous loader for type:' + context.type);\n          loader.abort();\n        }\n      }\n      var config = this.hls.config,\n          retry = void 0,\n          timeout = void 0,\n          retryDelay = void 0,\n          maxRetryDelay = void 0;\n      if (context.type === 'manifest') {\n        retry = config.manifestLoadingMaxRetry;\n        timeout = config.manifestLoadingTimeOut;\n        retryDelay = config.manifestLoadingRetryDelay;\n        maxRetryDelay = config.manifestLoadingMaxRetryTimeout;\n      } else {\n        retry = config.levelLoadingMaxRetry;\n        timeout = config.levelLoadingTimeOut;\n        retryDelay = config.levelLoadingRetryDelay;\n        maxRetryDelay = config.levelLoadingMaxRetryTimeout;\n        _logger.logger.log('loading playlist for ' + context.type + ' ' + (context.level || context.id));\n      }\n      loader = this.loaders[context.type] = context.loader = typeof config.pLoader !== 'undefined' ? new config.pLoader(config) : new config.loader(config);\n      context.url = url;\n      context.responseType = '';\n\n      var loaderConfig = void 0,\n          loaderCallbacks = void 0;\n      loaderConfig = { timeout: timeout, maxRetry: retry, retryDelay: retryDelay, maxRetryDelay: maxRetryDelay };\n      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };\n      loader.load(context, loaderConfig, loaderCallbacks);\n    }\n  }, {\n    key: 'resolve',\n    value: function resolve(url, baseUrl) {\n      return _urlToolkit2.default.buildAbsoluteURL(baseUrl, url);\n    }\n  }, {\n    key: 'parseMasterPlaylist',\n    value: function parseMasterPlaylist(string, baseurl) {\n      var levels = [],\n          result = void 0;\n      MASTER_PLAYLIST_REGEX.lastIndex = 0;\n      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n        var level = {};\n\n        var attrs = level.attrs = new _attrList2.default(result[1]);\n        level.url = this.resolve(result[2], baseurl);\n\n        var resolution = attrs.decimalResolution('RESOLUTION');\n        if (resolution) {\n          level.width = resolution.width;\n          level.height = resolution.height;\n        }\n        level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');\n        level.name = attrs.NAME;\n\n        var codecs = attrs.CODECS;\n        if (codecs) {\n          codecs = codecs.split(/[ ,]+/);\n          for (var i = 0; i < codecs.length; i++) {\n            var codec = codecs[i];\n            if (codec.indexOf('avc1') !== -1) {\n              level.videoCodec = this.avc1toavcoti(codec);\n            } else {\n              level.audioCodec = codec;\n            }\n          }\n        }\n\n        levels.push(level);\n      }\n      return levels;\n    }\n  }, {\n    key: 'parseMasterPlaylistMedia',\n    value: function parseMasterPlaylistMedia(string, baseurl, type) {\n      var result = void 0,\n          medias = [],\n          id = 0;\n      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) != null) {\n        var media = {};\n        var attrs = new _attrList2.default(result[1]);\n        if (attrs.TYPE === type) {\n          media.groupId = attrs['GROUP-ID'];\n          media.name = attrs.NAME;\n          media.type = type;\n          media.default = attrs.DEFAULT === 'YES';\n          media.autoselect = attrs.AUTOSELECT === 'YES';\n          media.forced = attrs.FORCED === 'YES';\n          if (attrs.URI) {\n            media.url = this.resolve(attrs.URI, baseurl);\n          }\n          media.lang = attrs.LANGUAGE;\n          if (!media.name) {\n            media.name = media.lang;\n          }\n          media.id = id++;\n          medias.push(media);\n        }\n      }\n      return medias;\n    }\n  }, {\n    key: 'avc1toavcoti',\n    value: function avc1toavcoti(codec) {\n      var result,\n          avcdata = codec.split('.');\n      if (avcdata.length > 2) {\n        result = avcdata.shift() + '.';\n        result += parseInt(avcdata.shift()).toString(16);\n        result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);\n      } else {\n        result = codec;\n      }\n      return result;\n    }\n  }, {\n    key: 'parseLevelPlaylist',\n    value: function parseLevelPlaylist(string, baseurl, id, type) {\n      var currentSN = 0,\n          totalduration = 0,\n          level = { type: null, version: null, url: baseurl, fragments: [], live: true, startSN: 0 },\n          levelkey = new LevelKey(),\n          cc = 0,\n          prevFrag = null,\n          frag = new Fragment(),\n          result,\n          i;\n\n      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n\n      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n        var duration = result[1];\n        if (duration) {\n          // INF\n          frag.duration = parseFloat(duration);\n          // avoid sliced strings    https://github.com/dailymotion/hls.js/issues/939\n          var title = (' ' + result[2]).slice(1);\n          frag.title = title ? title : null;\n          frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n        } else if (result[3]) {\n          // url\n          if (!isNaN(frag.duration)) {\n            var sn = currentSN++;\n            frag.type = type;\n            frag.start = totalduration;\n            frag.levelkey = levelkey;\n            frag.sn = sn;\n            frag.level = id;\n            frag.cc = cc;\n            frag.baseurl = baseurl;\n            // avoid sliced strings    https://github.com/dailymotion/hls.js/issues/939\n            frag.relurl = (' ' + result[3]).slice(1);\n\n            level.fragments.push(frag);\n            prevFrag = frag;\n            totalduration += frag.duration;\n\n            frag = new Fragment();\n          }\n        } else if (result[4]) {\n          // X-BYTERANGE\n          frag.rawByteRange = (' ' + result[4]).slice(1);\n          if (prevFrag) {\n            var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;\n            if (lastByteRangeEndOffset) {\n              frag.lastByteRangeEndOffset = lastByteRangeEndOffset;\n            }\n          }\n        } else if (result[5]) {\n          // PROGRAM-DATE-TIME\n          // avoid sliced strings    https://github.com/dailymotion/hls.js/issues/939\n          frag.rawProgramDateTime = (' ' + result[5]).slice(1);\n          frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);\n        } else {\n          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n          for (i = 1; i < result.length; i++) {\n            if (result[i] !== undefined) {\n              break;\n            }\n          }\n\n          // avoid sliced strings    https://github.com/dailymotion/hls.js/issues/939\n          var value1 = (' ' + result[i + 1]).slice(1);\n          var value2 = (' ' + result[i + 2]).slice(1);\n\n          switch (result[i]) {\n            case '#':\n              frag.tagList.push(value2 ? [value1, value2] : [value1]);\n              break;\n            case 'PLAYLIST-TYPE':\n              level.type = value1.toUpperCase();\n              break;\n            case 'MEDIA-SEQUENCE':\n              currentSN = level.startSN = parseInt(value1);\n              break;\n            case 'TARGETDURATION':\n              level.targetduration = parseFloat(value1);\n              break;\n            case 'VERSION':\n              level.version = parseInt(value1);\n              break;\n            case 'EXTM3U':\n              break;\n            case 'ENDLIST':\n              level.live = false;\n              break;\n            case 'DIS':\n              cc++;\n              frag.tagList.push(['DIS']);\n              break;\n            case 'DISCONTINUITY-SEQ':\n              cc = parseInt(value1);\n              break;\n            case 'KEY':\n              // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4\n              var decryptparams = value1;\n              var keyAttrs = new _attrList2.default(decryptparams);\n              var decryptmethod = keyAttrs.enumeratedString('METHOD'),\n                  decrypturi = keyAttrs.URI,\n                  decryptiv = keyAttrs.hexadecimalInteger('IV');\n              if (decryptmethod) {\n                levelkey = new LevelKey();\n                if (decrypturi && ['AES-128', 'SAMPLE-AES'].indexOf(decryptmethod) >= 0) {\n                  levelkey.method = decryptmethod;\n                  // URI to get the key\n                  levelkey.baseuri = baseurl;\n                  levelkey.reluri = decrypturi;\n                  levelkey.key = null;\n                  // Initialization Vector (IV)\n                  levelkey.iv = decryptiv;\n                }\n              }\n              break;\n            case 'START':\n              var startParams = value1;\n              var startAttrs = new _attrList2.default(startParams);\n              var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n              //TIME-OFFSET can be 0\n              if (!isNaN(startTimeOffset)) {\n                level.startTimeOffset = startTimeOffset;\n              }\n              break;\n            case 'MAP':\n              var mapAttrs = new _attrList2.default(value1);\n              frag.relurl = mapAttrs.URI;\n              frag.rawByteRange = mapAttrs.BYTERANGE;\n              frag.baseurl = baseurl;\n              frag.level = id;\n              frag.type = type;\n              frag.sn = 'initSegment';\n              level.initSegment = frag;\n              frag = new Fragment();\n              break;\n            default:\n              _logger.logger.warn('line parsed but not handled: ' + result);\n              break;\n          }\n        }\n      }\n      frag = prevFrag;\n      //logger.log('found ' + level.fragments.length + ' fragments');\n      if (frag && !frag.relurl) {\n        level.fragments.pop();\n        totalduration -= frag.duration;\n      }\n      level.totalduration = totalduration;\n      level.averagetargetduration = totalduration / level.fragments.length;\n      level.endSN = currentSN - 1;\n      return level;\n    }\n  }, {\n    key: 'loadsuccess',\n    value: function loadsuccess(response, stats, context) {\n      var string = response.data,\n          url = response.url,\n          type = context.type,\n          id = context.id,\n          level = context.level,\n          hls = this.hls;\n\n      this.loaders[type] = undefined;\n      // responseURL not supported on some browsers (it is used to detect URL redirection)\n      // data-uri mode also not supported (but no need to detect redirection)\n      if (url === undefined || url.indexOf('data:') === 0) {\n        // fallback to initial URL\n        url = context.url;\n      }\n      stats.tload = performance.now();\n      //stats.mtime = new Date(target.getResponseHeader('Last-Modified'));\n      if (string.indexOf('#EXTM3U') === 0) {\n        if (string.indexOf('#EXTINF:') > 0) {\n          var isLevel = type !== 'audioTrack' && type !== 'subtitleTrack',\n              levelId = !isNaN(level) ? level : !isNaN(id) ? id : 0,\n              levelDetails = this.parseLevelPlaylist(string, url, levelId, type === 'audioTrack' ? 'audio' : type === 'subtitleTrack' ? 'subtitle' : 'main');\n          levelDetails.tload = stats.tload;\n          if (type === 'manifest') {\n            // first request, stream manifest (no master playlist), fire manifest loaded event with level details\n            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: [{ url: url, details: levelDetails }], audioTracks: [], url: url, stats: stats });\n          }\n          stats.tparsed = performance.now();\n          if (levelDetails.targetduration) {\n            if (isLevel) {\n              hls.trigger(_events2.default.LEVEL_LOADED, { details: levelDetails, level: level || 0, id: id || 0, stats: stats });\n            } else {\n              if (type === 'audioTrack') {\n                hls.trigger(_events2.default.AUDIO_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });\n              } else if (type === 'subtitleTrack') {\n                hls.trigger(_events2.default.SUBTITLE_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });\n              }\n            }\n          } else {\n            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'invalid targetduration' });\n          }\n        } else {\n          var levels = this.parseMasterPlaylist(string, url);\n          // multi level playlist, parse level info\n          if (levels.length) {\n            var audioTracks = this.parseMasterPlaylistMedia(string, url, 'AUDIO');\n            var subtitles = this.parseMasterPlaylistMedia(string, url, 'SUBTITLES');\n            if (audioTracks.length) {\n              // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n              var embeddedAudioFound = false;\n              audioTracks.forEach(function (audioTrack) {\n                if (!audioTrack.url) {\n                  embeddedAudioFound = true;\n                }\n              });\n              // if no embedded audio track defined, but audio codec signaled in quality level, we need to signal this main audio track\n              // this could happen with playlists with alt audio rendition in which quality levels (main) contains both audio+video. but with mixed audio track not signaled\n              if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n                _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');\n                audioTracks.unshift({ type: 'main', name: 'main' });\n              }\n            }\n            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: levels, audioTracks: audioTracks, subtitles: subtitles, url: url, stats: stats });\n          } else {\n            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no level found in manifest' });\n          }\n        }\n      } else {\n        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no EXTM3U delimiter' });\n      }\n    }\n  }, {\n    key: 'loaderror',\n    value: function loaderror(response, context) {\n      var details,\n          fatal,\n          loader = context.loader;\n      switch (context.type) {\n        case 'manifest':\n          details = _errors.ErrorDetails.MANIFEST_LOAD_ERROR;\n          fatal = true;\n          break;\n        case 'level':\n          details = _errors.ErrorDetails.LEVEL_LOAD_ERROR;\n          fatal = false;\n          break;\n        case 'audioTrack':\n          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n          fatal = false;\n          break;\n      }\n      if (loader) {\n        loader.abort();\n        this.loaders[context.type] = undefined;\n      }\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, response: response, context: context });\n    }\n  }, {\n    key: 'loadtimeout',\n    value: function loadtimeout(stats, context) {\n      var details,\n          fatal,\n          loader = context.loader;\n      switch (context.type) {\n        case 'manifest':\n          details = _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT;\n          fatal = true;\n          break;\n        case 'level':\n          details = _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT;\n          fatal = false;\n          break;\n        case 'audioTrack':\n          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT;\n          fatal = false;\n          break;\n      }\n      if (loader) {\n        loader.abort();\n        this.loaders[context.type] = undefined;\n      }\n      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, context: context });\n    }\n  }]);\n\n  return PlaylistLoader;\n}(_eventHandler2.default);\n\nexports.default = PlaylistLoader;\n\n},{\"2\":2,\"31\":31,\"32\":32,\"33\":33,\"45\":45,\"50\":50}],42:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Generate MP4 Box\n*/\n\n//import Hex from '../utils/hex';\nvar MP4 = function () {\n  function MP4() {\n    _classCallCheck(this, MP4);\n  }\n\n  _createClass(MP4, null, [{\n    key: 'init',\n    value: function init() {\n      MP4.types = {\n        avc1: [], // codingname\n        avcC: [],\n        btrt: [],\n        dinf: [],\n        dref: [],\n        esds: [],\n        ftyp: [],\n        hdlr: [],\n        mdat: [],\n        mdhd: [],\n        mdia: [],\n        mfhd: [],\n        minf: [],\n        moof: [],\n        moov: [],\n        mp4a: [],\n        '.mp3': [],\n        mvex: [],\n        mvhd: [],\n        pasp: [],\n        sdtp: [],\n        stbl: [],\n        stco: [],\n        stsc: [],\n        stsd: [],\n        stsz: [],\n        stts: [],\n        tfdt: [],\n        tfhd: [],\n        traf: [],\n        trak: [],\n        trun: [],\n        trex: [],\n        tkhd: [],\n        vmhd: [],\n        smhd: []\n      };\n\n      var i;\n      for (i in MP4.types) {\n        if (MP4.types.hasOwnProperty(i)) {\n          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n        }\n      }\n\n      var videoHdlr = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n      ]);\n\n      var audioHdlr = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n      ]);\n\n      MP4.HDLR_TYPES = {\n        'video': videoHdlr,\n        'audio': audioHdlr\n      };\n\n      var dref = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // entry_count\n      0x00, 0x00, 0x00, 0x0c, // entry_size\n      0x75, 0x72, 0x6c, 0x20, // 'url' type\n      0x00, // version 0\n      0x00, 0x00, 0x01 // entry_flags\n      ]);\n\n      var stco = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00 // entry_count\n      ]);\n\n      MP4.STTS = MP4.STSC = MP4.STCO = stco;\n\n      MP4.STSZ = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // sample_size\n      0x00, 0x00, 0x00, 0x00]);\n      MP4.VMHD = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x01, // flags\n      0x00, 0x00, // graphicsmode\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n      ]);\n      MP4.SMHD = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, // balance\n      0x00, 0x00 // reserved\n      ]);\n\n      MP4.STSD = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01]); // entry_count\n\n      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n      var minorVersion = new Uint8Array([0, 0, 0, 1]);\n\n      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n    }\n  }, {\n    key: 'box',\n    value: function box(type) {\n      var payload = Array.prototype.slice.call(arguments, 1),\n          size = 8,\n          i = payload.length,\n          len = i,\n          result;\n      // calculate the total size we need to allocate\n      while (i--) {\n        size += payload[i].byteLength;\n      }\n      result = new Uint8Array(size);\n      result[0] = size >> 24 & 0xff;\n      result[1] = size >> 16 & 0xff;\n      result[2] = size >> 8 & 0xff;\n      result[3] = size & 0xff;\n      result.set(type, 4);\n      // copy the payload into the result\n      for (i = 0, size = 8; i < len; i++) {\n        // copy payload[i] array @ offset size\n        result.set(payload[i], size);\n        size += payload[i].byteLength;\n      }\n      return result;\n    }\n  }, {\n    key: 'hdlr',\n    value: function hdlr(type) {\n      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n    }\n  }, {\n    key: 'mdat',\n    value: function mdat(data) {\n      return MP4.box(MP4.types.mdat, data);\n    }\n  }, {\n    key: 'mdhd',\n    value: function mdhd(timescale, duration) {\n      duration *= timescale;\n      return MP4.box(MP4.types.mdhd, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x02, // creation_time\n      0x00, 0x00, 0x00, 0x03, // modification_time\n      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale\n      duration >> 24, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration\n      0x55, 0xc4, // 'und' language (undetermined)\n      0x00, 0x00]));\n    }\n  }, {\n    key: 'mdia',\n    value: function mdia(track) {\n      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n    }\n  }, {\n    key: 'mfhd',\n    value: function mfhd(sequenceNumber) {\n      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags\n      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]));\n    }\n  }, {\n    key: 'minf',\n    value: function minf(track) {\n      if (track.type === 'audio') {\n        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n      } else {\n        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n      }\n    }\n  }, {\n    key: 'moof',\n    value: function moof(sn, baseMediaDecodeTime, track) {\n      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n    }\n    /**\n     * @param tracks... (optional) {array} the tracks associated with this movie\n     */\n\n  }, {\n    key: 'moov',\n    value: function moov(tracks) {\n      var i = tracks.length,\n          boxes = [];\n\n      while (i--) {\n        boxes[i] = MP4.trak(tracks[i]);\n      }\n\n      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));\n    }\n  }, {\n    key: 'mvex',\n    value: function mvex(tracks) {\n      var i = tracks.length,\n          boxes = [];\n\n      while (i--) {\n        boxes[i] = MP4.trex(tracks[i]);\n      }\n      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));\n    }\n  }, {\n    key: 'mvhd',\n    value: function mvhd(timescale, duration) {\n      duration *= timescale;\n      var bytes = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // creation_time\n      0x00, 0x00, 0x00, 0x02, // modification_time\n      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale\n      duration >> 24 & 0xFF, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration\n      0x00, 0x01, 0x00, 0x00, // 1.0 rate\n      0x01, 0x00, // 1.0 volume\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n      0xff, 0xff, 0xff, 0xff // next_track_ID\n      ]);\n      return MP4.box(MP4.types.mvhd, bytes);\n    }\n  }, {\n    key: 'sdtp',\n    value: function sdtp(track) {\n      var samples = track.samples || [],\n          bytes = new Uint8Array(4 + samples.length),\n          flags,\n          i;\n      // leave the full box header (4 bytes) all zero\n      // write the sample table\n      for (i = 0; i < samples.length; i++) {\n        flags = samples[i].flags;\n        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n      }\n\n      return MP4.box(MP4.types.sdtp, bytes);\n    }\n  }, {\n    key: 'stbl',\n    value: function stbl(track) {\n      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n    }\n  }, {\n    key: 'avc1',\n    value: function avc1(track) {\n      var sps = [],\n          pps = [],\n          i,\n          data,\n          len;\n      // assemble the SPSs\n\n      for (i = 0; i < track.sps.length; i++) {\n        data = track.sps[i];\n        len = data.byteLength;\n        sps.push(len >>> 8 & 0xFF);\n        sps.push(len & 0xFF);\n        sps = sps.concat(Array.prototype.slice.call(data)); // SPS\n      }\n\n      // assemble the PPSs\n      for (i = 0; i < track.pps.length; i++) {\n        data = track.pps[i];\n        len = data.byteLength;\n        pps.push(len >>> 8 & 0xFF);\n        pps.push(len & 0xFF);\n        pps = pps.concat(Array.prototype.slice.call(data));\n      }\n\n      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version\n      sps[3], // profile\n      sps[4], // profile compat\n      sps[5], // level\n      0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes\n      0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n      ]).concat(pps))),\n          // \"PPS\"\n      width = track.width,\n          height = track.height,\n          hSpacing = track.pixelRatio[0],\n          vSpacing = track.pixelRatio[1];\n      //console.log('avcc:' + Hex.hexDump(avcc));\n      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n      width >> 8 & 0xFF, width & 0xff, // width\n      height >> 8 & 0xFF, height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n      0x12, 0x64, 0x61, 0x69, 0x6C, //dailymotion/hls.js\n      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11]), // pre_defined = -1\n      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n      0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate\n      MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing\n      hSpacing >> 16 & 0xFF, hSpacing >> 8 & 0xFF, hSpacing & 0xFF, vSpacing >> 24, // vSpacing\n      vSpacing >> 16 & 0xFF, vSpacing >> 8 & 0xFF, vSpacing & 0xFF])));\n    }\n  }, {\n    key: 'esds',\n    value: function esds(track) {\n      var configlen = track.config.length;\n      return new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n\n      0x03, // descriptor_type\n      0x17 + configlen, // length\n      0x00, 0x01, //es_id\n      0x00, // stream_priority\n\n      0x04, // descriptor_type\n      0x0f + configlen, // length\n      0x40, //codec : mpeg4_audio\n      0x15, // stream_type\n      0x00, 0x00, 0x00, // buffer_size\n      0x00, 0x00, 0x00, 0x00, // maxBitrate\n      0x00, 0x00, 0x00, 0x00, // avgBitrate\n\n      0x05 // descriptor_type\n      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\n    }\n  }, {\n    key: 'mp4a',\n    value: function mp4a(track) {\n      var audiosamplerate = track.audiosamplerate;\n      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, track.channelCount, // channelcount\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, 0x00, 0x00, // reserved2\n      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //\n      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));\n    }\n  }, {\n    key: 'mp3',\n    value: function mp3(track) {\n      var audiosamplerate = track.audiosamplerate;\n      return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, track.channelCount, // channelcount\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, 0x00, 0x00, // reserved2\n      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //\n      0x00, 0x00]));\n    }\n  }, {\n    key: 'stsd',\n    value: function stsd(track) {\n      if (track.type === 'audio') {\n        if (!track.isAAC && track.codec === 'mp3') {\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n        }\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n      } else {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n      }\n    }\n  }, {\n    key: 'tkhd',\n    value: function tkhd(track) {\n      var id = track.id,\n          duration = track.duration * track.timescale,\n          width = track.width,\n          height = track.height;\n      return MP4.box(MP4.types.tkhd, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x07, // flags\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // modification_time\n      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID\n      0x00, 0x00, 0x00, 0x00, // reserved\n      duration >> 24, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, // layer\n      0x00, 0x00, // alternate_group\n      0x00, 0x00, // non-audio track volume\n      0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width\n      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height\n      ]));\n    }\n  }, {\n    key: 'traf',\n    value: function traf(track, baseMediaDecodeTime) {\n      var sampleDependencyTable = MP4.sdtp(track),\n          id = track.id;\n      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF])), MP4.box(MP4.types.tfdt, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      baseMediaDecodeTime >> 24, baseMediaDecodeTime >> 16 & 0XFF, baseMediaDecodeTime >> 8 & 0XFF, baseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd\n      16 + // tfdt\n      8 + // traf header\n      16 + // mfhd\n      8 + // moof header\n      8), // mdat header\n      sampleDependencyTable);\n    }\n\n    /**\n     * Generate a track box.\n     * @param track {object} a track definition\n     * @return {Uint8Array} the track box\n     */\n\n  }, {\n    key: 'trak',\n    value: function trak(track) {\n      track.duration = track.duration || 0xffffffff;\n      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n    }\n  }, {\n    key: 'trex',\n    value: function trex(track) {\n      var id = track.id;\n      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x00, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x01, 0x00, 0x01 // default_sample_flags\n      ]));\n    }\n  }, {\n    key: 'trun',\n    value: function trun(track, offset) {\n      var samples = track.samples || [],\n          len = samples.length,\n          arraylen = 12 + 16 * len,\n          array = new Uint8Array(arraylen),\n          i,\n          sample,\n          duration,\n          size,\n          flags,\n          cts;\n      offset += 8 + arraylen;\n      array.set([0x00, // version 0\n      0x00, 0x0f, 0x01, // flags\n      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count\n      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset\n      ], 0);\n      for (i = 0; i < len; i++) {\n        sample = samples[i];\n        duration = sample.duration;\n        size = sample.size;\n        flags = sample.flags;\n        cts = sample.cts;\n        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration\n        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size\n        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags\n        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset\n        ], 12 + 16 * i);\n      }\n      return MP4.box(MP4.types.trun, array);\n    }\n  }, {\n    key: 'initSegment',\n    value: function initSegment(tracks) {\n      if (!MP4.types) {\n        MP4.init();\n      }\n      var movie = MP4.moov(tracks),\n          result;\n      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);\n      result.set(MP4.FTYP);\n      result.set(movie, MP4.FTYP.byteLength);\n      return result;\n    }\n  }]);\n\n  return MP4;\n}();\n\nexports.default = MP4;\n\n},{}],43:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fMP4 remuxer\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _aac = _dereq_(34);\n\nvar _aac2 = _interopRequireDefault(_aac);\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _logger = _dereq_(50);\n\nvar _mp4Generator = _dereq_(42);\n\nvar _mp4Generator2 = _interopRequireDefault(_mp4Generator);\n\nvar _errors = _dereq_(31);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MP4Remuxer = function () {\n  function MP4Remuxer(observer, config, typeSupported) {\n    _classCallCheck(this, MP4Remuxer);\n\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.ISGenerated = false;\n    this.PES2MP4SCALEFACTOR = 4;\n    this.PES_TIMESCALE = 90000;\n    this.MP4_TIMESCALE = this.PES_TIMESCALE / this.PES2MP4SCALEFACTOR;\n  }\n\n  _createClass(MP4Remuxer, [{\n    key: 'destroy',\n    value: function destroy() {}\n  }, {\n    key: 'resetTimeStamp',\n    value: function resetTimeStamp(defaultTimeStamp) {\n      this._initPTS = this._initDTS = defaultTimeStamp;\n    }\n  }, {\n    key: 'resetInitSegment',\n    value: function resetInitSegment() {\n      this.ISGenerated = false;\n    }\n  }, {\n    key: 'remux',\n    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {\n      // generate Init Segment if needed\n      if (!this.ISGenerated) {\n        this.generateIS(audioTrack, videoTrack, timeOffset);\n      }\n\n      if (this.ISGenerated) {\n        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is\n        // calculated in remuxAudio.\n        //logger.log('nb AAC samples:' + audioTrack.samples.length);\n        if (audioTrack.samples.length) {\n          var audioData = this.remuxAudio(audioTrack, timeOffset, contiguous, accurateTimeOffset);\n          //logger.log('nb AVC samples:' + videoTrack.samples.length);\n          if (videoTrack.samples.length) {\n            var audioTrackLength = void 0;\n            if (audioData) {\n              audioTrackLength = audioData.endPTS - audioData.startPTS;\n            }\n            this.remuxVideo(videoTrack, timeOffset, contiguous, audioTrackLength);\n          }\n        } else {\n          var videoData = void 0;\n          //logger.log('nb AVC samples:' + videoTrack.samples.length);\n          if (videoTrack.samples.length) {\n            videoData = this.remuxVideo(videoTrack, timeOffset, contiguous);\n          }\n          if (videoData && audioTrack.codec) {\n            this.remuxEmptyAudio(audioTrack, timeOffset, contiguous, videoData);\n          }\n        }\n      }\n      //logger.log('nb ID3 samples:' + audioTrack.samples.length);\n      if (id3Track.samples.length) {\n        this.remuxID3(id3Track, timeOffset);\n      }\n      //logger.log('nb ID3 samples:' + audioTrack.samples.length);\n      if (textTrack.samples.length) {\n        this.remuxText(textTrack, timeOffset);\n      }\n      //notify end of parsing\n      this.observer.trigger(_events2.default.FRAG_PARSED);\n    }\n  }, {\n    key: 'generateIS',\n    value: function generateIS(audioTrack, videoTrack, timeOffset) {\n      var observer = this.observer,\n          audioSamples = audioTrack.samples,\n          videoSamples = videoTrack.samples,\n          pesTimeScale = this.PES_TIMESCALE,\n          typeSupported = this.typeSupported,\n          container = 'audio/mp4',\n          tracks = {},\n          data = { tracks: tracks, unique: false },\n          computePTSDTS = this._initPTS === undefined,\n          initPTS,\n          initDTS;\n\n      if (computePTSDTS) {\n        initPTS = initDTS = Infinity;\n      }\n      if (audioTrack.config && audioSamples.length) {\n        audioTrack.timescale = audioTrack.audiosamplerate;\n        // MP4 duration (track duration in seconds multiplied by timescale) is coded on 32 bits\n        // we know that each AAC sample contains 1024 frames....\n        // in order to avoid overflowing the 32 bit counter for large duration, we use smaller timescale (timescale/gcd)\n        // we just need to ensure that AAC sample duration will still be an integer (will be 1024/gcd)\n        if (audioTrack.timescale * audioTrack.duration > Math.pow(2, 32)) {\n          (function () {\n            var greatestCommonDivisor = function greatestCommonDivisor(a, b) {\n              if (!b) {\n                return a;\n              }\n              return greatestCommonDivisor(b, a % b);\n            };\n            audioTrack.timescale = audioTrack.audiosamplerate / greatestCommonDivisor(audioTrack.audiosamplerate, audioTrack.isAAC ? 1024 : 1152);\n          })();\n        }\n        _logger.logger.log('audio mp4 timescale :' + audioTrack.timescale);\n        if (!audioTrack.isAAC) {\n          if (typeSupported.mpeg) {\n            // Chrome and Safari\n            container = 'audio/mpeg';\n            audioTrack.codec = '';\n          } else if (typeSupported.mp3) {\n            // Firefox\n            audioTrack.codec = 'mp3';\n          }\n        }\n        tracks.audio = {\n          container: container,\n          codec: audioTrack.codec,\n          initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : _mp4Generator2.default.initSegment([audioTrack]),\n          metadata: {\n            channelCount: audioTrack.channelCount\n          }\n        };\n        if (computePTSDTS) {\n          // remember first PTS of this demuxing context. for audio, PTS = DTS\n          initPTS = initDTS = audioSamples[0].pts - pesTimeScale * timeOffset;\n        }\n      }\n\n      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n        videoTrack.timescale = this.MP4_TIMESCALE;\n        tracks.video = {\n          container: 'video/mp4',\n          codec: videoTrack.codec,\n          initSegment: _mp4Generator2.default.initSegment([videoTrack]),\n          metadata: {\n            width: videoTrack.width,\n            height: videoTrack.height\n          }\n        };\n        if (computePTSDTS) {\n          initPTS = Math.min(initPTS, videoSamples[0].pts - pesTimeScale * timeOffset);\n          initDTS = Math.min(initDTS, videoSamples[0].dts - pesTimeScale * timeOffset);\n          this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });\n        }\n      }\n\n      if (Object.keys(tracks).length) {\n        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);\n        this.ISGenerated = true;\n        if (computePTSDTS) {\n          this._initPTS = initPTS;\n          this._initDTS = initDTS;\n        }\n      } else {\n        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });\n      }\n    }\n  }, {\n    key: 'remuxVideo',\n    value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n      var offset = 8,\n          pesTimeScale = this.PES_TIMESCALE,\n          pes2mp4ScaleFactor = this.PES2MP4SCALEFACTOR,\n          mp4SampleDuration,\n          mdat,\n          moof,\n          firstPTS,\n          firstDTS,\n          nextDTS,\n          lastPTS,\n          lastDTS,\n          inputSamples = track.samples,\n          outputSamples = [],\n          nbSamples = inputSamples.length,\n          ptsNormalize = this._PTSNormalize,\n          initDTS = this._initDTS;\n\n      // for (let i = 0; i < track.samples.length; i++) {\n      //   let avcSample = track.samples[i];\n      //   let units = avcSample.units.units;\n      //   let unitsString = '';\n      //   for (let j = 0; j < units.length ; j++) {\n      //     unitsString += units[j].type + ',';\n      //     if (units[j].data.length < 500) {\n      //       unitsString += Hex.hexDump(units[j].data);\n      //     }\n      //   }\n      //   logger.log(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);\n      // }\n\n      // sort video samples by DTS then PTS order\n      inputSamples.sort(function (a, b) {\n        var deltadts = a.dts - b.dts;\n        return deltadts ? deltadts : a.pts - b.pts;\n      });\n\n      // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)\n      var PTSDTSshift = inputSamples.reduce(function (prev, curr) {\n        return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);\n      }, 0);\n      if (PTSDTSshift < 0) {\n        _logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');\n        for (var i = 0; i < inputSamples.length; i++) {\n          inputSamples[i].dts += PTSDTSshift;\n        }\n      }\n\n      // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n      // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n      var nextAvcDts = void 0;\n      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n      if (contiguous) {\n        // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n        nextAvcDts = this.nextAvcDts;\n      } else {\n        // if not contiguous, let's use target timeOffset\n        nextAvcDts = timeOffset * pesTimeScale;\n      }\n\n      // compute first DTS and last DTS, normalize them against reference value\n      var sample = inputSamples[0];\n      firstDTS = Math.max(ptsNormalize(sample.dts - initDTS, nextAvcDts), 0);\n      firstPTS = Math.max(ptsNormalize(sample.pts - initDTS, nextAvcDts), 0);\n\n      // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)\n      var delta = Math.round((firstDTS - nextAvcDts) / 90);\n      // if fragment are contiguous, detect hole/overlapping between fragments\n      if (contiguous) {\n        if (delta) {\n          if (delta > 1) {\n            _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');\n          } else if (delta < -1) {\n            _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');\n          }\n          // remove hole/gap : set DTS to next expected DTS\n          firstDTS = nextAvcDts;\n          inputSamples[0].dts = firstDTS + initDTS;\n          // offset PTS as well, ensure that PTS is smaller or equal than new DTS\n          firstPTS = Math.max(firstPTS - delta, nextAvcDts);\n          inputSamples[0].pts = firstPTS + initDTS;\n          _logger.logger.log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');\n        }\n      }\n      nextDTS = firstDTS;\n\n      // compute lastPTS/lastDTS\n      sample = inputSamples[inputSamples.length - 1];\n      lastDTS = Math.max(ptsNormalize(sample.dts - initDTS, nextAvcDts), 0);\n      lastPTS = Math.max(ptsNormalize(sample.pts - initDTS, nextAvcDts), 0);\n      lastPTS = Math.max(lastPTS, lastDTS);\n\n      var vendor = navigator.vendor,\n          userAgent = navigator.userAgent,\n          isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');\n\n      // on Safari let's signal the same sample duration for all samples\n      // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n      // set this constant duration as being the avg delta between consecutive DTS.\n      if (isSafari) {\n        mp4SampleDuration = Math.round((lastDTS - firstDTS) / (pes2mp4ScaleFactor * (inputSamples.length - 1)));\n      }\n\n      var nbNalu = 0,\n          naluLen = 0;\n      for (var _i = 0; _i < nbSamples; _i++) {\n        // compute total/avc sample length and nb of NAL units\n        var _sample = inputSamples[_i],\n            units = _sample.units.units,\n            nbUnits = units.length,\n            sampleLen = 0;\n        for (var j = 0; j < nbUnits; j++) {\n          sampleLen += units[j].data.length;\n        }\n        naluLen += sampleLen;\n        nbNalu += nbUnits;\n        _sample.length = sampleLen;\n\n        // normalize PTS/DTS\n        if (isSafari) {\n          // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples\n          _sample.dts = firstDTS + _i * pes2mp4ScaleFactor * mp4SampleDuration;\n        } else {\n          // ensure sample monotonic DTS\n          _sample.dts = Math.max(ptsNormalize(_sample.dts - initDTS, nextAvcDts), firstDTS);\n          // ensure dts is a multiple of scale factor to avoid rounding issues\n          _sample.dts = Math.round(_sample.dts / pes2mp4ScaleFactor) * pes2mp4ScaleFactor;\n        }\n        // we normalize PTS against nextAvcDts, we also substract initDTS (some streams don't start @ PTS O)\n        // and we ensure that computed value is greater or equal than sample DTS\n        _sample.pts = Math.max(ptsNormalize(_sample.pts - initDTS, nextAvcDts), _sample.dts);\n        // ensure pts is a multiple of scale factor to avoid rounding issues\n        _sample.pts = Math.round(_sample.pts / pes2mp4ScaleFactor) * pes2mp4ScaleFactor;\n      }\n\n      /* concatenate the video data and construct the mdat in place\n        (need 8 more bytes to fill length and mpdat type) */\n      var mdatSize = naluLen + 4 * nbNalu + 8;\n      try {\n        mdat = new Uint8Array(mdatSize);\n      } catch (err) {\n        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating video mdat ' + mdatSize });\n        return;\n      }\n      var view = new DataView(mdat.buffer);\n      view.setUint32(0, mdatSize);\n      mdat.set(_mp4Generator2.default.types.mdat, 4);\n\n      for (var _i2 = 0; _i2 < nbSamples; _i2++) {\n        var avcSample = inputSamples[_i2],\n            avcSampleUnits = avcSample.units.units,\n            mp4SampleLength = 0,\n            compositionTimeOffset = void 0;\n        // convert NALU bitstream to MP4 format (prepend NALU with size field)\n        for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {\n          var unit = avcSampleUnits[_j],\n              unitData = unit.data,\n              unitDataLen = unit.data.byteLength;\n          view.setUint32(offset, unitDataLen);\n          offset += 4;\n          mdat.set(unitData, offset);\n          offset += unitDataLen;\n          mp4SampleLength += 4 + unitDataLen;\n        }\n\n        if (!isSafari) {\n          // expected sample duration is the Decoding Timestamp diff of consecutive samples\n          if (_i2 < nbSamples - 1) {\n            mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;\n          } else {\n            var config = this.config,\n                lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;\n            if (config.stretchShortVideoTrack) {\n              // In some cases, a segment's audio track duration may exceed the video track duration.\n              // Since we've already remuxed audio, and we know how long the audio track is, we look to\n              // see if the delta to the next segment is longer than the minimum of maxBufferHole and\n              // maxSeekHole. If so, playback would potentially get stuck, so we artificially inflate\n              // the duration of the last frame to minimize any potential gap between segments.\n              var maxBufferHole = config.maxBufferHole,\n                  maxSeekHole = config.maxSeekHole,\n                  gapTolerance = Math.floor(Math.min(maxBufferHole, maxSeekHole) * pesTimeScale),\n                  deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * pesTimeScale : this.nextAudioPts) - avcSample.pts;\n              if (deltaToFrameEnd > gapTolerance) {\n                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n                // frame overlap. maxBufferHole/maxSeekHole should be >> lastFrameDuration anyway.\n                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n                if (mp4SampleDuration < 0) {\n                  mp4SampleDuration = lastFrameDuration;\n                }\n                _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');\n              } else {\n                mp4SampleDuration = lastFrameDuration;\n              }\n            } else {\n              mp4SampleDuration = lastFrameDuration;\n            }\n          }\n          mp4SampleDuration /= pes2mp4ScaleFactor;\n          compositionTimeOffset = Math.round((avcSample.pts - avcSample.dts) / pes2mp4ScaleFactor);\n        } else {\n          compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / (pes2mp4ScaleFactor * mp4SampleDuration)));\n        }\n\n        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');\n        outputSamples.push({\n          size: mp4SampleLength,\n          // constant duration\n          duration: mp4SampleDuration,\n          cts: compositionTimeOffset,\n          flags: {\n            isLeading: 0,\n            isDependedOn: 0,\n            hasRedundancy: 0,\n            degradPrio: 0,\n            dependsOn: avcSample.key ? 2 : 1,\n            isNonSync: avcSample.key ? 0 : 1\n          }\n        });\n      }\n      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n      this.nextAvcDts = lastDTS + mp4SampleDuration * pes2mp4ScaleFactor;\n      var dropped = track.dropped;\n      track.len = 0;\n      track.nbNalu = 0;\n      track.dropped = 0;\n      if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {\n        var flags = outputSamples[0].flags;\n        // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue\n        // https://code.google.com/p/chromium/issues/detail?id=229412\n        flags.dependsOn = 2;\n        flags.isNonSync = 0;\n      }\n      track.samples = outputSamples;\n      moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / pes2mp4ScaleFactor, track);\n      track.samples = [];\n\n      var data = {\n        data1: moof,\n        data2: mdat,\n        startPTS: firstPTS / pesTimeScale,\n        endPTS: (lastPTS + pes2mp4ScaleFactor * mp4SampleDuration) / pesTimeScale,\n        startDTS: firstDTS / pesTimeScale,\n        endDTS: this.nextAvcDts / pesTimeScale,\n        type: 'video',\n        nb: outputSamples.length,\n        dropped: dropped\n      };\n      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);\n      return data;\n    }\n  }, {\n    key: 'remuxAudio',\n    value: function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {\n      var pesTimeScale = this.PES_TIMESCALE,\n          mp4timeScale = track.timescale,\n          pes2mp4ScaleFactor = pesTimeScale / mp4timeScale,\n          expectedSampleDuration = track.timescale * (track.isAAC ? 1024 : 1152) / track.audiosamplerate,\n          pesFrameDuration = expectedSampleDuration * pes2mp4ScaleFactor,\n          ptsNormalize = this._PTSNormalize,\n          initDTS = this._initDTS,\n          rawMPEG = !track.isAAC && this.typeSupported.mpeg;\n\n      var view,\n          offset = rawMPEG ? 0 : 8,\n          audioSample,\n          mp4Sample,\n          unit,\n          mdat,\n          moof,\n          firstPTS,\n          firstDTS,\n          lastDTS,\n          pts,\n          dts,\n          ptsnorm,\n          dtsnorm,\n          outputSamples = [],\n          inputSamples = [],\n          fillFrame,\n          newStamp,\n          nextAudioPts;\n\n      track.samples.sort(function (a, b) {\n        return a.pts - b.pts;\n      });\n      inputSamples = track.samples;\n\n      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n      // for sake of clarity:\n      // consecutive fragments are frags with\n      //  - less than 100ms gaps between new time offset and next expected PTS OR\n      //  - less than 20 audio frames distance\n      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n      // this helps ensuring audio continuity\n      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n\n      nextAudioPts = this.nextAudioPts;\n      contiguous |= inputSamples.length && nextAudioPts && (Math.abs(timeOffset - nextAudioPts / pesTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - this._initDTS) < 20 * pesFrameDuration);\n\n      if (!contiguous) {\n        // if fragments are not contiguous, let's use timeOffset to compute next Audio PTS\n        nextAudioPts = timeOffset * pesTimeScale;\n      }\n      // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n      // In an effort to prevent this from happening, we inject frames here where there are gaps.\n      // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n      // frame.\n\n      // only inject/drop audio frames in case time offset is accurate\n      if (accurateTimeOffset && track.isAAC) {\n        for (var i = 0, nextPtsNorm = nextAudioPts; i < inputSamples.length;) {\n          // First, let's see how far off this frame is from where we expect it to be\n          var sample = inputSamples[i],\n              ptsNorm = ptsNormalize(sample.pts - initDTS, nextAudioPts),\n              delta = ptsNorm - nextPtsNorm;\n\n          // If we're overlapping by more than a duration, drop this sample\n          if (delta <= -pesFrameDuration) {\n            _logger.logger.warn('Dropping 1 audio frame @ ' + Math.round(nextPtsNorm / 90) / 1000 + 's due to ' + Math.round(Math.abs(delta / 90)) + ' ms overlap.');\n            inputSamples.splice(i, 1);\n            track.len -= sample.unit.length;\n            // Don't touch nextPtsNorm or i\n          }\n          // Otherwise, if we're more than a frame away from where we should be, insert missing frames\n          // also only inject silent audio frames if currentTime !== 0 (nextPtsNorm !== 0)\n          else if (delta >= pesFrameDuration && nextPtsNorm) {\n              var missing = Math.round(delta / pesFrameDuration);\n              _logger.logger.warn('Injecting ' + missing + ' audio frame @ ' + Math.round(nextPtsNorm / 90) / 1000 + 's due to ' + Math.round(delta / 90) + ' ms gap.');\n              for (var j = 0; j < missing; j++) {\n                newStamp = nextPtsNorm + initDTS;\n                newStamp = Math.max(newStamp, initDTS);\n                fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                if (!fillFrame) {\n                  _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');\n                  fillFrame = sample.unit.subarray();\n                }\n                inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });\n                track.len += fillFrame.length;\n                nextPtsNorm += pesFrameDuration;\n                i += 1;\n              }\n\n              // Adjust sample to next expected pts\n              sample.pts = sample.dts = nextPtsNorm + initDTS;\n              nextPtsNorm += pesFrameDuration;\n              i += 1;\n            }\n            // Otherwise, we're within half a frame duration, so just adjust pts\n            else {\n                if (Math.abs(delta) > 0.1 * pesFrameDuration) {\n                  //logger.log(`Invalid frame delta ${Math.round(ptsNorm - nextPtsNorm + pesFrameDuration)} at PTS ${Math.round(ptsNorm / 90)} (should be ${Math.round(pesFrameDuration)}).`);\n                }\n                nextPtsNorm += pesFrameDuration;\n                if (i === 0) {\n                  sample.pts = sample.dts = initDTS + nextAudioPts;\n                } else {\n                  sample.pts = sample.dts = inputSamples[i - 1].pts + pesFrameDuration;\n                }\n                i += 1;\n              }\n        }\n      }\n\n      for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {\n        audioSample = inputSamples[_j2];\n        unit = audioSample.unit;\n        pts = audioSample.pts - initDTS;\n        dts = audioSample.dts - initDTS;\n        //logger.log(`Audio/PTS:${Math.round(pts/90)}`);\n        // if not first sample\n        if (lastDTS !== undefined) {\n          ptsnorm = ptsNormalize(pts, lastDTS);\n          dtsnorm = ptsNormalize(dts, lastDTS);\n          mp4Sample.duration = Math.round((dtsnorm - lastDTS) / pes2mp4ScaleFactor);\n        } else {\n          ptsnorm = ptsNormalize(pts, nextAudioPts);\n          dtsnorm = ptsNormalize(dts, nextAudioPts);\n          var _delta = Math.round(1000 * (ptsnorm - nextAudioPts) / pesTimeScale),\n              numMissingFrames = 0;\n          // if fragment are contiguous, detect hole/overlapping between fragments\n          // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n          if (contiguous && track.isAAC) {\n            // log delta\n            if (_delta) {\n              if (_delta > 0) {\n                numMissingFrames = Math.round((ptsnorm - nextAudioPts) / pesFrameDuration);\n                _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');\n                if (numMissingFrames > 0) {\n                  fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                  if (!fillFrame) {\n                    fillFrame = unit.subarray();\n                  }\n                  track.len += numMissingFrames * fillFrame.length;\n                }\n                // if we have frame overlap, overlapping for more than half a frame duraion\n              } else if (_delta < -12) {\n                // drop overlapping audio frames... browser will deal with it\n                _logger.logger.log(-_delta + ' ms overlapping between AAC samples detected, drop frame');\n                track.len -= unit.byteLength;\n                continue;\n              }\n              // set PTS/DTS to expected PTS/DTS\n              ptsnorm = dtsnorm = nextAudioPts;\n            }\n          }\n          // remember first PTS of our audioSamples, ensure value is positive\n          firstPTS = Math.max(0, ptsnorm);\n          firstDTS = Math.max(0, dtsnorm);\n          if (track.len > 0) {\n            /* concatenate the audio data and construct the mdat in place\n              (need 8 more bytes to fill length and mdat type) */\n\n            var mdatSize = rawMPEG ? track.len : track.len + 8;\n            try {\n              mdat = new Uint8Array(mdatSize);\n            } catch (err) {\n              this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating audio mdat ' + mdatSize });\n              return;\n            }\n            if (!rawMPEG) {\n              view = new DataView(mdat.buffer);\n              view.setUint32(0, mdatSize);\n              mdat.set(_mp4Generator2.default.types.mdat, 4);\n            }\n          } else {\n            // no audio samples\n            return;\n          }\n          for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {\n            newStamp = ptsnorm - (numMissingFrames - _i3) * pesFrameDuration;\n            fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n            if (!fillFrame) {\n              _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');\n              fillFrame = unit.subarray();\n            }\n            mdat.set(fillFrame, offset);\n            offset += fillFrame.byteLength;\n            mp4Sample = {\n              size: fillFrame.byteLength,\n              cts: 0,\n              duration: 1024,\n              flags: {\n                isLeading: 0,\n                isDependedOn: 0,\n                hasRedundancy: 0,\n                degradPrio: 0,\n                dependsOn: 1\n              }\n            };\n            outputSamples.push(mp4Sample);\n          }\n        }\n        mdat.set(unit, offset);\n        var unitLen = unit.byteLength;\n        offset += unitLen;\n        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');\n        mp4Sample = {\n          size: unitLen,\n          cts: 0,\n          duration: 0,\n          flags: {\n            isLeading: 0,\n            isDependedOn: 0,\n            hasRedundancy: 0,\n            degradPrio: 0,\n            dependsOn: 1\n          }\n        };\n        outputSamples.push(mp4Sample);\n        lastDTS = dtsnorm;\n      }\n      var lastSampleDuration = 0;\n      var nbSamples = outputSamples.length;\n      //set last sample duration as being identical to previous sample\n      if (nbSamples >= 2) {\n        lastSampleDuration = outputSamples[nbSamples - 2].duration;\n        mp4Sample.duration = lastSampleDuration;\n      }\n      if (nbSamples) {\n        // next audio sample PTS should be equal to last sample PTS + duration\n        this.nextAudioPts = ptsnorm + pes2mp4ScaleFactor * lastSampleDuration;\n        //logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));\n        track.len = 0;\n        track.samples = outputSamples;\n        if (rawMPEG) {\n          moof = new Uint8Array();\n        } else {\n          moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / pes2mp4ScaleFactor, track);\n        }\n        track.samples = [];\n        var audioData = {\n          data1: moof,\n          data2: mdat,\n          startPTS: firstPTS / pesTimeScale,\n          endPTS: this.nextAudioPts / pesTimeScale,\n          startDTS: firstDTS / pesTimeScale,\n          endDTS: (dtsnorm + pes2mp4ScaleFactor * lastSampleDuration) / pesTimeScale,\n          type: 'audio',\n          nb: nbSamples\n        };\n        this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);\n        return audioData;\n      }\n      return null;\n    }\n  }, {\n    key: 'remuxEmptyAudio',\n    value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n      var pesTimeScale = this.PES_TIMESCALE,\n          mp4timeScale = track.timescale ? track.timescale : track.audiosamplerate,\n          pes2mp4ScaleFactor = pesTimeScale / mp4timeScale,\n          nextAudioPts = this.nextAudioPts,\n\n\n      // sync with video's timestamp\n      startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * pesTimeScale) + this._initDTS,\n          endDTS = videoData.endDTS * pesTimeScale + this._initDTS,\n\n      // one sample's duration value\n      sampleDuration = 1024,\n          frameDuration = pes2mp4ScaleFactor * sampleDuration,\n\n\n      // samples count of this segment's duration\n      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),\n\n\n      // silent frame\n      silentFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n\n      _logger.logger.warn('remux empty Audio');\n      // Can't remux if we can't generate a silent frame...\n      if (!silentFrame) {\n        _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');\n        return;\n      }\n\n      var samples = [];\n      for (var i = 0; i < nbSamples; i++) {\n        var stamp = startDTS + i * frameDuration;\n        samples.push({ unit: silentFrame, pts: stamp, dts: stamp });\n        track.len += silentFrame.length;\n      }\n      track.samples = samples;\n\n      this.remuxAudio(track, timeOffset, contiguous);\n    }\n  }, {\n    key: 'remuxID3',\n    value: function remuxID3(track, timeOffset) {\n      var length = track.samples.length,\n          sample;\n      // consume samples\n      if (length) {\n        for (var index = 0; index < length; index++) {\n          sample = track.samples[index];\n          // setting id3 pts, dts to relative time\n          // using this._initPTS and this._initDTS to calculate relative time\n          sample.pts = (sample.pts - this._initPTS) / this.PES_TIMESCALE;\n          sample.dts = (sample.dts - this._initDTS) / this.PES_TIMESCALE;\n        }\n        this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {\n          samples: track.samples\n        });\n      }\n\n      track.samples = [];\n      timeOffset = timeOffset;\n    }\n  }, {\n    key: 'remuxText',\n    value: function remuxText(track, timeOffset) {\n      track.samples.sort(function (a, b) {\n        return a.pts - b.pts;\n      });\n\n      var length = track.samples.length,\n          sample;\n      // consume samples\n      if (length) {\n        for (var index = 0; index < length; index++) {\n          sample = track.samples[index];\n          // setting text pts, dts to relative time\n          // using this._initPTS and this._initDTS to calculate relative time\n          sample.pts = (sample.pts - this._initPTS) / this.PES_TIMESCALE;\n        }\n        this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {\n          samples: track.samples\n        });\n      }\n\n      track.samples = [];\n      timeOffset = timeOffset;\n    }\n  }, {\n    key: '_PTSNormalize',\n    value: function _PTSNormalize(value, reference) {\n      var offset;\n      if (reference === undefined) {\n        return value;\n      }\n      if (reference < value) {\n        // - 2^33\n        offset = -8589934592;\n      } else {\n        // + 2^33\n        offset = 8589934592;\n      }\n      /* PTS is 33bit (from 0 to 2^33 -1)\n        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n        PTS looping occured. fill the gap */\n      while (Math.abs(value - reference) > 4294967296) {\n        value += offset;\n      }\n      return value;\n    }\n  }]);\n\n  return MP4Remuxer;\n}();\n\nexports.default = MP4Remuxer;\n\n},{\"31\":31,\"33\":33,\"34\":34,\"42\":42,\"50\":50}],44:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\n\nvar _events = _dereq_(33);\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PassThroughRemuxer = function () {\n  function PassThroughRemuxer(observer) {\n    _classCallCheck(this, PassThroughRemuxer);\n\n    this.observer = observer;\n  }\n\n  _createClass(PassThroughRemuxer, [{\n    key: 'destroy',\n    value: function destroy() {}\n  }, {\n    key: 'resetTimeStamp',\n    value: function resetTimeStamp() {}\n  }, {\n    key: 'resetInitSegment',\n    value: function resetInitSegment() {}\n  }, {\n    key: 'remux',\n    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {\n      var observer = this.observer;\n      var streamType = '';\n      if (audioTrack) {\n        streamType += 'audio';\n      }\n      if (videoTrack) {\n        streamType += 'video';\n      }\n      observer.trigger(_events2.default.FRAG_PARSING_DATA, {\n        data1: rawData,\n        startPTS: timeOffset,\n        startDTS: timeOffset,\n        type: streamType,\n        nb: 1,\n        dropped: 0\n      });\n      //notify end of parsing\n      observer.trigger(_events2.default.FRAG_PARSED);\n    }\n  }]);\n\n  return PassThroughRemuxer;\n}();\n\nexports.default = PassThroughRemuxer;\n\n},{\"33\":33}],45:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/;\nvar ATTR_LIST_REGEX = /\\s*(.+?)\\s*=((?:\\\".*?\\\")|.*?)(?:,|$)/g;\n\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\n\nvar AttrList = function () {\n  function AttrList(attrs) {\n    _classCallCheck(this, AttrList);\n\n    if (typeof attrs === 'string') {\n      attrs = AttrList.parseAttrList(attrs);\n    }\n    for (var attr in attrs) {\n      if (attrs.hasOwnProperty(attr)) {\n        this[attr] = attrs[attr];\n      }\n    }\n  }\n\n  _createClass(AttrList, [{\n    key: 'decimalInteger',\n    value: function decimalInteger(attrName) {\n      var intValue = parseInt(this[attrName], 10);\n      if (intValue > Number.MAX_SAFE_INTEGER) {\n        return Infinity;\n      }\n      return intValue;\n    }\n  }, {\n    key: 'hexadecimalInteger',\n    value: function hexadecimalInteger(attrName) {\n      if (this[attrName]) {\n        var stringValue = (this[attrName] || '0x').slice(2);\n        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n\n        var value = new Uint8Array(stringValue.length / 2);\n        for (var i = 0; i < stringValue.length / 2; i++) {\n          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n        }\n        return value;\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: 'hexadecimalIntegerAsNumber',\n    value: function hexadecimalIntegerAsNumber(attrName) {\n      var intValue = parseInt(this[attrName], 16);\n      if (intValue > Number.MAX_SAFE_INTEGER) {\n        return Infinity;\n      }\n      return intValue;\n    }\n  }, {\n    key: 'decimalFloatingPoint',\n    value: function decimalFloatingPoint(attrName) {\n      return parseFloat(this[attrName]);\n    }\n  }, {\n    key: 'enumeratedString',\n    value: function enumeratedString(attrName) {\n      return this[attrName];\n    }\n  }, {\n    key: 'decimalResolution',\n    value: function decimalResolution(attrName) {\n      var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n      if (res === null) {\n        return undefined;\n      }\n      return {\n        width: parseInt(res[1], 10),\n        height: parseInt(res[2], 10)\n      };\n    }\n  }], [{\n    key: 'parseAttrList',\n    value: function parseAttrList(input) {\n      var match,\n          attrs = {};\n      ATTR_LIST_REGEX.lastIndex = 0;\n      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n        var value = match[2],\n            quote = '\"';\n\n        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n          value = value.slice(1, -1);\n        }\n        attrs[match[1]] = value;\n      }\n      return attrs;\n    }\n  }]);\n\n  return AttrList;\n}();\n\nexports.default = AttrList;\n\n},{}],46:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar BinarySearch = {\n    /**\n     * Searches for an item in an array which matches a certain condition.\n     * This requires the condition to only match one item in the array,\n     * and for the array to be ordered.\n     *\n     * @param {Array} list The array to search.\n     * @param {Function} comparisonFunction\n     *      Called and provided a candidate item as the first argument.\n     *      Should return:\n     *          > -1 if the item should be located at a lower index than the provided item.\n     *          > 1 if the item should be located at a higher index than the provided item.\n     *          > 0 if the item is the item you're looking for.\n     *\n     * @return {*} The object if it is found or null otherwise.\n     */\n    search: function search(list, comparisonFunction) {\n        var minIndex = 0;\n        var maxIndex = list.length - 1;\n        var currentIndex = null;\n        var currentElement = null;\n\n        while (minIndex <= maxIndex) {\n            currentIndex = (minIndex + maxIndex) / 2 | 0;\n            currentElement = list[currentIndex];\n\n            var comparisonResult = comparisonFunction(currentElement);\n            if (comparisonResult > 0) {\n                minIndex = currentIndex + 1;\n            } else if (comparisonResult < 0) {\n                maxIndex = currentIndex - 1;\n            } else {\n                return currentElement;\n            }\n        }\n\n        return null;\n    }\n};\n\nmodule.exports = BinarySearch;\n\n},{}],47:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *\n * This code was ported from the dash.js project at:\n *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js\n *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2\n *\n * The original copyright appears below:\n *\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2015-2016, DASH Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  2. Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n */\n\nvar specialCea608CharsCodes = {\n    0x2a: 0xe1, // lowercase a, acute accent\n    0x5c: 0xe9, // lowercase e, acute accent\n    0x5e: 0xed, // lowercase i, acute accent\n    0x5f: 0xf3, // lowercase o, acute accent\n    0x60: 0xfa, // lowercase u, acute accent\n    0x7b: 0xe7, // lowercase c with cedilla\n    0x7c: 0xf7, // division symbol\n    0x7d: 0xd1, // uppercase N tilde\n    0x7e: 0xf1, // lowercase n tilde\n    0x7f: 0x2588, // Full block\n    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n    // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n    0x80: 0xae, // Registered symbol (R)\n    0x81: 0xb0, // degree sign\n    0x82: 0xbd, // 1/2 symbol\n    0x83: 0xbf, // Inverted (open) question mark\n    0x84: 0x2122, // Trademark symbol (TM)\n    0x85: 0xa2, // Cents symbol\n    0x86: 0xa3, // Pounds sterling\n    0x87: 0x266a, // Music 8'th note\n    0x88: 0xe0, // lowercase a, grave accent\n    0x89: 0x20, // transparent space (regular)\n    0x8a: 0xe8, // lowercase e, grave accent\n    0x8b: 0xe2, // lowercase a, circumflex accent\n    0x8c: 0xea, // lowercase e, circumflex accent\n    0x8d: 0xee, // lowercase i, circumflex accent\n    0x8e: 0xf4, // lowercase o, circumflex accent\n    0x8f: 0xfb, // lowercase u, circumflex accent\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n    0x90: 0xc1, // capital letter A with acute\n    0x91: 0xc9, // capital letter E with acute\n    0x92: 0xd3, // capital letter O with acute\n    0x93: 0xda, // capital letter U with acute\n    0x94: 0xdc, // capital letter U with diaresis\n    0x95: 0xfc, // lowercase letter U with diaeresis\n    0x96: 0x2018, // opening single quote\n    0x97: 0xa1, // inverted exclamation mark\n    0x98: 0x2a, // asterisk\n    0x99: 0x2019, // closing single quote\n    0x9a: 0x2501, // box drawings heavy horizontal\n    0x9b: 0xa9, // copyright sign\n    0x9c: 0x2120, // Service mark\n    0x9d: 0x2022, // (round) bullet\n    0x9e: 0x201c, // Left double quotation mark\n    0x9f: 0x201d, // Right double quotation mark\n    0xa0: 0xc0, // uppercase A, grave accent\n    0xa1: 0xc2, // uppercase A, circumflex\n    0xa2: 0xc7, // uppercase C with cedilla\n    0xa3: 0xc8, // uppercase E, grave accent\n    0xa4: 0xca, // uppercase E, circumflex\n    0xa5: 0xcb, // capital letter E with diaresis\n    0xa6: 0xeb, // lowercase letter e with diaresis\n    0xa7: 0xce, // uppercase I, circumflex\n    0xa8: 0xcf, // uppercase I, with diaresis\n    0xa9: 0xef, // lowercase i, with diaresis\n    0xaa: 0xd4, // uppercase O, circumflex\n    0xab: 0xd9, // uppercase U, grave accent\n    0xac: 0xf9, // lowercase u, grave accent\n    0xad: 0xdb, // uppercase U, circumflex\n    0xae: 0xab, // left-pointing double angle quotation mark\n    0xaf: 0xbb, // right-pointing double angle quotation mark\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n    0xb0: 0xc3, // Uppercase A, tilde\n    0xb1: 0xe3, // Lowercase a, tilde\n    0xb2: 0xcd, // Uppercase I, acute accent\n    0xb3: 0xcc, // Uppercase I, grave accent\n    0xb4: 0xec, // Lowercase i, grave accent\n    0xb5: 0xd2, // Uppercase O, grave accent\n    0xb6: 0xf2, // Lowercase o, grave accent\n    0xb7: 0xd5, // Uppercase O, tilde\n    0xb8: 0xf5, // Lowercase o, tilde\n    0xb9: 0x7b, // Open curly brace\n    0xba: 0x7d, // Closing curly brace\n    0xbb: 0x5c, // Backslash\n    0xbc: 0x5e, // Caret\n    0xbd: 0x5f, // Underscore\n    0xbe: 0x7c, // Pipe (vertical line)\n    0xbf: 0x223c, // Tilde operator\n    0xc0: 0xc4, // Uppercase A, umlaut\n    0xc1: 0xe4, // Lowercase A, umlaut\n    0xc2: 0xd6, // Uppercase O, umlaut\n    0xc3: 0xf6, // Lowercase o, umlaut\n    0xc4: 0xdf, // Esszett (sharp S)\n    0xc5: 0xa5, // Yen symbol\n    0xc6: 0xa4, // Generic currency sign\n    0xc7: 0x2503, // Box drawings heavy vertical\n    0xc8: 0xc5, // Uppercase A, ring\n    0xc9: 0xe5, // Lowercase A, ring\n    0xca: 0xd8, // Uppercase O, stroke\n    0xcb: 0xf8, // Lowercase o, strok\n    0xcc: 0x250f, // Box drawings heavy down and right\n    0xcd: 0x2513, // Box drawings heavy down and left\n    0xce: 0x2517, // Box drawings heavy up and right\n    0xcf: 0x251b // Box drawings heavy up and left\n};\n\n/**\n * Utils\n */\nvar getCharForByte = function getCharForByte(byte) {\n    var charCode = byte;\n    if (specialCea608CharsCodes.hasOwnProperty(byte)) {\n        charCode = specialCea608CharsCodes[byte];\n    }\n    return String.fromCharCode(charCode);\n};\n\nvar NR_ROWS = 15,\n    NR_COLS = 100;\n// Tables to look up row from PAC data\nvar rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };\nvar rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };\nvar rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };\nvar rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };\n\nvar backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\n\n/**\n * Simple logger class to be able to write with time-stamps and filter on level.\n */\nvar logger = {\n    verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },\n    time: null,\n    verboseLevel: 0, // Only write errors\n    setTime: function setTime(newTime) {\n        this.time = newTime;\n    },\n    log: function log(severity, msg) {\n        var minLevel = this.verboseFilter[severity];\n        if (this.verboseLevel >= minLevel) {\n            console.log(this.time + ' [' + severity + '] ' + msg);\n        }\n    }\n};\n\nvar numArrayToHexArray = function numArrayToHexArray(numArray) {\n    var hexArray = [];\n    for (var j = 0; j < numArray.length; j++) {\n        hexArray.push(numArray[j].toString(16));\n    }\n    return hexArray;\n};\n\nvar PenState = function () {\n    function PenState(foreground, underline, italics, background, flash) {\n        _classCallCheck(this, PenState);\n\n        this.foreground = foreground || 'white';\n        this.underline = underline || false;\n        this.italics = italics || false;\n        this.background = background || 'black';\n        this.flash = flash || false;\n    }\n\n    _createClass(PenState, [{\n        key: 'reset',\n        value: function reset() {\n            this.foreground = 'white';\n            this.underline = false;\n            this.italics = false;\n            this.background = 'black';\n            this.flash = false;\n        }\n    }, {\n        key: 'setStyles',\n        value: function setStyles(styles) {\n            var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];\n            for (var i = 0; i < attribs.length; i++) {\n                var style = attribs[i];\n                if (styles.hasOwnProperty(style)) {\n                    this[style] = styles[style];\n                }\n            }\n        }\n    }, {\n        key: 'isDefault',\n        value: function isDefault() {\n            return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;\n        }\n    }, {\n        key: 'equals',\n        value: function equals(other) {\n            return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n        }\n    }, {\n        key: 'copy',\n        value: function copy(newPenState) {\n            this.foreground = newPenState.foreground;\n            this.underline = newPenState.underline;\n            this.italics = newPenState.italics;\n            this.background = newPenState.background;\n            this.flash = newPenState.flash;\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;\n        }\n    }]);\n\n    return PenState;\n}();\n\n/**\n * Unicode character with styling and background.\n * @constructor\n */\n\n\nvar StyledUnicodeChar = function () {\n    function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {\n        _classCallCheck(this, StyledUnicodeChar);\n\n        this.uchar = uchar || ' '; // unicode character\n        this.penState = new PenState(foreground, underline, italics, background, flash);\n    }\n\n    _createClass(StyledUnicodeChar, [{\n        key: 'reset',\n        value: function reset() {\n            this.uchar = ' ';\n            this.penState.reset();\n        }\n    }, {\n        key: 'setChar',\n        value: function setChar(uchar, newPenState) {\n            this.uchar = uchar;\n            this.penState.copy(newPenState);\n        }\n    }, {\n        key: 'setPenState',\n        value: function setPenState(newPenState) {\n            this.penState.copy(newPenState);\n        }\n    }, {\n        key: 'equals',\n        value: function equals(other) {\n            return this.uchar === other.uchar && this.penState.equals(other.penState);\n        }\n    }, {\n        key: 'copy',\n        value: function copy(newChar) {\n            this.uchar = newChar.uchar;\n            this.penState.copy(newChar.penState);\n        }\n    }, {\n        key: 'isEmpty',\n        value: function isEmpty() {\n            return this.uchar === ' ' && this.penState.isDefault();\n        }\n    }]);\n\n    return StyledUnicodeChar;\n}();\n\n/**\n * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n * @constructor\n */\n\n\nvar Row = function () {\n    function Row() {\n        _classCallCheck(this, Row);\n\n        this.chars = [];\n        for (var i = 0; i < NR_COLS; i++) {\n            this.chars.push(new StyledUnicodeChar());\n        }\n        this.pos = 0;\n        this.currPenState = new PenState();\n    }\n\n    _createClass(Row, [{\n        key: 'equals',\n        value: function equals(other) {\n            var equal = true;\n            for (var i = 0; i < NR_COLS; i++) {\n                if (!this.chars[i].equals(other.chars[i])) {\n                    equal = false;\n                    break;\n                }\n            }\n            return equal;\n        }\n    }, {\n        key: 'copy',\n        value: function copy(other) {\n            for (var i = 0; i < NR_COLS; i++) {\n                this.chars[i].copy(other.chars[i]);\n            }\n        }\n    }, {\n        key: 'isEmpty',\n        value: function isEmpty() {\n            var empty = true;\n            for (var i = 0; i < NR_COLS; i++) {\n                if (!this.chars[i].isEmpty()) {\n                    empty = false;\n                    break;\n                }\n            }\n            return empty;\n        }\n\n        /**\n         *  Set the cursor to a valid column.\n         */\n\n    }, {\n        key: 'setCursor',\n        value: function setCursor(absPos) {\n            if (this.pos !== absPos) {\n                this.pos = absPos;\n            }\n            if (this.pos < 0) {\n                logger.log('ERROR', 'Negative cursor position ' + this.pos);\n                this.pos = 0;\n            } else if (this.pos > NR_COLS) {\n                logger.log('ERROR', 'Too large cursor position ' + this.pos);\n                this.pos = NR_COLS;\n            }\n        }\n\n        /**\n         * Move the cursor relative to current position.\n         */\n\n    }, {\n        key: 'moveCursor',\n        value: function moveCursor(relPos) {\n            var newPos = this.pos + relPos;\n            if (relPos > 1) {\n                for (var i = this.pos + 1; i < newPos + 1; i++) {\n                    this.chars[i].setPenState(this.currPenState);\n                }\n            }\n            this.setCursor(newPos);\n        }\n\n        /**\n         * Backspace, move one step back and clear character.\n         */\n\n    }, {\n        key: 'backSpace',\n        value: function backSpace() {\n            this.moveCursor(-1);\n            this.chars[this.pos].setChar(' ', this.currPenState);\n        }\n    }, {\n        key: 'insertChar',\n        value: function insertChar(byte) {\n            if (byte >= 0x90) {\n                //Extended char\n                this.backSpace();\n            }\n            var char = getCharForByte(byte);\n            if (this.pos >= NR_COLS) {\n                logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');\n                return;\n            }\n            this.chars[this.pos].setChar(char, this.currPenState);\n            this.moveCursor(1);\n        }\n    }, {\n        key: 'clearFromPos',\n        value: function clearFromPos(startPos) {\n            var i;\n            for (i = startPos; i < NR_COLS; i++) {\n                this.chars[i].reset();\n            }\n        }\n    }, {\n        key: 'clear',\n        value: function clear() {\n            this.clearFromPos(0);\n            this.pos = 0;\n            this.currPenState.reset();\n        }\n    }, {\n        key: 'clearToEndOfRow',\n        value: function clearToEndOfRow() {\n            this.clearFromPos(this.pos);\n        }\n    }, {\n        key: 'getTextString',\n        value: function getTextString() {\n            var chars = [];\n            var empty = true;\n            for (var i = 0; i < NR_COLS; i++) {\n                var char = this.chars[i].uchar;\n                if (char !== ' ') {\n                    empty = false;\n                }\n                chars.push(char);\n            }\n            if (empty) {\n                return '';\n            } else {\n                return chars.join('');\n            }\n        }\n    }, {\n        key: 'setPenStyles',\n        value: function setPenStyles(styles) {\n            this.currPenState.setStyles(styles);\n            var currChar = this.chars[this.pos];\n            currChar.setPenState(this.currPenState);\n        }\n    }]);\n\n    return Row;\n}();\n\n/**\n * Keep a CEA-608 screen of 32x15 styled characters\n * @constructor\n*/\n\n\nvar CaptionScreen = function () {\n    function CaptionScreen() {\n        _classCallCheck(this, CaptionScreen);\n\n        this.rows = [];\n        for (var i = 0; i < NR_ROWS; i++) {\n            this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)\n        }\n        this.currRow = NR_ROWS - 1;\n        this.nrRollUpRows = null;\n        this.reset();\n    }\n\n    _createClass(CaptionScreen, [{\n        key: 'reset',\n        value: function reset() {\n            for (var i = 0; i < NR_ROWS; i++) {\n                this.rows[i].clear();\n            }\n            this.currRow = NR_ROWS - 1;\n        }\n    }, {\n        key: 'equals',\n        value: function equals(other) {\n            var equal = true;\n            for (var i = 0; i < NR_ROWS; i++) {\n                if (!this.rows[i].equals(other.rows[i])) {\n                    equal = false;\n                    break;\n                }\n            }\n            return equal;\n        }\n    }, {\n        key: 'copy',\n        value: function copy(other) {\n            for (var i = 0; i < NR_ROWS; i++) {\n                this.rows[i].copy(other.rows[i]);\n            }\n        }\n    }, {\n        key: 'isEmpty',\n        value: function isEmpty() {\n            var empty = true;\n            for (var i = 0; i < NR_ROWS; i++) {\n                if (!this.rows[i].isEmpty()) {\n                    empty = false;\n                    break;\n                }\n            }\n            return empty;\n        }\n    }, {\n        key: 'backSpace',\n        value: function backSpace() {\n            var row = this.rows[this.currRow];\n            row.backSpace();\n        }\n    }, {\n        key: 'clearToEndOfRow',\n        value: function clearToEndOfRow() {\n            var row = this.rows[this.currRow];\n            row.clearToEndOfRow();\n        }\n\n        /**\n         * Insert a character (without styling) in the current row.\n         */\n\n    }, {\n        key: 'insertChar',\n        value: function insertChar(char) {\n            var row = this.rows[this.currRow];\n            row.insertChar(char);\n        }\n    }, {\n        key: 'setPen',\n        value: function setPen(styles) {\n            var row = this.rows[this.currRow];\n            row.setPenStyles(styles);\n        }\n    }, {\n        key: 'moveCursor',\n        value: function moveCursor(relPos) {\n            var row = this.rows[this.currRow];\n            row.moveCursor(relPos);\n        }\n    }, {\n        key: 'setCursor',\n        value: function setCursor(absPos) {\n            logger.log('INFO', 'setCursor: ' + absPos);\n            var row = this.rows[this.currRow];\n            row.setCursor(absPos);\n        }\n    }, {\n        key: 'setPAC',\n        value: function setPAC(pacData) {\n            logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));\n            var newRow = pacData.row - 1;\n            if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n                newRow = this.nrRollUpRows - 1;\n            }\n\n            //Make sure this only affects Roll-up Captions by checking this.nrRollUpRows\n            if (this.nrRollUpRows && this.currRow !== newRow) {\n                //clear all rows first\n                for (var i = 0; i < NR_ROWS; i++) {\n                    this.rows[i].clear();\n                }\n\n                //Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location\n                //topRowIndex - the start of rows to copy (inclusive index)\n                var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n                //We only copy if the last position was already shown.\n                //We use the cueStartTime value to check this.\n                var lastOutputScreen = this.lastOutputScreen;\n                if (lastOutputScreen) {\n                    var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;\n                    if (prevLineTime && prevLineTime < logger.time) {\n                        for (var _i = 0; _i < this.nrRollUpRows; _i++) {\n                            this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);\n                        }\n                    }\n                }\n            }\n\n            this.currRow = newRow;\n            var row = this.rows[this.currRow];\n            if (pacData.indent !== null) {\n                var indent = pacData.indent;\n                var prevPos = Math.max(indent - 1, 0);\n                row.setCursor(pacData.indent);\n                pacData.color = row.chars[prevPos].penState.foreground;\n            }\n            var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };\n            this.setPen(styles);\n        }\n\n        /**\n         * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n         */\n\n    }, {\n        key: 'setBkgData',\n        value: function setBkgData(bkgData) {\n\n            logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));\n            this.backSpace();\n            this.setPen(bkgData);\n            this.insertChar(0x20); //Space\n        }\n    }, {\n        key: 'setRollUpRows',\n        value: function setRollUpRows(nrRows) {\n            this.nrRollUpRows = nrRows;\n        }\n    }, {\n        key: 'rollUp',\n        value: function rollUp() {\n            if (this.nrRollUpRows === null) {\n                logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');\n                return; //Not properly setup\n            }\n            logger.log('TEXT', this.getDisplayText());\n            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n            var topRow = this.rows.splice(topRowIndex, 1)[0];\n            topRow.clear();\n            this.rows.splice(this.currRow, 0, topRow);\n            logger.log('INFO', 'Rolling up');\n            //logger.log('TEXT', this.get_display_text())\n        }\n\n        /**\n         * Get all non-empty rows with as unicode text.\n         */\n\n    }, {\n        key: 'getDisplayText',\n        value: function getDisplayText(asOneRow) {\n            asOneRow = asOneRow || false;\n            var displayText = [];\n            var text = '';\n            var rowNr = -1;\n            for (var i = 0; i < NR_ROWS; i++) {\n                var rowText = this.rows[i].getTextString();\n                if (rowText) {\n                    rowNr = i + 1;\n                    if (asOneRow) {\n                        displayText.push('Row ' + rowNr + ': \\'' + rowText + '\\'');\n                    } else {\n                        displayText.push(rowText.trim());\n                    }\n                }\n            }\n            if (displayText.length > 0) {\n                if (asOneRow) {\n                    text = '[' + displayText.join(' | ') + ']';\n                } else {\n                    text = displayText.join('\\n');\n                }\n            }\n            return text;\n        }\n    }, {\n        key: 'getTextAndFormat',\n        value: function getTextAndFormat() {\n            return this.rows;\n        }\n    }]);\n\n    return CaptionScreen;\n}();\n\n//var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];\n\nvar Cea608Channel = function () {\n    function Cea608Channel(channelNumber, outputFilter) {\n        _classCallCheck(this, Cea608Channel);\n\n        this.chNr = channelNumber;\n        this.outputFilter = outputFilter;\n        this.mode = null;\n        this.verbose = 0;\n        this.displayedMemory = new CaptionScreen();\n        this.nonDisplayedMemory = new CaptionScreen();\n        this.lastOutputScreen = new CaptionScreen();\n        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n        this.writeScreen = this.displayedMemory;\n        this.mode = null;\n        this.cueStartTime = null; // Keeps track of where a cue started.\n    }\n\n    _createClass(Cea608Channel, [{\n        key: 'reset',\n        value: function reset() {\n            this.mode = null;\n            this.displayedMemory.reset();\n            this.nonDisplayedMemory.reset();\n            this.lastOutputScreen.reset();\n            this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n            this.writeScreen = this.displayedMemory;\n            this.mode = null;\n            this.cueStartTime = null;\n            this.lastCueEndTime = null;\n        }\n    }, {\n        key: 'getHandler',\n        value: function getHandler() {\n            return this.outputFilter;\n        }\n    }, {\n        key: 'setHandler',\n        value: function setHandler(newHandler) {\n            this.outputFilter = newHandler;\n        }\n    }, {\n        key: 'setPAC',\n        value: function setPAC(pacData) {\n            this.writeScreen.setPAC(pacData);\n        }\n    }, {\n        key: 'setBkgData',\n        value: function setBkgData(bkgData) {\n            this.writeScreen.setBkgData(bkgData);\n        }\n    }, {\n        key: 'setMode',\n        value: function setMode(newMode) {\n            if (newMode === this.mode) {\n                return;\n            }\n            this.mode = newMode;\n            logger.log('INFO', 'MODE=' + newMode);\n            if (this.mode === 'MODE_POP-ON') {\n                this.writeScreen = this.nonDisplayedMemory;\n            } else {\n                this.writeScreen = this.displayedMemory;\n                this.writeScreen.reset();\n            }\n            if (this.mode !== 'MODE_ROLL-UP') {\n                this.displayedMemory.nrRollUpRows = null;\n                this.nonDisplayedMemory.nrRollUpRows = null;\n            }\n            this.mode = newMode;\n        }\n    }, {\n        key: 'insertChars',\n        value: function insertChars(chars) {\n            for (var i = 0; i < chars.length; i++) {\n                this.writeScreen.insertChar(chars[i]);\n            }\n            var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';\n            logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));\n            if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {\n                logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));\n                this.outputDataUpdate();\n            }\n        }\n    }, {\n        key: 'ccRCL',\n        value: function ccRCL() {\n            // Resume Caption Loading (switch mode to Pop On)\n            logger.log('INFO', 'RCL - Resume Caption Loading');\n            this.setMode('MODE_POP-ON');\n        }\n    }, {\n        key: 'ccBS',\n        value: function ccBS() {\n            // BackSpace\n            logger.log('INFO', 'BS - BackSpace');\n            if (this.mode === 'MODE_TEXT') {\n                return;\n            }\n            this.writeScreen.backSpace();\n            if (this.writeScreen === this.displayedMemory) {\n                this.outputDataUpdate();\n            }\n        }\n    }, {\n        key: 'ccAOF',\n        value: function ccAOF() {\n            // Reserved (formerly Alarm Off)\n            return;\n        }\n    }, {\n        key: 'ccAON',\n        value: function ccAON() {\n            // Reserved (formerly Alarm On)\n            return;\n        }\n    }, {\n        key: 'ccDER',\n        value: function ccDER() {\n            // Delete to End of Row\n            logger.log('INFO', 'DER- Delete to End of Row');\n            this.writeScreen.clearToEndOfRow();\n            this.outputDataUpdate();\n        }\n    }, {\n        key: 'ccRU',\n        value: function ccRU(nrRows) {\n            //Roll-Up Captions-2,3,or 4 Rows\n            logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');\n            this.writeScreen = this.displayedMemory;\n            this.setMode('MODE_ROLL-UP');\n            this.writeScreen.setRollUpRows(nrRows);\n        }\n    }, {\n        key: 'ccFON',\n        value: function ccFON() {\n            //Flash On\n            logger.log('INFO', 'FON - Flash On');\n            this.writeScreen.setPen({ flash: true });\n        }\n    }, {\n        key: 'ccRDC',\n        value: function ccRDC() {\n            // Resume Direct Captioning (switch mode to PaintOn)\n            logger.log('INFO', 'RDC - Resume Direct Captioning');\n            this.setMode('MODE_PAINT-ON');\n        }\n    }, {\n        key: 'ccTR',\n        value: function ccTR() {\n            // Text Restart in text mode (not supported, however)\n            logger.log('INFO', 'TR');\n            this.setMode('MODE_TEXT');\n        }\n    }, {\n        key: 'ccRTD',\n        value: function ccRTD() {\n            // Resume Text Display in Text mode (not supported, however)\n            logger.log('INFO', 'RTD');\n            this.setMode('MODE_TEXT');\n        }\n    }, {\n        key: 'ccEDM',\n        value: function ccEDM() {\n            // Erase Displayed Memory\n            logger.log('INFO', 'EDM - Erase Displayed Memory');\n            this.displayedMemory.reset();\n            this.outputDataUpdate();\n        }\n    }, {\n        key: 'ccCR',\n        value: function ccCR() {\n            // Carriage Return\n            logger.log('CR - Carriage Return');\n            this.writeScreen.rollUp();\n            this.outputDataUpdate();\n        }\n    }, {\n        key: 'ccENM',\n        value: function ccENM() {\n            //Erase Non-Displayed Memory\n            logger.log('INFO', 'ENM - Erase Non-displayed Memory');\n            this.nonDisplayedMemory.reset();\n        }\n    }, {\n        key: 'ccEOC',\n        value: function ccEOC() {\n            //End of Caption (Flip Memories)\n            logger.log('INFO', 'EOC - End Of Caption');\n            if (this.mode === 'MODE_POP-ON') {\n                var tmp = this.displayedMemory;\n                this.displayedMemory = this.nonDisplayedMemory;\n                this.nonDisplayedMemory = tmp;\n                this.writeScreen = this.nonDisplayedMemory;\n                logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());\n            }\n            this.outputDataUpdate();\n        }\n    }, {\n        key: 'ccTO',\n        value: function ccTO(nrCols) {\n            // Tab Offset 1,2, or 3 columns\n            logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');\n            this.writeScreen.moveCursor(nrCols);\n        }\n    }, {\n        key: 'ccMIDROW',\n        value: function ccMIDROW(secondByte) {\n            // Parse MIDROW command\n            var styles = { flash: false };\n            styles.underline = secondByte % 2 === 1;\n            styles.italics = secondByte >= 0x2e;\n            if (!styles.italics) {\n                var colorIndex = Math.floor(secondByte / 2) - 0x10;\n                var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];\n                styles.foreground = colors[colorIndex];\n            } else {\n                styles.foreground = 'white';\n            }\n            logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));\n            this.writeScreen.setPen(styles);\n        }\n    }, {\n        key: 'outputDataUpdate',\n        value: function outputDataUpdate() {\n            var t = logger.time;\n            if (t === null) {\n                return;\n            }\n            if (this.outputFilter) {\n                if (this.outputFilter.updateData) {\n                    this.outputFilter.updateData(t, this.displayedMemory);\n                }\n                if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n                    // Start of a new cue\n                    this.cueStartTime = t;\n                } else {\n                    if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n                        if (this.outputFilter.newCue) {\n                            this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);\n                        }\n                        this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;\n                    }\n                }\n                this.lastOutputScreen.copy(this.displayedMemory);\n            }\n        }\n    }, {\n        key: 'cueSplitAtTime',\n        value: function cueSplitAtTime(t) {\n            if (this.outputFilter) {\n                if (!this.displayedMemory.isEmpty()) {\n                    if (this.outputFilter.newCue) {\n                        this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n                    }\n                    this.cueStartTime = t;\n                }\n            }\n        }\n    }]);\n\n    return Cea608Channel;\n}();\n\nvar Cea608Parser = function () {\n    function Cea608Parser(field, out1, out2) {\n        _classCallCheck(this, Cea608Parser);\n\n        this.field = field || 1;\n        this.outputs = [out1, out2];\n        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];\n        this.currChNr = -1; // Will be 1 or 2\n        this.lastCmdA = null; // First byte of last command\n        this.lastCmdB = null; // Second byte of last command\n        this.bufferedData = [];\n        this.startTime = null;\n        this.lastTime = null;\n        this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };\n    }\n\n    _createClass(Cea608Parser, [{\n        key: 'getHandler',\n        value: function getHandler(index) {\n            return this.channels[index].getHandler();\n        }\n    }, {\n        key: 'setHandler',\n        value: function setHandler(index, newHandler) {\n            this.channels[index].setHandler(newHandler);\n        }\n\n        /**\n         * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n         */\n\n    }, {\n        key: 'addData',\n        value: function addData(t, byteList) {\n            var cmdFound,\n                a,\n                b,\n                charsFound = false;\n\n            this.lastTime = t;\n            logger.setTime(t);\n\n            for (var i = 0; i < byteList.length; i += 2) {\n                a = byteList[i] & 0x7f;\n                b = byteList[i + 1] & 0x7f;\n                if (a === 0 && b === 0) {\n                    this.dataCounters.padding += 2;\n                    continue;\n                } else {\n                    logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');\n                }\n                cmdFound = this.parseCmd(a, b);\n                if (!cmdFound) {\n                    cmdFound = this.parseMidrow(a, b);\n                }\n                if (!cmdFound) {\n                    cmdFound = this.parsePAC(a, b);\n                }\n                if (!cmdFound) {\n                    cmdFound = this.parseBackgroundAttributes(a, b);\n                }\n                if (!cmdFound) {\n                    charsFound = this.parseChars(a, b);\n                    if (charsFound) {\n                        if (this.currChNr && this.currChNr >= 0) {\n                            var channel = this.channels[this.currChNr - 1];\n                            channel.insertChars(charsFound);\n                        } else {\n                            logger.log('WARNING', 'No channel found yet. TEXT-MODE?');\n                        }\n                    }\n                }\n                if (cmdFound) {\n                    this.dataCounters.cmd += 2;\n                } else if (charsFound) {\n                    this.dataCounters.char += 2;\n                } else {\n                    this.dataCounters.other += 2;\n                    logger.log('WARNING', 'Couldn\\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));\n                }\n            }\n        }\n\n        /**\n         * Parse Command.\n         * @returns {Boolean} Tells if a command was found\n         */\n\n    }, {\n        key: 'parseCmd',\n        value: function parseCmd(a, b) {\n            var chNr = null;\n\n            var cond1 = (a === 0x14 || a === 0x1C) && 0x20 <= b && b <= 0x2F;\n            var cond2 = (a === 0x17 || a === 0x1F) && 0x21 <= b && b <= 0x23;\n            if (!(cond1 || cond2)) {\n                return false;\n            }\n\n            if (a === this.lastCmdA && b === this.lastCmdB) {\n                this.lastCmdA = null;\n                this.lastCmdB = null; // Repeated commands are dropped (once)\n                logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');\n                return true;\n            }\n\n            if (a === 0x14 || a === 0x17) {\n                chNr = 1;\n            } else {\n                chNr = 2; // (a === 0x1C || a=== 0x1f)\n            }\n\n            var channel = this.channels[chNr - 1];\n\n            if (a === 0x14 || a === 0x1C) {\n                if (b === 0x20) {\n                    channel.ccRCL();\n                } else if (b === 0x21) {\n                    channel.ccBS();\n                } else if (b === 0x22) {\n                    channel.ccAOF();\n                } else if (b === 0x23) {\n                    channel.ccAON();\n                } else if (b === 0x24) {\n                    channel.ccDER();\n                } else if (b === 0x25) {\n                    channel.ccRU(2);\n                } else if (b === 0x26) {\n                    channel.ccRU(3);\n                } else if (b === 0x27) {\n                    channel.ccRU(4);\n                } else if (b === 0x28) {\n                    channel.ccFON();\n                } else if (b === 0x29) {\n                    channel.ccRDC();\n                } else if (b === 0x2A) {\n                    channel.ccTR();\n                } else if (b === 0x2B) {\n                    channel.ccRTD();\n                } else if (b === 0x2C) {\n                    channel.ccEDM();\n                } else if (b === 0x2D) {\n                    channel.ccCR();\n                } else if (b === 0x2E) {\n                    channel.ccENM();\n                } else if (b === 0x2F) {\n                    channel.ccEOC();\n                }\n            } else {\n                //a == 0x17 || a == 0x1F\n                channel.ccTO(b - 0x20);\n            }\n            this.lastCmdA = a;\n            this.lastCmdB = b;\n            this.currChNr = chNr;\n            return true;\n        }\n\n        /**\n         * Parse midrow styling command\n         * @returns {Boolean}\n         */\n\n    }, {\n        key: 'parseMidrow',\n        value: function parseMidrow(a, b) {\n            var chNr = null;\n\n            if ((a === 0x11 || a === 0x19) && 0x20 <= b && b <= 0x2f) {\n                if (a === 0x11) {\n                    chNr = 1;\n                } else {\n                    chNr = 2;\n                }\n                if (chNr !== this.currChNr) {\n                    logger.log('ERROR', 'Mismatch channel in midrow parsing');\n                    return false;\n                }\n                var channel = this.channels[chNr - 1];\n                channel.ccMIDROW(b);\n                logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');\n                return true;\n            }\n            return false;\n        }\n        /**\n         * Parse Preable Access Codes (Table 53).\n         * @returns {Boolean} Tells if PAC found\n         */\n\n    }, {\n        key: 'parsePAC',\n        value: function parsePAC(a, b) {\n\n            var chNr = null;\n            var row = null;\n\n            var case1 = (0x11 <= a && a <= 0x17 || 0x19 <= a && a <= 0x1F) && 0x40 <= b && b <= 0x7F;\n            var case2 = (a === 0x10 || a === 0x18) && 0x40 <= b && b <= 0x5F;\n            if (!(case1 || case2)) {\n                return false;\n            }\n\n            if (a === this.lastCmdA && b === this.lastCmdB) {\n                this.lastCmdA = null;\n                this.lastCmdB = null;\n                return true; // Repeated commands are dropped (once)\n            }\n\n            chNr = a <= 0x17 ? 1 : 2;\n\n            if (0x40 <= b && b <= 0x5F) {\n                row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n            } else {\n                // 0x60 <= b <= 0x7F\n                row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n            }\n            var pacData = this.interpretPAC(row, b);\n            var channel = this.channels[chNr - 1];\n            channel.setPAC(pacData);\n            this.lastCmdA = a;\n            this.lastCmdB = b;\n            this.currChNr = chNr;\n            return true;\n        }\n\n        /**\n         * Interpret the second byte of the pac, and return the information.\n         * @returns {Object} pacData with style parameters.\n         */\n\n    }, {\n        key: 'interpretPAC',\n        value: function interpretPAC(row, byte) {\n            var pacIndex = byte;\n            var pacData = { color: null, italics: false, indent: null, underline: false, row: row };\n\n            if (byte > 0x5F) {\n                pacIndex = byte - 0x60;\n            } else {\n                pacIndex = byte - 0x40;\n            }\n            pacData.underline = (pacIndex & 1) === 1;\n            if (pacIndex <= 0xd) {\n                pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];\n            } else if (pacIndex <= 0xf) {\n                pacData.italics = true;\n                pacData.color = 'white';\n            } else {\n                pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n            }\n            return pacData; // Note that row has zero offset. The spec uses 1.\n        }\n\n        /**\n         * Parse characters.\n         * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n         */\n\n    }, {\n        key: 'parseChars',\n        value: function parseChars(a, b) {\n\n            var channelNr = null,\n                charCodes = null,\n                charCode1 = null;\n\n            if (a >= 0x19) {\n                channelNr = 2;\n                charCode1 = a - 8;\n            } else {\n                channelNr = 1;\n                charCode1 = a;\n            }\n            if (0x11 <= charCode1 && charCode1 <= 0x13) {\n                // Special character\n                var oneCode = b;\n                if (charCode1 === 0x11) {\n                    oneCode = b + 0x50;\n                } else if (charCode1 === 0x12) {\n                    oneCode = b + 0x70;\n                } else {\n                    oneCode = b + 0x90;\n                }\n                logger.log('INFO', 'Special char \\'' + getCharForByte(oneCode) + '\\' in channel ' + channelNr);\n                charCodes = [oneCode];\n            } else if (0x20 <= a && a <= 0x7f) {\n                charCodes = b === 0 ? [a] : [a, b];\n            }\n            if (charCodes) {\n                var hexCodes = numArrayToHexArray(charCodes);\n                logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));\n                this.lastCmdA = null;\n                this.lastCmdB = null;\n            }\n            return charCodes;\n        }\n\n        /**\n        * Parse extended background attributes as well as new foreground color black.\n        * @returns{Boolean} Tells if background attributes are found\n        */\n\n    }, {\n        key: 'parseBackgroundAttributes',\n        value: function parseBackgroundAttributes(a, b) {\n            var bkgData, index, chNr, channel;\n\n            var case1 = (a === 0x10 || a === 0x18) && 0x20 <= b && b <= 0x2f;\n            var case2 = (a === 0x17 || a === 0x1f) && 0x2d <= b && b <= 0x2f;\n            if (!(case1 || case2)) {\n                return false;\n            }\n            bkgData = {};\n            if (a === 0x10 || a === 0x18) {\n                index = Math.floor((b - 0x20) / 2);\n                bkgData.background = backgroundColors[index];\n                if (b % 2 === 1) {\n                    bkgData.background = bkgData.background + '_semi';\n                }\n            } else if (b === 0x2d) {\n                bkgData.background = 'transparent';\n            } else {\n                bkgData.foreground = 'black';\n                if (b === 0x2f) {\n                    bkgData.underline = true;\n                }\n            }\n            chNr = a < 0x18 ? 1 : 2;\n            channel = this.channels[chNr - 1];\n            channel.setBkgData(bkgData);\n            this.lastCmdA = null;\n            this.lastCmdB = null;\n            return true;\n        }\n\n        /**\n         * Reset state of parser and its channels.\n         */\n\n    }, {\n        key: 'reset',\n        value: function reset() {\n            for (var i = 0; i < this.channels.length; i++) {\n                if (this.channels[i]) {\n                    this.channels[i].reset();\n                }\n            }\n            this.lastCmdA = null;\n            this.lastCmdB = null;\n        }\n\n        /**\n         * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n         */\n\n    }, {\n        key: 'cueSplitAtTime',\n        value: function cueSplitAtTime(t) {\n            for (var i = 0; i < this.channels.length; i++) {\n                if (this.channels[i]) {\n                    this.channels[i].cueSplitAtTime(t);\n                }\n            }\n        }\n    }]);\n\n    return Cea608Parser;\n}();\n\nexports.default = Cea608Parser;\n\n},{}],48:[function(_dereq_,module,exports){\n'use strict';\n\nvar _vttparser = _dereq_(53);\n\nvar Cues = {\n\n  newCue: function newCue(track, startTime, endTime, captionScreen) {\n    var row;\n    var cue;\n    var indenting;\n    var indent;\n    var text;\n    var VTTCue = window.VTTCue || window.TextTrackCue;\n\n    for (var r = 0; r < captionScreen.rows.length; r++) {\n      row = captionScreen.rows[r];\n      indenting = true;\n      indent = 0;\n      text = '';\n\n      if (!row.isEmpty()) {\n        for (var c = 0; c < row.chars.length; c++) {\n          if (row.chars[c].uchar.match(/\\s/) && indenting) {\n            indent++;\n          } else {\n            text += row.chars[c].uchar;\n            indenting = false;\n          }\n        }\n        //To be used for cleaning-up orphaned roll-up captions\n        row.cueStartTime = startTime;\n        cue = new VTTCue(startTime, endTime, (0, _vttparser.fixLineBreaks)(text.trim()));\n\n        if (indent >= 16) {\n          indent--;\n        } else {\n          indent++;\n        }\n\n        // VTTCue.line get's flakey when using controls, so let's now include line 13&14\n        // also, drop line 1 since it's to close to the top\n        if (navigator.userAgent.match(/Firefox\\//)) {\n          cue.line = r + 1;\n        } else {\n          cue.line = r > 7 ? r - 2 : r + 1;\n        }\n        cue.align = 'left';\n        // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break\n        cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\\//) ? 50 : 0)));\n        track.addCue(cue);\n      }\n    }\n  }\n\n};\n\nmodule.exports = Cues;\n\n},{\"53\":53}],49:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\n * compute an Exponential Weighted moving average\n * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n *  - heavily inspired from shaka-player\n */\n\nvar EWMA = function () {\n\n  //  About half of the estimated value will be from the last |halfLife| samples by weight.\n  function EWMA(halfLife) {\n    _classCallCheck(this, EWMA);\n\n    // Larger values of alpha expire historical data more slowly.\n    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n    this.estimate_ = 0;\n    this.totalWeight_ = 0;\n  }\n\n  _createClass(EWMA, [{\n    key: \"sample\",\n    value: function sample(weight, value) {\n      var adjAlpha = Math.pow(this.alpha_, weight);\n      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n      this.totalWeight_ += weight;\n    }\n  }, {\n    key: \"getTotalWeight\",\n    value: function getTotalWeight() {\n      return this.totalWeight_;\n    }\n  }, {\n    key: \"getEstimate\",\n    value: function getEstimate() {\n      if (this.alpha_) {\n        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n        return this.estimate_ / zeroFactor;\n      } else {\n        return this.estimate_;\n      }\n    }\n  }]);\n\n  return EWMA;\n}();\n\nexports.default = EWMA;\n\n},{}],50:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction noop() {}\n\nvar fakeLogger = {\n  trace: noop,\n  debug: noop,\n  log: noop,\n  warn: noop,\n  info: noop,\n  error: noop\n};\n\nvar exportedLogger = fakeLogger;\n\n/*globals self: false */\n\n//let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\n\nfunction formatMsg(type, msg) {\n  msg = '[' + type + '] > ' + msg;\n  return msg;\n}\n\nfunction consolePrintFn(type) {\n  var func = self.console[type];\n  if (func) {\n    return function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (args[0]) {\n        args[0] = formatMsg(type, args[0]);\n      }\n      func.apply(self.console, args);\n    };\n  }\n  return noop;\n}\n\nfunction exportLoggerFunctions(debugConfig) {\n  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    functions[_key2 - 1] = arguments[_key2];\n  }\n\n  functions.forEach(function (type) {\n    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n  });\n}\n\nvar enableLogs = exports.enableLogs = function enableLogs(debugConfig) {\n  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {\n    exportLoggerFunctions(debugConfig,\n    // Remove out from list here to hard-disable a log-level\n    //'trace',\n    'debug', 'log', 'info', 'warn', 'error');\n    // Some browsers don't allow to use bind on console object anyway\n    // fallback to default if needed\n    try {\n      exportedLogger.log();\n    } catch (e) {\n      exportedLogger = fakeLogger;\n    }\n  } else {\n    exportedLogger = fakeLogger;\n  }\n};\n\nvar logger = exports.logger = exportedLogger;\n\n},{}],51:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *  TimeRanges to string helper\n */\n\nvar TimeRanges = function () {\n  function TimeRanges() {\n    _classCallCheck(this, TimeRanges);\n  }\n\n  _createClass(TimeRanges, null, [{\n    key: 'toString',\n    value: function toString(r) {\n      var log = '',\n          len = r.length;\n      for (var i = 0; i < len; i++) {\n        log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';\n      }\n      return log;\n    }\n  }]);\n\n  return TimeRanges;\n}();\n\nexports.default = TimeRanges;\n\n},{}],52:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexports.default = function () {\n  if (typeof window !== 'undefined' && window.VTTCue) {\n    return window.VTTCue;\n  }\n\n  var autoKeyword = 'auto';\n  var directionSetting = {\n    '': true,\n    lr: true,\n    rl: true\n  };\n  var alignSetting = {\n    start: true,\n    middle: true,\n    end: true,\n    left: true,\n    right: true\n  };\n\n  function findDirectionSetting(value) {\n    if (typeof value !== 'string') {\n      return false;\n    }\n    var dir = directionSetting[value.toLowerCase()];\n    return dir ? value.toLowerCase() : false;\n  }\n\n  function findAlignSetting(value) {\n    if (typeof value !== 'string') {\n      return false;\n    }\n    var align = alignSetting[value.toLowerCase()];\n    return align ? value.toLowerCase() : false;\n  }\n\n  function extend(obj) {\n    var i = 1;\n    for (; i < arguments.length; i++) {\n      var cobj = arguments[i];\n      for (var p in cobj) {\n        obj[p] = cobj[p];\n      }\n    }\n\n    return obj;\n  }\n\n  function VTTCue(startTime, endTime, text) {\n    var cue = this;\n    var isIE8 = function () {\n      if (typeof navigator === 'undefined') {\n        return;\n      }\n      return (/MSIE\\s8\\.0/.test(navigator.userAgent)\n      );\n    }();\n    var baseObj = {};\n\n    if (isIE8) {\n      cue = document.createElement('custom');\n    } else {\n      baseObj.enumerable = true;\n    }\n\n    /**\n     * Shim implementation specific properties. These properties are not in\n     * the spec.\n     */\n\n    // Lets us know when the VTTCue's data has changed in such a way that we need\n    // to recompute its display state. This lets us compute its display state\n    // lazily.\n    cue.hasBeenReset = false;\n\n    /**\n     * VTTCue and TextTrackCue properties\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\n     */\n\n    var _id = '';\n    var _pauseOnExit = false;\n    var _startTime = startTime;\n    var _endTime = endTime;\n    var _text = text;\n    var _region = null;\n    var _vertical = '';\n    var _snapToLines = true;\n    var _line = 'auto';\n    var _lineAlign = 'start';\n    var _position = 50;\n    var _positionAlign = 'middle';\n    var _size = 50;\n    var _align = 'middle';\n\n    Object.defineProperty(cue, 'id', extend({}, baseObj, {\n      get: function get() {\n        return _id;\n      },\n      set: function set(value) {\n        _id = '' + value;\n      }\n    }));\n\n    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {\n      get: function get() {\n        return _pauseOnExit;\n      },\n      set: function set(value) {\n        _pauseOnExit = !!value;\n      }\n    }));\n\n    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {\n      get: function get() {\n        return _startTime;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('Start time must be set to a number.');\n        }\n        _startTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {\n      get: function get() {\n        return _endTime;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('End time must be set to a number.');\n        }\n        _endTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'text', extend({}, baseObj, {\n      get: function get() {\n        return _text;\n      },\n      set: function set(value) {\n        _text = '' + value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'region', extend({}, baseObj, {\n      get: function get() {\n        return _region;\n      },\n      set: function set(value) {\n        _region = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {\n      get: function get() {\n        return _vertical;\n      },\n      set: function set(value) {\n        var setting = findDirectionSetting(value);\n        // Have to check for false because the setting an be an empty string.\n        if (setting === false) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _vertical = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {\n      get: function get() {\n        return _snapToLines;\n      },\n      set: function set(value) {\n        _snapToLines = !!value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'line', extend({}, baseObj, {\n      get: function get() {\n        return _line;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number' && value !== autoKeyword) {\n          throw new SyntaxError('An invalid number or illegal string was specified.');\n        }\n        _line = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {\n      get: function get() {\n        return _lineAlign;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _lineAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'position', extend({}, baseObj, {\n      get: function get() {\n        return _position;\n      },\n      set: function set(value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Position must be between 0 and 100.');\n        }\n        _position = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {\n      get: function get() {\n        return _positionAlign;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _positionAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'size', extend({}, baseObj, {\n      get: function get() {\n        return _size;\n      },\n      set: function set(value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Size must be between 0 and 100.');\n        }\n        _size = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    Object.defineProperty(cue, 'align', extend({}, baseObj, {\n      get: function get() {\n        return _align;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _align = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    /**\n     * Other <track> spec defined properties\n     */\n\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n    cue.displayState = undefined;\n\n    if (isIE8) {\n      return cue;\n    }\n  }\n\n  /**\n   * VTTCue methods\n   */\n\n  VTTCue.prototype.getCueAsHTML = function () {\n    // Assume WebVTT.convertCueToDOMTree is on the global.\n    var WebVTT = window.WebVTT;\n    return WebVTT.convertCueToDOMTree(window, this.text);\n  };\n\n  return VTTCue;\n}();\n\n},{}],53:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fixLineBreaks = undefined;\n\nvar _vttcue = _dereq_(52);\n\nvar _vttcue2 = _interopRequireDefault(_vttcue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar StringDecoder = function StringDecoder() {\n  return {\n    decode: function decode(data) {\n      if (!data) {\n        return '';\n      }\n      if (typeof data !== 'string') {\n        throw new Error('Error - expected string data.');\n      }\n      return decodeURIComponent(encodeURIComponent(data));\n    }\n  };\n}; /*\n    * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716\n    */\n\nfunction VTTParser() {\n  this.window = window;\n  this.state = 'INITIAL';\n  this.buffer = '';\n  this.decoder = new StringDecoder();\n  this.regionList = [];\n}\n\n// Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\n  }\n\n  var m = input.match(/^(\\d+):(\\d{2})(:\\d{2})?\\.(\\d{3})/);\n  if (!m) {\n    return null;\n  }\n\n  if (m[3]) {\n    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\n    return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);\n  } else if (m[1] > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[1], m[2], 0, m[4]);\n  } else {\n    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\n    return computeSeconds(0, m[1], m[2], m[4]);\n  }\n}\n\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nfunction Settings() {\n  this.values = Object.create(null);\n}\n\nSettings.prototype = {\n  // Only accept the first assignment to any key.\n  set: function set(k, v) {\n    if (!this.get(k) && v !== '') {\n      this.values[k] = v;\n    }\n  },\n  // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  get: function get(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n    return this.has(k) ? this.values[k] : dflt;\n  },\n  // Check whether we have a value for a key.\n  has: function has(k) {\n    return k in this.values;\n  },\n  // Accept a setting if its one of the given alternatives.\n  alt: function alt(k, v, a) {\n    for (var n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  },\n  // Accept a setting if its a valid (signed) integer.\n  integer: function integer(k, v) {\n    if (/^-?\\d+$/.test(v)) {\n      // integer\n      this.set(k, parseInt(v, 10));\n    }\n  },\n  // Accept a setting if its a valid percentage.\n  percent: function percent(k, v) {\n    var m;\n    if (m = v.match(/^([\\d]{1,3})(\\.[\\d]*)?%$/)) {\n      v = parseFloat(v);\n      if (v >= 0 && v <= 100) {\n        this.set(k, v);\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\n// Helper function to parse input into groups separated by 'groupDelim', and\n// interprete each group as a key/value pair separated by 'keyValueDelim'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  var groups = groupDelim ? input.split(groupDelim) : [input];\n  for (var i in groups) {\n    if (typeof groups[i] !== 'string') {\n      continue;\n    }\n    var kv = groups[i].split(keyValueDelim);\n    if (kv.length !== 2) {\n      continue;\n    }\n    var k = kv[0];\n    var v = kv[1];\n    callback(k, v);\n  }\n}\n\nvar defaults = new _vttcue2.default(0, 0, 0);\n// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244\n// Chrome and Safari don't yet support this change, but FF does\nvar center = defaults.align === 'middle' ? 'middle' : 'center';\n\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  var oInput = input;\n  // 4.1 WebVTT timestamp\n  function consumeTimeStamp() {\n    var ts = parseTimeStamp(input);\n    if (ts === null) {\n      throw new Error('Malformed timestamp: ' + oInput);\n    }\n    // Remove time stamp from input.\n    input = input.replace(/^[^\\sa-zA-Z-]+/, '');\n    return ts;\n  }\n\n  // 4.4.2 WebVTT cue settings\n  function consumeCueSettings(input, cue) {\n    var settings = new Settings();\n\n    parseOptions(input, function (k, v) {\n      switch (k) {\n        case 'region':\n          // Find the last region we parsed with the same region id.\n          for (var i = regionList.length - 1; i >= 0; i--) {\n            if (regionList[i].id === v) {\n              settings.set(k, regionList[i].region);\n              break;\n            }\n          }\n          break;\n        case 'vertical':\n          settings.alt(k, v, ['rl', 'lr']);\n          break;\n        case 'line':\n          var vals = v.split(','),\n              vals0 = vals[0];\n          settings.integer(k, vals0);\n          if (settings.percent(k, vals0)) {\n            settings.set('snapToLines', false);\n          }\n          settings.alt(k, vals0, ['auto']);\n          if (vals.length === 2) {\n            settings.alt('lineAlign', vals[1], ['start', center, 'end']);\n          }\n          break;\n        case 'position':\n          vals = v.split(',');\n          settings.percent(k, vals[0]);\n          if (vals.length === 2) {\n            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);\n          }\n          break;\n        case 'size':\n          settings.percent(k, v);\n          break;\n        case 'align':\n          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);\n          break;\n      }\n    }, /:/, /\\s/);\n\n    // Apply default values for any missing fields.\n    cue.region = settings.get('region', null);\n    cue.vertical = settings.get('vertical', '');\n    var line = settings.get('line', 'auto');\n    if (line === 'auto' && defaults.line === -1) {\n      // set numeric line number for Safari\n      line = -1;\n    }\n    cue.line = line;\n    cue.lineAlign = settings.get('lineAlign', 'start');\n    cue.snapToLines = settings.get('snapToLines', true);\n    cue.size = settings.get('size', 100);\n    cue.align = settings.get('align', center);\n    var position = settings.get('position', 'auto');\n    if (position === 'auto' && defaults.position === 50) {\n      // set numeric position for Safari\n      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;\n    }\n    cue.position = position;\n  }\n\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, '');\n  }\n\n  // 4.1 WebVTT cue timings.\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n  skipWhitespace();\n  if (input.substr(0, 3) !== '-->') {\n    // (3) next characters must match '-->'\n    throw new Error('Malformed time stamp (time stamps must be separated by \\'-->\\'): ' + oInput);\n  }\n  input = input.substr(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n  // 4.1 WebVTT cue settings list.\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\n\nfunction fixLineBreaks(input) {\n  return input.replace(/<br(?: \\/)?>/gi, '\\n');\n}\n\nVTTParser.prototype = {\n  parse: function parse(data) {\n    var self = this;\n\n    // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n    if (data) {\n      // Try to decode the data that we received.\n      self.buffer += self.decoder.decode(data, { stream: true });\n    }\n\n    function collectNextLine() {\n      var buffer = self.buffer;\n      var pos = 0;\n\n      buffer = fixLineBreaks(buffer);\n\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n      var line = buffer.substr(0, pos);\n      // Advance the buffer early in case we fail below.\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n      self.buffer = buffer.substr(pos);\n      return line;\n    }\n\n    // 3.2 WebVTT metadata header syntax\n    function parseHeader(input) {\n      parseOptions(input, function (k, v) {\n        switch (k) {\n          case 'Region':\n            // 3.3 WebVTT region metadata header syntax\n            console.log('parse region', v);\n            //parseRegion(v);\n            break;\n        }\n      }, /:/);\n    }\n\n    // 5.1 WebVTT file parsing.\n    try {\n      var line;\n      if (self.state === 'INITIAL') {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(self.buffer)) {\n          return this;\n        }\n\n        line = collectNextLine();\n\n        var m = line.match(/^WEBVTT([ \\t].*)?$/);\n        if (!m || !m[0]) {\n          throw new Error('Malformed WebVTT signature.');\n        }\n\n        self.state = 'HEADER';\n      }\n\n      var alreadyCollectedLine = false;\n      while (self.buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(self.buffer)) {\n          return this;\n        }\n\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n\n        switch (self.state) {\n          case 'HEADER':\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n            if (/:/.test(line)) {\n              parseHeader(line);\n            } else if (!line) {\n              // An empty line terminates the header and starts the body (cues).\n              self.state = 'ID';\n            }\n            continue;\n          case 'NOTE':\n            // Ignore NOTE blocks.\n            if (!line) {\n              self.state = 'ID';\n            }\n            continue;\n          case 'ID':\n            // Check for the start of NOTE blocks.\n            if (/^NOTE($|[ \\t])/.test(line)) {\n              self.state = 'NOTE';\n              break;\n            }\n            // 19-29 - Allow any number of line terminators, then initialize new cue values.\n            if (!line) {\n              continue;\n            }\n            self.cue = new _vttcue2.default(0, 0, '');\n            self.state = 'CUE';\n            // 30-39 - Check if self line contains an optional identifier or timing data.\n            if (line.indexOf('-->') === -1) {\n              self.cue.id = line;\n              continue;\n            }\n          // Process line as start of a cue.\n          /*falls through*/\n          case 'CUE':\n            // 40 - Collect cue timings and settings.\n            try {\n              parseCue(line, self.cue, self.regionList);\n            } catch (e) {\n              // In case of an error ignore rest of the cue.\n              self.cue = null;\n              self.state = 'BADCUE';\n              continue;\n            }\n            self.state = 'CUETEXT';\n            continue;\n          case 'CUETEXT':\n            var hasSubstring = line.indexOf('-->') !== -1;\n            // 34 - If we have an empty line then report the cue.\n            // 35 - If we have the special substring '-->' then report the cue,\n            // but do not collect the line as we need to process the current\n            // one as a new cue.\n            if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n              // We are done parsing self cue.\n              if (self.oncue) {\n                self.oncue(self.cue);\n              }\n              self.cue = null;\n              self.state = 'ID';\n              continue;\n            }\n            if (self.cue.text) {\n              self.cue.text += '\\n';\n            }\n            self.cue.text += line;\n            continue;\n          case 'BADCUE':\n            // BADCUE\n            // 54-62 - Collect and discard the remaining cue.\n            if (!line) {\n              self.state = 'ID';\n            }\n            continue;\n        }\n      }\n    } catch (e) {\n\n      // If we are currently parsing a cue, report what we have.\n      if (self.state === 'CUETEXT' && self.cue && self.oncue) {\n        self.oncue(self.cue);\n      }\n      self.cue = null;\n      // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n      self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';\n    }\n    return this;\n  },\n  flush: function flush() {\n    var self = this;\n    try {\n      // Finish decoding the stream.\n      self.buffer += self.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (self.cue || self.state === 'HEADER') {\n        self.buffer += '\\n\\n';\n        self.parse();\n      }\n      // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n      if (self.state === 'INITIAL') {\n        throw new Error('Malformed WebVTT signature.');\n      }\n    } catch (e) {\n      throw e;\n    }\n    if (self.onflush) {\n      self.onflush();\n    }\n    return this;\n  }\n};\n\nexports.fixLineBreaks = fixLineBreaks;\nexports.default = VTTParser;\n\n},{\"52\":52}],54:[function(_dereq_,module,exports){\n'use strict';\n\nvar _vttparser = _dereq_(53);\n\nvar _vttparser2 = _interopRequireDefault(_vttparser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar cueString2millis = function cueString2millis(timeString) {\n    var ts = parseInt(timeString.substr(-3));\n    var secs = parseInt(timeString.substr(-6, 2));\n    var mins = parseInt(timeString.substr(-9, 2));\n    var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;\n\n    if (isNaN(ts) || isNaN(secs) || isNaN(mins) || isNaN(hours)) {\n        return -1;\n    }\n\n    ts += 1000 * secs;\n    ts += 60 * 1000 * mins;\n    ts += 60 * 60 * 1000 * hours;\n\n    return ts;\n};\n\nvar calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {\n    var currCC = vttCCs[cc];\n    var prevCC = vttCCs[currCC.prevCC];\n\n    // This is the first discontinuity or cues have been processed since the last discontinuity\n    // Offset = current discontinuity time\n    if (!prevCC || !prevCC.new && currCC.new) {\n        vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;\n        currCC.new = false;\n        return;\n    }\n\n    // There have been discontinuities since cues were last parsed.\n    // Offset = time elapsed\n    while (prevCC && prevCC.new) {\n        vttCCs.ccOffset += currCC.start - prevCC.start;\n        currCC.new = false;\n        currCC = prevCC;\n        prevCC = vttCCs[currCC.prevCC];\n    }\n\n    vttCCs.presentationOffset = presentationTime;\n};\n\nvar WebVTTParser = {\n    parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {\n        // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character.\n        var re = /\\r\\n|\\n\\r|\\n|\\r/g;\n        var vttLines = String.fromCharCode.apply(null, new Uint8Array(vttByteArray)).trim().replace(re, '\\n').split('\\n');\n        var cueTime = '00:00.000';\n        var mpegTs = 0;\n        var localTime = 0;\n        var presentationTime = 0;\n        var cues = [];\n        var parsingError = void 0;\n        var inHeader = true;\n        // let VTTCue = VTTCue || window.TextTrackCue;\n\n        // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.\n        var parser = new _vttparser2.default();\n\n        parser.oncue = function (cue) {\n            // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.\n            var currCC = vttCCs[cc];\n            var cueOffset = vttCCs.ccOffset;\n\n            // Update offsets for new discontinuities\n            if (currCC && currCC.new) {\n                if (localTime) {\n                    // When local time is provided, offset = discontinuity start time - local time\n                    cueOffset = vttCCs.ccOffset = currCC.start;\n                } else {\n                    calculateOffset(vttCCs, cc, presentationTime);\n                }\n            }\n\n            if (presentationTime && !localTime) {\n                // If we have MPEGTS but no LOCAL time, offset = presentation time + discontinuity offset\n                cueOffset = presentationTime + vttCCs.ccOffset - vttCCs.presentationOffset;\n            }\n\n            cue.startTime += cueOffset - localTime;\n            cue.endTime += cueOffset - localTime;\n\n            // Fix encoding of special characters. TODO: Test with all sorts of weird characters.\n            cue.text = decodeURIComponent(escape(cue.text));\n            if (cue.endTime > 0) {\n                cues.push(cue);\n            }\n        };\n\n        parser.onparsingerror = function (e) {\n            parsingError = e;\n        };\n\n        parser.onflush = function () {\n            if (parsingError && errorCallBack) {\n                errorCallBack(parsingError);\n                return;\n            }\n            callBack(cues);\n        };\n\n        // Go through contents line by line.\n        vttLines.forEach(function (line) {\n            if (inHeader) {\n                // Look for X-TIMESTAMP-MAP in header.\n                if (line.startsWith('X-TIMESTAMP-MAP=')) {\n                    // Once found, no more are allowed anyway, so stop searching.\n                    inHeader = false;\n                    // Extract LOCAL and MPEGTS.\n                    line.substr(16).split(',').forEach(function (timestamp) {\n                        if (timestamp.startsWith('LOCAL:')) {\n                            cueTime = timestamp.substr(6);\n                        } else if (timestamp.startsWith('MPEGTS:')) {\n                            mpegTs = parseInt(timestamp.substr(7));\n                        }\n                    });\n                    try {\n                        // Calculate subtitle offset in milliseconds.\n                        // If sync PTS is less than zero, we have a 33-bit wraparound, which is fixed by adding 2^33 = 8589934592.\n                        syncPTS = syncPTS < 0 ? syncPTS + 8589934592 : syncPTS;\n                        // Adjust MPEGTS by sync PTS.\n                        mpegTs -= syncPTS;\n                        // Convert cue time to seconds\n                        localTime = cueString2millis(cueTime) / 1000;\n                        // Convert MPEGTS to seconds from 90kHz.\n                        presentationTime = mpegTs / 90000;\n\n                        if (localTime === -1) {\n                            parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);\n                        }\n                    } catch (e) {\n                        parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);\n                    }\n                    // Return without parsing X-TIMESTAMP-MAP line.\n                    return;\n                } else if (line === '') {\n                    inHeader = false;\n                }\n            }\n            // Parse line by default.\n            parser.parse(line + '\\n');\n        });\n\n        parser.flush();\n    }\n};\n\nmodule.exports = WebVTTParser;\n\n},{\"53\":53}],55:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _logger = _dereq_(50);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar XhrLoader = function () {\n  function XhrLoader(config) {\n    _classCallCheck(this, XhrLoader);\n\n    if (config && config.xhrSetup) {\n      this.xhrSetup = config.xhrSetup;\n    }\n  }\n\n  _createClass(XhrLoader, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.abort();\n      this.loader = null;\n    }\n  }, {\n    key: 'abort',\n    value: function abort() {\n      var loader = this.loader;\n      if (loader && loader.readyState !== 4) {\n        this.stats.aborted = true;\n        loader.abort();\n      }\n\n      window.clearTimeout(this.requestTimeout);\n      this.requestTimeout = null;\n      window.clearTimeout(this.retryTimeout);\n      this.retryTimeout = null;\n    }\n  }, {\n    key: 'load',\n    value: function load(context, config, callbacks) {\n      this.context = context;\n      this.config = config;\n      this.callbacks = callbacks;\n      this.stats = { trequest: performance.now(), retry: 0 };\n      this.retryDelay = config.retryDelay;\n      this.loadInternal();\n    }\n  }, {\n    key: 'loadInternal',\n    value: function loadInternal() {\n      var xhr,\n          context = this.context;\n\n      if (typeof XDomainRequest !== 'undefined') {\n        xhr = this.loader = new XDomainRequest();\n      } else {\n        xhr = this.loader = new XMLHttpRequest();\n      }\n\n      xhr.onreadystatechange = this.readystatechange.bind(this);\n      xhr.onprogress = this.loadprogress.bind(this);\n\n      xhr.open('GET', context.url, true);\n\n      if (context.rangeEnd) {\n        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n      }\n      xhr.responseType = context.responseType;\n      var stats = this.stats;\n      stats.tfirst = 0;\n      stats.loaded = 0;\n      if (this.xhrSetup) {\n        this.xhrSetup(xhr, context.url);\n      }\n      // setup timeout before we perform request\n      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);\n      xhr.send();\n    }\n  }, {\n    key: 'readystatechange',\n    value: function readystatechange(event) {\n      var xhr = event.currentTarget,\n          readyState = xhr.readyState,\n          stats = this.stats,\n          context = this.context,\n          config = this.config;\n\n      // don't proceed if xhr has been aborted\n      if (stats.aborted) {\n        return;\n      }\n\n      // >= HEADERS_RECEIVED\n      if (readyState >= 2) {\n        // clear xhr timeout and rearm it if readyState less than 4\n        window.clearTimeout(this.requestTimeout);\n        if (stats.tfirst === 0) {\n          stats.tfirst = Math.max(performance.now(), stats.trequest);\n        }\n        if (readyState === 4) {\n          var status = xhr.status;\n          // http status between 200 to 299 are all successful\n          if (status >= 200 && status < 300) {\n            stats.tload = Math.max(stats.tfirst, performance.now());\n            var data = void 0,\n                len = void 0;\n            if (context.responseType === 'arraybuffer') {\n              data = xhr.response;\n              len = data.byteLength;\n            } else {\n              data = xhr.responseText;\n              len = data.length;\n            }\n            stats.loaded = stats.total = len;\n            var response = { url: xhr.responseURL, data: data };\n            this.callbacks.onSuccess(response, stats, context);\n          } else {\n            // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n            if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {\n              _logger.logger.error(status + ' while loading ' + context.url);\n              this.callbacks.onError({ code: status, text: xhr.statusText }, context);\n            } else {\n              // retry\n              _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');\n              // aborts and resets internal state\n              this.destroy();\n              // schedule retry\n              this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n              // set exponential backoff\n              this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);\n              stats.retry++;\n            }\n          }\n        } else {\n          // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n          this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);\n        }\n      }\n    }\n  }, {\n    key: 'loadtimeout',\n    value: function loadtimeout() {\n      _logger.logger.warn('timeout while loading ' + this.context.url);\n      this.callbacks.onTimeout(this.stats, this.context);\n    }\n  }, {\n    key: 'loadprogress',\n    value: function loadprogress(event) {\n      var stats = this.stats;\n      stats.loaded = event.loaded;\n      if (event.lengthComputable) {\n        stats.total = event.total;\n      }\n      var onProgress = this.callbacks.onProgress;\n      if (onProgress) {\n        // last args is to provide on progress data\n        onProgress(stats, this.context, null);\n      }\n    }\n  }]);\n\n  return XhrLoader;\n}();\n\nexports.default = XhrLoader;\n\n},{\"50\":50}]},{},[38])(38)\n});\n//# sourceMappingURL=hls.js.map\n\n\n/***/ }),\n\n/***/ 40:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _getPrototypeOf = __webpack_require__(2);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(3);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(4);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(6);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _style = __webpack_require__(7);\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _container = __webpack_require__(10);\n\nvar _container2 = _interopRequireDefault(_container);\n\nvar _menuItem = __webpack_require__(41);\n\nvar _menuItem2 = _interopRequireDefault(_menuItem);\n\nvar _link = __webpack_require__(12);\n\nvar _link2 = _interopRequireDefault(_link);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _class = function (_React$Component) {\n    (0, _inherits3.default)(_class, _React$Component);\n\n    function _class(props) {\n        (0, _classCallCheck3.default)(this, _class);\n\n        return (0, _possibleConstructorReturn3.default)(this, (_class.__proto__ || (0, _getPrototypeOf2.default)(_class)).call(this, props));\n    }\n\n    (0, _createClass3.default)(_class, [{\n        key: 'render',\n        value: function render() {\n            return _react2.default.createElement('div', { className: 'header', 'data-jsx': 3006156612\n            }, _react2.default.createElement(_container2.default, { flex: true }, _react2.default.createElement(_link2.default, { href: '/' }, _react2.default.createElement('img', { src: '/static/logo.svg', 'data-jsx': 3006156612\n            })), _react2.default.createElement('div', { className: 'menu', 'data-jsx': 3006156612\n            }, _react2.default.createElement('a', { href: '/register', 'data-jsx': 3006156612\n            }, _react2.default.createElement(_menuItem2.default, null, '\\u6CE8\\u518C')), _react2.default.createElement('a', { href: '/login', 'data-jsx': 3006156612\n            }, _react2.default.createElement(_menuItem2.default, null, '\\u767B\\u5F55')), _react2.default.createElement(_menuItem2.default, null, '\\u5173\\u4E8E'))), _react2.default.createElement(_style2.default, {\n                styleId: 3006156612,\n                css: '.header[data-jsx=\"3006156612\"] {position: fixed;height: 40px;background: #000;width: 100%;z-index: 9999;}.header[data-jsx=\"3006156612\"] img[data-jsx=\"3006156612\"] {display: block;max-height: 100%;width: 40px;}.container[data-jsx=\"3006156612\"] {width: 1050px;height: 100%;margin: 0 auto;display:-webkit-flex; display:flex;}.menu[data-jsx=\"3006156612\"] {display:-webkit-flex; display:flex;align-items: center;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHNcXGhlYWRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFnQzRCLEFBQ0MsZ0NBQ1csZ0JBQ0gsYUFDSSxpQkFDTCxZQUNFLGNBQ2pCLENBQ1ksMkRBQ00sZUFDRSxpQkFDTCxZQUNmLENBQ1csbUNBQ00sY0FDRCxhQUNFLGVBQ0QsbUNBQ2pCLENBQ00sOEJBQ1csbUNBQ00sb0JBQ3ZCIiwiZmlsZSI6ImNvbXBvbmVudHNcXGhlYWRlci5qcyIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9BYmFpanVuL0RvY3VtZW50cy9HaXRIdWIvbG9saSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL2NvbnRhaW5lcidcclxuaW1wb3J0IE1lbnVJdGVtIGZyb20gJy4vbWVudUl0ZW0nO1xyXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcblxyXG4gICAgY29uc3RydWN0b3IgKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiPlxyXG4gICAgICAgICAgICAgICAgPENvbnRhaW5lciBmbGV4PXt0cnVlfT5cclxuICAgICAgICAgICAgICAgICAgICA8TGluayBocmVmPVwiL1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cIi9zdGF0aWMvbG9nby5zdmdcIi8+IFxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtZW51XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIvcmVnaXN0ZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxNZW51SXRlbT7ms6jlhow8L01lbnVJdGVtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiL2xvZ2luXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TWVudUl0ZW0+55m75b2VPC9NZW51SXRlbT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPE1lbnVJdGVtPuWFs+S6jjwvTWVudUl0ZW0+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L0NvbnRhaW5lcj5cclxuXHJcbiAgICAgICAgICAgICAgICA8c3R5bGUganN4PntgXHJcbiAgICAgICAgICAgICAgICAgICAgLmhlYWRlciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA0MHB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAjMDAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgei1pbmRleDogOTk5OTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLmhlYWRlciBpbWcge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4LWhlaWdodDogMTAwJTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDQwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC5jb250YWluZXIge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTA1MHB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMCBhdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAubWVudSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYH08L3N0eWxlPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn0iXX0= */\\n/*@ sourceURL=components\\\\header.js */'\n            }));\n        }\n    }]);\n\n    return _class;\n}(_react2.default.Component);\n\nexports.default = _class;\n\n ;(function register() { /* react-hot-loader/webpack */ if (process.env.NODE_ENV !== 'production') { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\components\\\\header.js\"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\components\\\\header.js\"); } } })();\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n\n/***/ 41:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _getPrototypeOf = __webpack_require__(2);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(3);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(4);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(6);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(5);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _style = __webpack_require__(7);\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _container = __webpack_require__(10);\n\nvar _container2 = _interopRequireDefault(_container);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _class = function (_React$Component) {\n    (0, _inherits3.default)(_class, _React$Component);\n\n    function _class(props) {\n        (0, _classCallCheck3.default)(this, _class);\n\n        return (0, _possibleConstructorReturn3.default)(this, (_class.__proto__ || (0, _getPrototypeOf2.default)(_class)).call(this, props));\n    }\n\n    (0, _createClass3.default)(_class, [{\n        key: 'render',\n        value: function render() {\n            return _react2.default.createElement('li', { className: 'menu-item', 'data-jsx': 3111979664\n            }, this.props.children, _react2.default.createElement(_style2.default, {\n                styleId: 3111979664,\n                css: '.menu-item[data-jsx=\"3111979664\"] {color: #fff;padding: 5px 0;position: relative;text-decoration: none;-webkit-transition: opacity .1s linear;-webkit-transition: opacity .1s linear;-moz-transition: opacity .1s linear;-ms-transition: opacity .1s linear;transition: opacity .1s linear;margin-right: 20px;cursor: pointer;}.menu-item[data-jsx=\"3111979664\"]:after {border-bottom: 2px solid #6fb900;bottom: 0;content: \"\";left: 0;pointer-events: none;position: absolute;right: 0;}.menu-item[data-jsx=\"3111979664\"]:hover {opacity: .7;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHNcXG1lbnVJdGVtLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWM0QixBQUNJLG1DQUNJLFlBQ0csZUFDSSxtQkFDRyxzQkFDaUIsdUNBQ1IsNklBQ1osbUJBQ0gsZ0JBQ25CLENBQ2lCLHlDQUNtQixpQ0FDdkIsVUFDRSxZQUNKLFFBQ2EscUJBQ0YsbUJBQ1YsU0FDWixDQUNpQix5Q0FDRixZQUNmIiwiZmlsZSI6ImNvbXBvbmVudHNcXG1lbnVJdGVtLmpzIiwic291cmNlUm9vdCI6IkM6L1VzZXJzL0FiYWlqdW4vRG9jdW1lbnRzL0dpdEh1Yi9sb2xpIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vY29udGFpbmVyJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm1lbnUtaXRlbVwiPlxyXG4gICAgICAgICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XHJcblxyXG4gICAgICAgICAgICAgICAgPHN0eWxlIGpzeD57YFxyXG4gICAgICAgICAgICAgICAgICAgIC5tZW51LWl0ZW0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogI2ZmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogNXB4IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgLjFzIGxpbmVhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAuMXMgbGluZWFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDIwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLm1lbnUtaXRlbTphZnRlciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAjNmZiOTAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAubWVudS1pdGVtOmhvdmVyIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogLjc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYH08L3N0eWxlPlxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgIClcclxuICAgIH1cclxufSJdfQ== */\\n/*@ sourceURL=components\\\\menuItem.js */'\n            }));\n        }\n    }]);\n\n    return _class;\n}(_react2.default.Component);\n\nexports.default = _class;\n\n ;(function register() { /* react-hot-loader/webpack */ if (process.env.NODE_ENV !== 'production') { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\components\\\\menuItem.js\"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\components\\\\menuItem.js\"); } } })();\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n\n/***/ 42:\n/***/ (function(module, exports) {\n\n(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ }),\n\n/***/ 57:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _regenerator = __webpack_require__(15);\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = __webpack_require__(14);\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\n__webpack_require__(17);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar verify = function () {\n    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {\n        var userid, res, json, token;\n        return _regenerator2.default.wrap(function _callee$(_context) {\n            while (1) {\n                switch (_context.prev = _context.next) {\n                    case 0:\n                        userid = randomUserid();\n\n                        localStorage.setItem(\"userid\", userid);\n\n                        _context.next = 4;\n                        return fetch(\"https://loliapi.com/login/\" + userid);\n\n                    case 4:\n                        res = _context.sent;\n                        _context.next = 7;\n                        return res.json();\n\n                    case 7:\n                        json = _context.sent;\n                        token = json.Message.Token;\n\n                        localStorage.setItem(\"token\", token);\n\n                    case 10:\n                    case \"end\":\n                        return _context.stop();\n                }\n            }\n        }, _callee, this);\n    }));\n\n    return function verify() {\n        return _ref.apply(this, arguments);\n    };\n}();\n\nfunction randomUserid() {\n    var str = \"\";\n    var str2 = \"\";\n    var pos = '';\n    var arr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\n    for (var i = 0; i < 32; i++) {\n        pos = Math.round(Math.random() * (arr.length - 1));\n        str += arr[pos];\n    }\n\n    str2 = str.substring(0, 8) + '-' + str.substring(8, 12) + '-' + str.substring(12, 16) + '-' + str.substring(16, 20) + '-' + str.substring(20, 32);\n    return str2;\n}\n\nexports.default = verify;\n\n ;(function register() { /* react-hot-loader/webpack */ if (process.env.NODE_ENV !== 'production') { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\lib\\\\tool.js\"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, \"C:\\\\Users\\\\Abaijun\\\\Documents\\\\GitHub\\\\loli\\\\lib\\\\tool.js\"); } } })();\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n\n/***/ 600:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(19);\nmodule.exports = __webpack_require__(268);\n\n\n/***/ })\n\n},[600]);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRhaW5lci5qcz9jNDRiYjQwIiwid2VicGFjazovLy8uL34vaXNvbW9ycGhpYy1mZXRjaC9mZXRjaC1ucG0tYnJvd3NlcmlmeS5qcz9jNDRiYjQwIiwid2VicGFjazovLy8uL3BhZ2VzL21vdmllLmpzPzM0YzMyN2EiLCJ3ZWJwYWNrOi8vLy4vfi9jbGFzc25hbWVzL2luZGV4LmpzPzM0YzMyN2EiLCJ3ZWJwYWNrOi8vLy4vfi9obHMuanMvZGlzdC9obHMuanM/MzRjMzI3YSIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2hlYWRlci5qcz8zNGMzMjdhIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvbWVudUl0ZW0uanM/MzRjMzI3YSIsIndlYnBhY2s6Ly8vLi9+L3doYXR3Zy1mZXRjaC9mZXRjaC5qcz8zNGMzMjdhIiwid2VicGFjazovLy8uL2xpYi90b29sLmpzPzM0YzMyN2EiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPOzs7O0FBQ0E7Ozs7Ozs7b0NBSUg7O29CQUFhLE9BQU87NENBQUE7O3FJQUVuQjs7Ozs7aUNBR0c7Z0JBQUk7NkJBRUE7d0JBQVEsS0FBSyxNQUNiO3lCQUFTLEtBQUssTUFFbEI7QUFKSSxhQURpQjttQ0FNakIsdUJBQUssV0FBVyw0QkFDWDthQURMLE9BQ1UsTUFBTTt5QkFEaEI7cUJBMkJQO0FBM0JPOzs7OztFQWJpQixnQkFBTTs7Ozs7Ozs7Ozs7O0FDSG5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMTzs7OztBQUNBOzs7O0FBQ1A7O0FBQ087Ozs7QUFDQTs7OztBQUNZOzs7O0FBQ0c7Ozs7QUFDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7aUNBUVA7c0NBQU0sYUFBYSxRQUNuQjt3Q0FBUSxhQUFhLFFBRXpCOztBQUNBOztv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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSCxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZ0JBQWdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxNQUFNLEdBQUcsYUFBYSxHQUFHLGdCQUFnQixHQUFHLHFDQUFxQyxHQUFHLFVBQVU7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGFBQWE7QUFDMUUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHdIQUF3SDtBQUNuTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Es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QUNBLGdEQUFnRCwyR0FBMkc7QUFDM0o7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQWdFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdCQUFnQixHQUFHLEtBQUss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QUFDQSx1REFBdUQsb0RBQW9EO0FBQzNHO0FBQ0EsT0FBTztBQUNQO0FBQ0EsNkNBQTZDLHFKQUFxSjtBQUNsTTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxtREFBbUQ7QUFDN0c7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxFQUFFLHdDQUF3QztBQUMzQzs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLGlEQUFpRCxhQUFhLHVGQUF1RixFQUFFLHVGQUF1Rjs7QUFFOU8sMENBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SCxFQUFFO0FBQzllO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0NBQStDLGlCQUFpQixHQUFHLGVBQWUsR0FBRyxxQkFBcUIsR0FBRyxtQkFBbUI7QUFDaEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE1BQU0sR0FBRyxhQUFhLEdBQUcsZ0JBQWdCLEdBQUcscUNBQXFDLEdBQUcsVUFBVTtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYTtBQUNoRSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsd0hBQXdIO0FBQ3pLO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELG9CQUFvQjtBQUNqRjtBQUNBO0FBQ0EsaUVBQWlFLDBCQUEwQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw4QkFBOEIsc0VBQXNFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHVDQUF1QztBQUN2RztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0NBQWdDLDJDQUEyQyxn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Q2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZUFBZTtBQUNyRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxXQUFXO0FBQ2xFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpRkFBaUY7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2RUFBNkUsdUJBQXVCO0FBQ3BHO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdCQUF3QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFH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Q0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qix1QkFBdUI7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx1Q0FBdUMsMEJBQTBCO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsMEJBQTBCLGVBQWU7QUFDeEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6Y0Q7Ozs7OzBFQWlCQTsrQkFBQTtzRUFBQTtzQkFBQTtpREFBQTt5QkFDUTtBQURSLGlDQUdJOztxQ0FBYSxRQUFRLFVBQVU7O3dDQUhuQzsrQkFLc0IscUNBQW1DOzt5QkFBL0M7QUFMVjt3Q0FBQTsrQkFNdUIsSUFBSTs7eUJBQWpCO0FBTlYsd0NBT1E7QUFQUixnQ0FPZ0IsS0FBSyxRQUVqQjs7cUNBQWEsUUFBUSxTQUFTOzt5QkFUbEM7eUJBQUE7d0NBQUE7O0FBQUE7b0JBQUE7OztvQkFBZTs7Ozs7QUFmZixTQUFTLGVBQ0w7UUFBSSxNQUNKO1FBQUksT0FDSjtRQUFJLE1BQ0o7UUFBSSxNQUFNLENBQUMsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUVyTDs7U0FBSSxJQUFJLElBQUksR0FBRyxJQUFJLElBQUksS0FDbkI7Y0FBTSxLQUFLLE1BQU0sS0FBSyxZQUFZLElBQUksU0FDdEM7ZUFBTyxJQUNWO0FBRUQ7O1dBQU8sSUFBSSxVQUFVLEdBQUcsS0FBSyxNQUFNLElBQUksVUFBVSxHQUFHLE1BQU0sTUFBTSxJQUFJLFVBQVUsSUFBSSxNQUFNLE1BQU0sSUFBSSxVQUFVLElBQUcsTUFBTSxNQUFNLElBQUksVUFBVSxJQUN6STtXQUNIO0FBY0Q7O2tCQUFlLE8iLCJmaWxlIjoiYnVuZGxlc1xccGFnZXNcXG1vdmllLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lckNsYXNzID0gY2xhc3NOYW1lcyh7XHJcbiAgICAgICAgICAgICdjb250YWluZXInOiB0cnVlLFxyXG4gICAgICAgICAgICAnZmxleCc6IHRoaXMucHJvcHMuZmxleCxcclxuICAgICAgICAgICAgJ3NtYWxsJzogdGhpcy5wcm9wcy5zbWFsbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjb250YWluZXJDbGFzc30+XHJcbiAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDxzdHlsZSBqc3g+e2BcclxuICAgICAgICAgICAgICAgICAgICAuY29udGFpbmVyLnNtYWxsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwNTBweDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbnRhaW5lciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC5jb250YWluZXIuZmxleCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi1oZWlnaHQ6IDYzMHB4KSBhbmQgKG1pbi13aWR0aDogMTI5NHB4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb250YWluZXIge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwNjZweDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLWhlaWdodDogODcwcHgpIGFuZCAobWluLXdpZHRoOiAxMzIwcHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRhaW5lciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTI4MHB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYH08L3N0eWxlPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRhaW5lci5qcyIsIi8vIHRoZSB3aGF0d2ctZmV0Y2ggcG9seWZpbGwgaW5zdGFsbHMgdGhlIGZldGNoKCkgZnVuY3Rpb25cbi8vIG9uIHRoZSBnbG9iYWwgb2JqZWN0ICh3aW5kb3cgb3Igc2VsZilcbi8vXG4vLyBSZXR1cm4gdGhhdCBhcyB0aGUgZXhwb3J0IGZvciB1c2UgaW4gV2VicGFjaywgQnJvd3NlcmlmeSBldGMuXG5yZXF1aXJlKCd3aGF0d2ctZmV0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gc2VsZi5mZXRjaC5iaW5kKHNlbGYpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzb21vcnBoaWMtZmV0Y2gvZmV0Y2gtbnBtLWJyb3dzZXJpZnkuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMiAzIDQgNSA2IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnXHJcbmltcG9ydCAnaXNvbW9ycGhpYy1mZXRjaCdcclxuaW1wb3J0IEhscyBmcm9tICdobHMuanMnXHJcbmltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCdcclxuaW1wb3J0IEhlYWRlciBmcm9tICcuLi9jb21wb25lbnRzL2hlYWRlcidcclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi9jb21wb25lbnRzL2NvbnRhaW5lcidcclxuaW1wb3J0IHZlcmlmeSBmcm9tICcuLi9saWIvdG9vbCdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIHN0YXRpYyBhc3luYyBnZXRJbml0aWFsUHJvcHMgKHsgcXVlcnk6IHsgaWQgfSB9KSB7XHJcbiAgICAgICAgcmV0dXJuIHtpZDogaWR9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgY29tcG9uZW50V2lsbE1vdW50KCkge1xyXG4gICAgICAgIGxldCB1aWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInVzZXJpZFwiKTtcclxuICAgICAgICBsZXQgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VuXCIpO1xyXG5cclxuICAgICAgICAvLyDnm7TmjqXku44gdXJsIOi/m+WFpee7hOS7tlxyXG4gICAgICAgIGlmICh1aWQgPT0gbnVsbCB8fCB0b2tlbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZlcmlmeSgpO1xyXG4gICAgICAgICAgICB1aWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInVzZXJpZFwiKTtcclxuICAgICAgICAgICAgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IGZldGNoKGBodHRwczovL2xvbGlhcGkuY29tL3BsYXkvJHt0aGlzLnByb3BzLmlkfT91aWQ9JHt1aWR9JnRva2VuPSR7dG9rZW59YCk7XHJcbiAgICAgICAgbGV0IHJlczIgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9sb2xpYXBpLmNvbS9pbmZvLyR7dGhpcy5wcm9wcy5pZH1gKTtcclxuICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgICAgICAgbGV0IGluZm8gPSBhd2FpdCByZXMyLmpzb24oKTtcclxuXHJcbiAgICAgICAgaWYgKGRhdGEuUmVzdWx0ID09IDApIHtcclxuICAgICAgICAgICAgLy8g6K6k6K+B5bey6L+H5pyfLCDpnIDopoHph43mlrDorqTor4FcclxuICAgICAgICAgICAgdmVyaWZ5KCk7XHJcbiAgICAgICAgICAgIHVpZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidXNlcmlkXCIpO1xyXG4gICAgICAgICAgICB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidG9rZW5cIik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyDph43mlrDorqTor4HlkI7lj5Hor7fmsYJcclxuICAgICAgICAgICAgcmVzID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vbG9saWFwaS5jb20vcGxheS8ke3RoaXMucHJvcHMuaWR9P3VpZD0ke3VpZH0mdG9rZW49JHt0b2tlbn1gKTtcclxuICAgICAgICAgICAgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNldFN0YXRlKHt1cmw6IGRhdGEuTWVzc2FnZX0pO1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2luZm86IGluZm8uTWVzc2FnZX0pO1xyXG5cclxuICAgICAgICBpZihIbHMuaXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgICAgICB2YXIgdmlkZW8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGVzdCcpO1xyXG4gICAgICAgICAgICB2YXIgaGxzID0gbmV3IEhscygpO1xyXG4gICAgICAgICAgICAvLyB2YXIgbTN1OFVybCA9IGRlY29kZVVSSUNvbXBvbmVudChcImh0dHBzOi8vbG9saWFwaS5jb20vY29ycy9cIiArIHRoaXMuc3RhdGUudXJsKTtcclxuICAgICAgICAgICAgdmFyIG0zdThVcmwgPSB0aGlzLnN0YXRlLnVybDtcclxuICAgICAgICAgICAgaGxzLmxvYWRTb3VyY2UobTN1OFVybCk7XHJcbiAgICAgICAgICAgIGhscy5hdHRhY2hNZWRpYSh2aWRlbyk7XHJcbiAgICAgICAgICAgIGhscy5vbihIbHMuRXZlbnRzLk1BTklGRVNUX1BBUlNFRCxmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICB2aWRlby5wbGF5KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt1cmw6IFwiXCIsIGluZm86IHt9fTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb3ZpZVwiPlxyXG4gICAgICAgICAgICAgICAgPEhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRpdGxlPnt0aGlzLnN0YXRlLmluZm8uTmFtZX08L3RpdGxlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxtZXRhIGNoYXJTZXQ9J3V0Zi04JyAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiL3N0YXRpYy9nbG9iYWwuY3NzXCIgLz5cclxuICAgICAgICAgICAgICAgIDwvSGVhZD5cclxuXHJcbiAgICAgICAgICAgICAgICA8SGVhZGVyLz5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWFza1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDb250YWluZXIgZmxleD17dHJ1ZX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx2aWRlbyBjbGFzc05hbWU9XCJ0ZXN0XCI+PC92aWRlbz5cclxuICAgICAgICAgICAgICAgICAgICA8L0NvbnRhaW5lcj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICA8c3R5bGUganN4PntgXHJcbiAgICAgICAgICAgICAgICAgICAgLnRlc3Qge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDAgYXV0bztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLm1hc2sge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAjMDAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLWhlaWdodDogNjMwcHgpIGFuZCAobWluLXdpZHRoOiAxMjk0cHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hc2sge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA0ODBweDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLWhlaWdodDogODcwcHgpIGFuZCAobWluLXdpZHRoOiAxMzIwcHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hc2sge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA3MjBweDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGB9PC9zdHlsZT5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFnZXMvbW92aWUuanM/ZW50cnkiLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZykpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jbGFzc25hbWVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDIgMyA0IDUgNiIsIihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLkhscyA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxufSx7fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXHJcbihmdW5jdGlvbihyb290KSB7IFxyXG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xyXG5cclxuICB2YXIgSEFTSF9TUExJVCA9IC9eKFteI10qKSguKikkLztcclxuICB2YXIgUVVFUllfU1BMSVQgPSAvXihbXlxcP10qKSguKikkLztcclxuICB2YXIgRE9NQUlOX1NQTElUID0gL14oKFthLXpdKzpcXC9cXC8pP1teOlxcL10rKD86OlswLTldKyk/KT8oXFwvPy4qKSQvaTtcclxuXHJcbiAgdmFyIFVSTFRvb2xraXQgPSB7XHJcbiAgICAvLyBidWlsZCBhbiBhYnNvbHV0ZSBVUkwgZnJvbSBhIHJlbGF0aXZlIG9uZSB1c2luZyB0aGUgcHJvdmlkZWQgYmFzZVVSTFxyXG4gICAgLy8gaWYgcmVsYXRpdmVVUkwgaXMgYW4gYWJzb2x1dGUgVVJMIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMgaXMuXHJcbiAgICBidWlsZEFic29sdXRlVVJMOiBmdW5jdGlvbihiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xyXG4gICAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxyXG4gICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMLnRyaW0oKTtcclxuICAgICAgaWYgKC9eW2Etel0rOi9pLnRlc3QocmVsYXRpdmVVUkwpKSB7XHJcbiAgICAgICAgLy8gY29tcGxldGUgdXJsLCBub3QgcmVsYXRpdmVcclxuICAgICAgICByZXR1cm4gcmVsYXRpdmVVUkw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZWxhdGl2ZVVSTFF1ZXJ5ID0gbnVsbDtcclxuICAgICAgdmFyIHJlbGF0aXZlVVJMSGFzaCA9IG51bGw7XHJcblxyXG4gICAgICB2YXIgcmVsYXRpdmVVUkxIYXNoU3BsaXQgPSBIQVNIX1NQTElULmV4ZWMocmVsYXRpdmVVUkwpO1xyXG4gICAgICBpZiAocmVsYXRpdmVVUkxIYXNoU3BsaXQpIHtcclxuICAgICAgICByZWxhdGl2ZVVSTEhhc2ggPSByZWxhdGl2ZVVSTEhhc2hTcGxpdFsyXTtcclxuICAgICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMSGFzaFNwbGl0WzFdO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciByZWxhdGl2ZVVSTFF1ZXJ5U3BsaXQgPSBRVUVSWV9TUExJVC5leGVjKHJlbGF0aXZlVVJMKTtcclxuICAgICAgaWYgKHJlbGF0aXZlVVJMUXVlcnlTcGxpdCkge1xyXG4gICAgICAgIHJlbGF0aXZlVVJMUXVlcnkgPSByZWxhdGl2ZVVSTFF1ZXJ5U3BsaXRbMl07XHJcbiAgICAgICAgcmVsYXRpdmVVUkwgPSByZWxhdGl2ZVVSTFF1ZXJ5U3BsaXRbMV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBiYXNlVVJMSGFzaFNwbGl0ID0gSEFTSF9TUExJVC5leGVjKGJhc2VVUkwpO1xyXG4gICAgICBpZiAoYmFzZVVSTEhhc2hTcGxpdCkge1xyXG4gICAgICAgIGJhc2VVUkwgPSBiYXNlVVJMSGFzaFNwbGl0WzFdO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBiYXNlVVJMUXVlcnlTcGxpdCA9IFFVRVJZX1NQTElULmV4ZWMoYmFzZVVSTCk7XHJcbiAgICAgIGlmIChiYXNlVVJMUXVlcnlTcGxpdCkge1xyXG4gICAgICAgIGJhc2VVUkwgPSBiYXNlVVJMUXVlcnlTcGxpdFsxXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGJhc2VVUkxEb21haW5TcGxpdCA9IERPTUFJTl9TUExJVC5leGVjKGJhc2VVUkwpO1xyXG4gICAgICBpZiAoIWJhc2VVUkxEb21haW5TcGxpdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBlLmcuICdodHRwOi8vJywgJ2h0dHBzOi8vJywgJydcclxuICAgICAgdmFyIGJhc2VVUkxQcm90b2NvbCA9IGJhc2VVUkxEb21haW5TcGxpdFsyXSB8fCAnJztcclxuICAgICAgLy8gZS5nLiAnaHR0cDovL2V4YW1wbGUuY29tJywgJy8vZXhhbXBsZS5jb20nLCAnZXhhbXBsZS5jb20nLCAnJ1xyXG4gICAgICB2YXIgYmFzZVVSTFByb3RvY29sRG9tYWluID0gYmFzZVVSTERvbWFpblNwbGl0WzFdIHx8ICcnO1xyXG4gICAgICAvLyBlLmcuICcvYS9iL2MvcGxheWxpc3QubTN1OCcsICdhL2IvYy9wbGF5bGlzdC5tM3U4J1xyXG4gICAgICB2YXIgYmFzZVVSTFBhdGggPSBiYXNlVVJMRG9tYWluU3BsaXRbM107XHJcbiAgICAgIGlmIChiYXNlVVJMUGF0aC5pbmRleE9mKCcvJykgIT09IDAgJiYgYmFzZVVSTFByb3RvY29sRG9tYWluICE9PSAnJykge1xyXG4gICAgICAgIC8vIHRoaXMgaGFuZGxlcyBhIGJhc2UgdXJsIG9mIGh0dHA6Ly9leGFtcGxlLmNvbSAobWlzc2luZyBsYXN0IHNsYXNoKVxyXG4gICAgICAgIGJhc2VVUkxQYXRoID0gJy8nK2Jhc2VVUkxQYXRoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgYnVpbHRVUkwgPSBudWxsO1xyXG4gICAgICBpZiAoL15cXC9cXC8vLnRlc3QocmVsYXRpdmVVUkwpKSB7XHJcbiAgICAgICAgLy8gcmVsYXRpdmUgdXJsIHN0YXJ0cyB3dGggJy8vJyBzbyBjb3B5IHByb3RvY29sICh3aGljaCBtYXkgYmUgJycgaWYgYmFzZVVybCBkaWRuJ3QgcHJvdmlkZSBvbmUpXHJcbiAgICAgICAgYnVpbHRVUkwgPSBiYXNlVVJMUHJvdG9jb2wrVVJMVG9vbGtpdC5idWlsZEFic29sdXRlUGF0aCgnJywgcmVsYXRpdmVVUkwuc3Vic3RyaW5nKDIpKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICgvXlxcLy8udGVzdChyZWxhdGl2ZVVSTCkpIHtcclxuICAgICAgICAvLyByZWxhdGl2ZSB1cmwgc3RhcnRzIHdpdGggJy8nIHNvIHN0YXJ0IGZyb20gcm9vdCBvZiBkb21haW5cclxuICAgICAgICBidWlsdFVSTCA9IGJhc2VVUkxQcm90b2NvbERvbWFpbisnLycrVVJMVG9vbGtpdC5idWlsZEFic29sdXRlUGF0aCgnJywgcmVsYXRpdmVVUkwuc3Vic3RyaW5nKDEpKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBidWlsdFVSTCA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVBhdGgoYmFzZVVSTFByb3RvY29sRG9tYWluK2Jhc2VVUkxQYXRoLCByZWxhdGl2ZVVSTCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHB1dCB0aGUgcXVlcnkgYW5kIGhhc2ggcGFydHMgYmFja1xyXG4gICAgICBpZiAocmVsYXRpdmVVUkxRdWVyeSkge1xyXG4gICAgICAgIGJ1aWx0VVJMICs9IHJlbGF0aXZlVVJMUXVlcnk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlbGF0aXZlVVJMSGFzaCkge1xyXG4gICAgICAgIGJ1aWx0VVJMICs9IHJlbGF0aXZlVVJMSGFzaDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYnVpbHRVUkw7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGJ1aWxkIGFuIGFic29sdXRlIHBhdGggdXNpbmcgdGhlIHByb3ZpZGVkIGJhc2VQYXRoXHJcbiAgICAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2RvY3VtZW50L2Nvb2tpZSNVc2luZ19yZWxhdGl2ZV9VUkxzX2luX3RoZV9wYXRoX3BhcmFtZXRlclxyXG4gICAgLy8gdGhpcyBkb2VzIG5vdCBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgcmVsYXRpdmVQYXRoIGlzIFwiL1wiIG9yIFwiLy9cIi4gVGhlc2UgY2FzZXMgc2hvdWxkIGJlIGhhbmRsZWQgb3V0c2lkZSB0aGlzLlxyXG4gICAgYnVpbGRBYnNvbHV0ZVBhdGg6IGZ1bmN0aW9uKGJhc2VQYXRoLCByZWxhdGl2ZVBhdGgpIHtcclxuICAgICAgdmFyIHNSZWxQYXRoID0gcmVsYXRpdmVQYXRoO1xyXG4gICAgICB2YXIgblVwTG4sIHNEaXIgPSAnJywgc1BhdGggPSBiYXNlUGF0aC5yZXBsYWNlKC9bXlxcL10qJC8sIHNSZWxQYXRoLnJlcGxhY2UoLyhcXC98XikoPzpcXC4/XFwvKykrL2csICckMScpKTtcclxuICAgICAgZm9yICh2YXIgbkVuZCwgblN0YXJ0ID0gMDsgbkVuZCA9IHNQYXRoLmluZGV4T2YoJy8uLi8nLCBuU3RhcnQpLCBuRW5kID4gLTE7IG5TdGFydCA9IG5FbmQgKyBuVXBMbikge1xyXG4gICAgICAgIG5VcExuID0gL15cXC8oPzpcXC5cXC5cXC8pKi8uZXhlYyhzUGF0aC5zbGljZShuRW5kKSlbMF0ubGVuZ3RoO1xyXG4gICAgICAgIHNEaXIgPSAoc0RpciArIHNQYXRoLnN1YnN0cmluZyhuU3RhcnQsIG5FbmQpKS5yZXBsYWNlKG5ldyBSZWdFeHAoJyg/OlxcXFxcXC8rW15cXFxcXFwvXSopezAsJyArICgoblVwTG4gLSAxKSAvIDMpICsgJ30kJyksICcvJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNEaXIgKyBzUGF0aC5zdWJzdHIoblN0YXJ0KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xyXG4gIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcclxuICAgIG1vZHVsZS5leHBvcnRzID0gVVJMVG9vbGtpdDtcclxuICBlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBVUkxUb29sa2l0OyB9KTtcclxuICBlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcclxuICAgIGV4cG9ydHNbXCJVUkxUb29sa2l0XCJdID0gVVJMVG9vbGtpdDtcclxuICBlbHNlXHJcbiAgICByb290W1wiVVJMVG9vbGtpdFwiXSA9IFVSTFRvb2xraXQ7XHJcbn0pKHRoaXMpO1xyXG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xyXG5cbn0se31dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGJ1bmRsZUZuID0gYXJndW1lbnRzWzNdO1xudmFyIHNvdXJjZXMgPSBhcmd1bWVudHNbNF07XG52YXIgY2FjaGUgPSBhcmd1bWVudHNbNV07XG5cbnZhciBzdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICB2YXIgd2tleTtcbiAgICB2YXIgY2FjaGVLZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWNoZUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgIHZhciBleHAgPSBjYWNoZVtrZXldLmV4cG9ydHM7XG4gICAgICAgIC8vIFVzaW5nIGJhYmVsIGFzIGEgdHJhbnNwaWxlciB0byB1c2UgZXNtb2R1bGUsIHRoZSBleHBvcnQgd2lsbCBhbHdheXNcbiAgICAgICAgLy8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGRlZmF1bHQgZXhwb3J0IGFzIGEgcHJvcGVydHkgb2YgaXQuIFRvIGVuc3VyZVxuICAgICAgICAvLyB0aGUgZXhpc3RpbmcgYXBpIGFuZCBiYWJlbCBlc21vZHVsZSBleHBvcnRzIGFyZSBib3RoIHN1cHBvcnRlZCB3ZVxuICAgICAgICAvLyBjaGVjayBmb3IgYm90aFxuICAgICAgICBpZiAoZXhwID09PSBmbiB8fCBleHAgJiYgZXhwLmRlZmF1bHQgPT09IGZuKSB7XG4gICAgICAgICAgICB3a2V5ID0ga2V5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXdrZXkpIHtcbiAgICAgICAgd2tleSA9IE1hdGguZmxvb3IoTWF0aC5wb3coMTYsIDgpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgd2NhY2hlID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGNhY2hlS2V5c1tpXTtcbiAgICAgICAgICAgIHdjYWNoZVtrZXldID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZXNbd2tleV0gPSBbXG4gICAgICAgICAgICBGdW5jdGlvbihbJ3JlcXVpcmUnLCdtb2R1bGUnLCdleHBvcnRzJ10sICcoJyArIGZuICsgJykoc2VsZiknKSxcbiAgICAgICAgICAgIHdjYWNoZVxuICAgICAgICBdO1xuICAgIH1cbiAgICB2YXIgc2tleSA9IE1hdGguZmxvb3IoTWF0aC5wb3coMTYsIDgpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuXG4gICAgdmFyIHNjYWNoZSA9IHt9OyBzY2FjaGVbd2tleV0gPSB3a2V5O1xuICAgIHNvdXJjZXNbc2tleV0gPSBbXG4gICAgICAgIEZ1bmN0aW9uKFsncmVxdWlyZSddLCAoXG4gICAgICAgICAgICAvLyB0cnkgdG8gY2FsbCBkZWZhdWx0IGlmIGRlZmluZWQgdG8gYWxzbyBzdXBwb3J0IGJhYmVsIGVzbW9kdWxlXG4gICAgICAgICAgICAvLyBleHBvcnRzXG4gICAgICAgICAgICAndmFyIGYgPSByZXF1aXJlKCcgKyBzdHJpbmdpZnkod2tleSkgKyAnKTsnICtcbiAgICAgICAgICAgICcoZi5kZWZhdWx0ID8gZi5kZWZhdWx0IDogZikoc2VsZik7J1xuICAgICAgICApKSxcbiAgICAgICAgc2NhY2hlXG4gICAgXTtcblxuICAgIHZhciB3b3JrZXJTb3VyY2VzID0ge307XG4gICAgcmVzb2x2ZVNvdXJjZXMoc2tleSk7XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlU291cmNlcyhrZXkpIHtcbiAgICAgICAgd29ya2VyU291cmNlc1trZXldID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBkZXBQYXRoIGluIHNvdXJjZXNba2V5XVsxXSkge1xuICAgICAgICAgICAgdmFyIGRlcEtleSA9IHNvdXJjZXNba2V5XVsxXVtkZXBQYXRoXTtcbiAgICAgICAgICAgIGlmICghd29ya2VyU291cmNlc1tkZXBLZXldKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVNvdXJjZXMoZGVwS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzcmMgPSAnKCcgKyBidW5kbGVGbiArICcpKHsnXG4gICAgICAgICsgT2JqZWN0LmtleXMod29ya2VyU291cmNlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoa2V5KSArICc6WydcbiAgICAgICAgICAgICAgICArIHNvdXJjZXNba2V5XVswXVxuICAgICAgICAgICAgICAgICsgJywnICsgc3RyaW5naWZ5KHNvdXJjZXNba2V5XVsxXSkgKyAnXSdcbiAgICAgICAgICAgIDtcbiAgICAgICAgfSkuam9pbignLCcpXG4gICAgICAgICsgJ30se30sWycgKyBzdHJpbmdpZnkoc2tleSkgKyAnXSknXG4gICAgO1xuXG4gICAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMIHx8IHdpbmRvdy5tc1VSTDtcblxuICAgIHZhciBibG9iID0gbmV3IEJsb2IoW3NyY10sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5iYXJlKSB7IHJldHVybiBibG9iOyB9XG4gICAgdmFyIHdvcmtlclVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVXJsKTtcbiAgICB3b3JrZXIub2JqZWN0VVJMID0gd29ya2VyVXJsO1xuICAgIHJldHVybiB3b3JrZXI7XG59O1xuXG59LHt9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogSExTIGNvbmZpZ1xuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5obHNEZWZhdWx0Q29uZmlnID0gdW5kZWZpbmVkO1xuXG52YXIgX2FickNvbnRyb2xsZXIgPSBfZGVyZXFfKDUpO1xuXG52YXIgX2FickNvbnRyb2xsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWJyQ29udHJvbGxlcik7XG5cbnZhciBfYnVmZmVyQ29udHJvbGxlciA9IF9kZXJlcV8oOCk7XG5cbnZhciBfYnVmZmVyQ29udHJvbGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9idWZmZXJDb250cm9sbGVyKTtcblxudmFyIF9jYXBMZXZlbENvbnRyb2xsZXIgPSBfZGVyZXFfKDkpO1xuXG52YXIgX2NhcExldmVsQ29udHJvbGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jYXBMZXZlbENvbnRyb2xsZXIpO1xuXG52YXIgX2Zwc0NvbnRyb2xsZXIgPSBfZGVyZXFfKDExKTtcblxudmFyIF9mcHNDb250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Zwc0NvbnRyb2xsZXIpO1xuXG52YXIgX3hockxvYWRlciA9IF9kZXJlcV8oNTUpO1xuXG52YXIgX3hockxvYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF94aHJMb2FkZXIpO1xuXG52YXIgX2F1ZGlvVHJhY2tDb250cm9sbGVyID0gX2RlcmVxXyg3KTtcblxudmFyIF9hdWRpb1RyYWNrQ29udHJvbGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hdWRpb1RyYWNrQ29udHJvbGxlcik7XG5cbnZhciBfYXVkaW9TdHJlYW1Db250cm9sbGVyID0gX2RlcmVxXyg2KTtcblxudmFyIF9hdWRpb1N0cmVhbUNvbnRyb2xsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXVkaW9TdHJlYW1Db250cm9sbGVyKTtcblxudmFyIF9jdWVzID0gX2RlcmVxXyg0OCk7XG5cbnZhciBfY3VlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jdWVzKTtcblxudmFyIF90aW1lbGluZUNvbnRyb2xsZXIgPSBfZGVyZXFfKDE2KTtcblxudmFyIF90aW1lbGluZUNvbnRyb2xsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZWxpbmVDb250cm9sbGVyKTtcblxudmFyIF9zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IF9kZXJlcV8oMTUpO1xuXG52YXIgX3N1YnRpdGxlVHJhY2tDb250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1YnRpdGxlVHJhY2tDb250cm9sbGVyKTtcblxudmFyIF9zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgPSBfZGVyZXFfKDE0KTtcblxudmFyIF9zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VidGl0bGVTdHJlYW1Db250cm9sbGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8jZW5kaWZcblxuLy8jZW5kaWZcblxuLy8jaWYgc3VidGl0bGVcblxuLy9pbXBvcnQgRmV0Y2hMb2FkZXIgZnJvbSAnLi91dGlscy9mZXRjaC1sb2FkZXInO1xuLy8jaWYgYWx0YXVkaW9cbnZhciBobHNEZWZhdWx0Q29uZmlnID0gZXhwb3J0cy5obHNEZWZhdWx0Q29uZmlnID0ge1xuICAgICAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgc3RhcnRQb3NpdGlvbjogLTEsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIGRlZmF1bHRBdWRpb0NvZGVjOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIGRlYnVnOiBmYWxzZSwgLy8gdXNlZCBieSBsb2dnZXJcbiAgICAgIGNhcExldmVsT25GUFNEcm9wOiBmYWxzZSwgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICAgICAgY2FwTGV2ZWxUb1BsYXllclNpemU6IGZhbHNlLCAvLyB1c2VkIGJ5IGNhcC1sZXZlbC1jb250cm9sbGVyXG4gICAgICBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTogMSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgbWF4QnVmZmVyTGVuZ3RoOiAzMCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgbWF4QnVmZmVyU2l6ZTogNjAgKiAxMDAwICogMTAwMCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgbWF4QnVmZmVySG9sZTogMC41LCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBtYXhTZWVrSG9sZTogMiwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgbG93QnVmZmVyV2F0Y2hkb2dQZXJpb2Q6IDAuNSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kOiAzLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBudWRnZU9mZnNldDogMC4xLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBudWRnZU1heFJldHJ5OiAzLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlOiAwLjIsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIGxpdmVTeW5jRHVyYXRpb25Db3VudDogMywgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50OiBJbmZpbml0eSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgbGl2ZVN5bmNEdXJhdGlvbjogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIG1heE1heEJ1ZmZlckxlbmd0aDogNjAwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBlbmFibGVXb3JrZXI6IHRydWUsIC8vIHVzZWQgYnkgZGVtdXhlclxuICAgICAgZW5hYmxlU29mdHdhcmVBRVM6IHRydWUsIC8vIHVzZWQgYnkgZGVjcnlwdGVyXG4gICAgICBtYW5pZmVzdExvYWRpbmdUaW1lT3V0OiAxMDAwMCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgICAgIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5OiAxLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICAgICAgbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTogMTAwMCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgICAgIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gICAgICBzdGFydExldmVsOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgbGV2ZWwtY29udHJvbGxlclxuICAgICAgbGV2ZWxMb2FkaW5nVGltZU91dDogMTAwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gICAgICBsZXZlbExvYWRpbmdNYXhSZXRyeTogNCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgICAgIGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gICAgICBsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICAgICAgZnJhZ0xvYWRpbmdUaW1lT3V0OiAyMDAwMCwgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgICAgIGZyYWdMb2FkaW5nTWF4UmV0cnk6IDYsIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gICAgICBmcmFnTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gICAgICBmcmFnTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gICAgICBmcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ6IDMsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIHN0YXJ0RnJhZ1ByZWZldGNoOiBmYWxzZSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6IDUwMDAsIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgICAgIGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOiAwLjIsIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgICAgIGFwcGVuZEVycm9yTWF4UmV0cnk6IDMsIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgICAgIGxvYWRlcjogX3hockxvYWRlcjIuZGVmYXVsdCxcbiAgICAgIC8vbG9hZGVyOiBGZXRjaExvYWRlcixcbiAgICAgIGZMb2FkZXI6IHVuZGVmaW5lZCxcbiAgICAgIHBMb2FkZXI6IHVuZGVmaW5lZCxcbiAgICAgIHhoclNldHVwOiB1bmRlZmluZWQsXG4gICAgICBmZXRjaFNldHVwOiB1bmRlZmluZWQsXG4gICAgICBhYnJDb250cm9sbGVyOiBfYWJyQ29udHJvbGxlcjIuZGVmYXVsdCxcbiAgICAgIGJ1ZmZlckNvbnRyb2xsZXI6IF9idWZmZXJDb250cm9sbGVyMi5kZWZhdWx0LFxuICAgICAgY2FwTGV2ZWxDb250cm9sbGVyOiBfY2FwTGV2ZWxDb250cm9sbGVyMi5kZWZhdWx0LFxuICAgICAgZnBzQ29udHJvbGxlcjogX2Zwc0NvbnRyb2xsZXIyLmRlZmF1bHQsXG4gICAgICAvLyNpZiBhbHRhdWRpb1xuICAgICAgYXVkaW9TdHJlYW1Db250cm9sbGVyOiBfYXVkaW9TdHJlYW1Db250cm9sbGVyMi5kZWZhdWx0LFxuICAgICAgYXVkaW9UcmFja0NvbnRyb2xsZXI6IF9hdWRpb1RyYWNrQ29udHJvbGxlcjIuZGVmYXVsdCxcbiAgICAgIC8vI2VuZGlmXG4gICAgICAvLyNpZiBzdWJ0aXRsZVxuICAgICAgc3VidGl0bGVTdHJlYW1Db250cm9sbGVyOiBfc3VidGl0bGVTdHJlYW1Db250cm9sbGVyMi5kZWZhdWx0LFxuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXI6IF9zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjIuZGVmYXVsdCxcbiAgICAgIHRpbWVsaW5lQ29udHJvbGxlcjogX3RpbWVsaW5lQ29udHJvbGxlcjIuZGVmYXVsdCxcbiAgICAgIGN1ZUhhbmRsZXI6IF9jdWVzMi5kZWZhdWx0LFxuICAgICAgZW5hYmxlQ0VBNzA4Q2FwdGlvbnM6IHRydWUsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgICAgZW5hYmxlV2ViVlRUOiB0cnVlLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICAgIC8vI2VuZGlmXG4gICAgICBzdHJldGNoU2hvcnRWaWRlb1RyYWNrOiBmYWxzZSwgLy8gdXNlZCBieSBtcDQtcmVtdXhlclxuICAgICAgZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eTogdHJ1ZSwgLy8gdXNlZCBieSB0cy1kZW11eGVyXG4gICAgICBhYnJFd21hRmFzdExpdmU6IDMsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIGFickV3bWFTbG93TGl2ZTogOSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgICAgYWJyRXdtYUZhc3RWb0Q6IDMsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIGFickV3bWFTbG93Vm9EOiA5LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gICAgICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiA1ZTUsIC8vIDUwMCBrYnBzICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gICAgICBhYnJCYW5kV2lkdGhGYWN0b3I6IDAuOTUsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIGFickJhbmRXaWR0aFVwRmFjdG9yOiAwLjcsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIGFick1heFdpdGhSZWFsQml0cmF0ZTogZmFsc2UsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIG1heFN0YXJ2YXRpb25EZWxheTogNCwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgICAgbWF4TG9hZGluZ0RlbGF5OiA0LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gICAgICBtaW5BdXRvQml0cmF0ZTogMCAvLyB1c2VkIGJ5IGhsc1xufTtcblxufSx7XCIxMVwiOjExLFwiMTRcIjoxNCxcIjE1XCI6MTUsXCIxNlwiOjE2LFwiNDhcIjo0OCxcIjVcIjo1LFwiNTVcIjo1NSxcIjZcIjo2LFwiN1wiOjcsXCI4XCI6OCxcIjlcIjo5fV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZXZlbnRIYW5kbGVyID0gX2RlcmVxXygzMik7XG5cbnZhciBfZXZlbnRIYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50SGFuZGxlcik7XG5cbnZhciBfYnVmZmVySGVscGVyID0gX2RlcmVxXygzNSk7XG5cbnZhciBfYnVmZmVySGVscGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1ZmZlckhlbHBlcik7XG5cbnZhciBfZXJyb3JzID0gX2RlcmVxXygzMSk7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbnZhciBfZXdtYUJhbmR3aWR0aEVzdGltYXRvciA9IF9kZXJlcV8oMTApO1xuXG52YXIgX2V3bWFCYW5kd2lkdGhFc3RpbWF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXdtYUJhbmR3aWR0aEVzdGltYXRvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpbXBsZSBBQlIgQ29udHJvbGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIC0gY29tcHV0ZSBuZXh0IGxldmVsIGJhc2VkIG9uIGxhc3QgZnJhZ21lbnQgYncgaGV1cmlzdGljc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIC0gaW1wbGVtZW50IGFuIGFiYW5kb24gcnVsZXMgdHJpZ2dlcmVkIGlmIHdlIGhhdmUgbGVzcyB0aGFuIDIgZnJhZyBidWZmZXJlZCBhbmQgaWYgY29tcHV0ZWQgYncgc2hvd3MgdGhhdCB3ZSByaXNrIGJ1ZmZlciBzdGFsbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBBYnJDb250cm9sbGVyID0gZnVuY3Rpb24gKF9FdmVudEhhbmRsZXIpIHtcbiAgX2luaGVyaXRzKEFickNvbnRyb2xsZXIsIF9FdmVudEhhbmRsZXIpO1xuXG4gIGZ1bmN0aW9uIEFickNvbnRyb2xsZXIoaGxzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFickNvbnRyb2xsZXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEFickNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihBYnJDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBobHMsIF9ldmVudHMyLmRlZmF1bHQuRlJBR19MT0FESU5HLCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfTE9BREVELCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfQlVGRkVSRUQsIF9ldmVudHMyLmRlZmF1bHQuRVJST1IpKTtcblxuICAgIF90aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAwO1xuICAgIF90aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgX3RoaXMuaGxzID0gaGxzO1xuICAgIF90aGlzLm9uQ2hlY2sgPSBfdGhpcy5fYWJhbmRvblJ1bGVzQ2hlY2suYmluZChfdGhpcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFickNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIF9ldmVudEhhbmRsZXIyLmRlZmF1bHQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZyYWdMb2FkaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GcmFnTG9hZGluZyhkYXRhKSB7XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJykge1xuICAgICAgICBpZiAoIXRoaXMudGltZXIpIHtcbiAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbkNoZWNrLCAxMDApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxhenkgaW5pdCBvZiBidyBFc3RpbWF0b3IsIHJhdGlvbmFsZSBpcyB0aGF0IHdlIHVzZSBkaWZmZXJlbnQgcGFyYW1zIGZvciBMaXZlL1ZvRFxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHN0cmVhbSBtYW5pZmVzdCAvIHBsYXlsaXN0IHR5cGUgdG8gaW5zdGFudGlhdGUgaXQuXG4gICAgICAgIGlmICghdGhpcy5fYndFc3RpbWF0b3IpIHtcbiAgICAgICAgICB2YXIgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgICAgIGxldmVsID0gZGF0YS5mcmFnLmxldmVsLFxuICAgICAgICAgICAgICBpc0xpdmUgPSBobHMubGV2ZWxzW2xldmVsXS5kZXRhaWxzLmxpdmUsXG4gICAgICAgICAgICAgIGNvbmZpZyA9IGhscy5jb25maWcsXG4gICAgICAgICAgICAgIGV3bWFGYXN0ID0gdm9pZCAwLFxuICAgICAgICAgICAgICBld21hU2xvdyA9IHZvaWQgMDtcblxuICAgICAgICAgIGlmIChpc0xpdmUpIHtcbiAgICAgICAgICAgIGV3bWFGYXN0ID0gY29uZmlnLmFickV3bWFGYXN0TGl2ZTtcbiAgICAgICAgICAgIGV3bWFTbG93ID0gY29uZmlnLmFickV3bWFTbG93TGl2ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXdtYUZhc3QgPSBjb25maWcuYWJyRXdtYUZhc3RWb0Q7XG4gICAgICAgICAgICBld21hU2xvdyA9IGNvbmZpZy5hYnJFd21hU2xvd1ZvRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fYndFc3RpbWF0b3IgPSBuZXcgX2V3bWFCYW5kd2lkdGhFc3RpbWF0b3IyLmRlZmF1bHQoaGxzLCBld21hU2xvdywgZXdtYUZhc3QsIGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfYWJhbmRvblJ1bGVzQ2hlY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWJhbmRvblJ1bGVzQ2hlY2soKSB7XG4gICAgICAvKlxuICAgICAgICBtb25pdG9yIGZyYWdtZW50IHJldHJpZXZhbCB0aW1lLi4uXG4gICAgICAgIHdlIGNvbXB1dGUgZXhwZWN0ZWQgdGltZSBvZiBhcnJpdmFsIG9mIHRoZSBjb21wbGV0ZSBmcmFnbWVudC5cbiAgICAgICAgd2UgY29tcGFyZSBpdCB0byBleHBlY3RlZCB0aW1lIG9mIGJ1ZmZlciBzdGFydmF0aW9uXG4gICAgICAqL1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgIHYgPSBobHMubWVkaWEsXG4gICAgICAgICAgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQsXG4gICAgICAgICAgbG9hZGVyID0gZnJhZy5sb2FkZXIsXG4gICAgICAgICAgbWluQXV0b0xldmVsID0gaGxzLm1pbkF1dG9MZXZlbDtcblxuICAgICAgLy8gaWYgbG9hZGVyIGhhcyBiZWVuIGRlc3Ryb3llZCBvciBsb2FkaW5nIGhhcyBiZWVuIGFib3J0ZWQsIHN0b3AgdGltZXIgYW5kIHJldHVyblxuICAgICAgaWYgKCFsb2FkZXIgfHwgbG9hZGVyLnN0YXRzICYmIGxvYWRlci5zdGF0cy5hYm9ydGVkKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2ZyYWcgbG9hZGVyIGRlc3Ryb3kgb3IgYWJvcnRlZCwgZGlzYXJtIGFiYW5kb25SdWxlcycpO1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgICAgLyogb25seSBtb25pdG9yIGZyYWcgcmV0cmlldmFsIHRpbWUgaWZcbiAgICAgICh2aWRlbyBub3QgcGF1c2VkIE9SIGZpcnN0IGZyYWdtZW50IGJlaW5nIGxvYWRlZChyZWFkeSBzdGF0ZSA9PT0gSEFWRV9OT1RISU5HID0gMCkpIEFORCBhdXRvc3dpdGNoaW5nIGVuYWJsZWQgQU5EIG5vdCBsb3dlc3QgbGV2ZWwgKD0+IG1lYW5zIHRoYXQgd2UgaGF2ZSBzZXZlcmFsIGxldmVscykgKi9cbiAgICAgIGlmICh2ICYmICghdi5wYXVzZWQgJiYgdi5wbGF5YmFja1JhdGUgIT09IDAgfHwgIXYucmVhZHlTdGF0ZSkgJiYgZnJhZy5hdXRvTGV2ZWwgJiYgZnJhZy5sZXZlbCkge1xuICAgICAgICB2YXIgcmVxdWVzdERlbGF5ID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGF0cy50cmVxdWVzdCxcbiAgICAgICAgICAgIHBsYXliYWNrUmF0ZSA9IE1hdGguYWJzKHYucGxheWJhY2tSYXRlKTtcbiAgICAgICAgLy8gbW9uaXRvciBmcmFnbWVudCBsb2FkIHByb2dyZXNzIGFmdGVyIGhhbGYgb2YgZXhwZWN0ZWQgZnJhZ21lbnQgZHVyYXRpb24sdG8gc3RhYmlsaXplIGJpdHJhdGVcbiAgICAgICAgaWYgKHJlcXVlc3REZWxheSA+IDUwMCAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpIHtcbiAgICAgICAgICB2YXIgbGV2ZWxzID0gaGxzLmxldmVscyxcbiAgICAgICAgICAgICAgbG9hZFJhdGUgPSBNYXRoLm1heCgxLCBzdGF0cy5idyA/IHN0YXRzLmJ3IC8gOCA6IHN0YXRzLmxvYWRlZCAqIDEwMDAgLyByZXF1ZXN0RGVsYXkpLFxuICAgICAgICAgICAgICAvLyBieXRlL3M7IGF0IGxlYXN0IDEgYnl0ZS9zIHRvIGF2b2lkIGRpdmlzaW9uIGJ5IHplcm9cbiAgICAgICAgICAvLyBjb21wdXRlIGV4cGVjdGVkIGZyYWdtZW50IGxlbmd0aCB1c2luZyBmcmFnIGR1cmF0aW9uIGFuZCBsZXZlbCBiaXRyYXRlLiBhbHNvIGVuc3VyZSB0aGF0IGV4cGVjdGVkIGxlbiBpcyBndGUgdGhhbiBhbHJlYWR5IGxvYWRlZCBzaXplXG4gICAgICAgICAgbGV2ZWwgPSBsZXZlbHNbZnJhZy5sZXZlbF0sXG4gICAgICAgICAgICAgIGxldmVsQml0cmF0ZSA9IGxldmVsLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWwucmVhbEJpdHJhdGUsIGxldmVsLmJpdHJhdGUpIDogbGV2ZWwuYml0cmF0ZSxcbiAgICAgICAgICAgICAgZXhwZWN0ZWRMZW4gPSBzdGF0cy50b3RhbCA/IHN0YXRzLnRvdGFsIDogTWF0aC5tYXgoc3RhdHMubG9hZGVkLCBNYXRoLnJvdW5kKGZyYWcuZHVyYXRpb24gKiBsZXZlbEJpdHJhdGUgLyA4KSksXG4gICAgICAgICAgICAgIHBvcyA9IHYuY3VycmVudFRpbWUsXG4gICAgICAgICAgICAgIGZyYWdMb2FkZWREZWxheSA9IChleHBlY3RlZExlbiAtIHN0YXRzLmxvYWRlZCkgLyBsb2FkUmF0ZSxcbiAgICAgICAgICAgICAgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gKF9idWZmZXJIZWxwZXIyLmRlZmF1bHQuYnVmZmVySW5mbyh2LCBwb3MsIGhscy5jb25maWcubWF4QnVmZmVySG9sZSkuZW5kIC0gcG9zKSAvIHBsYXliYWNrUmF0ZTtcbiAgICAgICAgICAvLyBjb25zaWRlciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb25seSBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgQU5EXG4gICAgICAgICAgLy8gdGltZSB0byBmaW5pc2ggbG9hZGluZyBjdXJyZW50IGZyYWdtZW50IGlzIGJpZ2dlciB0aGFuIGJ1ZmZlciBzdGFydmF0aW9uIGRlbGF5XG4gICAgICAgICAgLy8gaWUgaWYgd2UgcmlzayBidWZmZXIgc3RhcnZhdGlvbiBpZiBidyBkb2VzIG5vdCBpbmNyZWFzZSBxdWlja2x5XG4gICAgICAgICAgaWYgKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA8IDIgKiBmcmFnLmR1cmF0aW9uIC8gcGxheWJhY2tSYXRlICYmIGZyYWdMb2FkZWREZWxheSA+IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgICAgICAgdmFyIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBuZXh0TG9hZExldmVsID0gdm9pZCAwO1xuICAgICAgICAgICAgLy8gbGV0cyBpdGVyYXRlIHRocm91Z2ggbG93ZXIgbGV2ZWwgYW5kIHRyeSB0byBmaW5kIHRoZSBiaWdnZXN0IG9uZSB0aGF0IGNvdWxkIGF2b2lkIHJlYnVmZmVyaW5nXG4gICAgICAgICAgICAvLyB3ZSBzdGFydCBmcm9tIGN1cnJlbnQgbGV2ZWwgLSAxIGFuZCB3ZSBzdGVwIGRvd24gLCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2hpbmcgbGV2ZWxcbiAgICAgICAgICAgIGZvciAobmV4dExvYWRMZXZlbCA9IGZyYWcubGV2ZWwgLSAxOyBuZXh0TG9hZExldmVsID4gbWluQXV0b0xldmVsOyBuZXh0TG9hZExldmVsLS0pIHtcbiAgICAgICAgICAgICAgLy8gY29tcHV0ZSB0aW1lIHRvIGxvYWQgbmV4dCBmcmFnbWVudCBhdCBsb3dlciBsZXZlbFxuICAgICAgICAgICAgICAvLyAwLjggOiBjb25zaWRlciBvbmx5IDgwJSBvZiBjdXJyZW50IGJ3IHRvIGJlIGNvbnNlcnZhdGl2ZVxuICAgICAgICAgICAgICAvLyA4ID0gYml0cyBwZXIgYnl0ZSAoYnBzL0JwcylcbiAgICAgICAgICAgICAgdmFyIGxldmVsTmV4dEJpdHJhdGUgPSBsZXZlbHNbbmV4dExvYWRMZXZlbF0ucmVhbEJpdHJhdGUgPyBNYXRoLm1heChsZXZlbHNbbmV4dExvYWRMZXZlbF0ucmVhbEJpdHJhdGUsIGxldmVsc1tuZXh0TG9hZExldmVsXS5iaXRyYXRlKSA6IGxldmVsc1tuZXh0TG9hZExldmVsXS5iaXRyYXRlO1xuICAgICAgICAgICAgICBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPSBmcmFnLmR1cmF0aW9uICogbGV2ZWxOZXh0Qml0cmF0ZSAvICg4ICogMC44ICogbG9hZFJhdGUpO1xuICAgICAgICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgZm91bmQgYSBsb3dlciBsZXZlbCB0aGF0IGJlIHJlYnVmZmVyaW5nIGZyZWUgd2l0aCBjdXJyZW50IGVzdGltYXRlZCBidyAhXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9ubHkgZW1lcmdlbmN5IHN3aXRjaCBkb3duIGlmIGl0IHRha2VzIGxlc3MgdGltZSB0byBsb2FkIG5ldyBmcmFnbWVudCBhdCBsb3dlc3QgbGV2ZWwgaW5zdGVhZFxuICAgICAgICAgICAgLy8gb2YgZmluaXNoaW5nIGxvYWRpbmcgY3VycmVudCBvbmUgLi4uXG4gICAgICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgZnJhZ0xvYWRlZERlbGF5KSB7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2xvYWRpbmcgdG9vIHNsb3csIGFib3J0IGZyYWdtZW50IGxvYWRpbmcgYW5kIHN3aXRjaCB0byBsZXZlbCAnICsgbmV4dExvYWRMZXZlbCArICc6ZnJhZ0xvYWRlZERlbGF5WycgKyBuZXh0TG9hZExldmVsICsgJ108ZnJhZ0xvYWRlZERlbGF5WycgKyAoZnJhZy5sZXZlbCAtIDEpICsgJ107YnVmZmVyU3RhcnZhdGlvbkRlbGF5OicgKyBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkudG9GaXhlZCgxKSArICc8JyArIGZyYWdMb2FkZWREZWxheS50b0ZpeGVkKDEpICsgJzonICsgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LnRvRml4ZWQoMSkpO1xuICAgICAgICAgICAgICAvLyBmb3JjZSBuZXh0IGxvYWQgbGV2ZWwgaW4gYXV0byBtb2RlXG4gICAgICAgICAgICAgIGhscy5uZXh0TG9hZExldmVsID0gbmV4dExvYWRMZXZlbDtcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIGJ3IGVzdGltYXRlIGZvciB0aGlzIGZyYWdtZW50IGJlZm9yZSBjYW5jZWxsaW5nIGxvYWQgKHRoaXMgd2lsbCBoZWxwIHJlZHVjaW5nIHRoZSBidylcbiAgICAgICAgICAgICAgdGhpcy5fYndFc3RpbWF0b3Iuc2FtcGxlKHJlcXVlc3REZWxheSwgc3RhdHMubG9hZGVkKTtcbiAgICAgICAgICAgICAgLy9hYm9ydCBmcmFnbWVudCBsb2FkaW5nXG4gICAgICAgICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAvLyBzdG9wIGFiYW5kb24gcnVsZXMgdGltZXJcbiAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB7IGZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0cyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZyYWdMb2FkZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZyYWdMb2FkZWQoZGF0YSkge1xuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicgJiYgIWlzTmFOKGZyYWcuc24pKSB7XG4gICAgICAgIC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAvLyBzdG9yZSBsZXZlbCBpZCBhZnRlciBzdWNjZXNzZnVsIGZyYWdtZW50IGxvYWRcbiAgICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDtcbiAgICAgICAgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgbGV2ZWwgYXZlcmFnZSBiaXRyYXRlXG4gICAgICAgIGlmICh0aGlzLmhscy5jb25maWcuYWJyTWF4V2l0aFJlYWxCaXRyYXRlKSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgICAgIHZhciBsb2FkZWRCeXRlcyA9IChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuYnl0ZXMgOiAwKSArIGRhdGEuc3RhdHMubG9hZGVkO1xuICAgICAgICAgIHZhciBsb2FkZWREdXJhdGlvbiA9IChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuZHVyYXRpb24gOiAwKSArIGRhdGEuZnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICBsZXZlbC5sb2FkZWQgPSB7IGJ5dGVzOiBsb2FkZWRCeXRlcywgZHVyYXRpb246IGxvYWRlZER1cmF0aW9uIH07XG4gICAgICAgICAgbGV2ZWwucmVhbEJpdHJhdGUgPSBNYXRoLnJvdW5kKDggKiBsb2FkZWRCeXRlcyAvIGxvYWRlZER1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCxcbiAgICAgICAgaWYgKGRhdGEuZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgICAgIHZhciBzdGF0cyA9IGRhdGEuc3RhdHM7XG4gICAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHN0YXRzLnRsb2FkO1xuICAgICAgICAgIHRoaXMub25GcmFnQnVmZmVyZWQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZyYWdCdWZmZXJlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRnJhZ0J1ZmZlcmVkKGRhdGEpIHtcbiAgICAgIHZhciBzdGF0cyA9IGRhdGEuc3RhdHMsXG4gICAgICAgICAgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgIC8vIG9ubHkgdXBkYXRlIHN0YXRzIG9uIGZpcnN0IGZyYWcgYnVmZmVyaW5nXG4gICAgICAvLyBpZiBzYW1lIGZyYWcgaXMgbG9hZGVkIG11bHRpcGxlIHRpbWVzLCBpdCBtaWdodCBiZSBpbiBicm93c2VyIGNhY2hlLCBhbmQgbG9hZGVkIHF1aWNrbHlcbiAgICAgIC8vIGFuZCBsZWFkaW5nIHRvIHdyb25nIGJ3IGVzdGltYXRpb25cbiAgICAgIC8vIG9uIGJpdHJhdGUgdGVzdCwgYWxzbyBvbmx5IHVwZGF0ZSBzdGF0cyBvbmNlIChpZiB0bG9hZCA9IHRidWZmZXJlZCA9PSBvbiBGUkFHX0xPQURFRClcbiAgICAgIGlmIChzdGF0cy5hYm9ydGVkICE9PSB0cnVlICYmIGZyYWcubG9hZENvdW50ZXIgPT09IDEgJiYgZnJhZy50eXBlID09PSAnbWFpbicgJiYgIWlzTmFOKGZyYWcuc24pICYmICghZnJhZy5iaXRyYXRlVGVzdCB8fCBzdGF0cy50bG9hZCA9PT0gc3RhdHMudGJ1ZmZlcmVkKSkge1xuICAgICAgICAvLyB1c2UgdHBhcnNlZC10cmVxdWVzdCBpbnN0ZWFkIG9mIHRidWZmZXJlZC10cmVxdWVzdCB0byBjb21wdXRlIGZyYWdMb2FkaW5nUHJvY2Vzc2luZzsgcmF0aW9uYWxlIGlzIHRoYXQgIGJ1ZmZlciBhcHBlbmRpbmcgb25seSBoYXBwZW5zIG9uY2UgbWVkaWEgaXMgYXR0YWNoZWRcbiAgICAgICAgLy8gaW4gY2FzZSB3ZSB1c2UgY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoIHdoaWxlIG1lZGlhIGlzIG5vdCBhdHRhY2hlZCB5ZXQsIGZyYWdtZW50IG1pZ2h0IGJlIHBhcnNlZCB3aGlsZSBtZWRpYSBub3QgYXR0YWNoZWQgeWV0LCBidXQgaXQgd2lsbCBvbmx5IGJlIGJ1ZmZlcmVkIG9uIG1lZGlhIGF0dGFjaGVkXG4gICAgICAgIC8vIGFzIGEgY29uc2VxdWVuY2UgaXQgY291bGQgaGFwcGVuIHJlYWxseSBsYXRlIGluIHRoZSBwcm9jZXNzLiBtZWFuaW5nIHRoYXQgYXBwZW5kaW5nIGR1cmF0aW9uIG1pZ2h0IGFwcGVhcnMgaHVnZSAuLi4gbGVhZGluZyB0byB1bmRlcmVzdGltYXRlZCB0aHJvdWdocHV0IGVzdGltYXRpb25cbiAgICAgICAgdmFyIGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zID0gc3RhdHMudHBhcnNlZCAtIHN0YXRzLnRyZXF1ZXN0O1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2xhdGVuY3kvbG9hZGluZy9wYXJzaW5nL2FwcGVuZC9rYnBzOicgKyBNYXRoLnJvdW5kKHN0YXRzLnRmaXJzdCAtIHN0YXRzLnRyZXF1ZXN0KSArICcvJyArIE1hdGgucm91bmQoc3RhdHMudGxvYWQgLSBzdGF0cy50Zmlyc3QpICsgJy8nICsgTWF0aC5yb3VuZChzdGF0cy50cGFyc2VkIC0gc3RhdHMudGxvYWQpICsgJy8nICsgTWF0aC5yb3VuZChzdGF0cy50YnVmZmVyZWQgLSBzdGF0cy50cGFyc2VkKSArICcvJyArIE1hdGgucm91bmQoOCAqIHN0YXRzLmxvYWRlZCAvIChzdGF0cy50YnVmZmVyZWQgLSBzdGF0cy50cmVxdWVzdCkpKTtcbiAgICAgICAgdGhpcy5fYndFc3RpbWF0b3Iuc2FtcGxlKGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zLCBzdGF0cy5sb2FkZWQpO1xuICAgICAgICAvLyBpZiBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCwgKGhscy5zdGFydExldmVsID0gLTEpLCBzdG9yZSBiaXRyYXRlIHRlc3QgZGVsYXkgZHVyYXRpb25cbiAgICAgICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSBmcmFnTG9hZGluZ1Byb2Nlc3NpbmdNcyAvIDEwMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVycm9yKGRhdGEpIHtcbiAgICAgIC8vIHN0b3AgdGltZXIgaW4gY2FzZSBvZiBmcmFnIGxvYWRpbmcgZXJyb3JcbiAgICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgX2Vycm9ycy5FcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NsZWFyVGltZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclRpbWVyKCkge1xuICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIG5leHQgYXV0byBsZXZlbFxuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmluZEJlc3RMZXZlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQmVzdExldmVsKGN1cnJlbnRMZXZlbCwgY3VycmVudEZyYWdEdXJhdGlvbiwgY3VycmVudEJ3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgbWF4RmV0Y2hEdXJhdGlvbiwgYndGYWN0b3IsIGJ3VXBGYWN0b3IsIGxldmVscykge1xuICAgICAgZm9yICh2YXIgaSA9IG1heEF1dG9MZXZlbDsgaSA+PSBtaW5BdXRvTGV2ZWw7IGktLSkge1xuICAgICAgICB2YXIgbGV2ZWxJbmZvID0gbGV2ZWxzW2ldLFxuICAgICAgICAgICAgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHMsXG4gICAgICAgICAgICBhdmdEdXJhdGlvbiA9IGxldmVsRGV0YWlscyA/IGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uIC8gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggOiBjdXJyZW50RnJhZ0R1cmF0aW9uLFxuICAgICAgICAgICAgbGl2ZSA9IGxldmVsRGV0YWlscyA/IGxldmVsRGV0YWlscy5saXZlIDogZmFsc2UsXG4gICAgICAgICAgICBhZGp1c3RlZGJ3ID0gdm9pZCAwO1xuICAgICAgICAvLyBmb2xsb3cgYWxnb3JpdGhtIGNhcHR1cmVkIGZyb20gc3RhZ2VmcmlnaHQgOlxuICAgICAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2F2LysvbWFzdGVyL21lZGlhL2xpYnN0YWdlZnJpZ2h0L2h0dHBsaXZlL0xpdmVTZXNzaW9uLmNwcFxuICAgICAgICAvLyBQaWNrIHRoZSBoaWdoZXN0IGJhbmR3aWR0aCBzdHJlYW0gYmVsb3cgb3IgZXF1YWwgdG8gZXN0aW1hdGVkIGJhbmR3aWR0aC5cbiAgICAgICAgLy8gY29uc2lkZXIgb25seSA4MCUgb2YgdGhlIGF2YWlsYWJsZSBiYW5kd2lkdGgsIGJ1dCBpZiB3ZSBhcmUgc3dpdGNoaW5nIHVwLFxuICAgICAgICAvLyBiZSBldmVuIG1vcmUgY29uc2VydmF0aXZlICg3MCUpIHRvIGF2b2lkIG92ZXJlc3RpbWF0aW5nIGFuZCBpbW1lZGlhdGVseVxuICAgICAgICAvLyBzd2l0Y2hpbmcgYmFjay5cbiAgICAgICAgaWYgKGkgPD0gY3VycmVudExldmVsKSB7XG4gICAgICAgICAgYWRqdXN0ZWRidyA9IGJ3RmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkanVzdGVkYncgPSBid1VwRmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaXRyYXRlID0gbGV2ZWxzW2ldLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWxzW2ldLnJlYWxCaXRyYXRlLCBsZXZlbHNbaV0uYml0cmF0ZSkgOiBsZXZlbHNbaV0uYml0cmF0ZSxcbiAgICAgICAgICAgIGZldGNoRHVyYXRpb24gPSBiaXRyYXRlICogYXZnRHVyYXRpb24gLyBhZGp1c3RlZGJ3O1xuXG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLnRyYWNlKCdsZXZlbC9hZGp1c3RlZGJ3L2JpdHJhdGUvYXZnRHVyYXRpb24vbWF4RmV0Y2hEdXJhdGlvbi9mZXRjaER1cmF0aW9uOiAnICsgaSArICcvJyArIE1hdGgucm91bmQoYWRqdXN0ZWRidykgKyAnLycgKyBiaXRyYXRlICsgJy8nICsgYXZnRHVyYXRpb24gKyAnLycgKyBtYXhGZXRjaER1cmF0aW9uICsgJy8nICsgZmV0Y2hEdXJhdGlvbik7XG4gICAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgICBpZiAoYWRqdXN0ZWRidyA+IGJpdHJhdGUgJiYgKFxuICAgICAgICAvLyBmcmFnbWVudCBmZXRjaER1cmF0aW9uIHVua25vd24gT1IgbGl2ZSBzdHJlYW0gT1IgZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiBsZXNzIHRoYW4gbWF4IGFsbG93ZWQgZmV0Y2ggZHVyYXRpb24sIHRoZW4gdGhpcyBsZXZlbCBtYXRjaGVzXG4gICAgICAgIC8vIHdlIGRvbid0IGFjY291bnQgZm9yIG1heCBGZXRjaCBEdXJhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zLCB0aGlzIGlzIHRvIGF2b2lkIHN3aXRjaGluZyBkb3duIHdoZW4gbmVhciB0aGUgZWRnZSBvZiBsaXZlIHNsaWRpbmcgd2luZG93IC4uLlxuICAgICAgICAhZmV0Y2hEdXJhdGlvbiB8fCBsaXZlIHx8IGZldGNoRHVyYXRpb24gPCBtYXhGZXRjaER1cmF0aW9uKSkge1xuICAgICAgICAgIC8vIGFzIHdlIGFyZSBsb29waW5nIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGJlc3QgYWNoaWV2YWJsZSBxdWFsaXR5IGxldmVsXG5cbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gbm90IGVub3VnaCB0aW1lIGJ1ZGdldCBldmVuIHdpdGggcXVhbGl0eSBsZXZlbCAwIC4uLiByZWJ1ZmZlcmluZyBtaWdodCBoYXBwZW5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduZXh0QXV0b0xldmVsJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBmb3JjZWRBdXRvTGV2ZWwgPSB0aGlzLl9uZXh0QXV0b0xldmVsO1xuICAgICAgdmFyIGJ3RXN0aW1hdG9yID0gdGhpcy5fYndFc3RpbWF0b3I7XG4gICAgICAvLyBpbiBjYXNlIG5leHQgYXV0byBsZXZlbCBoYXMgYmVlbiBmb3JjZWQsIGFuZCBidyBub3QgYXZhaWxhYmxlIG9yIG5vdCByZWxpYWJsZSwgcmV0dXJuIGZvcmNlZCB2YWx1ZVxuICAgICAgaWYgKGZvcmNlZEF1dG9MZXZlbCAhPT0gLTEgJiYgKCFid0VzdGltYXRvciB8fCAhYndFc3RpbWF0b3IuY2FuRXN0aW1hdGUoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICAgIH1cbiAgICAgIC8vIGNvbXB1dGUgbmV4dCBsZXZlbCB1c2luZyBBQlIgbG9naWNcbiAgICAgIHZhciBuZXh0QUJSQXV0b0xldmVsID0gdGhpcy5fbmV4dEFCUkF1dG9MZXZlbDtcbiAgICAgIC8vIGlmIGZvcmNlZCBhdXRvIGxldmVsIGhhcyBiZWVuIGRlZmluZWQsIHVzZSBpdCB0byBjYXAgQUJSIGNvbXB1dGVkIHF1YWxpdHkgbGV2ZWxcbiAgICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICAgIG5leHRBQlJBdXRvTGV2ZWwgPSBNYXRoLm1pbihmb3JjZWRBdXRvTGV2ZWwsIG5leHRBQlJBdXRvTGV2ZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHRBQlJBdXRvTGV2ZWw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXh0TGV2ZWwpIHtcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX25leHRBQlJBdXRvTGV2ZWwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgIG1heEF1dG9MZXZlbCA9IGhscy5tYXhBdXRvTGV2ZWwsXG4gICAgICAgICAgbGV2ZWxzID0gaGxzLmxldmVscyxcbiAgICAgICAgICBjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgICAgIG1pbkF1dG9MZXZlbCA9IGhscy5taW5BdXRvTGV2ZWw7XG4gICAgICB2YXIgdiA9IGhscy5tZWRpYSxcbiAgICAgICAgICBjdXJyZW50TGV2ZWwgPSB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwsXG4gICAgICAgICAgY3VycmVudEZyYWdEdXJhdGlvbiA9IHRoaXMuZnJhZ0N1cnJlbnQgPyB0aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uIDogMCxcbiAgICAgICAgICBwb3MgPSB2ID8gdi5jdXJyZW50VGltZSA6IDAsXG5cbiAgICAgIC8vIHBsYXliYWNrUmF0ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIHBsYXliYWNrIHJhdGU7IGlmIHYucGxheWJhY2tSYXRlIGlzIDAsIHdlIHVzZSAxIHRvIGxvYWQgYXNcbiAgICAgIC8vIGlmIHdlJ3JlIHBsYXlpbmcgYmFjayBhdCB0aGUgbm9ybWFsIHJhdGUuXG4gICAgICBwbGF5YmFja1JhdGUgPSB2ICYmIHYucGxheWJhY2tSYXRlICE9PSAwID8gTWF0aC5hYnModi5wbGF5YmFja1JhdGUpIDogMS4wLFxuICAgICAgICAgIGF2Z2J3ID0gdGhpcy5fYndFc3RpbWF0b3IgPyB0aGlzLl9id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpIDogY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUsXG5cbiAgICAgIC8vIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSBpcyB0aGUgd2FsbC1jbG9jayB0aW1lIGxlZnQgdW50aWwgdGhlIHBsYXliYWNrIGJ1ZmZlciBpcyBleGhhdXN0ZWQuXG4gICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoX2J1ZmZlckhlbHBlcjIuZGVmYXVsdC5idWZmZXJJbmZvKHYsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLmVuZCAtIHBvcykgLyBwbGF5YmFja1JhdGU7XG5cbiAgICAgIC8vIEZpcnN0LCBsb29rIHRvIHNlZSBpZiB3ZSBjYW4gZmluZCBhIGxldmVsIG1hdGNoaW5nIHdpdGggb3VyIGF2ZyBiYW5kd2lkdGggQU5EIHRoYXQgY291bGQgYWxzbyBndWFyYW50ZWUgbm8gcmVidWZmZXJpbmcgYXQgYWxsXG4gICAgICB2YXIgYmVzdExldmVsID0gdGhpcy5fZmluZEJlc3RMZXZlbChjdXJyZW50TGV2ZWwsIGN1cnJlbnRGcmFnRHVyYXRpb24sIGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LCBjb25maWcuYWJyQmFuZFdpZHRoRmFjdG9yLCBjb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3IsIGxldmVscyk7XG4gICAgICBpZiAoYmVzdExldmVsID49IDApIHtcbiAgICAgICAgcmV0dXJuIGJlc3RMZXZlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLnRyYWNlKCdyZWJ1ZmZlcmluZyBleHBlY3RlZCB0byBoYXBwZW4sIGxldHMgdHJ5IHRvIGZpbmQgYSBxdWFsaXR5IGxldmVsIG1pbmltaXppbmcgdGhlIHJlYnVmZmVyaW5nJyk7XG4gICAgICAgIC8vIG5vdCBwb3NzaWJsZSB0byBnZXQgcmlkIG9mIHJlYnVmZmVyaW5nIC4uLiBsZXQncyB0cnkgdG8gZmluZCBsZXZlbCB0aGF0IHdpbGwgZ3VhcmFudGVlIGxlc3MgdGhhbiBtYXhTdGFydmF0aW9uRGVsYXkgb2YgcmVidWZmZXJpbmdcbiAgICAgICAgLy8gaWYgbm8gbWF0Y2hpbmcgbGV2ZWwgZm91bmQsIGxvZ2ljIHdpbGwgcmV0dXJuIDBcbiAgICAgICAgdmFyIG1heFN0YXJ2YXRpb25EZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5KSA6IGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXksXG4gICAgICAgICAgICBid0ZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IsXG4gICAgICAgICAgICBid1VwRmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yO1xuICAgICAgICBpZiAoYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBidWZmZXIgaXMgZW1wdHksIGxldCdzIGNoZWNrIGlmIHByZXZpb3VzIGZyYWdtZW50IHdhcyBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdFxuICAgICAgICAgIHZhciBiaXRyYXRlVGVzdERlbGF5ID0gdGhpcy5iaXRyYXRlVGVzdERlbGF5O1xuICAgICAgICAgIGlmIChiaXRyYXRlVGVzdERlbGF5KSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyB0aGUgY2FzZSwgdGhlbiB3ZSBuZWVkIHRvIGFkanVzdCBvdXIgbWF4IHN0YXJ2YXRpb24gZGVsYXkgdXNpbmcgbWF4TG9hZGluZ0RlbGF5IGNvbmZpZyB2YWx1ZVxuICAgICAgICAgICAgLy8gbWF4IHZpZGVvIGxvYWRpbmcgZGVsYXkgdXNlZCBpbiAgYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiA6XG4gICAgICAgICAgICAvLyBpbiB0aGF0IG1vZGUgQUJSIGNvbnRyb2xsZXIgd2lsbCBlbnN1cmUgdGhhdCB2aWRlbyBsb2FkaW5nIHRpbWUgKGllIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmaXJzdCBmcmFnbWVudCBhdCBsb3dlc3QgcXVhbGl0eSBsZXZlbCArXG4gICAgICAgICAgICAvLyB0aGUgdGltZSB0byBmZXRjaCB0aGUgZnJhZ21lbnQgYXQgdGhlIGFwcHJvcHJpYXRlIHF1YWxpdHkgbGV2ZWwgaXMgbGVzcyB0aGFuIGBgYG1heExvYWRpbmdEZWxheWBgYCApXG4gICAgICAgICAgICAvLyBjYXAgbWF4TG9hZGluZ0RlbGF5IGFuZCBlbnN1cmUgaXQgaXMgbm90IGJpZ2dlciAndGhhbiBiaXRyYXRlIHRlc3QnIGZyYWcgZHVyYXRpb25cbiAgICAgICAgICAgIHZhciBtYXhMb2FkaW5nRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heExvYWRpbmdEZWxheSkgOiBjb25maWcubWF4TG9hZGluZ0RlbGF5O1xuICAgICAgICAgICAgbWF4U3RhcnZhdGlvbkRlbGF5ID0gbWF4TG9hZGluZ0RlbGF5IC0gYml0cmF0ZVRlc3REZWxheTtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLnRyYWNlKCdiaXRyYXRlIHRlc3QgdG9vayAnICsgTWF0aC5yb3VuZCgxMDAwICogYml0cmF0ZVRlc3REZWxheSkgKyAnbXMsIHNldCBmaXJzdCBmcmFnbWVudCBtYXggZmV0Y2hEdXJhdGlvbiB0byAnICsgTWF0aC5yb3VuZCgxMDAwICogbWF4U3RhcnZhdGlvbkRlbGF5KSArICcgbXMnKTtcbiAgICAgICAgICAgIC8vIGRvbid0IHVzZSBjb25zZXJ2YXRpdmUgZmFjdG9yIG9uIGJpdHJhdGUgdGVzdFxuICAgICAgICAgICAgYndGYWN0b3IgPSBid1VwRmFjdG9yID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmVzdExldmVsID0gdGhpcy5fZmluZEJlc3RMZXZlbChjdXJyZW50TGV2ZWwsIGN1cnJlbnRGcmFnRHVyYXRpb24sIGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ICsgbWF4U3RhcnZhdGlvbkRlbGF5LCBid0ZhY3RvciwgYndVcEZhY3RvciwgbGV2ZWxzKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGJlc3RMZXZlbCwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFickNvbnRyb2xsZXI7XG59KF9ldmVudEhhbmRsZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBBYnJDb250cm9sbGVyO1xuXG59LHtcIjEwXCI6MTAsXCIzMVwiOjMxLFwiMzJcIjozMixcIjMzXCI6MzMsXCIzNVwiOjM1LFwiNTBcIjo1MH1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfYmluYXJ5U2VhcmNoID0gX2RlcmVxXyg0Nik7XG5cbnZhciBfYmluYXJ5U2VhcmNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpbmFyeVNlYXJjaCk7XG5cbnZhciBfYnVmZmVySGVscGVyID0gX2RlcmVxXygzNSk7XG5cbnZhciBfYnVmZmVySGVscGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1ZmZlckhlbHBlcik7XG5cbnZhciBfZGVtdXhlciA9IF9kZXJlcV8oMjUpO1xuXG52YXIgX2RlbXV4ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVtdXhlcik7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZXZlbnRIYW5kbGVyID0gX2RlcmVxXygzMik7XG5cbnZhciBfZXZlbnRIYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50SGFuZGxlcik7XG5cbnZhciBfbGV2ZWxIZWxwZXIgPSBfZGVyZXFfKDM2KTtcblxudmFyIF9sZXZlbEhlbHBlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sZXZlbEhlbHBlcik7XG5cbnZhciBfdGltZVJhbmdlcyA9IF9kZXJlcV8oNTEpO1xuXG52YXIgX3RpbWVSYW5nZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZVJhbmdlcyk7XG5cbnZhciBfZXJyb3JzID0gX2RlcmVxXygzMSk7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEF1ZGlvIFN0cmVhbSBDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgU3RhdGUgPSB7XG4gIFNUT1BQRUQ6ICdTVE9QUEVEJyxcbiAgU1RBUlRJTkc6ICdTVEFSVElORycsXG4gIElETEU6ICdJRExFJyxcbiAgUEFVU0VEOiAnUEFVU0VEJyxcbiAgS0VZX0xPQURJTkc6ICdLRVlfTE9BRElORycsXG4gIEZSQUdfTE9BRElORzogJ0ZSQUdfTE9BRElORycsXG4gIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICBXQUlUSU5HX1RSQUNLOiAnV0FJVElOR19UUkFDSycsXG4gIFBBUlNJTkc6ICdQQVJTSU5HJyxcbiAgUEFSU0VEOiAnUEFSU0VEJyxcbiAgQlVGRkVSX0ZMVVNISU5HOiAnQlVGRkVSX0ZMVVNISU5HJyxcbiAgRU5ERUQ6ICdFTkRFRCcsXG4gIEVSUk9SOiAnRVJST1InLFxuICBXQUlUSU5HX0lOSVRfUFRTOiAnV0FJVElOR19JTklUX1BUUydcbn07XG5cbnZhciBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0V2ZW50SGFuZGxlcikge1xuICBfaW5oZXJpdHMoQXVkaW9TdHJlYW1Db250cm9sbGVyLCBfRXZlbnRIYW5kbGVyKTtcblxuICBmdW5jdGlvbiBBdWRpb1N0cmVhbUNvbnRyb2xsZXIoaGxzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvU3RyZWFtQ29udHJvbGxlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQXVkaW9TdHJlYW1Db250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQXVkaW9TdHJlYW1Db250cm9sbGVyKSkuY2FsbCh0aGlzLCBobHMsIF9ldmVudHMyLmRlZmF1bHQuTUVESUFfQVRUQUNIRUQsIF9ldmVudHMyLmRlZmF1bHQuTUVESUFfREVUQUNISU5HLCBfZXZlbnRzMi5kZWZhdWx0LkFVRElPX1RSQUNLU19VUERBVEVELCBfZXZlbnRzMi5kZWZhdWx0LkFVRElPX1RSQUNLX1NXSVRDSElORywgX2V2ZW50czIuZGVmYXVsdC5BVURJT19UUkFDS19MT0FERUQsIF9ldmVudHMyLmRlZmF1bHQuS0VZX0xPQURFRCwgX2V2ZW50czIuZGVmYXVsdC5GUkFHX0xPQURFRCwgX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19EQVRBLCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0VELCBfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCBfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9DUkVBVEVELCBfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9BUFBFTkRFRCwgX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfRkxVU0hFRCwgX2V2ZW50czIuZGVmYXVsdC5JTklUX1BUU19GT1VORCkpO1xuXG4gICAgX3RoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICBfdGhpcy5hdWRpb0NvZGVjU3dhcCA9IGZhbHNlO1xuICAgIF90aGlzLnRpY2tzID0gMDtcbiAgICBfdGhpcy5fc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIF90aGlzLm9udGljayA9IF90aGlzLnRpY2suYmluZChfdGhpcyk7XG4gICAgX3RoaXMuaW5pdFBUUyA9IFtdO1xuICAgIF90aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEF1ZGlvU3RyZWFtQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgX2V2ZW50SGFuZGxlcjIuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgfVxuXG4gICAgLy9TaWduYWwgdGhhdCB2aWRlbyBQVFMgd2FzIGZvdW5kXG5cbiAgfSwge1xuICAgIGtleTogJ29uSW5pdFB0c0ZvdW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Jbml0UHRzRm91bmQoZGF0YSkge1xuICAgICAgdmFyIGRlbXV4ZXJJZCA9IGRhdGEuaWQsXG4gICAgICAgICAgY2MgPSBkYXRhLmZyYWcuY2MsXG4gICAgICAgICAgaW5pdFBUUyA9IGRhdGEuaW5pdFBUUztcbiAgICAgIGlmIChkZW11eGVySWQgPT09ICdtYWluJykge1xuICAgICAgICAvL0Fsd2F5cyB1cGRhdGUgdGhlIG5ldyBJTklUIFBUU1xuICAgICAgICAvL0NhbiBjaGFuZ2UgZHVlIGxldmVsIHN3aXRjaFxuICAgICAgICB0aGlzLmluaXRQVFNbY2NdID0gaW5pdFBUUztcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdJbml0UFRTIGZvciBjYzonICsgY2MgKyAnIGZvdW5kIGZyb20gdmlkZW8gdHJhY2s6JyArIGluaXRQVFMpO1xuXG4gICAgICAgIC8vSWYgd2UgYXJlIHdhaXRpbmcgd2UgbmVlZCB0byBkZW11eC9yZW11eCB0aGUgd2FpdGluZyBmcmFnXG4gICAgICAgIC8vV2l0aCB0aGUgbmV3IGluaXRQVFNcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfSU5JVF9QVFMpIHtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3NlbmRpbmcgcGVuZGluZyBhdWRpbyBmcmFnIHRvIGRlbXV4ZXInKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgIC8vV2UgaGF2ZSBhdWRpbyBmcmFnIHdhaXRpbmcgb3IgdmlkZW8gcHRzXG4gICAgICAgICAgLy9MZXQgcHJvY2VzcyBpdFxuICAgICAgICAgIHRoaXMub25GcmFnTG9hZGVkKHRoaXMud2FpdGluZ0ZyYWdtZW50KTtcbiAgICAgICAgICAvL0xldHMgY2xlYW4gdGhlIHdhaXRpbmcgZnJhZ1xuICAgICAgICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0YXJ0TG9hZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7XG4gICAgICBpZiAodGhpcy50cmFja3MpIHtcbiAgICAgICAgdmFyIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9udGljaywgMTAwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnYXVkaW86b3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAJyArIGxhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbiA/IHRoaXMuc3RhcnRQb3NpdGlvbiA6IHN0YXJ0UG9zaXRpb247XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUQVJUSU5HO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0b3BMb2FkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcExvYWQoKSB7XG4gICAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICBpZiAoZnJhZy5sb2FkZXIpIHtcbiAgICAgICAgICBmcmFnLmxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICB0aGlzLnRpY2tzKys7XG4gICAgICBpZiAodGhpcy50aWNrcyA9PT0gMSkge1xuICAgICAgICB0aGlzLmRvVGljaygpO1xuICAgICAgICBpZiAodGhpcy50aWNrcyA+IDEpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMudGljaywgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aWNrcyA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZG9UaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9UaWNrKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBwb3MsXG4gICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgdHJhY2tEZXRhaWxzLFxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgIGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgICAvL2xvZ2dlci5sb2coJ2F1ZGlvU3RyZWFtOicgKyB0aGlzLnN0YXRlKTtcbiAgICAgIHZhciBub3c7XG4gICAgICB2YXIgcmV0cnlEYXRlO1xuICAgICAgdmFyIGlzU2Vla2luZztcblxuICAgICAgdmFyIF9yZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAoX3RoaXMyLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSBTdGF0ZS5FUlJPUjpcbiAgICAgICAgICAvL2Rvbid0IGRvIGFueXRoaW5nIGluIGVycm9yIHN0YXRlIHRvIGF2b2lkIGJyZWFraW5nIGZ1cnRoZXIgLi4uXG4gICAgICAgICAgY2FzZSBTdGF0ZS5QQVVTRUQ6XG4gICAgICAgICAgLy9kb24ndCBkbyBhbnl0aGluZyBpbiBwYXVzZWQgc3RhdGUgZWl0aGVyIC4uLlxuICAgICAgICAgIGNhc2UgU3RhdGUuQlVGRkVSX0ZMVVNISU5HOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBTdGF0ZS5TVEFSVElORzpcbiAgICAgICAgICAgIF90aGlzMi5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICAgICAgICBfdGhpczIubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgU3RhdGUuSURMRTpcbiAgICAgICAgICAgIHZhciB0cmFja3MgPSBfdGhpczIudHJhY2tzO1xuICAgICAgICAgICAgLy8gYXVkaW8gdHJhY2tzIG5vdCByZWNlaXZlZCA9PiBleGl0IGxvb3BcbiAgICAgICAgICAgIGlmICghdHJhY2tzKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORFxuICAgICAgICAgICAgLy8gc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBkaXNhYmxlXG4gICAgICAgICAgICAvLyBleGl0IGxvb3BcbiAgICAgICAgICAgIC8vID0+IGlmIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcbiAgICAgICAgICAgIGlmICghX3RoaXMyLm1lZGlhICYmIChfdGhpczIuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmRcbiAgICAgICAgICAgIC8vICBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG5vdCB5ZXQgbG9hZGVkIGFueSBmcmFnbWVudCwgc3RhcnQgbG9hZGluZyBmcm9tIHN0YXJ0IHBvc2l0aW9uXG4gICAgICAgICAgICBpZiAoX3RoaXMyLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIHBvcyA9IF90aGlzMi5tZWRpYS5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvcyA9IF90aGlzMi5uZXh0TG9hZFBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1lZGlhID0gX3RoaXMyLm1lZGlhQnVmZmVyID8gX3RoaXMyLm1lZGlhQnVmZmVyIDogX3RoaXMyLm1lZGlhLFxuICAgICAgICAgICAgICAgIGJ1ZmZlckluZm8gPSBfYnVmZmVySGVscGVyMi5kZWZhdWx0LmJ1ZmZlckluZm8obWVkaWEsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLFxuICAgICAgICAgICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuLFxuICAgICAgICAgICAgICAgIGJ1ZmZlckVuZCA9IGJ1ZmZlckluZm8uZW5kLFxuICAgICAgICAgICAgICAgIGZyYWdQcmV2aW91cyA9IF90aGlzMi5mcmFnUHJldmlvdXMsXG4gICAgICAgICAgICAgICAgbWF4QnVmTGVuID0gY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCxcbiAgICAgICAgICAgICAgICBhdWRpb1N3aXRjaCA9IF90aGlzMi5hdWRpb1N3aXRjaCxcbiAgICAgICAgICAgICAgICB0cmFja0lkID0gX3RoaXMyLnRyYWNrSWQ7XG5cbiAgICAgICAgICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxuICAgICAgICAgICAgaWYgKGJ1ZmZlckxlbiA8IG1heEJ1ZkxlbiAmJiB0cmFja0lkIDwgdHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0cmFja0RldGFpbHMgPSB0cmFja3NbdHJhY2tJZF0uZGV0YWlscztcbiAgICAgICAgICAgICAgLy8gaWYgdHJhY2sgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciB0cmFjayByZXRyaWV2YWxcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0cmFja0RldGFpbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIHdlIGp1c3QgZ290IGRvbmUgbG9hZGluZyB0aGUgZmluYWwgZnJhZ21lbnQsIGNoZWNrIGlmIHdlIG5lZWQgdG8gZmluYWxpemUgbWVkaWEgc3RyZWFtXG4gICAgICAgICAgICAgIGlmICghYXVkaW9Td2l0Y2ggJiYgIXRyYWNrRGV0YWlscy5saXZlICYmIGZyYWdQcmV2aW91cyAmJiBmcmFnUHJldmlvdXMuc24gPT09IHRyYWNrRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBub3Qgc2Vla2luZyBvciBpZiB3ZSBhcmUgc2Vla2luZyBidXQgZXZlcnl0aGluZyAoYWxtb3N0KSB0aWwgdGhlIGVuZCBpcyBidWZmZXJlZCwgbGV0J3Mgc2lnbmFsIGVvc1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGNvbXBhcmUgZXhhY3RseSBtZWRpYS5kdXJhdGlvbiA9PT0gYnVmZmVySW5mby5lbmQgYXMgdGhlcmUgY291bGQgYmUgc29tZSBzdWJ0bGUgbWVkaWEgZHVyYXRpb24gZGlmZmVyZW5jZSB3aGVuIHN3aXRjaGluZ1xuICAgICAgICAgICAgICAgIC8vIGJldHdlZW4gZGlmZmVyZW50IHJlbmRpdGlvbnMuIHVzaW5nIGhhbGYgZnJhZyBkdXJhdGlvbiBzaG91bGQgaGVscCBjb3BlIHdpdGggdGhlc2UgY2FzZXMuXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpczIubWVkaWEuc2Vla2luZyB8fCBfdGhpczIubWVkaWEuZHVyYXRpb24gLSBidWZmZXJFbmQgPCBmcmFnUHJldmlvdXMuZHVyYXRpb24gLyAyKSB7XG4gICAgICAgICAgICAgICAgICAvLyBGaW5hbGl6ZSB0aGUgbWVkaWEgc3RyZWFtXG4gICAgICAgICAgICAgICAgICBfdGhpczIuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfRU9TLCB7IHR5cGU6ICdhdWRpbycgfSk7XG4gICAgICAgICAgICAgICAgICBfdGhpczIuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgICAgICAgICAgIHZhciBmcmFnbWVudHMgPSB0cmFja0RldGFpbHMuZnJhZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydCxcbiAgICAgICAgICAgICAgICAgIGVuZCA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgZnJhZyA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAvLyBXaGVuIHN3aXRjaGluZyBhdWRpbyB0cmFjaywgcmVsb2FkIGF1ZGlvIGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgIGlmIChhdWRpb1N3aXRjaCkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFja0RldGFpbHMubGl2ZSAmJiAhdHJhY2tEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpb3RyYWNrLCBsaXZlIHN0cmVhbSwgdW5rbm93biBQVFMsbG9hZCBmaXJzdCBmcmFnbWVudCcpO1xuICAgICAgICAgICAgICAgICAgYnVmZmVyRW5kID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYnVmZmVyRW5kID0gcG9zO1xuICAgICAgICAgICAgICAgICAgLy8gaWYgY3VycmVudFRpbWUgKHBvcykgaXMgbGVzcyB0aGFuIGFsdCBhdWRpbyBwbGF5bGlzdCBzdGFydCB0aW1lLCBpdCBtZWFucyB0aGF0IGFsdCBhdWRpbyBpcyBhaGVhZCBvZiBjdXJyZW50VGltZVxuICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5QVFNLbm93biAmJiBwb3MgPCBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBldmVyeXRoaW5nIGlzIGJ1ZmZlcmVkIGZyb20gcG9zIHRvIHN0YXJ0IG9yIGlmIGF1ZGlvIGJ1ZmZlciB1cGZyb250LCBsZXQncyBzZWVrIHRvIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXJJbmZvLmVuZCA+IHN0YXJ0IHx8IGJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdhbHQgYXVkaW8gdHJhY2sgYWhlYWQgb2YgbWFpbiB0cmFjaywgc2VlayB0byBzdGFydCBvZiBhbHQgYXVkaW8gdHJhY2snKTtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpczIubWVkaWEuY3VycmVudFRpbWUgPSBzdGFydCArIDAuMDU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHY6IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5pbml0U2VnbWVudCAmJiAhdHJhY2tEZXRhaWxzLmluaXRTZWdtZW50LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBmcmFnID0gdHJhY2tEZXRhaWxzLmluaXRTZWdtZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGlmIGJ1ZmZlckVuZCBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcbiAgICAgICAgICAgICAgZWxzZSBpZiAoYnVmZmVyRW5kIDw9IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5saXZlICYmIGZyYWcubG9hZElkeCAmJiBmcmFnLmxvYWRJZHggPT09IF90aGlzMi5mcmFnTG9hZElkeCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGxvYWRlZCB0aGlzIGZpcnN0IGZyYWdtZW50LCBhbmQgd2UgYXJlIHN0aWxsIGxhZ2dpbmcgYmVoaW5kIHRoZSBzdGFydCBvZiB0aGUgbGl2ZSBwbGF5bGlzdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBmb3JjZSBzZWVrIHRvIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0QnVmZmVyZWQgPSBidWZmZXJJbmZvLm5leHRTdGFydCA/IGJ1ZmZlckluZm8ubmV4dFN0YXJ0IDogc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbm8gYWx0IGF1ZGlvIGF2YWlsYWJsZSBAY3VycmVudFRpbWU6JyArIF90aGlzMi5tZWRpYS5jdXJyZW50VGltZSArICcsIHNlZWtpbmcgQCcgKyAobmV4dEJ1ZmZlcmVkICsgMC4wNSkpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIubWVkaWEuY3VycmVudFRpbWUgPSBuZXh0QnVmZmVyZWQgKyAwLjA1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHY6IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRGcmFnID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZ05leHQgPSBmcmFnUHJldmlvdXMgPyBmcmFnbWVudHNbZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuICsgMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QgPSBmdW5jdGlvbiBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cbiAgICAgICAgICAgICAgICAgICAgICAvLyBmcmFnWzFdIDogWzEwLDIwXVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cbiAgICAgICAgICAgICAgICAgICAgICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gICAgICAgICAgICAgICAgICAgICAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBsb29rdXAgdG9sZXJhbmNlIHRvIGJlIHNtYWxsIGVub3VnaCB0byBkZXRlY3QgdGhlIGN1cnJlbnQgc2VnbWVudCAtIGVuc3VyZXMgd2UgZG9uJ3Qgc2tpcCBvdmVyIHZlcnkgc21hbGwgc2VnbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlIDw9IGJ1ZmZlckVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgICAgfSAvLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZS5zdGFydCAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyRW5kID4gZW5kIC0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIC8vIFByZWZlciB0aGUgbmV4dCBmcmFnbWVudCBpZiBpdCdzIHdpdGhpbiB0b2xlcmFuY2VcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ05leHQgJiYgIWZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChmcmFnTmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdOZXh0O1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEZyYWcgPSBfYmluYXJ5U2VhcmNoMi5kZWZhdWx0LnNlYXJjaChmcmFnbWVudHMsIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxuICAgICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kRnJhZykge1xuICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBmb3VuZEZyYWc7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBmb3VuZEZyYWcuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdmaW5kIFNOIG1hdGNoaW5nIHdpdGggcG9zOicgKyAgYnVmZmVyRW5kICsgJzonICsgZnJhZy5zbik7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdQcmV2aW91cyAmJiBmcmFnLmxldmVsID09PSBmcmFnUHJldmlvdXMubGV2ZWwgJiYgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5zbiA8IHRyYWNrRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWcuc24gKyAxIC0gdHJhY2tEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ1NOIGp1c3QgbG9hZGVkLCBsb2FkIG5leHQgb25lOiAnICsgZnJhZy5zbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnICAgICAgbG9hZGluZyBmcmFnICcgKyBpICsnLHBvcy9idWZFbmQ6JyArIHBvcy50b0ZpeGVkKDMpICsgJy8nICsgYnVmZmVyRW5kLnRvRml4ZWQoMykpO1xuICAgICAgICAgICAgICAgIGlmIChmcmFnLmRlY3J5cHRkYXRhICYmIGZyYWcuZGVjcnlwdGRhdGEudXJpICE9IG51bGwgJiYgZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdMb2FkaW5nIGtleSBmb3IgJyArIGZyYWcuc24gKyAnIG9mIFsnICsgdHJhY2tEZXRhaWxzLnN0YXJ0U04gKyAnICwnICsgdHJhY2tEZXRhaWxzLmVuZFNOICsgJ10sdHJhY2sgJyArIHRyYWNrSWQpO1xuICAgICAgICAgICAgICAgICAgX3RoaXMyLnN0YXRlID0gU3RhdGUuS0VZX0xPQURJTkc7XG4gICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LktFWV9MT0FESU5HLCB7IGZyYWc6IGZyYWcgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnTG9hZGluZyAnICsgZnJhZy5zbiArICcgb2YgWycgKyB0cmFja0RldGFpbHMuc3RhcnRTTiArICcgLCcgKyB0cmFja0RldGFpbHMuZW5kU04gKyAnXSx0cmFjayAnICsgdHJhY2tJZCArICcsIGN1cnJlbnRUaW1lOicgKyBwb3MgKyAnLGJ1ZmZlckVuZDonICsgYnVmZmVyRW5kLnRvRml4ZWQoMykpO1xuICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgd2UgYXJlIG5vdCByZWxvYWRpbmcgdGhlIHNhbWUgZnJhZ21lbnRzIGluIGxvb3AgLi4uXG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMyLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLmZyYWdMb2FkSWR4Kys7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIuZnJhZ0xvYWRJZHggPSAwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZyYWcubG9hZENvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlcisrO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4VGhyZXNob2xkID0gY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBmcmFnIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkIDMgdGltZXMsIGFuZCBpZiBpdCBoYXMgYmVlbiByZWxvYWRlZCByZWNlbnRseVxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5sb2FkQ291bnRlciA+IG1heFRocmVzaG9sZCAmJiBNYXRoLmFicyhfdGhpczIuZnJhZ0xvYWRJZHggLSBmcmFnLmxvYWRJZHgpIDwgbWF4VGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IGZyYWcgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHY6IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWcubG9hZENvdW50ZXIgPSAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZnJhZy5sb2FkSWR4ID0gX3RoaXMyLmZyYWdMb2FkSWR4O1xuICAgICAgICAgICAgICAgICAgX3RoaXMyLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihmcmFnLnNuKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX0xPQURJTkcsIHsgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19UUkFDSzpcbiAgICAgICAgICAgIHRyYWNrID0gX3RoaXMyLnRyYWNrc1tfdGhpczIudHJhY2tJZF07XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBwbGF5bGlzdCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLmRldGFpbHMpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgICAgICBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIHJldHJ5RGF0ZSA9IF90aGlzMi5yZXRyeURhdGU7XG5cbiAgICAgICAgICAgIG1lZGlhID0gX3RoaXMyLm1lZGlhO1xuICAgICAgICAgICAgaXNTZWVraW5nID0gbWVkaWEgJiYgbWVkaWEuc2Vla2luZztcbiAgICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG5cbiAgICAgICAgICAgIGlmICghcmV0cnlEYXRlIHx8IG5vdyA+PSByZXRyeURhdGUgfHwgaXNTZWVraW5nKSB7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnYXVkaW9TdHJlYW1Db250cm9sbGVyOiByZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZScpO1xuICAgICAgICAgICAgICBfdGhpczIuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTOlxuICAgICAgICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcbiAgICAgICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElORzpcbiAgICAgICAgICBjYXNlIFN0YXRlLlBBUlNJTkc6XG4gICAgICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICAgICAgY2FzZSBTdGF0ZS5FTkRFRDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSgpO1xuXG4gICAgICBpZiAoKHR5cGVvZiBfcmV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihfcmV0KSkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYUF0dGFjaGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGRhdGEpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMub252ZW5kZWQgPSB0aGlzLm9uTWVkaWFFbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgaWYgKHRoaXMudHJhY2tzICYmIGNvbmZpZy5hdXRvU3RhcnRMb2FkKSB7XG4gICAgICAgIHRoaXMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1lZGlhRGV0YWNoaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAobWVkaWEgJiYgbWVkaWEuZW5kZWQpIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc2V0IGZyYWdtZW50IGxvYWRpbmcgY291bnRlciBvbiBNU0UgZGV0YWNoaW5nIHRvIGF2b2lkIHJlcG9ydGluZyBGUkFHX0xPT1BfTE9BRElOR19FUlJPUiBhZnRlciBlcnJvciByZWNvdmVyeVxuICAgICAgdmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzO1xuICAgICAgaWYgKHRyYWNrcykge1xuICAgICAgICAvLyByZXNldCBmcmFnbWVudCBsb2FkIGNvdW50ZXJcbiAgICAgICAgdHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgaWYgKHRyYWNrLmRldGFpbHMpIHtcbiAgICAgICAgICAgIHRyYWNrLmRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgIGZyYWdtZW50LmxvYWRDb3VudGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9udmVuZGVkID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1lZGlhU2Vla2luZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVkaWFTZWVraW5nKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGNoZWNrIGZvciBwb3RlbnRpYWwgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgLy8gYXZvaWQgcmVwb3J0aW5nIGZyYWdtZW50IGxvb3AgbG9hZGluZyBlcnJvciBpbiBjYXNlIHVzZXIgaXMgc2Vla2luZyBzZXZlcmFsIHRpbWVzIG9uIHNhbWUgcG9zaXRpb25cbiAgICAgIGlmICh0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgfVxuICAgICAgLy8gdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1lZGlhRW5kZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lZGlhRW5kZWQoKSB7XG4gICAgICAvLyByZXNldCBzdGFydFBvc2l0aW9uIGFuZCBsYXN0Q3VycmVudFRpbWUgdG8gcmVzdGFydCBwbGF5YmFjayBAIHN0cmVhbSBiZWdpbm5pbmdcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkF1ZGlvVHJhY2tzVXBkYXRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQXVkaW9UcmFja3NVcGRhdGVkKGRhdGEpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnYXVkaW8gdHJhY2tzIHVwZGF0ZWQnKTtcbiAgICAgIHRoaXMudHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZGF0YSkge1xuICAgICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgICAgdmFyIGFsdEF1ZGlvID0gISFkYXRhLnVybDtcbiAgICAgIHRoaXMudHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcblxuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFVU0VEO1xuICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBudWxsO1xuICAgICAgLy8gZGVzdHJveSB1c2VsZXNzIGRlbXV4ZXIgd2hlbiBzd2l0Y2hpbmcgYXVkaW8gdG8gbWFpblxuICAgICAgaWYgKCFhbHRBdWRpbykge1xuICAgICAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzd2l0Y2hpbmcgdG8gYXVkaW8gdHJhY2ssIHN0YXJ0IHRpbWVyIGlmIG5vdCBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vc2hvdWxkIHdlIHN3aXRjaCB0cmFja3MgP1xuICAgICAgaWYgKGFsdEF1ZGlvKSB7XG4gICAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSB0cnVlO1xuICAgICAgICAvL21haW4gYXVkaW8gdHJhY2sgYXJlIGhhbmRsZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXIsIGp1c3QgZG8gc29tZXRoaW5nIGlmIHN3aXRjaGluZyB0byBhbHQgYXVkaW8gdHJhY2tcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXG4gICAgICAgIGlmICh0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQXVkaW9UcmFja0xvYWRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQXVkaW9UcmFja0xvYWRlZChkYXRhKSB7XG4gICAgICB2YXIgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscyxcbiAgICAgICAgICB0cmFja0lkID0gZGF0YS5pZCxcbiAgICAgICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RyYWNrSWRdLFxuICAgICAgICAgIGR1cmF0aW9uID0gbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uLFxuICAgICAgICAgIHNsaWRpbmcgPSAwO1xuXG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3RyYWNrICcgKyB0cmFja0lkICsgJyBsb2FkZWQgWycgKyBuZXdEZXRhaWxzLnN0YXJ0U04gKyAnLCcgKyBuZXdEZXRhaWxzLmVuZFNOICsgJ10sZHVyYXRpb246JyArIGR1cmF0aW9uKTtcblxuICAgICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgICB2YXIgY3VyRGV0YWlscyA9IHRyYWNrLmRldGFpbHM7XG4gICAgICAgIGlmIChjdXJEZXRhaWxzICYmIG5ld0RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyB3ZSBhbHJlYWR5IGhhdmUgZGV0YWlscyBmb3IgdGhhdCBsZXZlbCwgbWVyZ2UgdGhlbVxuICAgICAgICAgIF9sZXZlbEhlbHBlcjIuZGVmYXVsdC5tZXJnZURldGFpbHMoY3VyRGV0YWlscywgbmV3RGV0YWlscyk7XG4gICAgICAgICAgc2xpZGluZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAvL3RoaXMubGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBjdXJEZXRhaWxzKTtcbiAgICAgICAgICBpZiAobmV3RGV0YWlscy5QVFNLbm93bikge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdsaXZlIGF1ZGlvIHBsYXlsaXN0IHNsaWRpbmc6JyArIHNsaWRpbmcudG9GaXhlZCgzKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbGl2ZSBhdWRpbyBwbGF5bGlzdCAtIG91dGRhdGVkIFBUUywgdW5rbm93biBzbGlkaW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdHJhY2suZGV0YWlscyA9IG5ld0RldGFpbHM7XG5cbiAgICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb25cbiAgICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBmaXJzdCwgY2hlY2sgaWYgc3RhcnQgdGltZSBvZmZzZXQgaGFzIGJlZW4gc2V0IGluIHBsYXlsaXN0LCBpZiB5ZXMsIHVzZSB0aGlzIHZhbHVlXG4gICAgICAgICAgdmFyIHN0YXJ0VGltZU9mZnNldCA9IG5ld0RldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgIGlmICghaXNOYU4oc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzdGFydCB0aW1lIG9mZnNldCBmb3VuZCBpbiBwbGF5bGlzdCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gdG8gJyArIHN0YXJ0VGltZU9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIC8vIG9ubHkgc3dpdGNoIGJhdGNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciB0cmFjayB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfVFJBQ0spIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uS2V5TG9hZGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25LZXlMb2FkZWQoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRnJhZ0xvYWRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRnJhZ0xvYWRlZChkYXRhKSB7XG4gICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgICAgIGZyYWdMb2FkZWQgPSBkYXRhLmZyYWc7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HICYmIGZyYWdDdXJyZW50ICYmIGZyYWdMb2FkZWQudHlwZSA9PT0gJ2F1ZGlvJyAmJiBmcmFnTG9hZGVkLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJiBmcmFnTG9hZGVkLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdLFxuICAgICAgICAgICAgZGV0YWlscyA9IHRyYWNrLmRldGFpbHMsXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgICAgIHRyYWNrSWQgPSBmcmFnQ3VycmVudC5sZXZlbCxcbiAgICAgICAgICAgIHNuID0gZnJhZ0N1cnJlbnQuc24sXG4gICAgICAgICAgICBjYyA9IGZyYWdDdXJyZW50LmNjLFxuICAgICAgICAgICAgYXVkaW9Db2RlYyA9IHRoaXMuY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IHRyYWNrLmF1ZGlvQ29kZWMgfHwgJ21wNGEuNDAuMicsXG4gICAgICAgICAgICBzdGF0cyA9IHRoaXMuc3RhdHMgPSBkYXRhLnN0YXRzO1xuICAgICAgICBpZiAoc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcblxuICAgICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgPSBkYXRhLnBheWxvYWQ7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnQ3VycmVudCwgaWQ6ICdhdWRpbycgfSk7XG4gICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XG4gICAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIXRoaXMuZGVtdXhlcikge1xuICAgICAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IF9kZW11eGVyMi5kZWZhdWx0KHRoaXMuaGxzLCAnYXVkaW8nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9DaGVjayBpZiB3ZSBoYXZlIHZpZGVvIGluaXRQVFNcbiAgICAgICAgICAvLyBJZiBub3Qgd2UgbmVlZCB0byB3YWl0IGZvciBpdFxuICAgICAgICAgIHZhciBpbml0UFRTID0gdGhpcy5pbml0UFRTW2NjXTtcbiAgICAgICAgICB2YXIgaW5pdFNlZ21lbnREYXRhID0gZGV0YWlscy5pbml0U2VnbWVudCA/IGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA6IFtdO1xuICAgICAgICAgIGlmIChpbml0U2VnbWVudERhdGEgfHwgaW5pdFBUUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdEZW11eGluZyAnICsgc24gKyAnIG9mIFsnICsgZGV0YWlscy5zdGFydFNOICsgJyAsJyArIGRldGFpbHMuZW5kU04gKyAnXSx0cmFjayAnICsgdHJhY2tJZCk7XG4gICAgICAgICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICAgICAgICAgIHZhciBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBmYWxzZTsgLy9kZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmU7XG4gICAgICAgICAgICB0aGlzLmRlbXV4ZXIucHVzaChkYXRhLnBheWxvYWQsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgbnVsbCwgZnJhZ0N1cnJlbnQsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGluaXRQVFMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3Vua25vd24gdmlkZW8gUFRTIGZvciBjb250aW51aXR5IGNvdW50ZXIgJyArIGNjICsgJywgd2FpdGluZyBmb3IgdmlkZW8gUFRTIGJlZm9yZSBkZW11eGluZyBhdWRpbyBmcmFnICcgKyBzbiArICcgb2YgWycgKyBkZXRhaWxzLnN0YXJ0U04gKyAnICwnICsgZGV0YWlscy5lbmRTTiArICddLHRyYWNrICcgKyB0cmFja0lkKTtcbiAgICAgICAgICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50ID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQoZGF0YSkge1xuICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIHZhciBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgICAgaWYgKGZyYWdDdXJyZW50ICYmIGRhdGEuaWQgPT09ICdhdWRpbycgJiYgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiYgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICB2YXIgdHJhY2tzID0gZGF0YS50cmFja3MsXG4gICAgICAgICAgICB0cmFjayA9IHZvaWQgMDtcblxuICAgICAgICAvLyBkZWxldGUgYW55IHZpZGVvIHRyYWNrIGZvdW5kIG9uIGF1ZGlvIGRlbXV4ZXJcbiAgICAgICAgaWYgKHRyYWNrcy52aWRlbykge1xuICAgICAgICAgIGRlbGV0ZSB0cmFja3MudmlkZW87XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgICB0cmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2F1ZGlvIHRyYWNrOmF1ZGlvLGNvbnRhaW5lcjonICsgdHJhY2suY29udGFpbmVyICsgJyxjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJyArIHRyYWNrLmxldmVsQ29kZWMgKyAnLycgKyB0cmFjay5jb2RlYyArICddJyk7XG4gICAgICAgICAgdmFyIGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgICAgICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICAgICAgICB2YXIgYXBwZW5kT2JqID0geyB0eXBlOiAnYXVkaW8nLCBkYXRhOiBpbml0U2VnbWVudCwgcGFyZW50OiAnYXVkaW8nLCBjb250ZW50OiAnaW5pdFNlZ21lbnQnIH07XG4gICAgICAgICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCkge1xuICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEYXRhID0gW2FwcGVuZE9ial07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9BUFBFTkRJTkcsIGFwcGVuZE9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GcmFnUGFyc2luZ0RhdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZyYWdQYXJzaW5nRGF0YShkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIHZhciBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgICAgaWYgKGZyYWdDdXJyZW50ICYmIGRhdGEuaWQgPT09ICdhdWRpbycgJiYgZGF0YS50eXBlID09PSAnYXVkaW8nICYmIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdHJhY2tJZCA9IF90aGlzMy50cmFja0lkLFxuICAgICAgICAgICAgICB0cmFjayA9IF90aGlzMy50cmFja3NbdHJhY2tJZF0sXG4gICAgICAgICAgICAgIGhscyA9IF90aGlzMy5obHM7XG5cbiAgICAgICAgICBpZiAoaXNOYU4oZGF0YS5lbmRQVFMpKSB7XG4gICAgICAgICAgICBkYXRhLmVuZFBUUyA9IGRhdGEuc3RhcnRQVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgIGRhdGEuZW5kRFRTID0gZGF0YS5zdGFydERUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygncGFyc2VkICcgKyBkYXRhLnR5cGUgKyAnLFBUUzpbJyArIGRhdGEuc3RhcnRQVFMudG9GaXhlZCgzKSArICcsJyArIGRhdGEuZW5kUFRTLnRvRml4ZWQoMykgKyAnXSxEVFM6WycgKyBkYXRhLnN0YXJ0RFRTLnRvRml4ZWQoMykgKyAnLycgKyBkYXRhLmVuZERUUy50b0ZpeGVkKDMpICsgJ10sbmI6JyArIGRhdGEubmIpO1xuICAgICAgICAgIF9sZXZlbEhlbHBlcjIuZGVmYXVsdC51cGRhdGVGcmFnUFRTRFRTKHRyYWNrLmRldGFpbHMsIGZyYWdDdXJyZW50LnNuLCBkYXRhLnN0YXJ0UFRTLCBkYXRhLmVuZFBUUyk7XG5cbiAgICAgICAgICB2YXIgYXVkaW9Td2l0Y2ggPSBfdGhpczMuYXVkaW9Td2l0Y2gsXG4gICAgICAgICAgICAgIG1lZGlhID0gX3RoaXMzLm1lZGlhLFxuICAgICAgICAgICAgICBhcHBlbmRPbkJ1ZmZlckZsdXNoID0gZmFsc2U7XG4gICAgICAgICAgLy9Pbmx5IGZsdXNoIGF1ZGlvIGZyb20gb2xkIGF1ZGlvIHRyYWNrcyB3aGVuIFBUUyBpcyBrbm93biBvbiBuZXcgYXVkaW8gdHJhY2tcbiAgICAgICAgICBpZiAoYXVkaW9Td2l0Y2ggJiYgbWVkaWEpIHtcbiAgICAgICAgICAgIGlmIChtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGN1cnJlbnRUaW1lOicgKyBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA+PSBkYXRhLnN0YXJ0UFRTKSB7XG4gICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzd2l0Y2hpbmcgYXVkaW8gdHJhY2sgOiBmbHVzaGluZyBhbGwgYXVkaW8nKTtcbiAgICAgICAgICAgICAgICBfdGhpczMuc3RhdGUgPSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc7XG4gICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfRkxVU0hJTkcsIHsgc3RhcnRPZmZzZXQ6IDAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlOiAnYXVkaW8nIH0pO1xuICAgICAgICAgICAgICAgIGFwcGVuZE9uQnVmZmVyRmx1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vTGV0cyBhbm5vdW5jZSB0aGF0IHRoZSBpbml0aWFsIGF1ZGlvIHRyYWNrIHN3aXRjaCBmbHVzaCBvY2N1clxuICAgICAgICAgICAgICAgIF90aGlzMy5hdWRpb1N3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHsgaWQ6IHRyYWNrSWQgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vTGV0cyBhbm5vdW5jZSB0aGF0IHRoZSBpbml0aWFsIGF1ZGlvIHRyYWNrIHN3aXRjaCBmbHVzaCBvY2N1clxuICAgICAgICAgICAgICBfdGhpczMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5BVURJT19UUkFDS19TV0lUQ0hFRCwgeyBpZDogdHJhY2tJZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGVuZGluZ0RhdGEgPSBfdGhpczMucGVuZGluZ0RhdGE7XG4gICAgICAgICAgaWYgKCFfdGhpczMuYXVkaW9Td2l0Y2gpIHtcbiAgICAgICAgICAgIFtkYXRhLmRhdGExLCBkYXRhLmRhdGEyXS5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ0RhdGEucHVzaCh7IHR5cGU6IGRhdGEudHlwZSwgZGF0YTogYnVmZmVyLCBwYXJlbnQ6ICdhdWRpbycsIGNvbnRlbnQ6ICdkYXRhJyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWFwcGVuZE9uQnVmZmVyRmx1c2ggJiYgcGVuZGluZ0RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHBlbmRpbmdEYXRhLmZvckVhY2goZnVuY3Rpb24gKGFwcGVuZE9iaikge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgYXBwZW5kIGluIFBBUlNJTkcgc3RhdGUgKHJhdGlvbmFsZSBpcyB0aGF0IGFuIGFwcGVuZGluZyBlcnJvciBjb3VsZCBoYXBwZW4gc3luY2hyb25vdXNseSBvbiBmaXJzdCBzZWdtZW50IGFwcGVuZGluZylcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgaXQgaXMgdXNlbGVzcyB0byBhcHBlbmQgZm9sbG93aW5nIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzMy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgIF90aGlzMy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIF90aGlzMy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9BUFBFTkRJTkcsIGFwcGVuZE9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX3RoaXMzLnBlbmRpbmdEYXRhID0gW107XG4gICAgICAgICAgICAgIF90aGlzMy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgICAgIF90aGlzMy50aWNrKCk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GcmFnUGFyc2VkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GcmFnUGFyc2VkKGRhdGEpIHtcbiAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICB2YXIgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICAgIGlmIChmcmFnQ3VycmVudCAmJiBkYXRhLmlkID09PSAnYXVkaW8nICYmIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgdGhpcy5zdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkJ1ZmZlckNyZWF0ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkJ1ZmZlckNyZWF0ZWQoZGF0YSkge1xuICAgICAgdmFyIGF1ZGlvVHJhY2sgPSBkYXRhLnRyYWNrcy5hdWRpbztcbiAgICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBhdWRpb1RyYWNrLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25CdWZmZXJBcHBlbmRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQnVmZmVyQXBwZW5kZWQoZGF0YSkge1xuICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnYXVkaW8nKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCBzdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIGFwcGVuZGVkXG4gICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gZGF0YS5wZW5kaW5nID4gMDtcbiAgICAgICAgICB0aGlzLl9jaGVja0FwcGVuZGVkUGFyc2VkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfY2hlY2tBcHBlbmRlZFBhcnNlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0FwcGVuZGVkUGFyc2VkKCkge1xuICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEICYmICghdGhpcy5hcHBlbmRlZCB8fCAhdGhpcy5wZW5kaW5nQnVmZmVyaW5nKSkge1xuICAgICAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQsXG4gICAgICAgICAgICBzdGF0cyA9IHRoaXMuc3RhdHMsXG4gICAgICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICAgICAgc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZywgaWQ6ICdhdWRpbycgfSk7XG4gICAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnYXVkaW8gYnVmZmVyZWQgOiAnICsgX3RpbWVSYW5nZXMyLmRlZmF1bHQudG9TdHJpbmcobWVkaWEuYnVmZmVyZWQpKTtcbiAgICAgICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCAmJiB0aGlzLmFwcGVuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7IGlkOiB0aGlzLnRyYWNrSWQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVycm9yKGRhdGEpIHtcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gYXVkaW8gZnJhZ21lbnRcbiAgICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gJ2F1ZGlvJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgICAgICBpZiAoIWRhdGEuZmF0YWwpIHtcbiAgICAgICAgICAgIHZhciBsb2FkRXJyb3IgPSB0aGlzLmZyYWdMb2FkRXJyb3I7XG4gICAgICAgICAgICBpZiAobG9hZEVycm9yKSB7XG4gICAgICAgICAgICAgIGxvYWRFcnJvcisrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9hZEVycm9yID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIGlmIChsb2FkRXJyb3IgPD0gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnkpIHtcbiAgICAgICAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gbG9hZEVycm9yO1xuICAgICAgICAgICAgICAvLyByZXNldCBsb2FkIGNvdW50ZXIgdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3JcbiAgICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlciA9IDA7XG4gICAgICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxuICAgICAgICAgICAgICB2YXIgZGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLCBsb2FkRXJyb3IgLSAxKSAqIGNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCk7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2F1ZGlvU3RyZWFtQ29udHJvbGxlcjogZnJhZyBsb2FkaW5nIGZhaWxlZCwgcmV0cnkgaW4gJyArIGRlbGF5ICsgJyBtcycpO1xuICAgICAgICAgICAgICB0aGlzLnJldHJ5RGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICAgICAgICAgIC8vIHJldHJ5IGxvYWRpbmcgc3RhdGVcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIuZXJyb3IoJ2F1ZGlvU3RyZWFtQ29udHJvbGxlcjogJyArIGRhdGEuZGV0YWlscyArICcgcmVhY2hlcyBtYXggcmV0cnksIHJlZGlzcGF0Y2ggYXMgZmF0YWwgLi4uJyk7XG4gICAgICAgICAgICAgIC8vIHJlZGlzcGF0Y2ggc2FtZSBlcnJvciBidXQgd2l0aCBmYXRhbCBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCBkYXRhKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5GUkFHX0xPT1BfTE9BRElOR19FUlJPUjpcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICAgIC8vICB3aGVuIGluIEVSUk9SIHN0YXRlLCBkb24ndCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIGluIGNhc2UgYSBub24tZmF0YWwgZXJyb3IgaXMgcmVjZWl2ZWRcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgICAgIC8vIGlmIGZhdGFsIGVycm9yLCBzdG9wIHByb2Nlc3NpbmcsIG90aGVyd2lzZSBtb3ZlIHRvIElETEUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGRhdGEuZmF0YWwgPyBTdGF0ZS5FUlJPUiA6IFN0YXRlLklETEU7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdhdWRpb1N0cmVhbUNvbnRyb2xsZXI6ICcgKyBkYXRhLmRldGFpbHMgKyAnIHdoaWxlIGxvYWRpbmcgZnJhZyxzd2l0Y2ggdG8gJyArIHRoaXMuc3RhdGUgKyAnIHN0YXRlIC4uLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgICAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICAgICAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdhdWRpbycgJiYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSkge1xuICAgICAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlcixcbiAgICAgICAgICAgICAgICBjdXJyZW50VGltZSA9IHRoaXMubWVkaWEuY3VycmVudFRpbWUsXG4gICAgICAgICAgICAgICAgbWVkaWFCdWZmZXJlZCA9IG1lZGlhICYmIF9idWZmZXJIZWxwZXIyLmRlZmF1bHQuaXNCdWZmZXJlZChtZWRpYSwgY3VycmVudFRpbWUpICYmIF9idWZmZXJIZWxwZXIyLmRlZmF1bHQuaXNCdWZmZXJlZChtZWRpYSwgY3VycmVudFRpbWUgKyAwLjUpO1xuICAgICAgICAgICAgLy8gcmVkdWNlIG1heCBidWYgbGVuIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWRcbiAgICAgICAgICAgIGlmIChtZWRpYUJ1ZmZlcmVkKSB7XG4gICAgICAgICAgICAgIHZhciBfY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICAgIGlmIChfY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCA+PSBfY29uZmlnLm1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxuICAgICAgICAgICAgICAgIF9jb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoIC89IDI7XG4gICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignYXVkaW86cmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIHRvICcgKyBfY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCArICdzJyk7XG4gICAgICAgICAgICAgICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiBfY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLCBidXQgYnJvd3NlciBpcyBzdGlsbCBjb21wbGFpbmluZyBhYm91dCBidWZmZXIgZnVsbCBlcnJvclxuICAgICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgb24gSUUvRWRnZSwgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL2RhaWx5bW90aW9uL2hscy5qcy9wdWxsLzcwOFxuICAgICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGF1ZGlvIGJ1ZmZlciB0byByZWNvdmVyXG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2J1ZmZlciBmdWxsIGVycm9yIGFsc28gbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBhdWRpbyBidWZmZXInKTtcbiAgICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJVRkZFUl9GTFVTSElORztcbiAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9GTFVTSElORywgeyBzdGFydE9mZnNldDogMCwgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHR5cGU6ICdhdWRpbycgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQnVmZmVyRmx1c2hlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQnVmZmVyRmx1c2hlZCgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgcGVuZGluZ0RhdGEgPSB0aGlzLnBlbmRpbmdEYXRhO1xuICAgICAgaWYgKHBlbmRpbmdEYXRhICYmIHBlbmRpbmdEYXRhLmxlbmd0aCkge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2FwcGVuZGluZyBwZW5kaW5nIGF1ZGlvIGRhdGEgb24gQnVmZmVyIEZsdXNoZWQnKTtcbiAgICAgICAgcGVuZGluZ0RhdGEuZm9yRWFjaChmdW5jdGlvbiAoYXBwZW5kT2JqKSB7XG4gICAgICAgICAgX3RoaXM0Lmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0FQUEVORElORywgYXBwZW5kT2JqKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnBlbmRpbmdEYXRhID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIGZyYWdcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGF0ZScsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV4dFN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnYXVkaW8gc3RyZWFtOicgKyBwcmV2aW91c1N0YXRlICsgJy0+JyArIG5leHRTdGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXVkaW9TdHJlYW1Db250cm9sbGVyO1xufShfZXZlbnRIYW5kbGVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQXVkaW9TdHJlYW1Db250cm9sbGVyO1xuXG59LHtcIjI1XCI6MjUsXCIzMVwiOjMxLFwiMzJcIjozMixcIjMzXCI6MzMsXCIzNVwiOjM1LFwiMzZcIjozNixcIjQ2XCI6NDYsXCI1MFwiOjUwLFwiNTFcIjo1MX1dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V2ZW50cyA9IF9kZXJlcV8oMzMpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX2V2ZW50SGFuZGxlciA9IF9kZXJlcV8oMzIpO1xuXG52YXIgX2V2ZW50SGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudEhhbmRsZXIpO1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBhdWRpbyB0cmFjayBjb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgQXVkaW9UcmFja0NvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0V2ZW50SGFuZGxlcikge1xuICBfaW5oZXJpdHMoQXVkaW9UcmFja0NvbnRyb2xsZXIsIF9FdmVudEhhbmRsZXIpO1xuXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2tDb250cm9sbGVyKGhscykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1RyYWNrQ29udHJvbGxlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQXVkaW9UcmFja0NvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihBdWRpb1RyYWNrQ29udHJvbGxlcikpLmNhbGwodGhpcywgaGxzLCBfZXZlbnRzMi5kZWZhdWx0Lk1BTklGRVNUX0xPQURJTkcsIF9ldmVudHMyLmRlZmF1bHQuTUFOSUZFU1RfTE9BREVELCBfZXZlbnRzMi5kZWZhdWx0LkFVRElPX1RSQUNLX0xPQURFRCkpO1xuXG4gICAgX3RoaXMudGlja3MgPSAwO1xuICAgIF90aGlzLm9udGljayA9IF90aGlzLnRpY2suYmluZChfdGhpcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEF1ZGlvVHJhY2tDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgX2V2ZW50SGFuZGxlcjIuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RpY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgdGhpcy50aWNrcysrO1xuICAgICAgaWYgKHRoaXMudGlja3MgPT09IDEpIHtcbiAgICAgICAgdGhpcy5kb1RpY2soKTtcbiAgICAgICAgaWYgKHRoaXMudGlja3MgPiAxKSB7XG4gICAgICAgICAgc2V0VGltZW91dCh0aGlzLnRpY2ssIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlja3MgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RvVGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvVGljaygpIHtcbiAgICAgIHRoaXMudXBkYXRlVHJhY2sodGhpcy50cmFja0lkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1hbmlmZXN0TG9hZGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgICAgLy8gcmVzZXQgYXVkaW8gdHJhY2tzIG9uIG1hbmlmZXN0IGxvYWRpbmdcbiAgICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1hbmlmZXN0TG9hZGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NYW5pZmVzdExvYWRlZChkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MgfHwgW107XG4gICAgICB2YXIgZGVmYXVsdEZvdW5kID0gZmFsc2U7XG4gICAgICB0aGlzLnRyYWNrcyA9IHRyYWNrcztcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5BVURJT19UUkFDS1NfVVBEQVRFRCwgeyBhdWRpb1RyYWNrczogdHJhY2tzIH0pO1xuICAgICAgLy8gbG9vcCB0aHJvdWdoIGF2YWlsYWJsZSBhdWRpbyB0cmFja3MgYW5kIGF1dG9zZWxlY3QgZGVmYXVsdCBpZiBuZWVkZWRcbiAgICAgIHZhciBpZCA9IDA7XG4gICAgICB0cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgaWYgKHRyYWNrLmRlZmF1bHQpIHtcbiAgICAgICAgICBfdGhpczIuYXVkaW9UcmFjayA9IGlkO1xuICAgICAgICAgIGRlZmF1bHRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlkKys7XG4gICAgICB9KTtcbiAgICAgIGlmIChkZWZhdWx0Rm91bmQgPT09IGZhbHNlICYmIHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdubyBkZWZhdWx0IGF1ZGlvIHRyYWNrIGRlZmluZWQsIHVzZSBmaXJzdCBhdWRpbyB0cmFjayBhcyBkZWZhdWx0Jyk7XG4gICAgICAgIHRoaXMuYXVkaW9UcmFjayA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25BdWRpb1RyYWNrTG9hZGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25BdWRpb1RyYWNrTG9hZGVkKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmlkIDwgdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnYXVkaW9UcmFjayAnICsgZGF0YS5pZCArICcgbG9hZGVkJyk7XG4gICAgICAgIHRoaXMudHJhY2tzW2RhdGEuaWRdLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0XG4gICAgICAgIGlmIChkYXRhLmRldGFpbHMubGl2ZSAmJiAhdGhpcy50aW1lcikge1xuICAgICAgICAgIC8vIGlmIGxpdmUgcGxheWxpc3Qgd2Ugd2lsbCBoYXZlIHRvIHJlbG9hZCBpdCBwZXJpb2RpY2FsbHlcbiAgICAgICAgICAvLyBzZXQgcmVsb2FkIHBlcmlvZCB0byBwbGF5bGlzdCB0YXJnZXQgZHVyYXRpb25cbiAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbnRpY2ssIDEwMDAgKiBkYXRhLmRldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YS5kZXRhaWxzLmxpdmUgJiYgdGhpcy50aW1lcikge1xuICAgICAgICAgIC8vIHBsYXlsaXN0IGlzIG5vdCBsaXZlIGFuZCB0aW1lciBpcyBhcm1lZCA6IHN0b3BwaW5nIGl0XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBnZXQgYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldEF1ZGlvVHJhY2tJbnRlcm5hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF1ZGlvVHJhY2tJbnRlcm5hbChuZXdJZCkge1xuICAgICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgICBpZiAobmV3SWQgPj0gMCAmJiBuZXdJZCA8IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3N3aXRjaGluZyB0byBhdWRpb1RyYWNrICcgKyBuZXdJZCk7XG4gICAgICAgIHZhciBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdLFxuICAgICAgICAgICAgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgICB0eXBlID0gYXVkaW9UcmFjay50eXBlLFxuICAgICAgICAgICAgdXJsID0gYXVkaW9UcmFjay51cmwsXG4gICAgICAgICAgICBldmVudE9iaiA9IHsgaWQ6IG5ld0lkLCB0eXBlOiB0eXBlLCB1cmw6IHVybCB9O1xuICAgICAgICAvLyBrZWVwIEFVRElPX1RSQUNLX1NXSVRDSCBmb3IgbGVnYWN5IHJlYXNvblxuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkFVRElPX1RSQUNLX1NXSVRDSCwgZXZlbnRPYmopO1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkFVRElPX1RSQUNLX1NXSVRDSElORywgZXZlbnRPYmopO1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGxvYWQgcGxheWxpc3QgZm9yIHRoaXMgYXVkaW8gVHJhY2tcbiAgICAgICAgdmFyIGRldGFpbHMgPSBhdWRpb1RyYWNrLmRldGFpbHM7XG4gICAgICAgIGlmICh1cmwgJiYgKGRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBkZXRhaWxzLmxpdmUgPT09IHRydWUpKSB7XG4gICAgICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnKHJlKWxvYWRpbmcgcGxheWxpc3QgZm9yIGF1ZGlvVHJhY2sgJyArIG5ld0lkKTtcbiAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkFVRElPX1RSQUNLX0xPQURJTkcsIHsgdXJsOiB1cmwsIGlkOiBuZXdJZCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVRyYWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVHJhY2sobmV3SWQpIHtcbiAgICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgICAgaWYgKG5ld0lkID49IDAgJiYgbmV3SWQgPCB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrSWQgPSBuZXdJZDtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCd1cGRhdGluZyBhdWRpb1RyYWNrICcgKyBuZXdJZCk7XG4gICAgICAgIHZhciBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdLFxuICAgICAgICAgICAgdXJsID0gYXVkaW9UcmFjay51cmw7XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBhdWRpbyBUcmFja1xuICAgICAgICB2YXIgZGV0YWlscyA9IGF1ZGlvVHJhY2suZGV0YWlscztcbiAgICAgICAgaWYgKHVybCAmJiAoZGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGRldGFpbHMubGl2ZSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCcocmUpbG9hZGluZyBwbGF5bGlzdCBmb3IgYXVkaW9UcmFjayAnICsgbmV3SWQpO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5BVURJT19UUkFDS19MT0FESU5HLCB7IHVybDogdXJsLCBpZDogbmV3SWQgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhdWRpb1RyYWNrcycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFja3M7XG4gICAgfVxuXG4gICAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKSAqKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXVkaW9UcmFjaycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFja0lkO1xuICAgIH1cblxuICAgIC8qKiBzZWxlY3QgYW4gYXVkaW8gdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cyoqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChhdWRpb1RyYWNrSWQpIHtcbiAgICAgIGlmICh0aGlzLnRyYWNrSWQgIT09IGF1ZGlvVHJhY2tJZCB8fCB0aGlzLnRyYWNrc1thdWRpb1RyYWNrSWRdLmRldGFpbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldEF1ZGlvVHJhY2tJbnRlcm5hbChhdWRpb1RyYWNrSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBdWRpb1RyYWNrQ29udHJvbGxlcjtcbn0oX2V2ZW50SGFuZGxlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEF1ZGlvVHJhY2tDb250cm9sbGVyO1xuXG59LHtcIjMyXCI6MzIsXCIzM1wiOjMzLFwiNTBcIjo1MH1dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V2ZW50cyA9IF9kZXJlcV8oMzMpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX2V2ZW50SGFuZGxlciA9IF9kZXJlcV8oMzIpO1xuXG52YXIgX2V2ZW50SGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudEhhbmRsZXIpO1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG52YXIgX2Vycm9ycyA9IF9kZXJlcV8oMzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBCdWZmZXIgQ29udHJvbGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIEJ1ZmZlckNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0V2ZW50SGFuZGxlcikge1xuICBfaW5oZXJpdHMoQnVmZmVyQ29udHJvbGxlciwgX0V2ZW50SGFuZGxlcik7XG5cbiAgZnVuY3Rpb24gQnVmZmVyQ29udHJvbGxlcihobHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyQ29udHJvbGxlcik7XG5cbiAgICAvLyB0aGUgdmFsdWUgdGhhdCB3ZSBoYXZlIHNldCBtZWRpYXNvdXJjZS5kdXJhdGlvbiB0b1xuICAgIC8vICh0aGUgYWN0dWFsIGR1cmF0aW9uIG1heSBiZSB0d2Vha2VkIHNsaWdobHkgYnkgdGhlIGJyb3dzZXIpXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJ1ZmZlckNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCdWZmZXJDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBobHMsIF9ldmVudHMyLmRlZmF1bHQuTUVESUFfQVRUQUNISU5HLCBfZXZlbnRzMi5kZWZhdWx0Lk1FRElBX0RFVEFDSElORywgX2V2ZW50czIuZGVmYXVsdC5NQU5JRkVTVF9QQVJTRUQsIF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX1JFU0VULCBfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9BUFBFTkRJTkcsIF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0NPREVDUywgX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfRU9TLCBfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9GTFVTSElORywgX2V2ZW50czIuZGVmYXVsdC5MRVZFTF9QVFNfVVBEQVRFRCwgX2V2ZW50czIuZGVmYXVsdC5MRVZFTF9VUERBVEVEKSk7XG5cbiAgICBfdGhpcy5fbXNEdXJhdGlvbiA9IG51bGw7XG4gICAgLy8gdGhlIHZhbHVlIHRoYXQgd2Ugd2FudCB0byBzZXQgbWVkaWFTb3VyY2UuZHVyYXRpb24gdG9cbiAgICBfdGhpcy5fbGV2ZWxEdXJhdGlvbiA9IG51bGw7XG5cbiAgICAvLyBTb3VyY2UgQnVmZmVyIGxpc3RlbmVyc1xuICAgIF90aGlzLm9uc2J1ZSA9IF90aGlzLm9uU0JVcGRhdGVFbmQuYmluZChfdGhpcyk7XG4gICAgX3RoaXMub25zYmUgPSBfdGhpcy5vblNCVXBkYXRlRXJyb3IuYmluZChfdGhpcyk7XG4gICAgX3RoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgIF90aGlzLnRyYWNrcyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdWZmZXJDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgX2V2ZW50SGFuZGxlcjIuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTGV2ZWxQdHNVcGRhdGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25MZXZlbFB0c1VwZGF0ZWQoZGF0YSkge1xuICAgICAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gICAgICB2YXIgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzLmF1ZGlvO1xuXG4gICAgICAvLyBBZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIChkZXNpcmVkIHBvaW50IGluIHRoZSB0aW1lbGluZSB3aGVyZSB0aGUgbmV4dCBmcmFtZXMgc2hvdWxkIGJlIGFwcGVuZGVkKVxuICAgICAgLy8gaW4gQ2hyb21lIGJyb3dzZXIgd2hlbiB3ZSBkZXRlY3QgTVBFRyBhdWRpbyBjb250YWluZXIgYW5kIHRpbWUgZGVsdGEgYmV0d2VlbiBsZXZlbCBQVFMgYW5kIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YFxuICAgICAgLy8gaXMgZ3JlYXRlciB0aGFuIDEwMG1zICh0aGlzIGlzIGVub3VnaCB0byBoYW5kbGUgc2VlayBmb3IgVk9EIG9yIGxldmVsIGNoYW5nZSBmb3IgTElWRSB2aWRlb3MpLiBBdCB0aGUgdGltZSBvZiBjaGFuZ2Ugd2UgaXNzdWVcbiAgICAgIC8vIGBTb3VyY2VCdWZmZXIuYWJvcnQoKWAgYW5kIGFkanVzdGluZyBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGAgaWYgYFNvdXJjZUJ1ZmZlci51cGRhdGluZ2AgaXMgZmFsc2Ugb3IgYXdhaXRpbmcgYHVwZGF0ZWVuZGBcbiAgICAgIC8vIGV2ZW50IGlmIFNCIGlzIGluIHVwZGF0aW5nIHN0YXRlLlxuICAgICAgLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYWlseW1vdGlvbi9obHMuanMvaXNzdWVzLzMzMiNpc3N1ZWNvbW1lbnQtMjU3OTg2NDg2XG5cbiAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nICYmIGF1ZGlvVHJhY2sgJiYgYXVkaW9UcmFjay5jb250YWluZXIgPT09ICdhdWRpby9tcGVnJykge1xuICAgICAgICAvLyBDaHJvbWUgYXVkaW8gbXAzIHRyYWNrXG4gICAgICAgIHZhciBhdWRpb0J1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLmF1ZGlvO1xuICAgICAgICB2YXIgZGVsdGEgPSBNYXRoLmFicyhhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgLSBkYXRhLnN0YXJ0KTtcblxuICAgICAgICAvLyBhZGp1c3QgdGltZXN0YW1wIG9mZnNldCBpZiB0aW1lIGRlbHRhIGlzIGdyZWF0ZXIgdGhhbiAxMDBtc1xuICAgICAgICBpZiAoZGVsdGEgPiAwLjEpIHtcbiAgICAgICAgICB2YXIgdXBkYXRpbmcgPSBhdWRpb0J1ZmZlci51cGRhdGluZztcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhdWRpb0J1ZmZlci5hYm9ydCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignY2FuIG5vdCBhYm9ydCBhdWRpbyBidWZmZXI6ICcgKyBlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdXBkYXRpbmcpIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2NoYW5nZSBtcGVnIGF1ZGlvIHRpbWVzdGFtcCBvZmZzZXQgZnJvbSAnICsgYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0ICsgJyB0byAnICsgZGF0YS5zdGFydCk7XG4gICAgICAgICAgICBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgPSBkYXRhLnN0YXJ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0ID0gZGF0YS5zdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1hbmlmZXN0UGFyc2VkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChkYXRhKSB7XG4gICAgICB2YXIgYXVkaW9FeHBlY3RlZCA9IGRhdGEuYXVkaW8sXG4gICAgICAgICAgdmlkZW9FeHBlY3RlZCA9IGRhdGEudmlkZW8sXG4gICAgICAgICAgc291cmNlQnVmZmVyTmIgPSAwO1xuICAgICAgLy8gaW4gY2FzZSBvZiBhbHQgYXVkaW8gMiBCVUZGRVJfQ09ERUNTIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCwgb25lIHBlciBzdHJlYW0gY29udHJvbGxlclxuICAgICAgLy8gc291cmNlYnVmZmVycyB3aWxsIGJlIGNyZWF0ZWQgYWxsIGF0IG9uY2Ugd2hlbiB0aGUgZXhwZWN0ZWQgbmIgb2YgdHJhY2tzIHdpbGwgYmUgcmVhY2hlZFxuICAgICAgLy8gaW4gY2FzZSBhbHQgYXVkaW8gaXMgbm90IHVzZWQsIG9ubHkgb25lIEJVRkZFUl9DT0RFQyBldmVudCB3aWxsIGJlIGZpcmVkIGZyb20gbWFpbiBzdHJlYW0gY29udHJvbGxlclxuICAgICAgLy8gaXQgd2lsbCBjb250YWluIHRoZSBleHBlY3RlZCBuYiBvZiBzb3VyY2UgYnVmZmVycywgbm8gbmVlZCB0byBjb21wdXRlIGl0XG4gICAgICBpZiAoZGF0YS5hbHRBdWRpbyAmJiAoYXVkaW9FeHBlY3RlZCB8fCB2aWRlb0V4cGVjdGVkKSkge1xuICAgICAgICBzb3VyY2VCdWZmZXJOYiA9IChhdWRpb0V4cGVjdGVkID8gMSA6IDApICsgKHZpZGVvRXhwZWN0ZWQgPyAxIDogMCk7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZyhzb3VyY2VCdWZmZXJOYiArICcgc291cmNlQnVmZmVyKHMpIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlck5iID0gc291cmNlQnVmZmVyTmI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYUF0dGFjaGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hpbmcoZGF0YSkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgLy8gc2V0dXAgdGhlIG1lZGlhIHNvdXJjZVxuICAgICAgICB2YXIgbXMgPSB0aGlzLm1lZGlhU291cmNlID0gbmV3IE1lZGlhU291cmNlKCk7XG4gICAgICAgIC8vTWVkaWEgU291cmNlIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLm9ubXNvID0gdGhpcy5vbk1lZGlhU291cmNlT3Blbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9ubXNlID0gdGhpcy5vbk1lZGlhU291cmNlRW5kZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbm1zYyA9IHRoaXMub25NZWRpYVNvdXJjZUNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLm9ubXNlKTtcbiAgICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLm9ubXNjKTtcbiAgICAgICAgLy8gbGluayB2aWRlbyBhbmQgbWVkaWEgU291cmNlXG4gICAgICAgIG1lZGlhLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwobXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWVkaWFEZXRhY2hpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgZGV0YWNoaW5nJyk7XG4gICAgICB2YXIgbXMgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgICAgaWYgKG1zKSB7XG4gICAgICAgIGlmIChtcy5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gZW5kT2ZTdHJlYW0gY291bGQgdHJpZ2dlciBleGNlcHRpb24gaWYgYW55IHNvdXJjZWJ1ZmZlciBpcyBpbiB1cGRhdGluZyBzdGF0ZVxuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgcmVhbGx5IGNhcmUgYWJvdXQgY2hlY2tpbmcgc291cmNlYnVmZmVyIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAvLyBhcyB3ZSBhcmUgYW55d2F5IGRldGFjaGluZyB0aGUgTWVkaWFTb3VyY2VcbiAgICAgICAgICAgIC8vIGxldCdzIGp1c3QgYXZvaWQgdGhpcyBleGNlcHRpb24gdG8gcHJvcGFnYXRlXG4gICAgICAgICAgICBtcy5lbmRPZlN0cmVhbSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2Fybignb25NZWRpYURldGFjaGluZzonICsgZXJyLm1lc3NhZ2UgKyAnIHdoaWxlIGNhbGxpbmcgZW5kT2ZTdHJlYW0nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMub25tc2UpO1xuICAgICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMub25tc2MpO1xuXG4gICAgICAgIC8vIERldGFjaCBwcm9wZXJseSB0aGUgTWVkaWFTb3VyY2UgZnJvbSB0aGUgSFRNTE1lZGlhRWxlbWVudCBhc1xuICAgICAgICAvLyBzdWdnZXN0ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3czYy9tZWRpYS1zb3VyY2UvaXNzdWVzLzUzLlxuICAgICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5tZWRpYS5zcmMpO1xuICAgICAgICAgIHRoaXMubWVkaWEucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICB0aGlzLm1lZGlhLmxvYWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWVkaWFTb3VyY2UgPSBudWxsO1xuICAgICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICAgIHRoaXMudHJhY2tzID0ge307XG4gICAgICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XG4gICAgICAgIHRoaXMuZmx1c2hSYW5nZSA9IFtdO1xuICAgICAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgICAgIHRoaXMuYXBwZW5kZWQgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5vbm1zbyA9IHRoaXMub25tc2UgPSB0aGlzLm9ubXNjID0gbnVsbDtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5NRURJQV9ERVRBQ0hFRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYVNvdXJjZU9wZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lZGlhU291cmNlT3BlbigpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIG9wZW5lZCcpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0Lk1FRElBX0FUVEFDSEVELCB7IG1lZGlhOiB0aGlzLm1lZGlhIH0pO1xuICAgICAgdmFyIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgICAvLyBvbmNlIHJlY2VpdmVkLCBkb24ndCBsaXN0ZW4gYW55bW9yZSB0byBzb3VyY2VvcGVuIGV2ZW50XG4gICAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2hlY2tQZW5kaW5nVHJhY2tzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tQZW5kaW5nVHJhY2tzKCkge1xuICAgICAgLy8gaWYgYW55IGJ1ZmZlciBjb2RlY3MgcGVuZGluZywgY2hlY2sgaWYgd2UgaGF2ZSBlbm91Z2ggdG8gY3JlYXRlIHNvdXJjZUJ1ZmZlcnNcbiAgICAgIHZhciBwZW5kaW5nVHJhY2tzID0gdGhpcy5wZW5kaW5nVHJhY2tzLFxuICAgICAgICAgIHBlbmRpbmdUcmFja3NOYiA9IE9iamVjdC5rZXlzKHBlbmRpbmdUcmFja3MpLmxlbmd0aDtcbiAgICAgIC8vIGlmIGFueSBwZW5kaW5nIHRyYWNrcyBhbmQgKGlmIG5iIG9mIHBlbmRpbmcgdHJhY2tzIGd0IG9yIGVxdWFsIHRoYW4gZXhwZWN0ZWQgbmIgb3IgaWYgdW5rbm93biBleHBlY3RlZCBuYilcbiAgICAgIGlmIChwZW5kaW5nVHJhY2tzTmIgJiYgKHRoaXMuc291cmNlQnVmZmVyTmIgPD0gcGVuZGluZ1RyYWNrc05iIHx8IHRoaXMuc291cmNlQnVmZmVyTmIgPT09IDApKSB7XG4gICAgICAgIC8vIG9rLCBsZXQncyBjcmVhdGUgdGhlbSBub3cgIVxuICAgICAgICB0aGlzLmNyZWF0ZVNvdXJjZUJ1ZmZlcnMocGVuZGluZ1RyYWNrcyk7XG4gICAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgICAvLyBhcHBlbmQgYW55IHBlbmRpbmcgc2VnbWVudHMgbm93ICFcbiAgICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWVkaWFTb3VyY2VDbG9zZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVkaWFTb3VyY2VDbG9zZSgpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGNsb3NlZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWVkaWFTb3VyY2VFbmRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVkaWFTb3VyY2VFbmRlZCgpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGVuZGVkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25TQlVwZGF0ZUVuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU0JVcGRhdGVFbmQoKSB7XG4gICAgICAvLyB1cGRhdGUgdGltZXN0YW1wT2Zmc2V0XG4gICAgICBpZiAodGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldCkge1xuICAgICAgICB2YXIgYXVkaW9CdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlci5hdWRpbztcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignY2hhbmdlIG1wZWcgYXVkaW8gdGltZXN0YW1wIG9mZnNldCBmcm9tICcgKyBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgKyAnIHRvICcgKyB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0KTtcbiAgICAgICAgYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0ID0gdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldDtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9uZWVkc0ZsdXNoKSB7XG4gICAgICAgIHRoaXMuZG9GbHVzaCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fbmVlZHNFb3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0VvcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRpbmcgPSBmYWxzZTtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgIC8vIGNvdW50IG5iIG9mIHBlbmRpbmcgc2VnbWVudHMgd2FpdGluZyBmb3IgYXBwZW5kaW5nIG9uIHRoaXMgc291cmNlYnVmZmVyXG4gICAgICB2YXIgcGVuZGluZyA9IHRoaXMuc2VnbWVudHMucmVkdWNlKGZ1bmN0aW9uIChjb3VudGVyLCBzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBzZWdtZW50LnBhcmVudCA9PT0gcGFyZW50ID8gY291bnRlciArIDEgOiBjb3VudGVyO1xuICAgICAgfSwgMCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0FQUEVOREVELCB7IHBhcmVudDogcGFyZW50LCBwZW5kaW5nOiBwZW5kaW5nIH0pO1xuXG4gICAgICAvLyBkb24ndCBhcHBlbmQgaW4gZmx1c2hpbmcgbW9kZVxuICAgICAgaWYgKCF0aGlzLl9uZWVkc0ZsdXNoKSB7XG4gICAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uU0JVcGRhdGVFcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU0JVcGRhdGVFcnJvcihldmVudCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIuZXJyb3IoJ3NvdXJjZUJ1ZmZlciBlcnJvcjonICsgZXZlbnQpO1xuICAgICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxuICAgICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcbiAgICAgIC8vIGl0IHdpbGwgYmUgZm9sbG93ZWQgYnkgYSBtZWRpYUVsZW1lbnQgZXJyb3IgLi4uKVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUiwgZmF0YWw6IGZhbHNlIH0pO1xuICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBkbyBtb3JlIHRoYW4gdGhhdCwgYXMgYWNjb3JkaW4gdG8gdGhlIHNwZWMsIHVwZGF0ZWVuZCB3aWxsIGJlIGZpcmVkIGp1c3QgYWZ0ZXJcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkJ1ZmZlclJlc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25CdWZmZXJSZXNldCgpIHtcbiAgICAgIHZhciBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICAgIGZvciAodmFyIHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICAgIHZhciBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLm1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcihzYik7XG4gICAgICAgICAgc2IucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgdGhpcy5vbnNidWUpO1xuICAgICAgICAgIHNiLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbnNiZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgIH1cbiAgICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XG4gICAgICB0aGlzLmZsdXNoUmFuZ2UgPSBbXTtcbiAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgIHRoaXMuYXBwZW5kZWQgPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQnVmZmVyQ29kZWNzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25CdWZmZXJDb2RlY3ModHJhY2tzKSB7XG4gICAgICAvLyBpZiBzb3VyY2UgYnVmZmVyKHMpIG5vdCBjcmVhdGVkIHlldCwgYXBwZW5kZWQgYnVmZmVyIHRyYWNrcyBpbiB0aGlzLnBlbmRpbmdUcmFja3NcbiAgICAgIC8vIGlmIHNvdXJjZWJ1ZmZlcnMgYWxyZWFkeSBjcmVhdGVkLCBkbyBub3RoaW5nIC4uLlxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVyKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgdHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgICAgIHRoaXMucGVuZGluZ1RyYWNrc1t0cmFja05hbWVdID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICAgICAgaWYgKG1lZGlhU291cmNlICYmIG1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICAgIC8vIHRyeSB0byBjcmVhdGUgc291cmNlYnVmZmVycyBpZiBtZWRpYXNvdXJjZSBvcGVuZWRcbiAgICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlU291cmNlQnVmZmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVNvdXJjZUJ1ZmZlcnModHJhY2tzKSB7XG4gICAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsXG4gICAgICAgICAgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuXG4gICAgICBmb3IgKHZhciB0cmFja05hbWUgaW4gdHJhY2tzKSB7XG4gICAgICAgIGlmICghc291cmNlQnVmZmVyW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgICAvLyB1c2UgbGV2ZWxDb2RlYyBhcyBmaXJzdCBwcmlvcml0eVxuICAgICAgICAgIHZhciBjb2RlYyA9IHRyYWNrLmxldmVsQ29kZWMgfHwgdHJhY2suY29kZWM7XG4gICAgICAgICAgdmFyIG1pbWVUeXBlID0gdHJhY2suY29udGFpbmVyICsgJztjb2RlY3M9JyArIGNvZGVjO1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnY3JlYXRpbmcgc291cmNlQnVmZmVyKCcgKyBtaW1lVHlwZSArICcpJyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzYiA9IHNvdXJjZUJ1ZmZlclt0cmFja05hbWVdID0gbWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKG1pbWVUeXBlKTtcbiAgICAgICAgICAgIHNiLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHRoaXMub25zYnVlKTtcbiAgICAgICAgICAgIHNiLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbnNiZSk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrc1t0cmFja05hbWVdID0geyBjb2RlYzogY29kZWMsIGNvbnRhaW5lcjogdHJhY2suY29udGFpbmVyIH07XG4gICAgICAgICAgICB0cmFjay5idWZmZXIgPSBzYjtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmVycm9yKCdlcnJvciB3aGlsZSB0cnlpbmcgdG8gYWRkIHNvdXJjZUJ1ZmZlcjonICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUiwgZmF0YWw6IGZhbHNlLCBlcnI6IGVyciwgbWltZVR5cGU6IG1pbWVUeXBlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9DUkVBVEVELCB7IHRyYWNrczogdHJhY2tzIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQnVmZmVyQXBwZW5kaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25CdWZmZXJBcHBlbmRpbmcoZGF0YSkge1xuICAgICAgaWYgKCF0aGlzLl9uZWVkc0ZsdXNoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWdtZW50cykge1xuICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbZGF0YV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkJ1ZmZlckFwcGVuZEZhaWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkJ1ZmZlckFwcGVuZEZhaWwoZGF0YSkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIuZXJyb3IoJ3NvdXJjZUJ1ZmZlciBlcnJvcjonLCBkYXRhLmV2ZW50KTtcbiAgICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAgIC8vIHRoaXMgZXJyb3IgbWlnaHQgbm90IGFsd2F5cyBiZSBmYXRhbCAoaXQgaXMgZmF0YWwgaWYgZGVjb2RlIGVycm9yIGlzIHNldCwgaW4gdGhhdCBjYXNlXG4gICAgICAvLyBpdCB3aWxsIGJlIGZvbGxvd2VkIGJ5IGEgbWVkaWFFbGVtZW50IGVycm9yIC4uLilcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICAvLyBvbiBCVUZGRVJfRU9TIG1hcmsgbWF0Y2hpbmcgc291cmNlYnVmZmVyKHMpIGFzIGVuZGVkIGFuZCB0cmlnZ2VyIGNoZWNrRW9zKClcblxuICB9LCB7XG4gICAga2V5OiAnb25CdWZmZXJFb3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkJ1ZmZlckVvcyhkYXRhKSB7XG4gICAgICB2YXIgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICAgIHZhciBkYXRhVHlwZSA9IGRhdGEudHlwZTtcbiAgICAgIGZvciAodmFyIHR5cGUgaW4gc2IpIHtcbiAgICAgICAgaWYgKCFkYXRhVHlwZSB8fCB0eXBlID09PSBkYXRhVHlwZSkge1xuICAgICAgICAgIGlmICghc2JbdHlwZV0uZW5kZWQpIHtcbiAgICAgICAgICAgIHNiW3R5cGVdLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZyh0eXBlICsgJyBzb3VyY2VCdWZmZXIgbm93IEVPUycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0VvcygpO1xuICAgIH1cblxuICAgIC8vIGlmIGFsbCBzb3VyY2UgYnVmZmVycyBhcmUgbWFya2VkIGFzIGVuZGVkLCBzaWduYWwgZW5kT2ZTdHJlYW0oKSB0byBNZWRpYVNvdXJjZS5cblxuICB9LCB7XG4gICAga2V5OiAnY2hlY2tFb3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0VvcygpIHtcbiAgICAgIHZhciBzYiA9IHRoaXMuc291cmNlQnVmZmVyLFxuICAgICAgICAgIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICAgIGlmICghbWVkaWFTb3VyY2UgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICAgIHRoaXMuX25lZWRzRW9zID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHR5cGUgaW4gc2IpIHtcbiAgICAgICAgdmFyIHNib2JqID0gc2JbdHlwZV07XG4gICAgICAgIGlmICghc2JvYmouZW5kZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNib2JqLnVwZGF0aW5nKSB7XG4gICAgICAgICAgdGhpcy5fbmVlZHNFb3MgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdhbGwgbWVkaWEgZGF0YSBhdmFpbGFibGUsIHNpZ25hbCBlbmRPZlN0cmVhbSgpIHRvIE1lZGlhU291cmNlIGFuZCBzdG9wIGxvYWRpbmcgZnJhZ21lbnQnKTtcbiAgICAgIC8vTm90aWZ5IHRoZSBtZWRpYSBlbGVtZW50IHRoYXQgaXQgbm93IGhhcyBhbGwgb2YgdGhlIG1lZGlhIGRhdGFcbiAgICAgIHRyeSB7XG4gICAgICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2V4Y2VwdGlvbiB3aGlsZSBjYWxsaW5nIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCknKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX25lZWRzRW9zID0gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25CdWZmZXJGbHVzaGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQnVmZmVyRmx1c2hpbmcoZGF0YSkge1xuICAgICAgdGhpcy5mbHVzaFJhbmdlLnB1c2goeyBzdGFydDogZGF0YS5zdGFydE9mZnNldCwgZW5kOiBkYXRhLmVuZE9mZnNldCwgdHlwZTogZGF0YS50eXBlIH0pO1xuICAgICAgLy8gYXR0ZW1wdCBmbHVzaCBpbW1lZGlhdGx5XG4gICAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA9IDA7XG4gICAgICB0aGlzLmRvRmx1c2goKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkxldmVsVXBkYXRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTGV2ZWxVcGRhdGVkKGV2ZW50KSB7XG4gICAgICB2YXIgZGV0YWlscyA9IGV2ZW50LmRldGFpbHM7XG4gICAgICBpZiAoZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xldmVsRHVyYXRpb24gPSBkZXRhaWxzLnRvdGFsZHVyYXRpb24gKyBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGFpbHltb3Rpb24vaGxzLmpzL2lzc3Vlcy8zNTVcblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgICAgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlLFxuICAgICAgICAgIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLFxuICAgICAgICAgIGxldmVsRHVyYXRpb24gPSB0aGlzLl9sZXZlbER1cmF0aW9uO1xuICAgICAgaWYgKGxldmVsRHVyYXRpb24gPT09IG51bGwgfHwgIW1lZGlhIHx8ICFtZWRpYVNvdXJjZSB8fCAhc291cmNlQnVmZmVyIHx8IG1lZGlhLnJlYWR5U3RhdGUgPT09IDAgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICAgIGlmIChzb3VyY2VCdWZmZXJbdHlwZV0udXBkYXRpbmcpIHtcbiAgICAgICAgICAvLyBjYW4ndCBzZXQgZHVyYXRpb24gd2hpbHN0IGEgYnVmZmVyIGlzIHVwZGF0aW5nXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbXNEdXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBpbml0aWFsaXNlIHRvIHRoZSB2YWx1ZSB0aGF0IHRoZSBtZWRpYSBzb3VyY2UgaXMgcmVwb3J0aW5nXG4gICAgICAgIHRoaXMuX21zRHVyYXRpb24gPSBtZWRpYVNvdXJjZS5kdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIHZhciBkdXJhdGlvbiA9IG1lZGlhLmR1cmF0aW9uO1xuICAgICAgLy8gbGV2ZWxEdXJhdGlvbiB3YXMgdGhlIGxhc3QgdmFsdWUgd2Ugc2V0LlxuICAgICAgLy8gbm90IHVzaW5nIG1lZGlhU291cmNlLmR1cmF0aW9uIGFzIHRoZSBicm93c2VyIG1heSB0d2VhayB0aGlzIHZhbHVlXG4gICAgICAvLyBvbmx5IHVwZGF0ZSBtZWRpYXNvdXJjZSBkdXJhdGlvbiBpZiBpdHMgdmFsdWUgaW5jcmVhc2UsIHRoaXMgaXMgdG8gYXZvaWRcbiAgICAgIC8vIGZsdXNoaW5nIGFscmVhZHkgYnVmZmVyZWQgcG9ydGlvbiB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIHF1YWxpdHkgbGV2ZWxcbiAgICAgIGlmIChsZXZlbER1cmF0aW9uID4gdGhpcy5fbXNEdXJhdGlvbiAmJiBsZXZlbER1cmF0aW9uID4gZHVyYXRpb24gfHwgZHVyYXRpb24gPT09IEluZmluaXR5IHx8IGlzTmFOKGR1cmF0aW9uKSkge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ1VwZGF0aW5nIG1lZGlhc291cmNlIGR1cmF0aW9uIHRvICcgKyBsZXZlbER1cmF0aW9uLnRvRml4ZWQoMykpO1xuICAgICAgICB0aGlzLl9tc0R1cmF0aW9uID0gbWVkaWFTb3VyY2UuZHVyYXRpb24gPSBsZXZlbER1cmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RvRmx1c2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb0ZsdXNoKCkge1xuICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBidWZmZXIgcmFuZ2VzIHRvIGZsdXNoXG4gICAgICB3aGlsZSAodGhpcy5mbHVzaFJhbmdlLmxlbmd0aCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmZsdXNoUmFuZ2VbMF07XG4gICAgICAgIC8vIGZsdXNoQnVmZmVyIHdpbGwgYWJvcnQgYW55IGJ1ZmZlciBhcHBlbmQgaW4gcHJvZ3Jlc3MgYW5kIGZsdXNoIEF1ZGlvL1ZpZGVvIEJ1ZmZlclxuICAgICAgICBpZiAodGhpcy5mbHVzaEJ1ZmZlcihyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCByYW5nZS50eXBlKSkge1xuICAgICAgICAgIC8vIHJhbmdlIGZsdXNoZWQsIHJlbW92ZSBmcm9tIGZsdXNoIGFycmF5XG4gICAgICAgICAgdGhpcy5mbHVzaFJhbmdlLnNoaWZ0KCk7XG4gICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX25lZWRzRmx1c2ggPSB0cnVlO1xuICAgICAgICAgIC8vIGF2b2lkIGxvb3BpbmcsIHdhaXQgZm9yIFNCIHVwZGF0ZSBlbmQgdG8gcmV0cmlnZ2VyIGEgZmx1c2hcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZsdXNoUmFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIGV2ZXJ5dGhpbmcgZmx1c2hlZFxuICAgICAgICB0aGlzLl9uZWVkc0ZsdXNoID0gZmFsc2U7XG5cbiAgICAgICAgLy8gbGV0J3MgcmVjb21wdXRlIHRoaXMuYXBwZW5kZWQsIHdoaWNoIGlzIHVzZWQgdG8gYXZvaWQgZmx1c2ggbG9vcGluZ1xuICAgICAgICB2YXIgYXBwZW5kZWQgPSAwO1xuICAgICAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgICAgIGFwcGVuZGVkICs9IHNvdXJjZUJ1ZmZlclt0eXBlXS5idWZmZXJlZC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIGVycm9yIGNvdWxkIGJlIHRocm93biB3aGlsZSBhY2Nlc3NpbmcgYnVmZmVyZWQsIGluIGNhc2Ugc291cmNlYnVmZmVyIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBmcm9tIE1lZGlhU291cmNlXG4gICAgICAgICAgLy8gdGhpcyBpcyBoYXJtZXNzIGF0IHRoaXMgc3RhZ2UsIGNhdGNoIHRoaXMgdG8gYXZvaWQgcmVwb3J0aW5nIGFuIGludGVybmFsIGV4Y2VwdGlvblxuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmVycm9yKCdlcnJvciB3aGlsZSBhY2Nlc3Npbmcgc291cmNlQnVmZmVyLmJ1ZmZlcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBlbmRlZCA9IGFwcGVuZGVkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0ZMVVNIRUQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RvQXBwZW5kaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9BcHBlbmRpbmcoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsXG4gICAgICAgICAgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZUJ1ZmZlcikubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLm1lZGlhLmVycm9yKSB7XG4gICAgICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmVycm9yKCd0cnlpbmcgdG8gYXBwZW5kIGFsdGhvdWdoIGEgbWVkaWEgZXJyb3Igb2NjdXJlZCwgZmx1c2ggc2VnbWVudCBhbmQgYWJvcnQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kaW5nKSB7XG4gICAgICAgICAgLy9sb2dnZXIubG9nKGBzYiBhcHBlbmRpbmcgaW4gcHJvZ3Jlc3NgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHMuc2hpZnQoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBzZWdtZW50LnR5cGUsXG4gICAgICAgICAgICAgICAgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICAgICAgaWYgKCFzYi51cGRhdGluZykge1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHNvdXJjZUJ1ZmZlciBlbmRlZCBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgc2VnbWVudFxuICAgICAgICAgICAgICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy9sb2dnZXIubG9nKGBhcHBlbmRpbmcgJHtzZWdtZW50LmNvbnRlbnR9ICR7dHlwZX0gU0IsIHNpemU6JHtzZWdtZW50LmRhdGEubGVuZ3RofSwgJHtzZWdtZW50LnBhcmVudH1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHNlZ21lbnQucGFyZW50O1xuICAgICAgICAgICAgICAgIHNiLmFwcGVuZEJ1ZmZlcihzZWdtZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQrKztcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMudW5zaGlmdChzZWdtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSBkb24ndCBoYXZlIGFueSBzb3VyY2UgYnVmZmVyIG1hdGNoaW5nIHdpdGggdGhpcyBzZWdtZW50IHR5cGUsXG4gICAgICAgICAgICAgIC8vIGl0IG1lYW5zIHRoYXQgTWVkaWFzb3VyY2UgZmFpbHMgdG8gY3JlYXRlIHNvdXJjZWJ1ZmZlclxuICAgICAgICAgICAgICAvLyBkaXNjYXJkIHRoaXMgc2VnbWVudCwgYW5kIHRyaWdnZXIgdXBkYXRlIGVuZFxuICAgICAgICAgICAgICB0aGlzLm9uU0JVcGRhdGVFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGluIGNhc2UgYW55IGVycm9yIG9jY3VyZWQgd2hpbGUgYXBwZW5kaW5nLCBwdXQgYmFjayBzZWdtZW50IGluIHNlZ21lbnRzIHRhYmxlXG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5lcnJvcignZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGFwcGVuZCBidWZmZXI6JyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHNlZ21lbnRzLnVuc2hpZnQoc2VnbWVudCk7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgcGFyZW50OiBzZWdtZW50LnBhcmVudCB9O1xuICAgICAgICAgICAgaWYgKGVyci5jb2RlICE9PSAyMikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRFcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBldmVudC5kZXRhaWxzID0gX2Vycm9ycy5FcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjtcbiAgICAgICAgICAgICAgLyogd2l0aCBVSEQgY29udGVudCwgd2UgY291bGQgZ2V0IGxvb3Agb2YgcXVvdGEgZXhjZWVkZWQgZXJyb3IgdW50aWxcbiAgICAgICAgICAgICAgICBicm93c2VyIGlzIGFibGUgdG8gZXZpY3Qgc29tZSBkYXRhIGZyb20gc291cmNlYnVmZmVyLiByZXRyeWluZyBoZWxwIHJlY292ZXJpbmcgdGhpc1xuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRFcnJvciA+IGhscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeSkge1xuICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnZmFpbCAnICsgaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5ICsgJyB0aW1lcyB0byBhcHBlbmQgc2VnbWVudCBpbiBzb3VyY2VCdWZmZXInKTtcbiAgICAgICAgICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCBldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgZXZlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBRdW90YUV4Y2VlZGVkRXJyb3I6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjcXVvdGFleGNlZWRlZGVycm9yXG4gICAgICAgICAgICAgIC8vIGxldCdzIHN0b3AgYXBwZW5kaW5nIGFueSBzZWdtZW50cywgYW5kIHJlcG9ydCBCVUZGRVJfRlVMTF9FUlJPUiBlcnJvclxuICAgICAgICAgICAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBfZXJyb3JzLkVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjtcbiAgICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgZXZlbnQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgIGZsdXNoIHNwZWNpZmllZCBidWZmZXJlZCByYW5nZSxcbiAgICAgIHJldHVybiB0cnVlIG9uY2UgcmFuZ2UgaGFzIGJlZW4gZmx1c2hlZC5cbiAgICAgIGFzIHNvdXJjZUJ1ZmZlci5yZW1vdmUoKSBpcyBhc3luY2hyb25vdXMsIGZsdXNoQnVmZmVyIHdpbGwgYmUgcmV0cmlnZ2VyZWQgb24gc291cmNlQnVmZmVyIHVwZGF0ZSBlbmRcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmbHVzaEJ1ZmZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZsdXNoQnVmZmVyKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHR5cGVJbikge1xuICAgICAgdmFyIHNiLFxuICAgICAgICAgIGksXG4gICAgICAgICAgYnVmU3RhcnQsXG4gICAgICAgICAgYnVmRW5kLFxuICAgICAgICAgIGZsdXNoU3RhcnQsXG4gICAgICAgICAgZmx1c2hFbmQsXG4gICAgICAgICAgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoc291cmNlQnVmZmVyKS5sZW5ndGgpIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdmbHVzaEJ1ZmZlcixwb3Mvc3RhcnQvZW5kOiAnICsgdGhpcy5tZWRpYS5jdXJyZW50VGltZS50b0ZpeGVkKDMpICsgJy8nICsgc3RhcnRPZmZzZXQgKyAnLycgKyBlbmRPZmZzZXQpO1xuICAgICAgICAvLyBzYWZlZ3VhcmQgdG8gYXZvaWQgaW5maW5pdGUgbG9vcGluZyA6IGRvbid0IHRyeSB0byBmbHVzaCBtb3JlIHRoYW4gdGhlIG5iIG9mIGFwcGVuZGVkIHNlZ21lbnRzXG4gICAgICAgIGlmICh0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA8IHRoaXMuYXBwZW5kZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgc291cmNlYnVmZmVyIHR5cGUgaXMgZGVmaW5lZCAodHlwZUluKTogaWYgeWVzLCBsZXQncyBvbmx5IGZsdXNoIHRoaXMgb25lXG4gICAgICAgICAgICAvLyBpZiBubywgbGV0J3MgZmx1c2ggYWxsIHNvdXJjZWJ1ZmZlcnNcbiAgICAgICAgICAgIGlmICh0eXBlSW4gJiYgdHlwZSAhPT0gdHlwZUluKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgICAvLyB3ZSBhcmUgZ29pbmcgdG8gZmx1c2ggYnVmZmVyLCBtYXJrIHNvdXJjZSBidWZmZXIgYXMgJ25vdCBlbmRlZCdcbiAgICAgICAgICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXNiLnVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNiLmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBidWZTdGFydCA9IHNiLmJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgICAgICAgICAgICAgICAgYnVmRW5kID0gc2IuYnVmZmVyZWQuZW5kKGkpO1xuICAgICAgICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmaXJlZm94IG5vdCBhYmxlIHRvIHByb3Blcmx5IGZsdXNoIG11bHRpcGxlIGJ1ZmZlcmVkIHJhbmdlLlxuICAgICAgICAgICAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xICYmIGVuZE9mZnNldCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoU3RhcnQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hFbmQgPSBlbmRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaFN0YXJ0ID0gTWF0aC5tYXgoYnVmU3RhcnQsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hFbmQgPSBNYXRoLm1pbihidWZFbmQsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvKiBzb21ldGltZXMgc291cmNlYnVmZmVyLnJlbW92ZSgpIGRvZXMgbm90IGZsdXNoXG4gICAgICAgICAgICAgICAgICAgICB0aGUgZXhhY3QgZXhwZWN0ZWQgdGltZSByYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgIHRvIGF2b2lkIHJvdW5kaW5nIGlzc3Vlcy9pbmZpbml0ZSBsb29wLFxuICAgICAgICAgICAgICAgICAgICAgb25seSBmbHVzaCBidWZmZXIgcmFuZ2Ugb2YgbGVuZ3RoIGdyZWF0ZXIgdGhhbiA1MDBtcy5cbiAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICBpZiAoTWF0aC5taW4oZmx1c2hFbmQsIGJ1ZkVuZCkgLSBmbHVzaFN0YXJ0ID4gMC41KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnZmx1c2ggJyArIHR5cGUgKyAnIFsnICsgZmx1c2hTdGFydCArICcsJyArIGZsdXNoRW5kICsgJ10sIG9mIFsnICsgYnVmU3RhcnQgKyAnLCcgKyBidWZFbmQgKyAnXSwgcG9zOicgKyB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgc2IucmVtb3ZlKGZsdXNoU3RhcnQsIGZsdXNoRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2V4Y2VwdGlvbiB3aGlsZSBhY2Nlc3Npbmcgc291cmNlYnVmZmVyLCBpdCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIE1lZGlhU291cmNlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnYWJvcnQgJyArIHR5cGUgKyAnIGFwcGVuZCBpbiBwcm9ncmVzcycpO1xuICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgYWJvcnQgYW55IGFwcGVuZGluZyBpbiBwcm9ncmVzc1xuICAgICAgICAgICAgICAvL3NiLmFib3J0KCk7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2Nhbm5vdCBmbHVzaCwgc2IgdXBkYXRpbmcgaW4gcHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdhYm9ydCBmbHVzaGluZyB0b28gbWFueSByZXRyaWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdidWZmZXIgZmx1c2hlZCcpO1xuICAgICAgfVxuICAgICAgLy8gZXZlcnl0aGluZyBmbHVzaGVkICFcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCdWZmZXJDb250cm9sbGVyO1xufShfZXZlbnRIYW5kbGVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQnVmZmVyQ29udHJvbGxlcjtcblxufSx7XCIzMVwiOjMxLFwiMzJcIjozMixcIjMzXCI6MzMsXCI1MFwiOjUwfV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZXZlbnRIYW5kbGVyID0gX2RlcmVxXygzMik7XG5cbnZhciBfZXZlbnRIYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50SGFuZGxlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGNhcCBzdHJlYW0gbGV2ZWwgdG8gbWVkaWEgc2l6ZSBkaW1lbnNpb24gY29udHJvbGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIENhcExldmVsQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfRXZlbnRIYW5kbGVyKSB7XG4gIF9pbmhlcml0cyhDYXBMZXZlbENvbnRyb2xsZXIsIF9FdmVudEhhbmRsZXIpO1xuXG4gIGZ1bmN0aW9uIENhcExldmVsQ29udHJvbGxlcihobHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FwTGV2ZWxDb250cm9sbGVyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ2FwTGV2ZWxDb250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2FwTGV2ZWxDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBobHMsIF9ldmVudHMyLmRlZmF1bHQuRlBTX0RST1BfTEVWRUxfQ0FQUElORywgX2V2ZW50czIuZGVmYXVsdC5NRURJQV9BVFRBQ0hJTkcsIF9ldmVudHMyLmRlZmF1bHQuTUFOSUZFU1RfUEFSU0VEKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2FwTGV2ZWxDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgICB0aGlzLm1lZGlhID0gdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgIHRoaXMudGltZXIgPSBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GcHNEcm9wTGV2ZWxDYXBwaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GcHNEcm9wTGV2ZWxDYXBwaW5nKGRhdGEpIHtcbiAgICAgIGlmICghdGhpcy5yZXN0cmljdGVkTGV2ZWxzKSB7XG4gICAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmlzTGV2ZWxSZXN0cmljdGVkKGRhdGEuZHJvcHBlZExldmVsKSkge1xuICAgICAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMucHVzaChkYXRhLmRyb3BwZWRMZXZlbCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYUF0dGFjaGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hpbmcoZGF0YSkge1xuICAgICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NYW5pZmVzdFBhcnNlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWFuaWZlc3RQYXJzZWQoZGF0YSkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgICAgICBobHMuZmlyc3RMZXZlbCA9IHRoaXMuZ2V0TWF4TGV2ZWwoZGF0YS5maXJzdExldmVsKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMuZGV0ZWN0UGxheWVyU2l6ZS5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICAgICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGV0ZWN0UGxheWVyU2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVjdFBsYXllclNpemUoKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICB2YXIgbGV2ZWxzTGVuZ3RoID0gdGhpcy5sZXZlbHMgPyB0aGlzLmxldmVscy5sZW5ndGggOiAwO1xuICAgICAgICBpZiAobGV2ZWxzTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gdGhpcy5nZXRNYXhMZXZlbChsZXZlbHNMZW5ndGggLSAxKTtcbiAgICAgICAgICBpZiAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPiB0aGlzLmF1dG9MZXZlbENhcHBpbmcpIHtcbiAgICAgICAgICAgIC8vIGlmIGF1dG8gbGV2ZWwgY2FwcGluZyBoYXMgYSBoaWdoZXIgdmFsdWUgZm9yIHRoZSBwcmV2aW91cyBvbmUsIGZsdXNoIHRoZSBidWZmZXIgdXNpbmcgbmV4dExldmVsU3dpdGNoXG4gICAgICAgICAgICAvLyB1c3VhbGx5IGhhcHBlbiB3aGVuIHRoZSB1c2VyIGdvIHRvIHRoZSBmdWxsc2NyZWVuIG1vZGUuXG4gICAgICAgICAgICBobHMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gaGxzLmF1dG9MZXZlbENhcHBpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICogcmV0dXJucyBsZXZlbCBzaG91bGQgYmUgdGhlIG9uZSB3aXRoIHRoZSBkaW1lbnNpb25zIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWVkaWEgKHBsYXllcikgZGltZW5zaW9ucyAoc28gdGhlIHZpZGVvIHdpbGwgYmUgZG93bnNjYWxlZClcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRNYXhMZXZlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1heExldmVsKGNhcExldmVsSW5kZXgpIHtcbiAgICAgIHZhciByZXN1bHQgPSAwLFxuICAgICAgICAgIGkgPSB2b2lkIDAsXG4gICAgICAgICAgbGV2ZWwgPSB2b2lkIDAsXG4gICAgICAgICAgbVdpZHRoID0gdGhpcy5tZWRpYVdpZHRoLFxuICAgICAgICAgIG1IZWlnaHQgPSB0aGlzLm1lZGlhSGVpZ2h0LFxuICAgICAgICAgIGxXaWR0aCA9IDAsXG4gICAgICAgICAgbEhlaWdodCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPD0gY2FwTGV2ZWxJbmRleDsgaSsrKSB7XG4gICAgICAgIGxldmVsID0gdGhpcy5sZXZlbHNbaV07XG4gICAgICAgIGlmICh0aGlzLmlzTGV2ZWxSZXN0cmljdGVkKGkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgbFdpZHRoID0gbGV2ZWwud2lkdGg7XG4gICAgICAgIGxIZWlnaHQgPSBsZXZlbC5oZWlnaHQ7XG4gICAgICAgIGlmIChtV2lkdGggPD0gbFdpZHRoIHx8IG1IZWlnaHQgPD0gbEhlaWdodCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lzTGV2ZWxSZXN0cmljdGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNMZXZlbFJlc3RyaWN0ZWQobGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgJiYgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLmluZGV4T2YobGV2ZWwpICE9PSAtMSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb250ZW50U2NhbGVGYWN0b3InLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSAxO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIHJldHVybiBwaXhlbFJhdGlvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21lZGlhV2lkdGgnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHdpZHRoID0gdm9pZCAwO1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICB3aWR0aCA9IG1lZGlhLndpZHRoIHx8IG1lZGlhLmNsaWVudFdpZHRoIHx8IG1lZGlhLm9mZnNldFdpZHRoO1xuICAgICAgICB3aWR0aCAqPSB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtZWRpYUhlaWdodCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgaGVpZ2h0ID0gdm9pZCAwO1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBoZWlnaHQgPSBtZWRpYS5oZWlnaHQgfHwgbWVkaWEuY2xpZW50SGVpZ2h0IHx8IG1lZGlhLm9mZnNldEhlaWdodDtcbiAgICAgICAgaGVpZ2h0ICo9IHRoaXMuY29udGVudFNjYWxlRmFjdG9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FwTGV2ZWxDb250cm9sbGVyO1xufShfZXZlbnRIYW5kbGVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2FwTGV2ZWxDb250cm9sbGVyO1xuXG59LHtcIjMyXCI6MzIsXCIzM1wiOjMzfV0sMTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpOyAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEVXTUEgQmFuZHdpZHRoIEVzdGltYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUcmFja3MgYmFuZHdpZHRoIHNhbXBsZXMgYW5kIGVzdGltYXRlcyBhdmFpbGFibGUgYmFuZHdpZHRoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEJhc2VkIG9uIHRoZSBtaW5pbXVtIG9mIHR3byBleHBvbmVudGlhbGx5LXdlaWdodGVkIG1vdmluZyBhdmVyYWdlcyB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZGlmZmVyZW50IGhhbGYtbGl2ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBfZXdtYSA9IF9kZXJlcV8oNDkpO1xuXG52YXIgX2V3bWEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXdtYSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBFd21hQmFuZFdpZHRoRXN0aW1hdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFd21hQmFuZFdpZHRoRXN0aW1hdG9yKGhscywgc2xvdywgZmFzdCwgZGVmYXVsdEVzdGltYXRlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IpO1xuXG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5kZWZhdWx0RXN0aW1hdGVfID0gZGVmYXVsdEVzdGltYXRlO1xuICAgIHRoaXMubWluV2VpZ2h0XyA9IDAuMDAxO1xuICAgIHRoaXMubWluRGVsYXlNc18gPSA1MDtcbiAgICB0aGlzLnNsb3dfID0gbmV3IF9ld21hMi5kZWZhdWx0KHNsb3cpO1xuICAgIHRoaXMuZmFzdF8gPSBuZXcgX2V3bWEyLmRlZmF1bHQoZmFzdCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXdtYUJhbmRXaWR0aEVzdGltYXRvciwgW3tcbiAgICBrZXk6ICdzYW1wbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYW1wbGUoZHVyYXRpb25NcywgbnVtQnl0ZXMpIHtcbiAgICAgIGR1cmF0aW9uTXMgPSBNYXRoLm1heChkdXJhdGlvbk1zLCB0aGlzLm1pbkRlbGF5TXNfKTtcbiAgICAgIHZhciBiYW5kd2lkdGggPSA4MDAwICogbnVtQnl0ZXMgLyBkdXJhdGlvbk1zLFxuXG4gICAgICAvL2NvbnNvbGUubG9nKCdpbnN0YW50IGJ3OicrIE1hdGgucm91bmQoYmFuZHdpZHRoKSk7XG4gICAgICAvLyB3ZSB3ZWlnaHQgc2FtcGxlIHVzaW5nIGxvYWRpbmcgZHVyYXRpb24uLi4uXG4gICAgICB3ZWlnaHQgPSBkdXJhdGlvbk1zIC8gMTAwMDtcbiAgICAgIHRoaXMuZmFzdF8uc2FtcGxlKHdlaWdodCwgYmFuZHdpZHRoKTtcbiAgICAgIHRoaXMuc2xvd18uc2FtcGxlKHdlaWdodCwgYmFuZHdpZHRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYW5Fc3RpbWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkVzdGltYXRlKCkge1xuICAgICAgdmFyIGZhc3QgPSB0aGlzLmZhc3RfO1xuICAgICAgcmV0dXJuIGZhc3QgJiYgZmFzdC5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0XztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRFc3RpbWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVzdGltYXRlKCkge1xuICAgICAgaWYgKHRoaXMuY2FuRXN0aW1hdGUoKSkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdzbG93IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2Zhc3QgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLmZhc3RfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgICAgLy8gVGFrZSB0aGUgbWluaW11bSBvZiB0aGVzZSB0d28gZXN0aW1hdGVzLiAgVGhpcyBzaG91bGQgaGF2ZSB0aGUgZWZmZWN0IG9mXG4gICAgICAgIC8vIGFkYXB0aW5nIGRvd24gcXVpY2tseSwgYnV0IHVwIG1vcmUgc2xvd2x5LlxuICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLCB0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEVzdGltYXRlXztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gRXdtYUJhbmRXaWR0aEVzdGltYXRvcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRXdtYUJhbmRXaWR0aEVzdGltYXRvcjtcblxufSx7XCI0OVwiOjQ5fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V2ZW50cyA9IF9kZXJlcV8oMzMpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX2V2ZW50SGFuZGxlciA9IF9kZXJlcV8oMzIpO1xuXG52YXIgX2V2ZW50SGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudEhhbmRsZXIpO1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBGUFMgQ29udHJvbGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIEZQU0NvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0V2ZW50SGFuZGxlcikge1xuICBfaW5oZXJpdHMoRlBTQ29udHJvbGxlciwgX0V2ZW50SGFuZGxlcik7XG5cbiAgZnVuY3Rpb24gRlBTQ29udHJvbGxlcihobHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRlBTQ29udHJvbGxlcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEZQU0NvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGUFNDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBobHMsIF9ldmVudHMyLmRlZmF1bHQuTUVESUFfQVRUQUNISU5HKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRlBTQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB9XG4gICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1lZGlhQXR0YWNoaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZWRpYUF0dGFjaGluZyhkYXRhKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgICAgaWYgKGNvbmZpZy5jYXBMZXZlbE9uRlBTRHJvcCkge1xuICAgICAgICB2YXIgdmlkZW8gPSB0aGlzLnZpZGVvID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiB2aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMuY2hlY2tGUFNJbnRlcnZhbC5iaW5kKHRoaXMpLCBjb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2QpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NoZWNrRlBTJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tGUFModmlkZW8sIGRlY29kZWRGcmFtZXMsIGRyb3BwZWRGcmFtZXMpIHtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgaWYgKGRlY29kZWRGcmFtZXMpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdFRpbWUpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZSxcbiAgICAgICAgICAgICAgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyxcbiAgICAgICAgICAgICAgY3VycmVudERlY29kZWQgPSBkZWNvZGVkRnJhbWVzIC0gdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyxcbiAgICAgICAgICAgICAgZHJvcHBlZEZQUyA9IDEwMDAgKiBjdXJyZW50RHJvcHBlZCAvIGN1cnJlbnRQZXJpb2QsXG4gICAgICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlBTX0RST1AsIHsgY3VycmVudERyb3BwZWQ6IGN1cnJlbnREcm9wcGVkLCBjdXJyZW50RGVjb2RlZDogY3VycmVudERlY29kZWQsIHRvdGFsRHJvcHBlZEZyYW1lczogZHJvcHBlZEZyYW1lcyB9KTtcbiAgICAgICAgICBpZiAoZHJvcHBlZEZQUyA+IDApIHtcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnY2hlY2tGUFMgOiBkcm9wcGVkRlBTL2RlY29kZWRGUFM6JyArIGRyb3BwZWRGUFMvKDEwMDAgKiBjdXJyZW50RGVjb2RlZCAvIGN1cnJlbnRQZXJpb2QpKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RHJvcHBlZCA+IGhscy5jb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQgKiBjdXJyZW50RGVjb2RlZCkge1xuICAgICAgICAgICAgICB2YXIgY3VycmVudExldmVsID0gaGxzLmN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgKyBjdXJyZW50TGV2ZWwpO1xuICAgICAgICAgICAgICBpZiAoY3VycmVudExldmVsID4gMCAmJiAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPT09IC0xIHx8IGhscy5hdXRvTGV2ZWxDYXBwaW5nID49IGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWwgLSAxO1xuICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlBTX0RST1BfTEVWRUxfQ0FQUElORywgeyBsZXZlbDogY3VycmVudExldmVsLCBkcm9wcGVkTGV2ZWw6IGhscy5jdXJyZW50TGV2ZWwgfSk7XG4gICAgICAgICAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICAgICAgaGxzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gZHJvcHBlZEZyYW1lcztcbiAgICAgICAgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IGRlY29kZWRGcmFtZXM7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2hlY2tGUFNJbnRlcnZhbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRlBTSW50ZXJ2YWwoKSB7XG4gICAgICB2YXIgdmlkZW8gPSB0aGlzLnZpZGVvO1xuICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUpIHtcbiAgICAgICAgICB2YXIgdmlkZW9QbGF5YmFja1F1YWxpdHkgPSB2aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMsIHZpZGVvUGxheWJhY2tRdWFsaXR5LmRyb3BwZWRWaWRlb0ZyYW1lcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW8ud2Via2l0RGVjb2RlZEZyYW1lQ291bnQsIHZpZGVvLndlYmtpdERyb3BwZWRGcmFtZUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGUFNDb250cm9sbGVyO1xufShfZXZlbnRIYW5kbGVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRlBTQ29udHJvbGxlcjtcblxufSx7XCIzMlwiOjMyLFwiMzNcIjozMyxcIjUwXCI6NTB9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZXZlbnRIYW5kbGVyID0gX2RlcmVxXygzMik7XG5cbnZhciBfZXZlbnRIYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50SGFuZGxlcik7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbnZhciBfZXJyb3JzID0gX2RlcmVxXygzMSk7XG5cbnZhciBfYnVmZmVySGVscGVyID0gX2RlcmVxXygzNSk7XG5cbnZhciBfYnVmZmVySGVscGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1ZmZlckhlbHBlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIExldmVsIENvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBMZXZlbENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0V2ZW50SGFuZGxlcikge1xuICBfaW5oZXJpdHMoTGV2ZWxDb250cm9sbGVyLCBfRXZlbnRIYW5kbGVyKTtcblxuICBmdW5jdGlvbiBMZXZlbENvbnRyb2xsZXIoaGxzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExldmVsQ29udHJvbGxlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTGV2ZWxDb250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGV2ZWxDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBobHMsIF9ldmVudHMyLmRlZmF1bHQuTUFOSUZFU1RfTE9BREVELCBfZXZlbnRzMi5kZWZhdWx0LkxFVkVMX0xPQURFRCwgX2V2ZW50czIuZGVmYXVsdC5GUkFHX0xPQURFRCwgX2V2ZW50czIuZGVmYXVsdC5FUlJPUikpO1xuXG4gICAgX3RoaXMub250aWNrID0gX3RoaXMudGljay5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5fbWFudWFsTGV2ZWwgPSAtMTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGV2ZWxDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hbnVhbExldmVsID0gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RhcnRMb2FkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRMb2FkKCkge1xuICAgICAgdGhpcy5jYW5sb2FkID0gdHJ1ZTtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgICAvLyBjbGVhbiB1cCBsaXZlIGxldmVsIGRldGFpbHMgdG8gZm9yY2UgcmVsb2FkIHRoZW0sIGFuZCByZXNldCBsb2FkIGVycm9yc1xuICAgICAgaWYgKGxldmVscykge1xuICAgICAgICBsZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgICAgIHZhciBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgICAgICAgIGlmIChsZXZlbERldGFpbHMgJiYgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgIGxldmVsLmRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIHNwZWVkIHVwIGxpdmUgcGxheWxpc3QgcmVmcmVzaCBpZiB0aW1lciBleGlzdHNcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0b3BMb2FkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcExvYWQoKSB7XG4gICAgICB0aGlzLmNhbmxvYWQgPSBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1hbmlmZXN0TG9hZGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NYW5pZmVzdExvYWRlZChkYXRhKSB7XG4gICAgICB2YXIgbGV2ZWxzMCA9IFtdLFxuICAgICAgICAgIGxldmVscyA9IFtdLFxuICAgICAgICAgIGJpdHJhdGVTdGFydCxcbiAgICAgICAgICBiaXRyYXRlU2V0ID0ge30sXG4gICAgICAgICAgdmlkZW9Db2RlY0ZvdW5kID0gZmFsc2UsXG4gICAgICAgICAgYXVkaW9Db2RlY0ZvdW5kID0gZmFsc2UsXG4gICAgICAgICAgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgYnJva2VubXA0aW5tcDMgPSAvY2hyb21lfGZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgICBjaGVja1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGNoZWNrU3VwcG9ydGVkKHR5cGUsIGNvZGVjKSB7XG4gICAgICAgIHJldHVybiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQodHlwZSArICcvbXA0O2NvZGVjcz0nICsgY29kZWMpO1xuICAgICAgfTtcblxuICAgICAgLy8gcmVncm91cCByZWR1bmRhbnQgbGV2ZWwgdG9nZXRoZXJcbiAgICAgIGRhdGEubGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbC52aWRlb0NvZGVjKSB7XG4gICAgICAgICAgdmlkZW9Db2RlY0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlcmFzZSBhdWRpbyBjb2RlYyBpbmZvIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtcDRhLjQwLjM0LiBkZW11eGVyIHdpbGwgYXV0b2RldGVjdCBjb2RlYyBhbmQgZmFsbGJhY2sgdG8gbXBlZy9hdWRpb1xuICAgICAgICBpZiAoYnJva2VubXA0aW5tcDMgJiYgbGV2ZWwuYXVkaW9Db2RlYyAmJiBsZXZlbC5hdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMzQnKSAhPT0gLTEpIHtcbiAgICAgICAgICBsZXZlbC5hdWRpb0NvZGVjID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbC5hdWRpb0NvZGVjIHx8IGxldmVsLmF0dHJzICYmIGxldmVsLmF0dHJzLkFVRElPKSB7XG4gICAgICAgICAgYXVkaW9Db2RlY0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVkdW5kYW50TGV2ZWxJZCA9IGJpdHJhdGVTZXRbbGV2ZWwuYml0cmF0ZV07XG4gICAgICAgIGlmIChyZWR1bmRhbnRMZXZlbElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBiaXRyYXRlU2V0W2xldmVsLmJpdHJhdGVdID0gbGV2ZWxzMC5sZW5ndGg7XG4gICAgICAgICAgbGV2ZWwudXJsID0gW2xldmVsLnVybF07XG4gICAgICAgICAgbGV2ZWwudXJsSWQgPSAwO1xuICAgICAgICAgIGxldmVsczAucHVzaChsZXZlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV2ZWxzMFtyZWR1bmRhbnRMZXZlbElkXS51cmwucHVzaChsZXZlbC51cmwpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gcmVtb3ZlIGF1ZGlvLW9ubHkgbGV2ZWwgaWYgd2UgYWxzbyBoYXZlIGxldmVscyB3aXRoIGF1ZGlvK3ZpZGVvIGNvZGVjcyBzaWduYWxsZWRcbiAgICAgIGlmICh2aWRlb0NvZGVjRm91bmQgJiYgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgICAgIGxldmVsczAuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAobGV2ZWwudmlkZW9Db2RlYykge1xuICAgICAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbHMgPSBsZXZlbHMwO1xuICAgICAgfVxuICAgICAgLy8gb25seSBrZWVwIGxldmVsIHdpdGggc3VwcG9ydGVkIGF1ZGlvL3ZpZGVvIGNvZGVjc1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgdmFyIGF1ZGlvQ29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjLFxuICAgICAgICAgICAgdmlkZW9Db2RlYyA9IGxldmVsLnZpZGVvQ29kZWM7XG4gICAgICAgIHJldHVybiAoIWF1ZGlvQ29kZWMgfHwgY2hlY2tTdXBwb3J0ZWQoJ2F1ZGlvJywgYXVkaW9Db2RlYykpICYmICghdmlkZW9Db2RlYyB8fCBjaGVja1N1cHBvcnRlZCgndmlkZW8nLCB2aWRlb0NvZGVjKSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgLy8gc3RhcnQgYml0cmF0ZSBpcyB0aGUgZmlyc3QgYml0cmF0ZSBvZiB0aGUgbWFuaWZlc3RcbiAgICAgICAgYml0cmF0ZVN0YXJ0ID0gbGV2ZWxzWzBdLmJpdHJhdGU7XG4gICAgICAgIC8vIHNvcnQgbGV2ZWwgb24gYml0cmF0ZVxuICAgICAgICBsZXZlbHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLmJpdHJhdGUgLSBiLmJpdHJhdGU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9sZXZlbHMgPSBsZXZlbHM7XG4gICAgICAgIC8vIGZpbmQgaW5kZXggb2YgZmlyc3QgbGV2ZWwgaW4gc29ydGVkIGxldmVsc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChsZXZlbHNbaV0uYml0cmF0ZSA9PT0gYml0cmF0ZVN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJzdExldmVsID0gaTtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbWFuaWZlc3QgbG9hZGVkLCcgKyBsZXZlbHMubGVuZ3RoICsgJyBsZXZlbChzKSBmb3VuZCwgZmlyc3QgYml0cmF0ZTonICsgYml0cmF0ZVN0YXJ0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0Lk1BTklGRVNUX1BBUlNFRCwgeyBsZXZlbHM6IGxldmVscywgZmlyc3RMZXZlbDogdGhpcy5fZmlyc3RMZXZlbCwgc3RhdHM6IGRhdGEuc3RhdHMsIGF1ZGlvOiBhdWRpb0NvZGVjRm91bmQsIHZpZGVvOiB2aWRlb0NvZGVjRm91bmQsIGFsdEF1ZGlvOiBkYXRhLmF1ZGlvVHJhY2tzLmxlbmd0aCA+IDAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUiwgZmF0YWw6IHRydWUsIHVybDogaGxzLnVybCwgcmVhc29uOiAnbm8gbGV2ZWwgd2l0aCBjb21wYXRpYmxlIGNvZGVjcyBmb3VuZCBpbiBtYW5pZmVzdCcgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0TGV2ZWxJbnRlcm5hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExldmVsSW50ZXJuYWwobmV3TGV2ZWwpIHtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICAgIGlmIChuZXdMZXZlbCA+PSAwICYmIG5ld0xldmVsIDwgbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xldmVsICE9PSBuZXdMZXZlbCkge1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc3dpdGNoaW5nIHRvIGxldmVsICcgKyBuZXdMZXZlbCk7XG4gICAgICAgICAgdGhpcy5fbGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgICB2YXIgbGV2ZWxQcm9wZXJ0aWVzID0gbGV2ZWxzW25ld0xldmVsXTtcbiAgICAgICAgICBsZXZlbFByb3BlcnRpZXMubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgICAvLyBMRVZFTF9TV0lUQ0ggdG8gYmUgZGVwcmVjYXRlZCBpbiBuZXh0IG1ham9yIHJlbGVhc2VcbiAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkxFVkVMX1NXSVRDSCwgbGV2ZWxQcm9wZXJ0aWVzKTtcbiAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkxFVkVMX1NXSVRDSElORywgbGV2ZWxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdLFxuICAgICAgICAgICAgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGxldmVsXG4gICAgICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8IGxldmVsRGV0YWlscy5saXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gbGV2ZWwgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgICAgIHZhciB1cmxJZCA9IGxldmVsLnVybElkO1xuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuTEVWRUxfTE9BRElORywgeyB1cmw6IGxldmVsLnVybFt1cmxJZF0sIGxldmVsOiBuZXdMZXZlbCwgaWQ6IHVybElkIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbnZhbGlkIGxldmVsIGlkIGdpdmVuLCB0cmlnZ2VyIGVycm9yXG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5MRVZFTF9TV0lUQ0hfRVJST1IsIGxldmVsOiBuZXdMZXZlbCwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdpbnZhbGlkIGxldmVsIGlkeCcgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25FcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRXJyb3IoZGF0YSkge1xuICAgICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGV0YWlscyA9IGRhdGEuZGV0YWlscyxcbiAgICAgICAgICBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgICBsZXZlbElkID0gdm9pZCAwLFxuICAgICAgICAgIGxldmVsID0gdm9pZCAwLFxuICAgICAgICAgIGxldmVsRXJyb3IgPSBmYWxzZTtcbiAgICAgIC8vIHRyeSB0byByZWNvdmVyIG5vdCBmYXRhbCBlcnJvcnNcbiAgICAgIHN3aXRjaCAoZGV0YWlscykge1xuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5GUkFHX0xPT1BfTE9BRElOR19FUlJPUjpcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICAgIGxldmVsSWQgPSBkYXRhLmZyYWcubGV2ZWw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX2Vycm9ycy5FcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgbGV2ZWxJZCA9IGRhdGEuY29udGV4dC5sZXZlbDtcbiAgICAgICAgICBsZXZlbEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUjpcbiAgICAgICAgICBsZXZlbElkID0gZGF0YS5sZXZlbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIHRyeSB0byBzd2l0Y2ggdG8gYSByZWR1bmRhbnQgc3RyZWFtIGlmIGFueSBhdmFpbGFibGUuXG4gICAgICAgKiBpZiBubyByZWR1bmRhbnQgc3RyZWFtIGF2YWlsYWJsZSwgZW1lcmdlbmN5IHN3aXRjaCBkb3duIChpZiBpbiBhdXRvIG1vZGUgYW5kIGN1cnJlbnQgbGV2ZWwgbm90IDApXG4gICAgICAgKiBvdGhlcndpc2UsIHdlIGNhbm5vdCByZWNvdmVyIHRoaXMgbmV0d29yayBlcnJvciAuLi5cbiAgICAgICAqL1xuICAgICAgaWYgKGxldmVsSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbElkXTtcbiAgICAgICAgaWYgKCFsZXZlbC5sb2FkRXJyb3IpIHtcbiAgICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldmVsLmxvYWRFcnJvcisrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFueSByZWR1bmRhbnQgc3RyZWFtcyBhdmFpbGFibGUgYW5kIGlmIHdlIGhhdmVuJ3QgdHJ5IHRoZW0gYWxsIChsZXZlbC5sb2FkRXJyb3IgaXMgcmVzZXRlZCBvbiBzdWNjZXNzZnVsIGZyYWcvbGV2ZWwgbG9hZC5cbiAgICAgICAgLy8gaWYgbGV2ZWwubG9hZEVycm9yIHJlYWNoZXMgbmJSZWR1bmRhbnRMZXZlbCBpdCBtZWFucyB0aGF0IHdlIHRyaWVkIHRoZW0gYWxsLCBubyBob3BlICA9PiBsZXQncyBzd2l0Y2ggZG93blxuICAgICAgICB2YXIgbmJSZWR1bmRhbnRMZXZlbCA9IGxldmVsLnVybC5sZW5ndGg7XG4gICAgICAgIGlmIChuYlJlZHVuZGFudExldmVsID4gMSAmJiBsZXZlbC5sb2FkRXJyb3IgPCBuYlJlZHVuZGFudExldmVsKSB7XG4gICAgICAgICAgbGV2ZWwudXJsSWQgPSAobGV2ZWwudXJsSWQgKyAxKSAlIG5iUmVkdW5kYW50TGV2ZWw7XG4gICAgICAgICAgbGV2ZWwuZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdsZXZlbCBjb250cm9sbGVyLCcgKyBkZXRhaWxzICsgJyBmb3IgbGV2ZWwgJyArIGxldmVsSWQgKyAnOiBzd2l0Y2hpbmcgdG8gcmVkdW5kYW50IHN0cmVhbSBpZCAnICsgbGV2ZWwudXJsSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdlIGNvdWxkIHRyeSB0byByZWNvdmVyIGlmIGluIGF1dG8gbW9kZSBhbmQgY3VycmVudCBsZXZlbCBub3QgbG93ZXN0IGxldmVsICgwKVxuICAgICAgICAgIHZhciByZWNvdmVyYWJsZSA9IHRoaXMuX21hbnVhbExldmVsID09PSAtMSAmJiBsZXZlbElkO1xuICAgICAgICAgIGlmIChyZWNvdmVyYWJsZSkge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignbGV2ZWwgY29udHJvbGxlciwnICsgZGV0YWlscyArICc6IHN3aXRjaC1kb3duIGZvciBuZXh0IGZyYWdtZW50Jyk7XG4gICAgICAgICAgICBobHMubmV4dEF1dG9MZXZlbCA9IE1hdGgubWF4KDAsIGxldmVsSWQgLSAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxldmVsICYmIGxldmVsLmRldGFpbHMgJiYgbGV2ZWwuZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdsZXZlbCBjb250cm9sbGVyLCcgKyBkZXRhaWxzICsgJyBvbiBsaXZlIHN0cmVhbSwgZGlzY2FyZCcpO1xuICAgICAgICAgICAgaWYgKGxldmVsRXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gcmVzZXQgdGhpcy5fbGV2ZWwgc28gdGhhdCBhbm90aGVyIGNhbGwgdG8gc2V0IGxldmVsKCkgd2lsbCByZXRyaWdnZXIgYSBmcmFnIGxvYWRcbiAgICAgICAgICAgICAgdGhpcy5fbGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvdGhlciBlcnJvcnMgYXJlIGhhbmRsZWQgYnkgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAgICAgICB9IGVsc2UgaWYgKGRldGFpbHMgPT09IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1IgfHwgZGV0YWlscyA9PT0gX2Vycm9ycy5FcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUKSB7XG4gICAgICAgICAgICB2YXIgbWVkaWEgPSBobHMubWVkaWEsXG5cbiAgICAgICAgICAgIC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxuICAgICAgICAgICAgbWVkaWFCdWZmZXJlZCA9IG1lZGlhICYmIF9idWZmZXJIZWxwZXIyLmRlZmF1bHQuaXNCdWZmZXJlZChtZWRpYSwgbWVkaWEuY3VycmVudFRpbWUpICYmIF9idWZmZXJIZWxwZXIyLmRlZmF1bHQuaXNCdWZmZXJlZChtZWRpYSwgbWVkaWEuY3VycmVudFRpbWUgKyAwLjUpO1xuICAgICAgICAgICAgaWYgKG1lZGlhQnVmZmVyZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHJldHJ5RGVsYXkgPSBobHMuY29uZmlnLmxldmVsTG9hZGluZ1JldHJ5RGVsYXk7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2xldmVsIGNvbnRyb2xsZXIsJyArIGRldGFpbHMgKyAnLCBidXQgbWVkaWEgYnVmZmVyZWQsIHJldHJ5IGluICcgKyByZXRyeURlbGF5ICsgJ21zJyk7XG4gICAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMub250aWNrLCByZXRyeURlbGF5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmVycm9yKCdjYW5ub3QgcmVjb3ZlciAnICsgZGV0YWlscyArICcgZXJyb3InKTtcbiAgICAgICAgICAgICAgdGhpcy5fbGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyByZWRpc3BhdGNoIHNhbWUgZXJyb3IgYnV0IHdpdGggZmF0YWwgc2V0IHRvIHRydWVcbiAgICAgICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlc2V0IGxldmVsIGxvYWQgZXJyb3IgY291bnRlciBvbiBzdWNjZXNzZnVsIGZyYWcgbG9hZGVkXG5cbiAgfSwge1xuICAgIGtleTogJ29uRnJhZ0xvYWRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRnJhZ0xvYWRlZChkYXRhKSB7XG4gICAgICB2YXIgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcbiAgICAgIGlmIChmcmFnTG9hZGVkICYmIGZyYWdMb2FkZWQudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1tmcmFnTG9hZGVkLmxldmVsXTtcbiAgICAgICAgaWYgKGxldmVsKSB7XG4gICAgICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTGV2ZWxMb2FkZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkxldmVsTG9hZGVkKGRhdGEpIHtcbiAgICAgIHZhciBsZXZlbElkID0gZGF0YS5sZXZlbDtcbiAgICAgIC8vIG9ubHkgcHJvY2VzcyBsZXZlbCBsb2FkZWQgZXZlbnRzIG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgbGV2ZWxcbiAgICAgIGlmIChsZXZlbElkID09PSB0aGlzLl9sZXZlbCkge1xuICAgICAgICB2YXIgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxJZF07XG4gICAgICAgIC8vIHJlc2V0IGxldmVsIGxvYWQgZXJyb3IgY291bnRlciBvbiBzdWNjZXNzZnVsIGxldmVsIGxvYWRlZFxuICAgICAgICBjdXJMZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgICB2YXIgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgICAgLy8gaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3QsIGFybSBhIHRpbWVyIHRvIHJlbG9hZCBpdFxuICAgICAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgdmFyIHJlbG9hZEludGVydmFsID0gMTAwMCAqIChuZXdEZXRhaWxzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA/IG5ld0RldGFpbHMuYXZlcmFnZXRhcmdldGR1cmF0aW9uIDogbmV3RGV0YWlscy50YXJnZXRkdXJhdGlvbiksXG4gICAgICAgICAgICAgIGN1ckRldGFpbHMgPSBjdXJMZXZlbC5kZXRhaWxzO1xuICAgICAgICAgIGlmIChjdXJEZXRhaWxzICYmIG5ld0RldGFpbHMuZW5kU04gPT09IGN1ckRldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICAgIC8vIGZvbGxvdyBITFMgU3BlYywgSWYgdGhlIGNsaWVudCByZWxvYWRzIGEgUGxheWxpc3QgZmlsZSBhbmQgZmluZHMgdGhhdCBpdCBoYXMgbm90XG4gICAgICAgICAgICAvLyBjaGFuZ2VkIHRoZW4gaXQgTVVTVCB3YWl0IGZvciBhIHBlcmlvZCBvZiBvbmUtaGFsZiB0aGUgdGFyZ2V0XG4gICAgICAgICAgICAvLyBkdXJhdGlvbiBiZWZvcmUgcmV0cnlpbmcuXG4gICAgICAgICAgICByZWxvYWRJbnRlcnZhbCAvPSAyO1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzYW1lIGxpdmUgcGxheWxpc3QsIHJlbG9hZCB0d2ljZSBmYXN0ZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZGVjcmVtZW50IHJlbG9hZEludGVydmFsIHdpdGggbGV2ZWwgbG9hZGluZyBkZWxheVxuICAgICAgICAgIHJlbG9hZEludGVydmFsIC09IHBlcmZvcm1hbmNlLm5vdygpIC0gZGF0YS5zdGF0cy50cmVxdWVzdDtcbiAgICAgICAgICAvLyBpbiBhbnkgY2FzZSwgZG9uJ3QgcmVsb2FkIG1vcmUgdGhhbiBldmVyeSBzZWNvbmRcbiAgICAgICAgICByZWxvYWRJbnRlcnZhbCA9IE1hdGgubWF4KDEwMDAsIE1hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpKTtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QsIHJlbG9hZCBpbiAnICsgcmVsb2FkSW50ZXJ2YWwgKyAnIG1zJyk7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5vbnRpY2ssIHJlbG9hZEludGVydmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RpY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgdmFyIGxldmVsSWQgPSB0aGlzLl9sZXZlbDtcbiAgICAgIGlmIChsZXZlbElkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jYW5sb2FkKSB7XG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbElkXSxcbiAgICAgICAgICAgIHVybElkID0gbGV2ZWwudXJsSWQ7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5MRVZFTF9MT0FESU5HLCB7IHVybDogbGV2ZWwudXJsW3VybElkXSwgbGV2ZWw6IGxldmVsSWQsIGlkOiB1cmxJZCB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsZXZlbHMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xldmVscztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGV2ZWw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICAgIGlmIChsZXZlbHMgJiYgbGV2ZWxzLmxlbmd0aCA+IG5ld0xldmVsKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZXZlbCAhPT0gbmV3TGV2ZWwgfHwgbGV2ZWxzW25ld0xldmVsXS5kZXRhaWxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnNldExldmVsSW50ZXJuYWwobmV3TGV2ZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWFudWFsTGV2ZWwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hbnVhbExldmVsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIHRoaXMuX21hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZpcnN0TGV2ZWwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0YXJ0TGV2ZWwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gaGxzLnN0YXJ0TGV2ZWwgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGNvbmZpZy5zdGFydExldmVsXG4gICAgICAvLyBpZiBub25lIG9mIHRoZXNlIHZhbHVlcyBhcmUgZGVmaW5lZCwgZmFsbGJhY2sgb24gdGhpcy5fZmlyc3RMZXZlbCAoZmlyc3QgcXVhbGl0eSBsZXZlbCBhcHBlYXJpbmcgaW4gdmFyaWFudCBtYW5pZmVzdClcbiAgICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGNvbmZpZ1N0YXJ0TGV2ZWwgPSB0aGlzLmhscy5jb25maWcuc3RhcnRMZXZlbDtcbiAgICAgICAgaWYgKGNvbmZpZ1N0YXJ0TGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjb25maWdTdGFydExldmVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRMZXZlbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICB0aGlzLl9zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbmV4dExvYWRMZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5fbWFudWFsTGV2ZWwgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYW51YWxMZXZlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhscy5uZXh0QXV0b0xldmVsO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV4dExldmVsKSB7XG4gICAgICB0aGlzLmxldmVsID0gbmV4dExldmVsO1xuICAgICAgaWYgKHRoaXMuX21hbnVhbExldmVsID09PSAtMSkge1xuICAgICAgICB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMZXZlbENvbnRyb2xsZXI7XG59KF9ldmVudEhhbmRsZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMZXZlbENvbnRyb2xsZXI7XG5cbn0se1wiMzFcIjozMSxcIjMyXCI6MzIsXCIzM1wiOjMzLFwiMzVcIjozNSxcIjUwXCI6NTB9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfYmluYXJ5U2VhcmNoID0gX2RlcmVxXyg0Nik7XG5cbnZhciBfYmluYXJ5U2VhcmNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpbmFyeVNlYXJjaCk7XG5cbnZhciBfYnVmZmVySGVscGVyID0gX2RlcmVxXygzNSk7XG5cbnZhciBfYnVmZmVySGVscGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1ZmZlckhlbHBlcik7XG5cbnZhciBfZGVtdXhlciA9IF9kZXJlcV8oMjUpO1xuXG52YXIgX2RlbXV4ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVtdXhlcik7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZXZlbnRIYW5kbGVyID0gX2RlcmVxXygzMik7XG5cbnZhciBfZXZlbnRIYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50SGFuZGxlcik7XG5cbnZhciBfbGV2ZWxIZWxwZXIgPSBfZGVyZXFfKDM2KTtcblxudmFyIF9sZXZlbEhlbHBlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sZXZlbEhlbHBlcik7XG5cbnZhciBfdGltZVJhbmdlcyA9IF9kZXJlcV8oNTEpO1xuXG52YXIgX3RpbWVSYW5nZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZVJhbmdlcyk7XG5cbnZhciBfZXJyb3JzID0gX2RlcmVxXygzMSk7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFN0cmVhbSBDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgU3RhdGUgPSB7XG4gIFNUT1BQRUQ6ICdTVE9QUEVEJyxcbiAgSURMRTogJ0lETEUnLFxuICBLRVlfTE9BRElORzogJ0tFWV9MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HOiAnRlJBR19MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6ICdGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWScsXG4gIFdBSVRJTkdfTEVWRUw6ICdXQUlUSU5HX0xFVkVMJyxcbiAgUEFSU0lORzogJ1BBUlNJTkcnLFxuICBQQVJTRUQ6ICdQQVJTRUQnLFxuICBCVUZGRVJfRkxVU0hJTkc6ICdCVUZGRVJfRkxVU0hJTkcnLFxuICBFTkRFRDogJ0VOREVEJyxcbiAgRVJST1I6ICdFUlJPUidcbn07XG5cbnZhciBTdHJlYW1Db250cm9sbGVyID0gZnVuY3Rpb24gKF9FdmVudEhhbmRsZXIpIHtcbiAgX2luaGVyaXRzKFN0cmVhbUNvbnRyb2xsZXIsIF9FdmVudEhhbmRsZXIpO1xuXG4gIGZ1bmN0aW9uIFN0cmVhbUNvbnRyb2xsZXIoaGxzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmVhbUNvbnRyb2xsZXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFN0cmVhbUNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJlYW1Db250cm9sbGVyKSkuY2FsbCh0aGlzLCBobHMsIF9ldmVudHMyLmRlZmF1bHQuTUVESUFfQVRUQUNIRUQsIF9ldmVudHMyLmRlZmF1bHQuTUVESUFfREVUQUNISU5HLCBfZXZlbnRzMi5kZWZhdWx0Lk1BTklGRVNUX0xPQURJTkcsIF9ldmVudHMyLmRlZmF1bHQuTUFOSUZFU1RfUEFSU0VELCBfZXZlbnRzMi5kZWZhdWx0LkxFVkVMX0xPQURFRCwgX2V2ZW50czIuZGVmYXVsdC5LRVlfTE9BREVELCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfTE9BREVELCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwgX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19EQVRBLCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0VELCBfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCBfZXZlbnRzMi5kZWZhdWx0LkFVRElPX1RSQUNLX1NXSVRDSElORywgX2V2ZW50czIuZGVmYXVsdC5BVURJT19UUkFDS19TV0lUQ0hFRCwgX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfQ1JFQVRFRCwgX2V2ZW50czIuZGVmYXVsdC5CVUZGRVJfQVBQRU5ERUQsIF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0ZMVVNIRUQpKTtcblxuICAgIF90aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgX3RoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICBfdGhpcy50aWNrcyA9IDA7XG4gICAgX3RoaXMuX3N0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICBfdGhpcy5vbnRpY2sgPSBfdGhpcy50aWNrLmJpbmQoX3RoaXMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdHJlYW1Db250cm9sbGVyLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICBfZXZlbnRIYW5kbGVyMi5kZWZhdWx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGFydExvYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgICAgaWYgKHRoaXMubGV2ZWxzKSB7XG4gICAgICAgIHZhciBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZSxcbiAgICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9udGljaywgMTAwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAvLyBkZXRlcm1pbmUgbG9hZCBsZXZlbFxuICAgICAgICAgIHZhciBzdGFydExldmVsID0gaGxzLnN0YXJ0TGV2ZWw7XG4gICAgICAgICAgaWYgKHN0YXJ0TGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyAtMSA6IGd1ZXNzIHN0YXJ0IExldmVsIGJ5IGRvaW5nIGEgYml0cmF0ZSB0ZXN0IGJ5IGxvYWRpbmcgZmlyc3QgZnJhZ21lbnQgb2YgbG93ZXN0IHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICAgIHN0YXJ0TGV2ZWwgPSAwO1xuICAgICAgICAgICAgdGhpcy5iaXRyYXRlVGVzdCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNldCBuZXcgbGV2ZWwgdG8gcGxheWxpc3QgbG9hZGVyIDogdGhpcyB3aWxsIHRyaWdnZXIgc3RhcnQgbGV2ZWwgbG9hZFxuICAgICAgICAgIC8vIGhscy5uZXh0TG9hZExldmVsIHJlbWFpbnMgdW50aWwgaXQgaXMgc2V0IHRvIGEgbmV3IHZhbHVlIG9yIHVudGlsIGEgbmV3IGZyYWcgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZFxuICAgICAgICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IHN0YXJ0TGV2ZWw7XG4gICAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gdW5kZWZpbmVkIGJ1dCBsYXN0Q3VycmVudFRpbWUgc2V0LCBzZXQgc3RhcnRQb3NpdGlvbiB0byBsYXN0IGN1cnJlbnRUaW1lXG4gICAgICAgIGlmIChsYXN0Q3VycmVudFRpbWUgPiAwICYmIHN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdvdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAnICsgbGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMykpO1xuICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSBsYXN0Q3VycmVudFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdjYW5ub3Qgc3RhcnQgbG9hZGluZyBhcyBtYW5pZmVzdCBub3QgcGFyc2VkIHlldCcpO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdG9wTG9hZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgICAgdmFyIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgaWYgKGZyYWcubG9hZGVyKSB7XG4gICAgICAgICAgZnJhZy5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RpY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgdGhpcy50aWNrcysrO1xuICAgICAgaWYgKHRoaXMudGlja3MgPT09IDEpIHtcbiAgICAgICAgdGhpcy5kb1RpY2soKTtcbiAgICAgICAgaWYgKHRoaXMudGlja3MgPiAxKSB7XG4gICAgICAgICAgc2V0VGltZW91dCh0aGlzLnRpY2ssIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlja3MgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RvVGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvVGljaygpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICBjYXNlIFN0YXRlLkVSUk9SOlxuICAgICAgICAgIC8vZG9uJ3QgZG8gYW55dGhpbmcgaW4gZXJyb3Igc3RhdGUgdG8gYXZvaWQgYnJlYWtpbmcgZnVydGhlciAuLi5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc6XG4gICAgICAgICAgLy8gaW4gYnVmZmVyIGZsdXNoaW5nIHN0YXRlLCByZXNldCBmcmFnTG9hZEVycm9yIGNvdW50ZXJcbiAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN0YXRlLklETEU6XG4gICAgICAgICAgLy8gd2hlbiB0aGlzIHJldHVybnMgZmFsc2UgdGhlcmUgd2FzIGFuIGVycm9yIGFuZCB3ZSBzaGFsbCByZXR1cm4gaW1tZWRpYXRseVxuICAgICAgICAgIC8vIGZyb20gY3VycmVudCB0aWNrXG4gICAgICAgICAgaWYgKCF0aGlzLl9kb1RpY2tJZGxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19MRVZFTDpcbiAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXTtcbiAgICAgICAgICAvLyBjaGVjayBpZiBwbGF5bGlzdCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgICAgIGlmIChsZXZlbCAmJiBsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIHZhciByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICAgIGlmICghcmV0cnlEYXRlIHx8IG5vdyA+PSByZXRyeURhdGUgfHwgdGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbWVkaWFDb250cm9sbGVyOiByZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZScpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN0YXRlLkVSUk9SOlxuICAgICAgICBjYXNlIFN0YXRlLlNUT1BQRUQ6XG4gICAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxuICAgICAgICBjYXNlIFN0YXRlLlBBUlNJTkc6XG4gICAgICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxuICAgICAgICBjYXNlIFN0YXRlLkVOREVEOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgYnVmZmVyXG4gICAgICB0aGlzLl9jaGVja0J1ZmZlcigpO1xuICAgICAgLy8gY2hlY2svdXBkYXRlIGN1cnJlbnQgZnJhZ21lbnRcbiAgICAgIHRoaXMuX2NoZWNrRnJhZ21lbnRDaGFuZ2VkKCk7XG4gICAgfVxuXG4gICAgLy8gSXJvbmljYWxseSB0aGUgXCJpZGxlXCIgc3RhdGUgaXMgdGhlIG9uIHdlIGRvIHRoZSBtb3N0IGxvZ2ljIGluIGl0IHNlZW1zIC4uLi5cbiAgICAvLyBOT1RFOiBNYXliZSB3ZSBjb3VsZCByYXRoZXIgc2NoZWR1bGUgYSBjaGVjayBmb3IgYnVmZmVyIGxlbmd0aCBhZnRlciBoYWxmIG9mIHRoZSBjdXJyZW50bHlcbiAgICAvLyAgICAgICBwbGF5ZWQgc2VnbWVudCwgb3Igb24gcGF1c2UvcGxheS9zZWVrIGluc3RlYWQgb2YgbmFpdmVseSBjaGVja2luZyBldmVyeSAxMDBtcz9cblxuICB9LCB7XG4gICAga2V5OiAnX2RvVGlja0lkbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZG9UaWNrSWRsZSgpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgICBjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORFxuICAgICAgLy8gc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBkaXNhYmxlXG4gICAgICAvLyBleGl0IGxvb3BcbiAgICAgIC8vID0+IGlmIHN0YXJ0IGxldmVsIGxvYWRlZCBhbmQgbWVkaWEgbm90IGF0dGFjaGVkIGJ1dCBzdGFydCBmcmFnIHByZWZldGNoIGlzIGVuYWJsZWQgYW5kIHN0YXJ0IGZyYWcgbm90IHJlcXVlc3RlZCB5ZXQsIHdlIHdpbGwgbm90IGV4aXQgbG9vcFxuICAgICAgaWYgKHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSB1bmRlZmluZWQgJiYgIW1lZGlhICYmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgICAgdmFyIHBvcyA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgIHBvcyA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgLy8gZGV0ZXJtaW5lIG5leHQgbG9hZCBsZXZlbFxuICAgICAgdmFyIGxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwsXG4gICAgICAgICAgbGV2ZWxJbmZvID0gdGhpcy5sZXZlbHNbbGV2ZWxdLFxuICAgICAgICAgIGxldmVsQml0cmF0ZSA9IGxldmVsSW5mby5iaXRyYXRlLFxuICAgICAgICAgIG1heEJ1ZkxlbiA9IHZvaWQgMDtcblxuICAgICAgLy8gY29tcHV0ZSBtYXggQnVmZmVyIExlbmd0aCB0aGF0IHdlIGNvdWxkIGdldCBmcm9tIHRoaXMgbG9hZCBsZXZlbCwgYmFzZWQgb24gbGV2ZWwgYml0cmF0ZS4gZG9uJ3QgYnVmZmVyIG1vcmUgdGhhbiA2MCBNQiBhbmQgbW9yZSB0aGFuIDMwc1xuICAgICAgaWYgKGxldmVsQml0cmF0ZSkge1xuICAgICAgICBtYXhCdWZMZW4gPSBNYXRoLm1heCg4ICogY29uZmlnLm1heEJ1ZmZlclNpemUgLyBsZXZlbEJpdHJhdGUsIGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4QnVmTGVuID0gY29uZmlnLm1heEJ1ZmZlckxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWluKG1heEJ1ZkxlbiwgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCk7XG5cbiAgICAgIC8vIGRldGVybWluZSBuZXh0IGNhbmRpZGF0ZSBmcmFnbWVudCB0byBiZSBsb2FkZWQsIGJhc2VkIG9uIGN1cnJlbnQgcG9zaXRpb24gYW5kIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgIC8vIGVuc3VyZSB1cCB0byBgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aGAgb2YgYnVmZmVyIHVwZnJvbnRcblxuICAgICAgdmFyIGJ1ZmZlckluZm8gPSBfYnVmZmVySGVscGVyMi5kZWZhdWx0LmJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiBtZWRpYSwgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSksXG4gICAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG4gICAgICAvLyBTdGF5IGlkbGUgaWYgd2UgYXJlIHN0aWxsIHdpdGggYnVmZmVyIG1hcmdpbnNcbiAgICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnQgLi4uXG4gICAgICBfbG9nZ2VyLmxvZ2dlci50cmFjZSgnYnVmZmVyIGxlbmd0aCBvZiAnICsgYnVmZmVyTGVuLnRvRml4ZWQoMykgKyAnIGlzIGJlbG93IG1heCBvZiAnICsgbWF4QnVmTGVuLnRvRml4ZWQoMykgKyAnLiBjaGVja2luZyBmb3IgbW9yZSBwYXlsb2FkIC4uLicpO1xuXG4gICAgICAvLyBzZXQgbmV4dCBsb2FkIGxldmVsIDogdGhpcyB3aWxsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkIGlmIG5lZWRlZFxuICAgICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG5cbiAgICAgIHZhciBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcbiAgICAgIC8vIGlmIGxldmVsIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgbGV2ZWwgcmV0cmlldmFsXG4gICAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcbiAgICAgIC8vIGEgdXNlbGVzcyBhbmQgb3V0ZGF0ZWQgZnJhZ21lbnQgKHRoYXQgbWlnaHQgZXZlbiBpbnRyb2R1Y2UgbG9hZCBlcnJvciBpZiBpdCBpcyBhbHJlYWR5IG91dCBvZiB0aGUgbGl2ZSBwbGF5bGlzdClcbiAgICAgIGlmICh0eXBlb2YgbGV2ZWxEZXRhaWxzID09PSAndW5kZWZpbmVkJyB8fCBsZXZlbERldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfTEVWRUw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBqdXN0IGdvdCBkb25lIGxvYWRpbmcgdGhlIGZpbmFsIGZyYWdtZW50LCBjaGVjayBpZiB3ZSBuZWVkIHRvIGZpbmFsaXplIG1lZGlhIHN0cmVhbVxuICAgICAgdmFyIGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgICAgaWYgKCFsZXZlbERldGFpbHMubGl2ZSAmJiBmcmFnUHJldmlvdXMgJiYgZnJhZ1ByZXZpb3VzLnNuID09PSBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgLy8gaWYgZXZlcnl0aGluZyAoYWxtb3N0KSB0aWwgdGhlIGVuZCBpcyBidWZmZXJlZCwgbGV0J3Mgc2lnbmFsIGVvc1xuICAgICAgICAvLyB3ZSBkb24ndCBjb21wYXJlIGV4YWN0bHkgbWVkaWEuZHVyYXRpb24gPT09IGJ1ZmZlckluZm8uZW5kIGFzIHRoZXJlIGNvdWxkIGJlIHNvbWUgc3VidGxlIG1lZGlhIGR1cmF0aW9uIGRpZmZlcmVuY2VcbiAgICAgICAgLy8gdXNpbmcgaGFsZiBmcmFnIGR1cmF0aW9uIHNob3VsZCBoZWxwIGNvcGUgd2l0aCB0aGVzZSBjYXNlcy5cbiAgICAgICAgLy8gYWxzbyBjb3BlIHdpdGggYWxtb3N0IHplcm8gbGFzdCBmcmFnIGR1cmF0aW9uIChtYXggbGFzdCBmcmFnIGR1cmF0aW9uIHdpdGggMjAwbXMpIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9kYWlseW1vdGlvbi9obHMuanMvcHVsbC82NTdcbiAgICAgICAgaWYgKG1lZGlhLmR1cmF0aW9uIC0gTWF0aC5tYXgoYnVmZmVySW5mby5lbmQsIGZyYWdQcmV2aW91cy5zdGFydCkgPD0gTWF0aC5tYXgoMC4yLCBmcmFnUHJldmlvdXMuZHVyYXRpb24gLyAyKSkge1xuICAgICAgICAgIC8vIEZpbmFsaXplIHRoZSBtZWRpYSBzdHJlYW1cbiAgICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICAgICAgICBkYXRhLnR5cGUgPSAndmlkZW8nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0VPUywgZGF0YSk7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgdGhlIGxldmVsRGV0YWlscyBmb3IgdGhlIHNlbGVjdGVkIHZhcmlhbnQsIGxldHMgY29udGludWUgZW5yaWNoZW4gb3VyIHN0cmVhbSAobG9hZCBrZXlzL2ZyYWdtZW50cyBvciB0cmlnZ2VyIEVPUywgZXRjLi4pXG4gICAgICByZXR1cm4gdGhpcy5fZmV0Y2hQYXlsb2FkT3JFb3MocG9zLCBidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19mZXRjaFBheWxvYWRPckVvcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9mZXRjaFBheWxvYWRPckVvcyhwb3MsIGJ1ZmZlckluZm8sIGxldmVsRGV0YWlscykge1xuICAgICAgdmFyIGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzLFxuICAgICAgICAgIGxldmVsID0gdGhpcy5sZXZlbCxcbiAgICAgICAgICBmcmFnbWVudHMgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzLFxuICAgICAgICAgIGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuXG4gICAgICAvLyBlbXB0eSBwbGF5bGlzdFxuICAgICAgaWYgKGZyYWdMZW4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBmaW5kIGZyYWdtZW50IGluZGV4LCBjb250aWd1b3VzIHdpdGggZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgICAgdmFyIHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLmR1cmF0aW9uLFxuICAgICAgICAgIGJ1ZmZlckVuZCA9IGJ1ZmZlckluZm8uZW5kLFxuICAgICAgICAgIGZyYWcgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQgJiYgIWxldmVsRGV0YWlscy5pbml0U2VnbWVudC5kYXRhKSB7XG4gICAgICAgIGZyYWcgPSBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbiBjYXNlIG9mIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgbm90IGxvY2F0ZWQgYmVmb3JlIHBsYXlsaXN0IHN0YXJ0XG4gICAgICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICAgIHZhciBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSA9IHRoaXMuY29uZmlnLmluaXRpYWxMaXZlTWFuaWZlc3RTaXplO1xuICAgICAgICAgIGlmIChmcmFnTGVuIDwgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUpIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ0NhbiBub3Qgc3RhcnQgcGxheWJhY2sgb2YgYSBsZXZlbCwgcmVhc29uOiBub3QgZW5vdWdoIGZyYWdtZW50cyAnICsgZnJhZ0xlbiArICcgPCAnICsgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZyYWcgPSB0aGlzLl9lbnN1cmVGcmFnbWVudEF0TGl2ZVBvaW50KGxldmVsRGV0YWlscywgYnVmZmVyRW5kLCBzdGFydCwgZW5kLCBmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgZnJhZ0xlbik7XG4gICAgICAgICAgLy8gaWYgaXQgZXhwbGljaXRlbHkgcmV0dXJucyBudWxsIGRvbid0IGxvYWQgYW55IGZyYWdtZW50IGFuZCBleGl0IGZ1bmN0aW9uIG5vd1xuICAgICAgICAgIGlmIChmcmFnID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFZvRCBwbGF5bGlzdDogaWYgYnVmZmVyRW5kIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgICAgIGlmIChidWZmZXJFbmQgPCBzdGFydCkge1xuICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZnJhZykge1xuICAgICAgICBmcmFnID0gdGhpcy5fZmluZEZyYWdtZW50KHN0YXJ0LCBmcmFnUHJldmlvdXMsIGZyYWdMZW4sIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlscyk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZEZyYWdtZW50T3JLZXkoZnJhZywgbGV2ZWwsIGxldmVsRGV0YWlscywgcG9zLCBidWZmZXJFbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2Vuc3VyZUZyYWdtZW50QXRMaXZlUG9pbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5zdXJlRnJhZ21lbnRBdExpdmVQb2ludChsZXZlbERldGFpbHMsIGJ1ZmZlckVuZCwgc3RhcnQsIGVuZCwgZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGZyYWdMZW4pIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWcsXG4gICAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgICB2YXIgZnJhZyA9IHZvaWQgMDtcblxuICAgICAgLy8gY2hlY2sgaWYgcmVxdWVzdGVkIHBvc2l0aW9uIGlzIHdpdGhpbiBzZWVrYWJsZSBib3VuZGFyaWVzIDpcbiAgICAgIC8vbG9nZ2VyLmxvZyhgc3RhcnQvcG9zL2J1ZkVuZC9zZWVraW5nOiR7c3RhcnQudG9GaXhlZCgzKX0vJHtwb3MudG9GaXhlZCgzKX0vJHtidWZmZXJFbmQudG9GaXhlZCgzKX0vJHt0aGlzLm1lZGlhLnNlZWtpbmd9YCk7XG4gICAgICB2YXIgbWF4TGF0ZW5jeSA9IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA6IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG5cbiAgICAgIGlmIChidWZmZXJFbmQgPCBNYXRoLm1heChzdGFydCAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBlbmQgLSBtYXhMYXRlbmN5KSkge1xuICAgICAgICB2YXIgbGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMubGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzdGFydCwgbGV2ZWxEZXRhaWxzKTtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdidWZmZXIgZW5kOiAnICsgYnVmZmVyRW5kLnRvRml4ZWQoMykgKyAnIGlzIGxvY2F0ZWQgdG9vIGZhciBmcm9tIHRoZSBlbmQgb2YgbGl2ZSBzbGlkaW5nIHBsYXlsaXN0LCByZXNldCBjdXJyZW50VGltZSB0byA6ICcgKyBsaXZlU3luY1Bvc2l0aW9uLnRvRml4ZWQoMykpO1xuICAgICAgICBidWZmZXJFbmQgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICBpZiAobWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSAmJiBtZWRpYS5kdXJhdGlvbiA+IGxpdmVTeW5jUG9zaXRpb24pIHtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgZW5kIG9mIGJ1ZmZlciBncmVhdGVyIHRoYW4gbGl2ZSBlZGdlLCBkb24ndCBsb2FkIGFueSBmcmFnbWVudFxuICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaWYgbGl2ZSBwbGF5bGlzdCBpbnRlcm1pdHRlbnRseSBzbGlkZXMgaW4gdGhlIHBhc3QuXG4gICAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYxLDE4MjU4MDE2N11cbiAgICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjIsMTgyNTgwMTY5XVxuICAgICAgLy8gTG9hZGluZyAxODI1ODAxNjggb2YgWzE4MjU4MDE2MiAsMTgyNTgwMTY5XSxsZXZlbCAxIC4uXG4gICAgICAvLyBMb2FkaW5nIDE4MjU4MDE2OSBvZiBbMTgyNTgwMTYyICwxODI1ODAxNjldLGxldmVsIDEgLi5cbiAgICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjIsMTgyNTgwMTY4XSA8PT09PT09PT09PT09PSBoZXJlIHdlIHNob3VsZCBoYXZlIGJ1ZmZlckVuZCA+IGVuZC4gaW4gdGhhdCBjYXNlIGJyZWFrIHRvIGF2b2lkIHJlbG9hZGluZyAxODI1ODAxNjhcbiAgICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjQsMTgyNTgwMTcxXVxuICAgICAgLy9cbiAgICAgIC8vIGRvbid0IHJldHVybiBudWxsIGluIGNhc2UgbWVkaWEgbm90IGxvYWRlZCB5ZXQgKHJlYWR5c3RhdGUgPT09IDApXG4gICAgICBpZiAobGV2ZWxEZXRhaWxzLlBUU0tub3duICYmIGJ1ZmZlckVuZCA+IGVuZCAmJiBtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgIWxldmVsRGV0YWlscy5QVFNLbm93bikge1xuICAgICAgICAvKiB3ZSBhcmUgc3dpdGNoaW5nIGxldmVsIG9uIGxpdmUgcGxheWxpc3QsIGJ1dCB3ZSBkb24ndCBoYXZlIGFueSBQVFMgaW5mbyBmb3IgdGhhdCBxdWFsaXR5IGxldmVsIC4uLlxuICAgICAgICAgICB0cnkgdG8gbG9hZCBmcmFnIG1hdGNoaW5nIHdpdGggbmV4dCBTTi5cbiAgICAgICAgICAgZXZlbiBpZiBTTiBhcmUgbm90IHN5bmNocm9uaXplZCBiZXR3ZWVuIHBsYXlsaXN0cywgbG9hZGluZyB0aGlzIGZyYWcgd2lsbCBoZWxwIHVzXG4gICAgICAgICAgIGNvbXB1dGUgcGxheWxpc3Qgc2xpZGluZyBhbmQgZmluZCB0aGUgcmlnaHQgb25lIGFmdGVyIGluIGNhc2UgaXQgd2FzIG5vdCB0aGUgcmlnaHQgY29uc2VjdXRpdmUgb25lICovXG4gICAgICAgIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0U04gPSBmcmFnUHJldmlvdXMuc24gKyAxO1xuICAgICAgICAgIGlmICh0YXJnZXRTTiA+PSBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiB0YXJnZXRTTiA8PSBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbdGFyZ2V0U04gLSBsZXZlbERldGFpbHMuc3RhcnRTTl07XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggbmV4dCBTTjogJyArIGZyYWcuc24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgICAvKiB3ZSBoYXZlIG5vIGlkZWEgYWJvdXQgd2hpY2ggZnJhZ21lbnQgc2hvdWxkIGJlIGxvYWRlZC5cbiAgICAgICAgICAgICBzbyBsZXQncyBsb2FkIG1pZCBmcmFnbWVudC4gaXQgd2lsbCBoZWxwIGNvbXB1dGluZyBwbGF5bGlzdCBzbGlkaW5nIGFuZCBmaW5kIHRoZSByaWdodCBvbmVcbiAgICAgICAgICAqL1xuICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbTWF0aC5taW4oZnJhZ0xlbiAtIDEsIE1hdGgucm91bmQoZnJhZ0xlbiAvIDIpKV07XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIHVua25vd24sIGxvYWQgbWlkZGxlIGZyYWcgOiAnICsgZnJhZy5zbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmFnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19maW5kRnJhZ21lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEZyYWdtZW50KHN0YXJ0LCBmcmFnUHJldmlvdXMsIGZyYWdMZW4sIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlscykge1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICAgIHZhciBmcmFnID0gdm9pZCAwO1xuICAgICAgdmFyIGZvdW5kRnJhZyA9IHZvaWQgMDtcbiAgICAgIHZhciBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICB2YXIgZnJhZ05leHQgPSBmcmFnUHJldmlvdXMgPyBmcmFnbWVudHNbZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuICsgMV0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0ID0gZnVuY3Rpb24gZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGNhbmRpZGF0ZSkge1xuICAgICAgICAvLyBvZmZzZXQgc2hvdWxkIGJlIHdpdGhpbiBmcmFnbWVudCBib3VuZGFyeSAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gICAgICAgIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxuICAgICAgICAvLyBidWZmZXJFbmQgPSA5Ljk5MVxuICAgICAgICAvLyBmcmFnW8OYXSA6IFswLDEwXVxuICAgICAgICAvLyBmcmFnWzFdIDogWzEwLDIwXVxuICAgICAgICAvLyBidWZmZXJFbmQgaXMgd2l0aGluIGZyYWdbMF0gcmFuZ2UgLi4uIGFsdGhvdWdoIHdoYXQgd2UgYXJlIGV4cGVjdGluZyBpcyB0byByZXR1cm4gZnJhZ1sxXSBoZXJlXG4gICAgICAgIC8vICAgICAgICAgICAgICBmcmFnIHN0YXJ0ICAgICAgICAgICAgICAgZnJhZyBzdGFydCtkdXJhdGlvblxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAgICAgLy8gICAgICAgICAgICAgIDwtLS0+ICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0+XG4gICAgICAgIC8vICAuLi4tLS0tLS0tLT48LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+PC0tLS0tLS0tLS4uLi5cbiAgICAgICAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gICAgICAgIC8vICByZXR1cm4gLTEgICAgICAgICAgICAgcmV0dXJuIDAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIC8vbG9nZ2VyLmxvZyhgbGV2ZWwvc24vc3RhcnQvZW5kL2J1ZkVuZDoke2xldmVsfS8ke2NhbmRpZGF0ZS5zbn0vJHtjYW5kaWRhdGUuc3RhcnR9LyR7KGNhbmRpZGF0ZS5zdGFydCtjYW5kaWRhdGUuZHVyYXRpb24pfS8ke2J1ZmZlckVuZH1gKTtcbiAgICAgICAgLy8gU2V0IHRoZSBsb29rdXAgdG9sZXJhbmNlIHRvIGJlIHNtYWxsIGVub3VnaCB0byBkZXRlY3QgdGhlIGN1cnJlbnQgc2VnbWVudCAtIGVuc3VyZXMgd2UgZG9uJ3Qgc2tpcCBvdmVyIHZlcnkgc21hbGwgc2VnbWVudHNcbiAgICAgICAgdmFyIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbik7XG4gICAgICAgIGlmIChjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPD0gYnVmZmVyRW5kKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gLy8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9O1xuXG4gICAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICAgIGlmIChidWZmZXJFbmQgPiBlbmQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlZmVyIHRoZSBuZXh0IGZyYWdtZW50IGlmIGl0J3Mgd2l0aGluIHRvbGVyYW5jZVxuICAgICAgICBpZiAoZnJhZ05leHQgJiYgIWZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChmcmFnTmV4dCkpIHtcbiAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnTmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3VuZEZyYWcgPSBfYmluYXJ5U2VhcmNoMi5kZWZhdWx0LnNlYXJjaChmcmFnbWVudHMsIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxuICAgICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdO1xuICAgICAgfVxuICAgICAgaWYgKGZvdW5kRnJhZykge1xuICAgICAgICBmcmFnID0gZm91bmRGcmFnO1xuICAgICAgICB2YXIgY3VyU05JZHggPSBmcmFnLnNuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICAgIHZhciBzYW1lTGV2ZWwgPSBmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsO1xuICAgICAgICB2YXIgcHJldkZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHggLSAxXTtcbiAgICAgICAgdmFyIG5leHRGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4ICsgMV07XG4gICAgICAgIC8vbG9nZ2VyLmxvZygnZmluZCBTTiBtYXRjaGluZyB3aXRoIHBvczonICsgIGJ1ZmZlckVuZCArICc6JyArIGZyYWcuc24pO1xuICAgICAgICBpZiAoc2FtZUxldmVsICYmIGZyYWcuc24gPT09IGZyYWdQcmV2aW91cy5zbikge1xuICAgICAgICAgIGlmIChmcmFnLnNuIDwgbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGFQVFMgPSBmcmFnUHJldmlvdXMuZGVsdGFQVFM7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNpZ25pZmljYW50IGRlbHRhIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBsYXJnZXIgdGhhbiBtYXggYWxsb3dlZCBob2xlLFxuICAgICAgICAgICAgLy8gYW5kIGlmIHByZXZpb3VzIHJlbXV4ZWQgZnJhZ21lbnQgZGlkIG5vdCBzdGFydCB3aXRoIGEga2V5ZnJhbWUuIChmcmFnUHJldmlvdXMuZHJvcHBlZClcbiAgICAgICAgICAgIC8vIGxldCdzIHRyeSB0byBsb2FkIHByZXZpb3VzIGZyYWdtZW50IGFnYWluIHRvIGdldCBsYXN0IGtleWZyYW1lXG4gICAgICAgICAgICAvLyB0aGVuIHdlIHdpbGwgcmVsb2FkIGFnYWluIGN1cnJlbnQgZnJhZ21lbnQgKHRoYXQgd2F5IHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpbGwgdGhlIGJ1ZmZlciBob2xlIC4uLilcbiAgICAgICAgICAgIGlmIChkZWx0YVBUUyAmJiBkZWx0YVBUUyA+IGNvbmZpZy5tYXhCdWZmZXJIb2xlICYmIGZyYWdQcmV2aW91cy5kcm9wcGVkICYmIGN1clNOSWR4KSB7XG4gICAgICAgICAgICAgIGZyYWcgPSBwcmV2RnJhZztcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignU04ganVzdCBsb2FkZWQsIHdpdGggbGFyZ2UgUFRTIGdhcCBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbywgbWF5YmUgZnJhZyBpcyBub3Qgc3RhcnRpbmcgd2l0aCBhIGtleWZyYW1lID8gbG9hZCBwcmV2aW91cyBvbmUgdG8gdHJ5IHRvIG92ZXJjb21lIHRoaXMnKTtcbiAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IHByZXZpb3VzIGZyYWcgbG9hZCBjb3VudGVyIHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIHdoZW4gbmV4dCBmcmFnbWVudCB3aWxsIGdldCByZWxvYWRlZFxuICAgICAgICAgICAgICBmcmFnUHJldmlvdXMubG9hZENvdW50ZXItLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZyYWcgPSBuZXh0RnJhZztcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdTTiBqdXN0IGxvYWRlZCwgbG9hZCBuZXh0IG9uZTogJyArIGZyYWcuc24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZnJhZy5kcm9wcGVkICYmICFzYW1lTGV2ZWwpIHtcbiAgICAgICAgICAvLyBPbmx5IGJhY2t0cmFjayBhIG1heCBvZiAxIGNvbnNlY3V0aXZlIGZyYWdtZW50IHRvIHByZXZlbnQgc2xpZGluZyBiYWNrIHRvbyBmYXIgd2hlbiBsaXR0bGUgb3Igbm8gZnJhZ3Mgc3RhcnQgd2l0aCBrZXlmcmFtZXNcbiAgICAgICAgICBpZiAobmV4dEZyYWcgJiYgbmV4dEZyYWcuYmFja3RyYWNrZWQpIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ0FscmVhZHkgYmFja3RyYWNrZWQgZnJvbSBmcmFnbWVudCAnICsgKGN1clNOSWR4ICsgMSkgKyAnLCB3aWxsIG5vdCBiYWNrdHJhY2sgdG8gZnJhZ21lbnQgJyArIGN1clNOSWR4ICsgJy4gTG9hZGluZyBmcmFnbWVudCAnICsgKGN1clNOSWR4ICsgMSkpO1xuICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBhIGZyYWdtZW50IGhhcyBkcm9wcGVkIGZyYW1lcyBhbmQgaXQncyBpbiBhIGRpZmZlcmVudCBsZXZlbC9zZXF1ZW5jZSwgbG9hZCB0aGUgcHJldmlvdXMgZnJhZ21lbnQgdG8gdHJ5IGFuZCBmaW5kIHRoZSBrZXlmcmFtZVxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGRyb3BwZWQgY291bnQgbm93IHNpbmNlIGl0IHdvbid0IGJlIHJlc2V0IHVudGlsIHdlIHBhcnNlIHRoZSBmcmFnbWVudCBhZ2Fpbiwgd2hpY2ggcHJldmVudHMgaW5maW5pdGUgYmFja3RyYWNraW5nIG9uIHRoZSBzYW1lIHNlZ21lbnRcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ0xvYWRlZCBmcmFnbWVudCB3aXRoIGRyb3BwZWQgZnJhbWVzLCBiYWNrdHJhY2tpbmcgMSBzZWdtZW50IHRvIGZpbmQgYSBrZXlmcmFtZScpO1xuICAgICAgICAgICAgZnJhZy5kcm9wcGVkID0gMDtcbiAgICAgICAgICAgIGlmIChwcmV2RnJhZyAmJiBwcmV2RnJhZy5sb2FkQ291bnRlcikge1xuICAgICAgICAgICAgICBwcmV2RnJhZy5sb2FkQ291bnRlci0tO1xuICAgICAgICAgICAgICBmcmFnID0gcHJldkZyYWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmFnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19sb2FkRnJhZ21lbnRPcktleScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkRnJhZ21lbnRPcktleShmcmFnLCBsZXZlbCwgbGV2ZWxEZXRhaWxzLCBwb3MsIGJ1ZmZlckVuZCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgIGNvbmZpZyA9IGhscy5jb25maWc7XG5cbiAgICAgIC8vbG9nZ2VyLmxvZygnbG9hZGluZyBmcmFnICcgKyBpICsnLHBvcy9idWZFbmQ6JyArIHBvcy50b0ZpeGVkKDMpICsgJy8nICsgYnVmZmVyRW5kLnRvRml4ZWQoMykpO1xuICAgICAgaWYgKGZyYWcuZGVjcnlwdGRhdGEgJiYgZnJhZy5kZWNyeXB0ZGF0YS51cmkgIT0gbnVsbCAmJiBmcmFnLmRlY3J5cHRkYXRhLmtleSA9PSBudWxsKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnTG9hZGluZyBrZXkgZm9yICcgKyBmcmFnLnNuICsgJyBvZiBbJyArIGxldmVsRGV0YWlscy5zdGFydFNOICsgJyAsJyArIGxldmVsRGV0YWlscy5lbmRTTiArICddLGxldmVsICcgKyBsZXZlbCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5LRVlfTE9BRElORywgeyBmcmFnOiBmcmFnIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdMb2FkaW5nICcgKyBmcmFnLnNuICsgJyBvZiBbJyArIGxldmVsRGV0YWlscy5zdGFydFNOICsgJyAsJyArIGxldmVsRGV0YWlscy5lbmRTTiArICddLGxldmVsICcgKyBsZXZlbCArICcsIGN1cnJlbnRUaW1lOicgKyBwb3MudG9GaXhlZCgzKSArICcsYnVmZmVyRW5kOicgKyBidWZmZXJFbmQudG9GaXhlZCgzKSk7XG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHdlIGFyZSBub3QgcmVsb2FkaW5nIHRoZSBzYW1lIGZyYWdtZW50cyBpbiBsb29wIC4uLlxuICAgICAgICBpZiAodGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5mcmFnTG9hZElkeCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnLmxvYWRDb3VudGVyKSB7XG4gICAgICAgICAgZnJhZy5sb2FkQ291bnRlcisrO1xuICAgICAgICAgIHZhciBtYXhUaHJlc2hvbGQgPSBjb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgICAgIC8vIGlmIHRoaXMgZnJhZyBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZCAzIHRpbWVzLCBhbmQgaWYgaXQgaGFzIGJlZW4gcmVsb2FkZWQgcmVjZW50bHlcbiAgICAgICAgICBpZiAoZnJhZy5sb2FkQ291bnRlciA+IG1heFRocmVzaG9sZCAmJiBNYXRoLmFicyh0aGlzLmZyYWdMb2FkSWR4IC0gZnJhZy5sb2FkSWR4KSA8IG1heFRocmVzaG9sZCkge1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IGZyYWcgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWcubG9hZENvdW50ZXIgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZyYWcubG9hZElkeCA9IHRoaXMuZnJhZ0xvYWRJZHg7XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIGlmICghaXNOYU4oZnJhZy5zbikpIHtcbiAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBmcmFnLmF1dG9MZXZlbCA9IGhscy5hdXRvTGV2ZWxFbmFibGVkO1xuICAgICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gdGhpcy5iaXRyYXRlVGVzdDtcbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX0xPQURJTkcsIHsgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgLy8gbGF6eSBkZW11eGVyIGluaXQsIGFzIHRoaXMgY291bGQgdGFrZSBzb21lIHRpbWUgLi4uIGRvIGl0IGR1cmluZyBmcmFnIGxvYWRpbmdcbiAgICAgICAgaWYgKCF0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgX2RlbXV4ZXIyLmRlZmF1bHQoaGxzLCAnbWFpbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEJ1ZmZlclJhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QnVmZmVyUmFuZ2UocG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBfYmluYXJ5U2VhcmNoMi5kZWZhdWx0LnNlYXJjaCh0aGlzLmJ1ZmZlclJhbmdlLCBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgcmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPiByYW5nZS5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZvbGxvd2luZ0J1ZmZlclJhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9sbG93aW5nQnVmZmVyUmFuZ2UocmFuZ2UpIHtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAvLyB0cnkgdG8gZ2V0IHJhbmdlIG9mIG5leHQgZnJhZ21lbnQgKDUwMG1zIGFmdGVyIHRoaXMgcmFuZ2UpXG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlclJhbmdlKHJhbmdlLmVuZCArIDAuNSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfY2hlY2tGcmFnbWVudENoYW5nZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tGcmFnbWVudENoYW5nZWQoKSB7XG4gICAgICB2YXIgcmFuZ2VDdXJyZW50LFxuICAgICAgICAgIGN1cnJlbnRUaW1lLFxuICAgICAgICAgIHZpZGVvID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmICh2aWRlbyAmJiB2aWRlby5yZWFkeVN0YXRlICYmIHZpZGVvLnNlZWtpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgIGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAgIC8qIGlmIHZpZGVvIGVsZW1lbnQgaXMgaW4gc2Vla2VkIHN0YXRlLCBjdXJyZW50VGltZSBjYW4gb25seSBpbmNyZWFzZS5cbiAgICAgICAgICAoYXNzdW1pbmcgdGhhdCBwbGF5YmFjayByYXRlIGlzIHBvc2l0aXZlIC4uLilcbiAgICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgICBtZWRpYSBkZWNvZGUgZXJyb3IsIGNoZWNrIHRoaXMsIHRvIGF2b2lkIHNlZWtpbmcgYmFjayB0b1xuICAgICAgICAgIHdyb25nIHBvc2l0aW9uIGFmdGVyIGEgbWVkaWEgZGVjb2RlIGVycm9yXG4gICAgICAgICovXG4gICAgICAgIGlmIChjdXJyZW50VGltZSA+IHZpZGVvLnBsYXliYWNrUmF0ZSAqIHRoaXMubGFzdEN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2J1ZmZlckhlbHBlcjIuZGVmYXVsdC5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSkpIHtcbiAgICAgICAgICByYW5nZUN1cnJlbnQgPSB0aGlzLmdldEJ1ZmZlclJhbmdlKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChfYnVmZmVySGVscGVyMi5kZWZhdWx0LmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lICsgMC4xKSkge1xuICAgICAgICAgIC8qIGVuc3VyZSB0aGF0IEZSQUdfQ0hBTkdFRCBldmVudCBpcyB0cmlnZ2VyZWQgYXQgc3RhcnR1cCxcbiAgICAgICAgICAgIHdoZW4gZmlyc3QgdmlkZW8gZnJhbWUgaXMgZGlzcGxheWVkIGFuZCBwbGF5YmFjayBpcyBwYXVzZWQuXG4gICAgICAgICAgICBhZGQgYSB0b2xlcmFuY2Ugb2YgMTAwbXMsIGluIGNhc2UgY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsXG4gICAgICAgICAgICBjaGVjayBpZiBjdXJyZW50IHBvcysxMDBtcyBpcyBidWZmZXJlZCBhbmQgdXNlIHRoYXQgYnVmZmVyIHJhbmdlXG4gICAgICAgICAgICBmb3IgRlJBR19DSEFOR0VEIGV2ZW50IHJlcG9ydGluZyAqL1xuICAgICAgICAgIHJhbmdlQ3VycmVudCA9IHRoaXMuZ2V0QnVmZmVyUmFuZ2UoY3VycmVudFRpbWUgKyAwLjEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZUN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgZnJhZ1BsYXlpbmcgPSByYW5nZUN1cnJlbnQuZnJhZztcbiAgICAgICAgICBpZiAoZnJhZ1BsYXlpbmcgIT09IHRoaXMuZnJhZ1BsYXlpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX0NIQU5HRUQsIHsgZnJhZzogZnJhZ1BsYXlpbmcgfSk7XG4gICAgICAgICAgICB2YXIgZnJhZ1BsYXlpbmdMZXZlbCA9IGZyYWdQbGF5aW5nLmxldmVsO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZyYWdQbGF5aW5nIHx8IHRoaXMuZnJhZ1BsYXlpbmcubGV2ZWwgIT09IGZyYWdQbGF5aW5nTGV2ZWwpIHtcbiAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkxFVkVMX1NXSVRDSEVELCB7IGxldmVsOiBmcmFnUGxheWluZ0xldmVsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mcmFnUGxheWluZyA9IGZyYWdQbGF5aW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIDpcbiAgICAgICAtIHBhdXNlIHBsYXliYWNrIGlmIHBsYXlpbmdcbiAgICAgICAtIGNhbmNlbCBhbnkgcGVuZGluZyBsb2FkIHJlcXVlc3RcbiAgICAgICAtIGFuZCB0cmlnZ2VyIGEgYnVmZmVyIGZsdXNoXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW1tZWRpYXRlTGV2ZWxTd2l0Y2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbW1lZGlhdGVMZXZlbFN3aXRjaCgpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnaW1tZWRpYXRlTGV2ZWxTd2l0Y2gnKTtcbiAgICAgIGlmICghdGhpcy5pbW1lZGlhdGVTd2l0Y2gpIHtcbiAgICAgICAgdGhpcy5pbW1lZGlhdGVTd2l0Y2ggPSB0cnVlO1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICAgICAgcHJldmlvdXNseVBhdXNlZCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgICAgcHJldmlvdXNseVBhdXNlZCA9IG1lZGlhLnBhdXNlZDtcbiAgICAgICAgICBtZWRpYS5wYXVzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRvbid0IHJlc3RhcnQgcGxheWJhY2sgYWZ0ZXIgaW5zdGFudCBsZXZlbCBzd2l0Y2ggaW4gY2FzZSBtZWRpYSBub3QgYXR0YWNoZWRcbiAgICAgICAgICBwcmV2aW91c2x5UGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZpb3VzbHlQYXVzZWQgPSBwcmV2aW91c2x5UGF1c2VkO1xuICAgICAgfVxuICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIGlmIChmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXG4gICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgICAvLyBmbHVzaCBldmVyeXRoaW5nXG4gICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICAgb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCBlbmQsIGFmdGVyIG5ldyBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZCA6XG4gICAgICAgIC0gbnVkZ2UgdmlkZW8gZGVjb2RlciBieSBzbGlnaHRseSBhZGp1c3RpbmcgdmlkZW8gY3VycmVudFRpbWUgKGlmIGN1cnJlbnRUaW1lIGJ1ZmZlcmVkKVxuICAgICAgICAtIHJlc3VtZSB0aGUgcGxheWJhY2sgaWYgbmVlZGVkXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW1tZWRpYXRlTGV2ZWxTd2l0Y2hFbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbW1lZGlhdGVMZXZlbFN3aXRjaEVuZCgpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAobWVkaWEgJiYgbWVkaWEuYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuaW1tZWRpYXRlU3dpdGNoID0gZmFsc2U7XG4gICAgICAgIGlmIChfYnVmZmVySGVscGVyMi5kZWZhdWx0LmlzQnVmZmVyZWQobWVkaWEsIG1lZGlhLmN1cnJlbnRUaW1lKSkge1xuICAgICAgICAgIC8vIG9ubHkgbnVkZ2UgaWYgY3VycmVudFRpbWUgaXMgYnVmZmVyZWRcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSAtPSAwLjAwMDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzbHlQYXVzZWQpIHtcbiAgICAgICAgICBtZWRpYS5wbGF5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduZXh0TGV2ZWxTd2l0Y2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0TGV2ZWxTd2l0Y2goKSB7XG4gICAgICAvKiB0cnkgdG8gc3dpdGNoIEFTQVAgd2l0aG91dCBicmVha2luZyB2aWRlbyBwbGF5YmFjayA6XG4gICAgICAgICBpbiBvcmRlciB0byBlbnN1cmUgc21vb3RoIGJ1dCBxdWljayBsZXZlbCBzd2l0Y2hpbmcsXG4gICAgICAgIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV4dCBmbHVzaGFibGUgYnVmZmVyIHJhbmdlXG4gICAgICAgIHdlIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCBuZXcgc2VnbWVudCBmZXRjaCB0aW1lXG4gICAgICAqL1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIC8vIGVuc3VyZSB0aGF0IG1lZGlhIGlzIGRlZmluZWQgYW5kIHRoYXQgbWV0YWRhdGEgYXJlIGF2YWlsYWJsZSAodG8gcmV0cmlldmUgY3VycmVudFRpbWUpXG4gICAgICBpZiAobWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgICB2YXIgZmV0Y2hkZWxheSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIG5leHRSYW5nZSA9IHZvaWQgMDtcbiAgICAgICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcbiAgICAgICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgICBjdXJyZW50UmFuZ2UgPSB0aGlzLmdldEJ1ZmZlclJhbmdlKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgICAgaWYgKGN1cnJlbnRSYW5nZSAmJiBjdXJyZW50UmFuZ2Uuc3RhcnQgPiAxKSB7XG4gICAgICAgICAgLy8gZmx1c2ggYnVmZmVyIHByZWNlZGluZyBjdXJyZW50IGZyYWdtZW50IChmbHVzaCB1bnRpbCBjdXJyZW50IGZyYWdtZW50IHN0YXJ0IG9mZnNldClcbiAgICAgICAgICAvLyBtaW51cyAxcyB0byBhdm9pZCB2aWRlbyBmcmVlemluZywgdGhhdCBjb3VsZCBoYXBwZW4gaWYgd2UgZmx1c2gga2V5ZnJhbWUgb2YgY3VycmVudCB2aWRlbyAuLi5cbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBjdXJyZW50UmFuZ2Uuc3RhcnQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lZGlhLnBhdXNlZCkge1xuICAgICAgICAgIC8vIGFkZCBhIHNhZmV0eSBkZWxheSBvZiAxc1xuICAgICAgICAgIHZhciBuZXh0TGV2ZWxJZCA9IHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwsXG4gICAgICAgICAgICAgIG5leHRMZXZlbCA9IHRoaXMubGV2ZWxzW25leHRMZXZlbElkXSxcbiAgICAgICAgICAgICAgZnJhZ0xhc3RLYnBzID0gdGhpcy5mcmFnTGFzdEticHM7XG4gICAgICAgICAgaWYgKGZyYWdMYXN0S2JwcyAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICAgICAgICBmZXRjaGRlbGF5ID0gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiAqIG5leHRMZXZlbC5iaXRyYXRlIC8gKDEwMDAgKiBmcmFnTGFzdEticHMpICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vbG9nZ2VyLmxvZygnZmV0Y2hkZWxheTonK2ZldGNoZGVsYXkpO1xuICAgICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcbiAgICAgICAgbmV4dFJhbmdlID0gdGhpcy5nZXRCdWZmZXJSYW5nZShtZWRpYS5jdXJyZW50VGltZSArIGZldGNoZGVsYXkpO1xuICAgICAgICBpZiAobmV4dFJhbmdlKSB7XG4gICAgICAgICAgLy8gd2UgY2FuIGZsdXNoIGJ1ZmZlciByYW5nZSBmb2xsb3dpbmcgdGhpcyBvbmUgd2l0aG91dCBzdGFsbGluZyBwbGF5YmFja1xuICAgICAgICAgIG5leHRSYW5nZSA9IHRoaXMuZm9sbG93aW5nQnVmZmVyUmFuZ2UobmV4dFJhbmdlKTtcbiAgICAgICAgICBpZiAobmV4dFJhbmdlKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgd2UgY2FuIGFsc28gY2FuY2VsIGFueSBsb2FkaW5nL2RlbXV4aW5nIGluIHByb2dyZXNzLCBhcyB0aGV5IGFyZSB1c2VsZXNzXG4gICAgICAgICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAgICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgLy8gZmx1c2ggcG9zaXRpb24gaXMgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoaXMgbmV3IGJ1ZmZlclxuICAgICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIobmV4dFJhbmdlLnN0YXJ0LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZsdXNoTWFpbkJ1ZmZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZsdXNoTWFpbkJ1ZmZlcihzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQlVGRkVSX0ZMVVNISU5HO1xuICAgICAgdmFyIGZsdXNoU2NvcGUgPSB7IHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCwgZW5kT2Zmc2V0OiBlbmRPZmZzZXQgfTtcbiAgICAgIC8vIGlmIGFsdGVybmF0ZSBhdWRpbyB0cmFja3MgYXJlIHVzZWQsIG9ubHkgZmx1c2ggdmlkZW8sIG90aGVyd2lzZSBmbHVzaCBldmVyeXRoaW5nXG4gICAgICBpZiAodGhpcy5hbHRBdWRpbykge1xuICAgICAgICBmbHVzaFNjb3BlLnR5cGUgPSAndmlkZW8nO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYUF0dGFjaGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGRhdGEpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMub252c2Vla2VkID0gdGhpcy5vbk1lZGlhU2Vla2VkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKTtcbiAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIGlmICh0aGlzLmxldmVscyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xuICAgICAgICB0aGlzLmhscy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWVkaWFEZXRhY2hpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5lbmRlZCkge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzZXQgZnJhZ21lbnQgbG9hZGluZyBjb3VudGVyIG9uIE1TRSBkZXRhY2hpbmcgdG8gYXZvaWQgcmVwb3J0aW5nIEZSQUdfTE9PUF9MT0FESU5HX0VSUk9SIGFmdGVyIGVycm9yIHJlY292ZXJ5XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgICBpZiAobGV2ZWxzKSB7XG4gICAgICAgIC8vIHJlc2V0IGZyYWdtZW50IGxvYWQgY291bnRlclxuICAgICAgICBsZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAobGV2ZWwuZGV0YWlscykge1xuICAgICAgICAgICAgbGV2ZWwuZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgZnJhZ21lbnQubG9hZENvdW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGZyYWdtZW50LmJhY2t0cmFja2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9udnNlZWtlZCA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWVkaWFTZWVraW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZWRpYVNlZWtpbmcoKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICAgIGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbWVkaWEgc2Vla2luZyB0byAnICsgY3VycmVudFRpbWUudG9GaXhlZCgzKSk7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HKSB7XG4gICAgICAgIHZhciBtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogbWVkaWE7XG4gICAgICAgIHZhciBidWZmZXJJbmZvID0gX2J1ZmZlckhlbHBlcjIuZGVmYXVsdC5idWZmZXJJbmZvKG1lZGlhQnVmZmVyLCBjdXJyZW50VGltZSwgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSksXG4gICAgICAgICAgICBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBzZWVraW5nIHRvIGEgdW5idWZmZXJlZCBhcmVhIEFORCBpZiBmcmFnIGxvYWRpbmcgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgaWYgKGJ1ZmZlckluZm8ubGVuID09PSAwICYmIGZyYWdDdXJyZW50KSB7XG4gICAgICAgICAgdmFyIHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLFxuICAgICAgICAgICAgICBmcmFnU3RhcnRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCAtIHRvbGVyYW5jZSxcbiAgICAgICAgICAgICAgZnJhZ0VuZE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0ICsgZnJhZ0N1cnJlbnQuZHVyYXRpb24gKyB0b2xlcmFuY2U7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgd2Ugc2VlayBwb3NpdGlvbiB3aWxsIGJlIG91dCBvZiBjdXJyZW50bHkgbG9hZGVkIGZyYWcgcmFuZ2UgOiBpZiBvdXQgY2FuY2VsIGZyYWcgbG9hZCwgaWYgaW4sIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgZnJhZ1N0YXJ0T2Zmc2V0IHx8IGN1cnJlbnRUaW1lID4gZnJhZ0VuZE9mZnNldCkge1xuICAgICAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgd2hpbGUgZnJhZ21lbnQgbG9hZCBpbiBwcm9ncmVzcywgY2FuY2VsIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzZWVraW5nIG91dHNpZGUgb2YgYnVmZmVyIGJ1dCB3aXRoaW4gY3VycmVudGx5IGxvYWRlZCBmcmFnbWVudCByYW5nZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBjaGVjayBmb3IgcG90ZW50aWFsIG5ldyBmcmFnbWVudFxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgLy8gYXZvaWQgcmVwb3J0aW5nIGZyYWdtZW50IGxvb3AgbG9hZGluZyBlcnJvciBpbiBjYXNlIHVzZXIgaXMgc2Vla2luZyBzZXZlcmFsIHRpbWVzIG9uIHNhbWUgcG9zaXRpb25cbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5GUkFHX0xPQURJTkcgJiYgdGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIGNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICAvLyBpbiBjYXNlIHNlZWtpbmcgb2NjdXJzIGFsdGhvdWdoIG5vIG1lZGlhIGJ1ZmZlcmVkLCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiBhbmQgbmV4dExvYWRQb3NpdGlvbiB0byBzZWVrIHRhcmdldFxuICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgLy8gdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1lZGlhU2Vla2VkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZWRpYVNlZWtlZCgpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbWVkaWEgc2Vla2VkIHRvICcgKyB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lLnRvRml4ZWQoMykpO1xuICAgICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHTUVOVF9QTEFZSU5HIHRyaWdnZXJpbmdcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWVkaWFFbmRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVkaWFFbmRlZCgpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbWVkaWEgZW5kZWQnKTtcbiAgICAgIC8vIHJlc2V0IHN0YXJ0UG9zaXRpb24gYW5kIGxhc3RDdXJyZW50VGltZSB0byByZXN0YXJ0IHBsYXliYWNrIEAgc3RyZWFtIGJlZ2lubmluZ1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWFuaWZlc3RMb2FkaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgICAvLyByZXNldCBidWZmZXIgb24gbWFuaWZlc3QgbG9hZGluZ1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCd0cmlnZ2VyIEJVRkZFUl9SRVNFVCcpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9SRVNFVCk7XG4gICAgICB0aGlzLmJ1ZmZlclJhbmdlID0gW107XG4gICAgICB0aGlzLnN0YWxsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1hbmlmZXN0UGFyc2VkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChkYXRhKSB7XG4gICAgICB2YXIgYWFjID0gZmFsc2UsXG4gICAgICAgICAgaGVhYWMgPSBmYWxzZSxcbiAgICAgICAgICBjb2RlYztcbiAgICAgIGRhdGEubGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIC8vIGRldGVjdCBpZiB3ZSBoYXZlIGRpZmZlcmVudCBraW5kIG9mIGF1ZGlvIGNvZGVjcyB1c2VkIGFtb25nc3QgcGxheWxpc3RzXG4gICAgICAgIGNvZGVjID0gbGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSkge1xuICAgICAgICAgICAgYWFjID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgICAgaGVhYWMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmF1ZGlvQ29kZWNTd2l0Y2ggPSBhYWMgJiYgaGVhYWM7XG4gICAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnYm90aCBBQUMvSEUtQUFDIGF1ZGlvIGZvdW5kIGluIGxldmVsczsgZGVjbGFyaW5nIGxldmVsIGNvZGVjIGFzIEhFLUFBQycpO1xuICAgICAgfVxuICAgICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICAgIHRoaXMuc3RhcnRMZXZlbExvYWRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIGlmIChjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xuICAgICAgICB0aGlzLmhscy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTGV2ZWxMb2FkZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkxldmVsTG9hZGVkKGRhdGEpIHtcbiAgICAgIHZhciBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzLFxuICAgICAgICAgIG5ld0xldmVsSWQgPSBkYXRhLmxldmVsLFxuICAgICAgICAgIGN1ckxldmVsID0gdGhpcy5sZXZlbHNbbmV3TGV2ZWxJZF0sXG4gICAgICAgICAgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24sXG4gICAgICAgICAgc2xpZGluZyA9IDA7XG5cbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbGV2ZWwgJyArIG5ld0xldmVsSWQgKyAnIGxvYWRlZCBbJyArIG5ld0RldGFpbHMuc3RhcnRTTiArICcsJyArIG5ld0RldGFpbHMuZW5kU04gKyAnXSxkdXJhdGlvbjonICsgZHVyYXRpb24pO1xuICAgICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBuZXdMZXZlbElkO1xuXG4gICAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICAgIHZhciBjdXJEZXRhaWxzID0gY3VyTGV2ZWwuZGV0YWlscztcbiAgICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIHdlIGFscmVhZHkgaGF2ZSBkZXRhaWxzIGZvciB0aGF0IGxldmVsLCBtZXJnZSB0aGVtXG4gICAgICAgICAgX2xldmVsSGVscGVyMi5kZWZhdWx0Lm1lcmdlRGV0YWlscyhjdXJEZXRhaWxzLCBuZXdEZXRhaWxzKTtcbiAgICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgICAgdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGN1ckRldGFpbHMpO1xuICAgICAgICAgIGlmIChuZXdEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3Qgc2xpZGluZzonICsgc2xpZGluZy50b0ZpeGVkKDMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdsaXZlIHBsYXlsaXN0IC0gb3V0ZGF0ZWQgUFRTLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbGl2ZSBwbGF5bGlzdCAtIGZpcnN0IGxvYWQsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBvdmVycmlkZSBsZXZlbCBpbmZvXG4gICAgICBjdXJMZXZlbC5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5MRVZFTF9VUERBVEVELCB7IGRldGFpbHM6IG5ld0RldGFpbHMsIGxldmVsOiBuZXdMZXZlbElkIH0pO1xuXG4gICAgICBpZiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgc2V0IHRvIC0xLiB1c2UgaXQgc3RyYWlnaHQgYXdheSBpZiB2YWx1ZSBpcyBkZWZpbmVkXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xIHx8IHRoaXMubGFzdEN1cnJlbnRUaW1lID09PSAtMSkge1xuICAgICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgICAgICB2YXIgc3RhcnRUaW1lT2Zmc2V0ID0gbmV3RGV0YWlscy5zdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgaWYgKCFpc05hTihzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ25lZ2F0aXZlIHN0YXJ0IHRpbWUgb2Zmc2V0ICcgKyBzdGFydFRpbWVPZmZzZXQgKyAnLCBjb3VudCBmcm9tIGVuZCBvZiBsYXN0IGZyYWdtZW50Jyk7XG4gICAgICAgICAgICAgIHN0YXJ0VGltZU9mZnNldCA9IHNsaWRpbmcgKyBkdXJhdGlvbiArIHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc3RhcnQgdGltZSBvZmZzZXQgZm91bmQgaW4gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvICcgKyBzdGFydFRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBzZXQgc3RhcnQgcG9zaXRpb24gdG8gYmUgZnJhZ21lbnQgTi10aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgKHVzdWFsbHkgMylcbiAgICAgICAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIG5ld0RldGFpbHMpO1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2NvbmZpZ3VyZSBzdGFydFBvc2l0aW9uIHRvICcgKyB0aGlzLnN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgLy8gb25seSBzd2l0Y2ggYmF0Y2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIGxldmVsIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25LZXlMb2FkZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbktleUxvYWRlZCgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5LRVlfTE9BRElORykge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GcmFnTG9hZGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GcmFnTG9hZGVkKGRhdGEpIHtcbiAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQsXG4gICAgICAgICAgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgJiYgZnJhZ0N1cnJlbnQgJiYgZnJhZ0xvYWRlZC50eXBlID09PSAnbWFpbicgJiYgZnJhZ0xvYWRlZC5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiYgZnJhZ0xvYWRlZC5zbiA9PT0gZnJhZ0N1cnJlbnQuc24pIHtcbiAgICAgICAgdmFyIHN0YXRzID0gZGF0YS5zdGF0cyxcbiAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IHRoaXMubGV2ZWxzW2ZyYWdDdXJyZW50LmxldmVsXSxcbiAgICAgICAgICAgIGRldGFpbHMgPSBjdXJyZW50TGV2ZWwuZGV0YWlscztcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdMb2FkZWQgICcgKyBmcmFnQ3VycmVudC5zbiArICcgb2YgWycgKyBkZXRhaWxzLnN0YXJ0U04gKyAnICwnICsgZGV0YWlscy5lbmRTTiArICddLGxldmVsICcgKyBmcmFnQ3VycmVudC5sZXZlbCk7XG4gICAgICAgIC8vIHJlc2V0IGZyYWcgYml0cmF0ZSB0ZXN0IGluIGFueSBjYXNlIGFmdGVyIGZyYWcgbG9hZGVkIGV2ZW50XG4gICAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0cyA9IHN0YXRzO1xuICAgICAgICAvLyBpZiB0aGlzIGZyYWcgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0IEFORCBpZiBobHMubmV4dExvYWRMZXZlbCBpcyBncmVhdGVyIHRoYW4gMFxuICAgICAgICAvLyB0aGVuIHRoaXMgbWVhbnMgdGhhdCB3ZSBzaG91bGQgYmUgYWJsZSB0byBsb2FkIGEgZnJhZ21lbnQgYXQgYSBoaWdoZXIgcXVhbGl0eSBsZXZlbFxuICAgICAgICBpZiAoZnJhZ0xvYWRlZC5iaXRyYXRlVGVzdCA9PT0gdHJ1ZSAmJiB0aGlzLmhscy5uZXh0TG9hZExldmVsKSB7XG4gICAgICAgICAgLy8gc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSAuLi4gd2UganVzdCBsb2FkZWQgYSBmcmFnbWVudCB0byBkZXRlcm1pbmUgYWRlcXVhdGUgc3RhcnQgYml0cmF0ZSBhbmQgaW5pdGlhbGl6ZSBhdXRvc3dpdGNoIGFsZ29cbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlJBR19CVUZGRVJFRCwgeyBzdGF0czogc3RhdHMsIGZyYWc6IGZyYWdDdXJyZW50LCBpZDogJ21haW4nIH0pO1xuICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB9IGVsc2UgaWYgKGZyYWdMb2FkZWQuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgZGV0YWlscy5pbml0U2VnbWVudC5kYXRhID0gZGF0YS5wYXlsb2FkO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZ0N1cnJlbnQsIGlkOiAnbWFpbicgfSk7XG4gICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XG4gICAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgICAgICAgbGV2ZWwgPSBmcmFnQ3VycmVudC5sZXZlbCxcbiAgICAgICAgICAgICAgc24gPSBmcmFnQ3VycmVudC5zbixcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9IHRoaXMuY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2FwKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3N3YXBwaW5nIHBsYXlsaXN0IGF1ZGlvIGNvZGVjJyk7XG4gICAgICAgICAgICBpZiAoYXVkaW9Db2RlYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSB0aGlzLmxhc3RBdWRpb0NvZGVjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ1BhcnNpbmcgJyArIHNuICsgJyBvZiBbJyArIGRldGFpbHMuc3RhcnRTTiArICcgLCcgKyBkZXRhaWxzLmVuZFNOICsgJ10sbGV2ZWwgJyArIGxldmVsICsgJywgY2MgJyArIGZyYWdDdXJyZW50LmNjKTtcbiAgICAgICAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICAgICAgICBpZiAoIWRlbXV4ZXIpIHtcbiAgICAgICAgICAgIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXIgPSBuZXcgX2RlbXV4ZXIyLmRlZmF1bHQodGhpcy5obHMsICdtYWluJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHRpbWUgT2Zmc2V0IGlzIGFjY3VyYXRlIGlmIGxldmVsIFBUUyBpcyBrbm93biwgb3IgaWYgcGxheWxpc3QgaXMgbm90IHNsaWRpbmcgKG5vdCBsaXZlKSBhbmQgaWYgbWVkaWEgaXMgbm90IHNlZWtpbmcgKHRoaXMgaXMgdG8gb3ZlcmNvbWUgcG90ZW50aWFsIHRpbWVzdGFtcCBkcmlmdHMgYmV0d2VlbiBwbGF5bGlzdHMgYW5kIGZyYWdtZW50cylcbiAgICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICAgIHZhciBtZWRpYVNlZWtpbmcgPSBtZWRpYSAmJiBtZWRpYS5zZWVraW5nO1xuICAgICAgICAgIHZhciBhY2N1cmF0ZVRpbWVPZmZzZXQgPSAhbWVkaWFTZWVraW5nICYmIChkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmUpO1xuICAgICAgICAgIHZhciBpbml0U2VnbWVudERhdGEgPSBkZXRhaWxzLmluaXRTZWdtZW50ID8gZGV0YWlscy5pbml0U2VnbWVudC5kYXRhIDogW107XG4gICAgICAgICAgZGVtdXhlci5wdXNoKGRhdGEucGF5bG9hZCwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYywgZnJhZ0N1cnJlbnQsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GcmFnUGFyc2luZ0luaXRTZWdtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GcmFnUGFyc2luZ0luaXRTZWdtZW50KGRhdGEpIHtcbiAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICB2YXIgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICAgIGlmIChmcmFnQ3VycmVudCAmJiBkYXRhLmlkID09PSAnbWFpbicgJiYgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiYgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICB2YXIgdHJhY2tzID0gZGF0YS50cmFja3MsXG4gICAgICAgICAgICB0cmFja05hbWUsXG4gICAgICAgICAgICB0cmFjaztcblxuICAgICAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cbiAgICAgICAgaWYgKHRyYWNrcy5hdWRpbyAmJiB0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICAgICAgZGVsZXRlIHRyYWNrcy5hdWRpbztcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgICB0cmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgdmFyIGF1ZGlvQ29kZWMgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXS5hdWRpb0NvZGVjLFxuICAgICAgICAgICAgICB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoYXVkaW9Db2RlYyAmJiB0aGlzLmF1ZGlvQ29kZWNTd2FwKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3N3YXBwaW5nIHBsYXlsaXN0IGF1ZGlvIGNvZGVjJyk7XG4gICAgICAgICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpbiBjYXNlIEFBQyBhbmQgSEUtQUFDIGF1ZGlvIGNvZGVjcyBhcmUgc2lnbmFsbGVkIGluIG1hbmlmZXN0XG4gICAgICAgICAgLy8gZm9yY2UgSEUtQUFDICwgYXMgaXQgc2VlbXMgdGhhdCBtb3N0IGJyb3dzZXJzIHByZWZlcnMgdGhhdCB3YXksXG4gICAgICAgICAgLy8gZXhjZXB0IGZvciBtb25vIHN0cmVhbXMgT1Igb24gRkZcbiAgICAgICAgICAvLyB0aGVzZSBjb25kaXRpb25zIG1pZ2h0IG5lZWQgdG8gYmUgcmV2aWV3ZWQgLi4uXG4gICAgICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZm9yY2UgSEUtQUFDIGlmIG1vbm8gc3RyZWFtXG4gICAgICAgICAgICBpZiAodHJhY2subWV0YWRhdGEuY2hhbm5lbENvdW50ICE9PSAxICYmXG4gICAgICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgZmlyZWZveFxuICAgICAgICAgICAgdWEuaW5kZXhPZignZmlyZWZveCcpID09PSAtMSkge1xuICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEhFLUFBQyBpcyBicm9rZW4gb24gQW5kcm9pZCwgYWx3YXlzIHNpZ25hbCBhdWRpbyBjb2RlYyBhcyBBQUMgZXZlbiBpZiB2YXJpYW50IG1hbmlmZXN0IHN0YXRlcyBvdGhlcndpc2VcbiAgICAgICAgICBpZiAodWEuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSAmJiB0cmFjay5jb250YWluZXIgIT09ICdhdWRpby9tcGVnJykge1xuICAgICAgICAgICAgLy8gRXhjbHVkZSBtcGVnIGF1ZGlvXG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ0FuZHJvaWQ6IGZvcmNlIGF1ZGlvIGNvZGVjIHRvICcgKyBhdWRpb0NvZGVjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrID0gdHJhY2tzLnZpZGVvO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0udmlkZW9Db2RlYztcbiAgICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiByZW11eGVyIHNwZWNpZnkgdGhhdCBhIHVuaXF1ZSB0cmFjayBuZWVkcyB0byBnZW5lcmF0ZWQsXG4gICAgICAgIC8vIGxldCdzIG1lcmdlIGFsbCB0cmFja3MgdG9nZXRoZXJcbiAgICAgICAgaWYgKGRhdGEudW5pcXVlKSB7XG4gICAgICAgICAgdmFyIG1lcmdlZFRyYWNrID0ge1xuICAgICAgICAgICAgY29kZWM6ICcnLFxuICAgICAgICAgICAgbGV2ZWxDb2RlYzogJydcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZvciAodHJhY2tOYW1lIGluIGRhdGEudHJhY2tzKSB7XG4gICAgICAgICAgICB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICAgICAgbWVyZ2VkVHJhY2suY29udGFpbmVyID0gdHJhY2suY29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKG1lcmdlZFRyYWNrLmNvZGVjKSB7XG4gICAgICAgICAgICAgIG1lcmdlZFRyYWNrLmNvZGVjICs9ICcsJztcbiAgICAgICAgICAgICAgbWVyZ2VkVHJhY2subGV2ZWxDb2RlYyArPSAnLCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2suY29kZWMpIHtcbiAgICAgICAgICAgICAgbWVyZ2VkVHJhY2suY29kZWMgKz0gdHJhY2suY29kZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2subGV2ZWxDb2RlYykge1xuICAgICAgICAgICAgICBtZXJnZWRUcmFjay5sZXZlbENvZGVjICs9IHRyYWNrLmxldmVsQ29kZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYWNrcyA9IHsgYXVkaW92aWRlbzogbWVyZ2VkVHJhY2sgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRyYWNrcyB0aGF0IGFyZSBnb2luZyB0byBiZSBwcm92aWRlZCB0byBidWZmZXJDb250cm9sbGVyXG4gICAgICAgIGZvciAodHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgICAgIHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdtYWluIHRyYWNrOicgKyB0cmFja05hbWUgKyAnLGNvbnRhaW5lcjonICsgdHJhY2suY29udGFpbmVyICsgJyxjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJyArIHRyYWNrLmxldmVsQ29kZWMgKyAnLycgKyB0cmFjay5jb2RlYyArICddJyk7XG4gICAgICAgICAgdmFyIGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgICAgICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGFybSBwZW5kaW5nIEJ1ZmZlcmluZyBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgYSBzZWdtZW50XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9BUFBFTkRJTkcsIHsgdHlwZTogdHJhY2tOYW1lLCBkYXRhOiBpbml0U2VnbWVudCwgcGFyZW50OiAnbWFpbicsIGNvbnRlbnQ6ICdpbml0U2VnbWVudCcgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZyYWdQYXJzaW5nRGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRnJhZ1BhcnNpbmdEYXRhKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgdmFyIGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZGF0YS5pZCA9PT0gJ21haW4nICYmIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmICEoZGF0YS50eXBlID09PSAnYXVkaW8nICYmIHRoaXMuYWx0QXVkaW8pICYmIC8vIGZpbHRlciBvdXQgbWFpbiBhdWRpbyBpZiBhdWRpbyB0cmFjayBpcyBsb2FkZWQgdGhyb3VnaCBhdWRpbyBzdHJlYW0gY29udHJvbGxlclxuICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXSxcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnQ3VycmVudDtcbiAgICAgICAgaWYgKGlzTmFOKGRhdGEuZW5kUFRTKSkge1xuICAgICAgICAgIGRhdGEuZW5kUFRTID0gZGF0YS5zdGFydFBUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xuICAgICAgICAgIGRhdGEuZW5kRFRTID0gZGF0YS5zdGFydERUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdQYXJzZWQgJyArIGRhdGEudHlwZSArICcsUFRTOlsnICsgZGF0YS5zdGFydFBUUy50b0ZpeGVkKDMpICsgJywnICsgZGF0YS5lbmRQVFMudG9GaXhlZCgzKSArICddLERUUzpbJyArIGRhdGEuc3RhcnREVFMudG9GaXhlZCgzKSArICcvJyArIGRhdGEuZW5kRFRTLnRvRml4ZWQoMykgKyAnXSxuYjonICsgZGF0YS5uYiArICcsZHJvcHBlZDonICsgKGRhdGEuZHJvcHBlZCB8fCAwKSk7XG5cbiAgICAgICAgLy8gRGV0ZWN0IGdhcHMgaW4gYSBmcmFnbWVudCAgYW5kIHRyeSB0byBmaXggaXQgYnkgZmluZGluZyBhIGtleWZyYW1lIGluIHRoZSBwcmV2aW91cyBmcmFnbWVudCAoc2VlIF9maW5kRnJhZ21lbnRzKVxuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgZnJhZy5kcm9wcGVkID0gZGF0YS5kcm9wcGVkO1xuICAgICAgICAgIGlmIChmcmFnLmRyb3BwZWQpIHtcbiAgICAgICAgICAgIGlmICghZnJhZy5iYWNrdHJhY2tlZCkge1xuICAgICAgICAgICAgICAvLyBSZXR1cm4gYmFjayB0byB0aGUgSURMRSBzdGF0ZSB3aXRob3V0IGFwcGVuZGluZyB0byBidWZmZXJcbiAgICAgICAgICAgICAgLy8gQ2F1c2VzIGZpbmRGcmFnbWVudHMgdG8gYmFja3RyYWNrIGEgc2VnbWVudCBhbmQgZmluZCB0aGUga2V5ZnJhbWVcbiAgICAgICAgICAgICAgLy8gQXVkaW8gZnJhZ21lbnRzIGFycml2aW5nIGJlZm9yZSB2aWRlbyBzZXRzIHRoZSBuZXh0TG9hZFBvc2l0aW9uLCBjYXVzaW5nIF9maW5kRnJhZ21lbnRzIHRvIHNraXAgdGhlIGJhY2t0cmFja2VkIGZyYWdtZW50XG4gICAgICAgICAgICAgIGZyYWcuYmFja3RyYWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBkYXRhLnN0YXJ0UFRTO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ0FscmVhZHkgYmFja3RyYWNrZWQgb24gdGhpcyBmcmFnbWVudCwgYXBwZW5kaW5nIHdpdGggdGhlIGdhcCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPbmx5IHJlc2V0IHRoZSBiYWNrdHJhY2tlZCBmbGFnIGlmIHdlJ3ZlIGxvYWRlZCB0aGUgZnJhZyB3aXRob3V0IGFueSBkcm9wcGVkIGZyYW1lc1xuICAgICAgICAgICAgZnJhZy5iYWNrdHJhY2tlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmlmdCA9IF9sZXZlbEhlbHBlcjIuZGVmYXVsdC51cGRhdGVGcmFnUFRTRFRTKGxldmVsLmRldGFpbHMsIGZyYWcuc24sIGRhdGEuc3RhcnRQVFMsIGRhdGEuZW5kUFRTLCBkYXRhLnN0YXJ0RFRTLCBkYXRhLmVuZERUUyksXG4gICAgICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5MRVZFTF9QVFNfVVBEQVRFRCwgeyBkZXRhaWxzOiBsZXZlbC5kZXRhaWxzLCBsZXZlbDogdGhpcy5sZXZlbCwgZHJpZnQ6IGRyaWZ0LCB0eXBlOiBkYXRhLnR5cGUsIHN0YXJ0OiBkYXRhLnN0YXJ0UFRTLCBlbmQ6IGRhdGEuZW5kUFRTIH0pO1xuXG4gICAgICAgIC8vIGhhcyByZW11eGVyIGRyb3BwZWQgdmlkZW8gZnJhbWVzIGxvY2F0ZWQgYmVmb3JlIGZpcnN0IGtleWZyYW1lID9cbiAgICAgICAgW2RhdGEuZGF0YTEsIGRhdGEuZGF0YTJdLmZvckVhY2goZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgIC8vIG9ubHkgYXBwZW5kIGluIFBBUlNJTkcgc3RhdGUgKHJhdGlvbmFsZSBpcyB0aGF0IGFuIGFwcGVuZGluZyBlcnJvciBjb3VsZCBoYXBwZW4gc3luY2hyb25vdXNseSBvbiBmaXJzdCBzZWdtZW50IGFwcGVuZGluZylcbiAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgaXQgaXMgdXNlbGVzcyB0byBhcHBlbmQgZm9sbG93aW5nIHNlZ21lbnRzXG4gICAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICYmIF90aGlzMi5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgICAgX3RoaXMyLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGFybSBwZW5kaW5nIEJ1ZmZlcmluZyBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgYSBzZWdtZW50XG4gICAgICAgICAgICBfdGhpczIucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9BUFBFTkRJTkcsIHsgdHlwZTogZGF0YS50eXBlLCBkYXRhOiBidWZmZXIsIHBhcmVudDogJ21haW4nLCBjb250ZW50OiAnZGF0YScgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRnJhZ1BhcnNlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRnJhZ1BhcnNlZChkYXRhKSB7XG4gICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgdmFyIGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZGF0YS5pZCA9PT0gJ21haW4nICYmIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgdGhpcy5zdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZGF0YSkge1xuICAgICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgICAgdmFyIGFsdEF1ZGlvID0gISFkYXRhLnVybCxcbiAgICAgICAgICB0cmFja0lkID0gZGF0YS5pZDtcbiAgICAgIC8vIGlmIHdlIHN3aXRjaCBvbiBtYWluIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggbWVkaWEuYnVmZmVyZWRcbiAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIHdlIHN3aXRjaCB0byBhbHQgYXVkaW86IGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyIGlzIGhhbmRsaW5nIGl0LlxuICAgICAgLy8gd2Ugd2lsbCBqdXN0IGhhdmUgdG8gY2hhbmdlIGJ1ZmZlciBzY2hlZHVsaW5nIG9uIGF1ZGlvVHJhY2tTd2l0Y2hlZFxuICAgICAgaWYgKCFhbHRBdWRpbykge1xuICAgICAgICBpZiAodGhpcy5tZWRpYUJ1ZmZlciAhPT0gdGhpcy5tZWRpYSkge1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc3dpdGNoaW5nIG9uIG1haW4gYXVkaW8sIHVzZSBtZWRpYS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICAgICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gcmVmaWxsIGF1ZGlvIGJ1ZmZlciBmcm9tIG1haW46IGNhbmNlbCBhbnkgZnJhZyBsb2FkaW5nIHRvIHNwZWVkIHVwIGF1ZGlvIHN3aXRjaFxuICAgICAgICAgIGlmIChmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8gdHJhY2ssIGNhbmNlbCBtYWluIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgLy8gZGVzdHJveSBkZW11eGVyIHRvIGZvcmNlIGluaXQgc2VnbWVudCBnZW5lcmF0aW9uIChmb2xsb3dpbmcgYXVkaW8gc3dpdGNoKVxuICAgICAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgICAgLy8gc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkJVRkZFUl9GTFVTSElORywgeyBzdGFydE9mZnNldDogMCwgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHR5cGU6ICdhdWRpbycgfSk7XG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHsgaWQ6IHRyYWNrSWQgfSk7XG4gICAgICAgIHRoaXMuYWx0QXVkaW8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkF1ZGlvVHJhY2tTd2l0Y2hlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQXVkaW9UcmFja1N3aXRjaGVkKGRhdGEpIHtcbiAgICAgIHZhciB0cmFja0lkID0gZGF0YS5pZCxcbiAgICAgICAgICBhbHRBdWRpbyA9ICEhdGhpcy5obHMuYXVkaW9UcmFja3NbdHJhY2tJZF0udXJsO1xuICAgICAgaWYgKGFsdEF1ZGlvKSB7XG4gICAgICAgIHZhciB2aWRlb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXI7XG4gICAgICAgIC8vIGlmIHdlIHN3aXRjaGVkIG9uIGFsdGVybmF0ZSBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIHZpZGVvIHNvdXJjZWJ1ZmZlciBidWZmZXJlZFxuICAgICAgICBpZiAodmlkZW9CdWZmZXIgJiYgdGhpcy5tZWRpYUJ1ZmZlciAhPT0gdmlkZW9CdWZmZXIpIHtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3N3aXRjaGluZyBvbiBhbHRlcm5hdGUgYXVkaW8sIHVzZSB2aWRlby5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdmlkZW9CdWZmZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYWx0QXVkaW8gPSBhbHRBdWRpbztcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQnVmZmVyQ3JlYXRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQnVmZmVyQ3JlYXRlZChkYXRhKSB7XG4gICAgICB2YXIgdHJhY2tzID0gZGF0YS50cmFja3MsXG4gICAgICAgICAgbWVkaWFUcmFjayA9IHZvaWQgMCxcbiAgICAgICAgICBuYW1lID0gdm9pZCAwLFxuICAgICAgICAgIGFsdGVybmF0ZSA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgdHlwZSBpbiB0cmFja3MpIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAodHJhY2suaWQgPT09ICdtYWluJykge1xuICAgICAgICAgIG5hbWUgPSB0eXBlO1xuICAgICAgICAgIG1lZGlhVHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAvLyBrZWVwIHZpZGVvIHNvdXJjZSBidWZmZXIgcmVmZXJlbmNlXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSB0cmFja3NbdHlwZV0uYnVmZmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbHRlcm5hdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWx0ZXJuYXRlICYmIG1lZGlhVHJhY2spIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdhbHRlcm5hdGUgdHJhY2sgZm91bmQsIHVzZSAnICsgbmFtZSArICcuYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nJyk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBtZWRpYVRyYWNrLmJ1ZmZlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQnVmZmVyQXBwZW5kZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkJ1ZmZlckFwcGVuZGVkKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ21haW4nKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCBzdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIGFwcGVuZGVkXG4gICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gZGF0YS5wZW5kaW5nID4gMDtcbiAgICAgICAgICB0aGlzLl9jaGVja0FwcGVuZGVkUGFyc2VkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfY2hlY2tBcHBlbmRlZFBhcnNlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0FwcGVuZGVkUGFyc2VkKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCAmJiAoIXRoaXMuYXBwZW5kZWQgfHwgIXRoaXMucGVuZGluZ0J1ZmZlcmluZykpIHtcbiAgICAgICAgdmFyIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWVkaWEgPSBfdGhpczMubWVkaWFCdWZmZXIgPyBfdGhpczMubWVkaWFCdWZmZXIgOiBfdGhpczMubWVkaWE7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ21haW4gYnVmZmVyZWQgOiAnICsgX3RpbWVSYW5nZXMyLmRlZmF1bHQudG9TdHJpbmcobWVkaWEuYnVmZmVyZWQpKTtcbiAgICAgICAgICAgIC8vIGZpbHRlciBwb3RlbnRpYWxseSBldmljdGVkIGJ1ZmZlclJhbmdlLiB0aGlzIGlzIHRvIGF2b2lkIG1lbWxlYWsgb24gbGl2ZSBzdHJlYW1zXG4gICAgICAgICAgICB2YXIgYnVmZmVyUmFuZ2UgPSBfdGhpczMuYnVmZmVyUmFuZ2UuZmlsdGVyKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgICByZXR1cm4gX2J1ZmZlckhlbHBlcjIuZGVmYXVsdC5pc0J1ZmZlcmVkKG1lZGlhLCAocmFuZ2Uuc3RhcnQgKyByYW5nZS5lbmQpIC8gMik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHB1c2ggbmV3IHJhbmdlXG4gICAgICAgICAgICBidWZmZXJSYW5nZS5wdXNoKHsgdHlwZTogZnJhZy50eXBlLCBzdGFydDogZnJhZy5zdGFydFBUUywgZW5kOiBmcmFnLmVuZFBUUywgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICAgIC8vIHNvcnQsIGFzIHdlIHVzZSBCaW5hcnlTZWFyY2ggZm9yIGxvb2t1cCBpbiBnZXRCdWZmZXJSYW5nZSAuLi5cbiAgICAgICAgICAgIF90aGlzMy5idWZmZXJSYW5nZSA9IGJ1ZmZlclJhbmdlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpczMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgICAgICAgIHZhciBzdGF0cyA9IF90aGlzMy5zdGF0cztcbiAgICAgICAgICAgIHN0YXRzLnRidWZmZXJlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGdldCByaWQgb2YgdGhpcy5mcmFnTGFzdEticHNcbiAgICAgICAgICAgIF90aGlzMy5mcmFnTGFzdEticHMgPSBNYXRoLnJvdW5kKDggKiBzdGF0cy50b3RhbCAvIChzdGF0cy50YnVmZmVyZWQgLSBzdGF0cy50Zmlyc3QpKTtcbiAgICAgICAgICAgIF90aGlzMy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnLCBpZDogJ21haW4nIH0pO1xuICAgICAgICAgICAgX3RoaXMzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVycm9yKGRhdGEpIHtcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnIHx8IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBtYWluIGZyYWdtZW50XG4gICAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdtYWluJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuXG4gICAgICAvLyAwLjUgOiB0b2xlcmFuY2UgbmVlZGVkIGFzIHNvbWUgYnJvd3NlcnMgc3RhbGxzIHBsYXliYWNrIGJlZm9yZSByZWFjaGluZyBidWZmZXJlZCBlbmRcbiAgICAgIG1lZGlhQnVmZmVyZWQgPSBtZWRpYSAmJiBfYnVmZmVySGVscGVyMi5kZWZhdWx0LmlzQnVmZmVyZWQobWVkaWEsIG1lZGlhLmN1cnJlbnRUaW1lKSAmJiBfYnVmZmVySGVscGVyMi5kZWZhdWx0LmlzQnVmZmVyZWQobWVkaWEsIG1lZGlhLmN1cnJlbnRUaW1lICsgMC41KTtcbiAgICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgX2Vycm9ycy5FcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgaWYgKCFkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgICB2YXIgbG9hZEVycm9yID0gdGhpcy5mcmFnTG9hZEVycm9yO1xuICAgICAgICAgICAgaWYgKGxvYWRFcnJvcikge1xuICAgICAgICAgICAgICBsb2FkRXJyb3IrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxvYWRFcnJvciA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICAvLyBrZWVwIHJldHJ5aW5nIC8gZG9uJ3QgcmFpc2UgZmF0YWwgbmV0d29yayBlcnJvciBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkIG9yIGlmIGluIGF1dG9tb2RlIHdpdGggY3VycmVudCBsZXZlbCBub3QgMFxuICAgICAgICAgICAgaWYgKGxvYWRFcnJvciA8PSBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSB8fCBtZWRpYUJ1ZmZlcmVkIHx8IGZyYWcuYXV0b0xldmVsICYmIGZyYWcubGV2ZWwpIHtcbiAgICAgICAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gbG9hZEVycm9yO1xuICAgICAgICAgICAgICAvLyByZXNldCBsb2FkIGNvdW50ZXIgdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3JcbiAgICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlciA9IDA7XG4gICAgICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxuICAgICAgICAgICAgICB2YXIgZGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLCBsb2FkRXJyb3IgLSAxKSAqIGNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCk7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ21lZGlhQ29udHJvbGxlcjogZnJhZyBsb2FkaW5nIGZhaWxlZCwgcmV0cnkgaW4gJyArIGRlbGF5ICsgJyBtcycpO1xuICAgICAgICAgICAgICB0aGlzLnJldHJ5RGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICAgICAgICAgIC8vIHJldHJ5IGxvYWRpbmcgc3RhdGVcbiAgICAgICAgICAgICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcbiAgICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5lcnJvcignbWVkaWFDb250cm9sbGVyOiAnICsgZGF0YS5kZXRhaWxzICsgJyByZWFjaGVzIG1heCByZXRyeSwgcmVkaXNwYXRjaCBhcyBmYXRhbCAuLi4nKTtcbiAgICAgICAgICAgICAgLy8gcmVkaXNwYXRjaCBzYW1lIGVycm9yIGJ1dCB3aXRoIGZhdGFsIHNldCB0byB0cnVlXG4gICAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIGRhdGEpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SOlxuICAgICAgICAgIGlmICghZGF0YS5mYXRhbCkge1xuICAgICAgICAgICAgLy8gaWYgYnVmZmVyIGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgaWYgKG1lZGlhQnVmZmVyZWQpIHtcbiAgICAgICAgICAgICAgLy8gdHJ5IHRvIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCA6IHJhdGlvbmFsZSBpcyB0aGF0IHdlIGNvdWxkIGdldFxuICAgICAgICAgICAgICAvLyBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBiZWNhdXNlIG9mIGJ1ZmZlciBldmljdGlvblxuICAgICAgICAgICAgICB0aGlzLl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGgoZnJhZy5kdXJhdGlvbik7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYnVmZmVyIGVtcHR5LiByZXBvcnQgYXMgZmF0YWwgaWYgaW4gbWFudWFsIG1vZGUgb3IgaWYgbG93ZXN0IGxldmVsLlxuICAgICAgICAgICAgICAvLyBsZXZlbCBjb250cm9sbGVyIHRha2VzIGNhcmUgb2YgZW1lcmdlbmN5IHN3aXRjaCBkb3duIGxvZ2ljXG4gICAgICAgICAgICAgIGlmICghZnJhZy5hdXRvTGV2ZWwgfHwgZnJhZy5sZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHJlZGlzcGF0Y2ggc2FtZSBlcnJvciBidXQgd2l0aCBmYXRhbCBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9lcnJvcnMuRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICAgIGNhc2UgX2Vycm9ycy5FcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICAgICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZmF0YWwgZXJyb3IsIHN0b3AgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ3N0cmVhbUNvbnRyb2xsZXI6ICcgKyBkYXRhLmRldGFpbHMgKyAnLHN3aXRjaCB0byAnICsgdGhpcy5zdGF0ZSArICcgc3RhdGUgLi4uJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBpbiBjYXMgb2Ygbm9uIGZhdGFsIGVycm9yIHdoaWxlIHdhaXRpbmcgbGV2ZWwgbG9hZCB0byBiZSBjb21wbGV0ZWQsIHN3aXRjaCBiYWNrIHRvIElETEVcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfZXJyb3JzLkVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgICAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICAgICAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdtYWluJyAmJiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpKSB7XG4gICAgICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZFxuICAgICAgICAgICAgaWYgKG1lZGlhQnVmZmVyZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKHRoaXMuY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vZGFpbHltb3Rpb24vaGxzLmpzL3B1bGwvNzA4XG4gICAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBmbHVzaCB0aGUgd2hvbGUgYnVmZmVyIHRvIHJlY292ZXJcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignYnVmZmVyIGZ1bGwgZXJyb3IgYWxzbyBtZWRpYS5jdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGZsdXNoIGV2ZXJ5dGhpbmcnKTtcbiAgICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3JlZHVjZU1heEJ1ZmZlckxlbmd0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWR1Y2VNYXhCdWZmZXJMZW5ndGgobWluTGVuZ3RoKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICBpZiAoY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCA+PSBtaW5MZW5ndGgpIHtcbiAgICAgICAgLy8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIGFzIGl0IG1pZ2h0IGJlIHRvbyBoaWdoLiB3ZSBkbyB0aGlzIHRvIGF2b2lkIGxvb3AgZmx1c2hpbmcgLi4uXG4gICAgICAgIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggLz0gMjtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignbWFpbjpyZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJyArIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggKyAncycpO1xuICAgICAgICAvLyBpbmNyZWFzZSBmcmFnbWVudCBsb2FkIEluZGV4IHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGFmdGVyIGJ1ZmZlciBmbHVzaFxuICAgICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiBjb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19jaGVja0J1ZmZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0J1ZmZlcigpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAvLyBpZiByZWFkeSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSBIQVZFX05PVEhJTkcgKG51bWVyaWMgdmFsdWUgMCksIHdlIGFyZSBhbGxvd2VkIHRvIHNlZWtcbiAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgbWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IG1lZGlhLFxuICAgICAgICAgICAgYnVmZmVyZWQgPSBtZWRpYUJ1ZmZlci5idWZmZXJlZDtcbiAgICAgICAgLy8gYWRqdXN0IGN1cnJlbnRUaW1lIHRvIHN0YXJ0IHBvc2l0aW9uIG9uIGxvYWRlZCBtZXRhZGF0YVxuICAgICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgYnVmZmVyZWQubGVuZ3RoICYmICFtZWRpYS5zZWVraW5nKSB7XG4gICAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgICAgICAgLy8gb25seSBhZGp1c3QgY3VycmVudFRpbWUgaWYgZGlmZmVyZW50IGZyb20gc3RhcnRQb3NpdGlvbiBvciBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZFxuICAgICAgICAgIC8vIGF0IHRoYXQgc3RhZ2UsIHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBidWZmZXJlZCByYW5nZSwgYXMgd2UgcmVhY2ggdGhhdCBjb2RlIGFmdGVyIGZpcnN0IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkXG4gICAgICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24sXG4gICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb25CdWZmZXJlZCA9IF9idWZmZXJIZWxwZXIyLmRlZmF1bHQuaXNCdWZmZXJlZChtZWRpYUJ1ZmZlciwgc3RhcnRQb3NpdGlvbik7XG4gICAgICAgICAgLy8gaWYgY3VycmVudFRpbWUgbm90IG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgc3RhcnRQb3NpdGlvbiBvciBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZFxuICAgICAgICAgIGlmIChjdXJyZW50VGltZSAhPT0gc3RhcnRQb3NpdGlvbiB8fCAhc3RhcnRQb3NpdGlvbkJ1ZmZlcmVkKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3RhcmdldCBzdGFydCBwb3NpdGlvbjonICsgc3RhcnRQb3NpdGlvbik7XG4gICAgICAgICAgICAvLyBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZCwgbGV0J3Mgc2VlayB0byBidWZmZXJlZC5zdGFydCgwKVxuICAgICAgICAgICAgaWYgKCFzdGFydFBvc2l0aW9uQnVmZmVyZWQpIHtcbiAgICAgICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IGJ1ZmZlcmVkLnN0YXJ0KDApO1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3RhcmdldCBzdGFydCBwb3NpdGlvbiBub3QgYnVmZmVyZWQsIHNlZWsgdG8gYnVmZmVyZWQuc3RhcnQoMCkgJyArIHN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdhZGp1c3QgY3VycmVudFRpbWUgZnJvbSAnICsgY3VycmVudFRpbWUgKyAnIHRvICcgKyBzdGFydFBvc2l0aW9uKTtcbiAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbW1lZGlhdGVTd2l0Y2gpIHtcbiAgICAgICAgICB0aGlzLmltbWVkaWF0ZUxldmVsU3dpdGNoRW5kKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlckluZm8gPSBfYnVmZmVySGVscGVyMi5kZWZhdWx0LmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKSxcbiAgICAgICAgICAgICAgZXhwZWN0ZWRQbGF5aW5nID0gIShtZWRpYS5wYXVzZWQgfHwgLy8gbm90IHBsYXlpbmcgd2hlbiBtZWRpYSBpcyBwYXVzZWRcbiAgICAgICAgICBtZWRpYS5lbmRlZCB8fCAvLyBub3QgcGxheWluZyB3aGVuIG1lZGlhIGlzIGVuZGVkXG4gICAgICAgICAgbWVkaWEuYnVmZmVyZWQubGVuZ3RoID09PSAwKSxcbiAgICAgICAgICAgICAgLy8gbm90IHBsYXlpbmcgaWYgbm90aGluZyBidWZmZXJlZFxuICAgICAgICAgIGp1bXBUaHJlc2hvbGQgPSAwLjUsXG4gICAgICAgICAgICAgIC8vIHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIHJhbmdlIGVuZFxuICAgICAgICAgIHBsYXloZWFkTW92aW5nID0gY3VycmVudFRpbWUgIT09IHRoaXMubGFzdEN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgICBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICAgIGlmIChwbGF5aGVhZE1vdmluZykge1xuICAgICAgICAgICAgLy8gcGxheWVkIG1vdmluZywgYnV0IHdhcyBwcmV2aW91c2x5IHN0YWxsZWQgPT4gbm93IG5vdCBzdHVjayBhbnltb3JlXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFsbFJlcG9ydGVkKSB7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ3BsYXliYWNrIG5vdCBzdHVjayBhbnltb3JlIEAnICsgY3VycmVudFRpbWUgKyAnLCBhZnRlciAnICsgTWF0aC5yb3VuZChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhbGxlZCkgKyAnbXMnKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YWxsZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwbGF5aGVhZCBub3QgbW92aW5nXG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRQbGF5aW5nKSB7XG4gICAgICAgICAgICAgIC8vIHBsYXloZWFkIG5vdCBtb3ZpbmcgQlVUIG1lZGlhIGV4cGVjdGVkIHRvIHBsYXlcbiAgICAgICAgICAgICAgdmFyIHRub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhbGxlZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0YWxsIGp1c3QgZGV0ZWN0ZWQsIHN0b3JlIGN1cnJlbnQgdGltZVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IHRub3c7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcGxheWJhY2sgYWxyZWFkeSBzdGFsbGVkLCBjaGVjayBzdGFsbGluZyBkdXJhdGlvblxuICAgICAgICAgICAgICAgIC8vIGlmIHN0YWxsaW5nIGZvciBtb3JlIHRoYW4gYSBnaXZlbiB0aHJlc2hvbGQsIGxldCdzIHRyeSB0byByZWNvdmVyXG4gICAgICAgICAgICAgICAgdmFyIHN0YWxsZWREdXJhdGlvbiA9IHRub3cgLSB0aGlzLnN0YWxsZWQ7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuO1xuICAgICAgICAgICAgICAgIHZhciBudWRnZVJldHJ5ID0gdGhpcy5udWRnZVJldHJ5IHx8IDA7XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSB3ZSByZWFjaGVkIHN0YWxsIGRlYWRsaW5lID9cbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyTGVuIDw9IGp1bXBUaHJlc2hvbGQgJiYgc3RhbGxlZER1cmF0aW9uID4gY29uZmlnLmxvd0J1ZmZlcldhdGNoZG9nUGVyaW9kICogMTAwMCkge1xuICAgICAgICAgICAgICAgICAgLy8gcmVwb3J0IHN0YWxsZWQgZXJyb3Igb25jZVxuICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YWxsUmVwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybigncGxheWJhY2sgc3RhbGxpbmcgaW4gbG93IGJ1ZmZlciBAJyArIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLCBmYXRhbDogZmFsc2UsIGJ1ZmZlcjogYnVmZmVyTGVuIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gaWYgYnVmZmVyIGxlbiBpcyBiZWxvdyB0aHJlc2hvbGQsIHRyeSB0byBqdW1wIHRvIHN0YXJ0IG9mIG5leHQgYnVmZmVyIHJhbmdlIGlmIGNsb3NlXG4gICAgICAgICAgICAgICAgICAvLyBubyBidWZmZXIgYXZhaWxhYmxlIEAgY3VycmVudFRpbWUsIGNoZWNrIGlmIG5leHQgYnVmZmVyIGlzIGNsb3NlICh3aXRoaW4gYSBjb25maWcubWF4U2Vla0hvbGUgc2Vjb25kIHJhbmdlKVxuICAgICAgICAgICAgICAgICAgdmFyIG5leHRCdWZmZXJTdGFydCA9IGJ1ZmZlckluZm8ubmV4dFN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhID0gbmV4dEJ1ZmZlclN0YXJ0IC0gY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgICAgICBpZiAobmV4dEJ1ZmZlclN0YXJ0ICYmIGRlbHRhIDwgY29uZmlnLm1heFNlZWtIb2xlICYmIGRlbHRhID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSArK251ZGdlUmV0cnk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBudWRnZU9mZnNldCA9IG51ZGdlUmV0cnkgKiBjb25maWcubnVkZ2VPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHQgYnVmZmVyIGlzIGNsb3NlICEgYWRqdXN0IGN1cnJlbnRUaW1lIHRvIG5leHRCdWZmZXJTdGFydFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgZW5zdXJlIGVmZmVjdGl2ZSB2aWRlbyBkZWNvZGluZ1xuICAgICAgICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2FkanVzdCBjdXJyZW50VGltZSBmcm9tICcgKyBtZWRpYS5jdXJyZW50VGltZSArICcgdG8gbmV4dCBidWZmZXJlZCBAICcgKyBuZXh0QnVmZmVyU3RhcnQgKyAnICsgbnVkZ2UgJyArIG51ZGdlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBuZXh0QnVmZmVyU3RhcnQgKyBudWRnZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgc3RhbGxlZCBzbyB0byByZWFybSB3YXRjaGRvZyB0aW1lclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWxsZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEUsIGZhdGFsOiBmYWxzZSwgaG9sZTogbmV4dEJ1ZmZlclN0YXJ0ICsgbnVkZ2VPZmZzZXQgLSBjdXJyZW50VGltZSB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlckxlbiA+IGp1bXBUaHJlc2hvbGQgJiYgc3RhbGxlZER1cmF0aW9uID4gY29uZmlnLmhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZCAqIDEwMDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlcG9ydCBzdGFsbGVkIGVycm9yIG9uY2VcbiAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdGFsbFJlcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ3BsYXliYWNrIHN0YWxsaW5nIGluIGhpZ2ggYnVmZmVyIEAnICsgY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnVmZmVyOiBidWZmZXJMZW4gfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyByZXNldCBzdGFsbGVkIHNvIHRvIHJlYXJtIHdhdGNoZG9nIHRpbWVyXG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YWxsZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSArK251ZGdlUmV0cnk7XG4gICAgICAgICAgICAgICAgICBpZiAobnVkZ2VSZXRyeSA8IGNvbmZpZy5udWRnZU1heFJldHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFRpbWUgPSBfY3VycmVudFRpbWUgKyBudWRnZVJldHJ5ICogY29uZmlnLm51ZGdlT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ2FkanVzdCBjdXJyZW50VGltZSBmcm9tICcgKyBfY3VycmVudFRpbWUgKyAnIHRvICcgKyB0YXJnZXRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGxheWJhY2sgc3RhbGxlZCBpbiBidWZmZXJlZCBhcmVhIC4uLiBsZXQncyBudWRnZSBjdXJyZW50VGltZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc1xuICAgICAgICAgICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5CVUZGRVJfTlVER0VfT05fU1RBTEwsIGZhdGFsOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmVycm9yKCdzdGlsbCBzdHVjayBpbiBoaWdoIGJ1ZmZlciBAJyArIGN1cnJlbnRUaW1lICsgJyBhZnRlciAnICsgY29uZmlnLm51ZGdlTWF4UmV0cnkgKyAnLCByYWlzZSBmYXRhbCBlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsIGZhdGFsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQoKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbiBmaXJzdCBmcmFnXG4gICAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXG4gICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25CdWZmZXJGbHVzaGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25CdWZmZXJGbHVzaGVkKCkge1xuICAgICAgLyogYWZ0ZXIgc3VjY2Vzc2Z1bCBidWZmZXIgZmx1c2hpbmcsIGZpbHRlciBmbHVzaGVkIGZyYWdtZW50cyBmcm9tIGJ1ZmZlclJhbmdlXG4gICAgICAgIHVzZSBtZWRpYUJ1ZmZlcmVkIGluc3RlYWQgb2YgbWVkaWEgKHNvIHRoYXQgd2Ugd2lsbCBjaGVjayBhZ2FpbnN0IHZpZGVvLmJ1ZmZlcmVkIHJhbmdlcyBpbiBjYXNlIG9mIGFsdCBhdWRpbyB0cmFjaylcbiAgICAgICovXG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICB0aGlzLmJ1ZmZlclJhbmdlID0gdGhpcy5idWZmZXJSYW5nZS5maWx0ZXIoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBfYnVmZmVySGVscGVyMi5kZWZhdWx0LmlzQnVmZmVyZWQobWVkaWEsIChyYW5nZS5zdGFydCArIHJhbmdlLmVuZCkgLyAyKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBpbmNyZWFzZSBmcmFnbWVudCBsb2FkIEluZGV4IHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGFmdGVyIGJ1ZmZlciBmbHVzaFxuICAgICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgLy8gbW92ZSB0byBJRExFIG9uY2UgZmx1c2ggY29tcGxldGUuIHRoaXMgc2hvdWxkIHRyaWdnZXIgbmV3IGZyYWdtZW50IGxvYWRpbmdcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIGZyYWdcbiAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzd2FwQXVkaW9Db2RlYycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9ICF0aGlzLmF1ZGlvQ29kZWNTd2FwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXB1dGVMaXZlUG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGxldmVsRGV0YWlscykge1xuICAgICAgdmFyIHRhcmdldExhdGVuY3kgPSB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uIDogdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgcmV0dXJuIHNsaWRpbmcgKyBNYXRoLm1heCgwLCBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbiAtIHRhcmdldExhdGVuY3kpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0YXRlJyxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXh0U3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBuZXh0U3RhdGUpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdtYWluIHN0cmVhbTonICsgcHJldmlvdXNTdGF0ZSArICctPicgKyBuZXh0U3RhdGUpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuU1RSRUFNX1NUQVRFX1RSQU5TSVRJT04sIHsgcHJldmlvdXNTdGF0ZTogcHJldmlvdXNTdGF0ZSwgbmV4dFN0YXRlOiBuZXh0U3RhdGUgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjdXJyZW50TGV2ZWwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldEJ1ZmZlclJhbmdlKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlLmZyYWcubGV2ZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduZXh0QnVmZmVyUmFuZ2UnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAvLyBmaXJzdCBnZXQgZW5kIHJhbmdlIG9mIGN1cnJlbnQgZnJhZ21lbnRcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sbG93aW5nQnVmZmVyUmFuZ2UodGhpcy5nZXRCdWZmZXJSYW5nZShtZWRpYS5jdXJyZW50VGltZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbmV4dExldmVsJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMubmV4dEJ1ZmZlclJhbmdlO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZS5mcmFnLmxldmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xpdmVTeW5jUG9zaXRpb24nLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xpdmVTeW5jUG9zaXRpb247XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5fbGl2ZVN5bmNQb3NpdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHJlYW1Db250cm9sbGVyO1xufShfZXZlbnRIYW5kbGVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3RyZWFtQ29udHJvbGxlcjtcblxufSx7XCIyNVwiOjI1LFwiMzFcIjozMSxcIjMyXCI6MzIsXCIzM1wiOjMzLFwiMzVcIjozNSxcIjM2XCI6MzYsXCI0NlwiOjQ2LFwiNTBcIjo1MCxcIjUxXCI6NTF9XSwxNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZXZlbnRIYW5kbGVyID0gX2RlcmVxXygzMik7XG5cbnZhciBfZXZlbnRIYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50SGFuZGxlcik7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFN1YnRpdGxlIFN0cmVhbSBDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyID0gZnVuY3Rpb24gKF9FdmVudEhhbmRsZXIpIHtcbiAgX2luaGVyaXRzKFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciwgX0V2ZW50SGFuZGxlcik7XG5cbiAgZnVuY3Rpb24gU3VidGl0bGVTdHJlYW1Db250cm9sbGVyKGhscykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcikpLmNhbGwodGhpcywgaGxzLCBfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCBfZXZlbnRzMi5kZWZhdWx0LlNVQlRJVExFX1RSQUNLU19VUERBVEVELCBfZXZlbnRzMi5kZWZhdWx0LlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgX2V2ZW50czIuZGVmYXVsdC5TVUJUSVRMRV9UUkFDS19MT0FERUQsIF9ldmVudHMyLmRlZmF1bHQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQpKTtcblxuICAgIF90aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgX3RoaXMudnR0RnJhZ1NOc1Byb2Nlc3NlZCA9IHt9O1xuICAgIF90aGlzLnZ0dEZyYWdRdWV1ZXMgPSB1bmRlZmluZWQ7XG4gICAgX3RoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA9IG51bGw7XG4gICAgX3RoaXMuY3VycmVudFRyYWNrSWQgPSAtMTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgX2V2ZW50SGFuZGxlcjIuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgcXVldWVkIGl0ZW1zIGFuZCBjcmVhdGUgYSBuZXcsIGVtcHR5IHF1ZXVlIGZvciBlYWNoIHRyYWNrLlxuXG4gIH0sIHtcbiAgICBrZXk6ICdjbGVhclZ0dEZyYWdRdWV1ZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclZ0dEZyYWdRdWV1ZXMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy52dHRGcmFnUXVldWVzID0ge307XG4gICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICBfdGhpczIudnR0RnJhZ1F1ZXVlc1t0cmFjay5pZF0gPSBbXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIElmIG5vIGZyYWcgaXMgYmVpbmcgcHJvY2Vzc2VkIGFuZCBxdWV1ZSBpc24ndCBlbXB0eSwgaW5pdGlhdGUgcHJvY2Vzc2luZyBvZiBuZXh0IGZyYWcgaW4gbGluZS5cblxuICB9LCB7XG4gICAga2V5OiAnbmV4dEZyYWcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0RnJhZygpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRseVByb2Nlc3NpbmcgPT09IG51bGwgJiYgdGhpcy5jdXJyZW50VHJhY2tJZCA+IC0xICYmIHRoaXMudnR0RnJhZ1F1ZXVlc1t0aGlzLmN1cnJlbnRUcmFja0lkXS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGZyYWcgPSB0aGlzLmN1cnJlbnRseVByb2Nlc3NpbmcgPSB0aGlzLnZ0dEZyYWdRdWV1ZXNbdGhpcy5jdXJyZW50VHJhY2tJZF0uc2hpZnQoKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfTE9BRElORywgeyBmcmFnOiBmcmFnIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gZnJhZ21lbnQgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcsIGFkZCBzbiB0byBsaXN0IG9mIGNvbXBsZXRlZCBpZiBzdWNjZXNzZnVsLlxuXG4gIH0sIHtcbiAgICBrZXk6ICdvblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhpcy52dHRGcmFnU05zUHJvY2Vzc2VkW2RhdGEuZnJhZy50cmFja0lkXS5wdXNoKGRhdGEuZnJhZy5zbik7XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnJlbnRseVByb2Nlc3NpbmcgPSBudWxsO1xuICAgICAgdGhpcy5uZXh0RnJhZygpO1xuICAgIH1cblxuICAgIC8vIElmIHNvbWV0aGluZyBnb2VzIHdyb25nLCBwcm9jZWRlIHRvIG5leHQgZnJhZywgaWYgd2Ugd2VyZSBwcm9jZXNzaW5nIG9uZS5cblxuICB9LCB7XG4gICAga2V5OiAnb25FcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRXJyb3IoZGF0YSkge1xuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBzdWJ0aXRsZSBmcmFnbWVudFxuICAgICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnc3VidGl0bGUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRseVByb2Nlc3NpbmcpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0RnJhZygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdvdCBhbGwgbmV3IHN1YnRpdGxlIHRyYWNrcy5cblxuICB9LCB7XG4gICAga2V5OiAnb25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tzVXBkYXRlZChkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzdWJ0aXRsZSB0cmFja3MgdXBkYXRlZCcpO1xuICAgICAgdGhpcy50cmFja3MgPSBkYXRhLnN1YnRpdGxlVHJhY2tzO1xuICAgICAgdGhpcy5jbGVhclZ0dEZyYWdRdWV1ZXMoKTtcbiAgICAgIHRoaXMudnR0RnJhZ1NOc1Byb2Nlc3NlZCA9IHt9O1xuICAgICAgdGhpcy50cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgX3RoaXMzLnZ0dEZyYWdTTnNQcm9jZXNzZWRbdHJhY2suaWRdID0gW107XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvblN1YnRpdGxlVHJhY2tTd2l0Y2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tTd2l0Y2goZGF0YSkge1xuICAgICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgICB0aGlzLmNsZWFyVnR0RnJhZ1F1ZXVlcygpO1xuICAgIH1cblxuICAgIC8vIEdvdCBhIG5ldyBzZXQgb2Ygc3VidGl0bGUgZnJhZ21lbnRzLlxuXG4gIH0sIHtcbiAgICBrZXk6ICdvblN1YnRpdGxlVHJhY2tMb2FkZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tMb2FkZWQoZGF0YSkge1xuICAgICAgdmFyIHByb2Nlc3NlZEZyYWdTTnMgPSB0aGlzLnZ0dEZyYWdTTnNQcm9jZXNzZWRbZGF0YS5pZF0sXG4gICAgICAgICAgZnJhZ1F1ZXVlID0gdGhpcy52dHRGcmFnUXVldWVzW2RhdGEuaWRdLFxuICAgICAgICAgIGN1cnJlbnRGcmFnU04gPSAhIXRoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA/IHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZy5zbiA6IC0xO1xuXG4gICAgICB2YXIgYWxyZWFkeVByb2Nlc3NlZCA9IGZ1bmN0aW9uIGFscmVhZHlQcm9jZXNzZWQoZnJhZykge1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRnJhZ1NOcy5pbmRleE9mKGZyYWcuc24pID4gLTE7XG4gICAgICB9O1xuXG4gICAgICB2YXIgYWxyZWFkeUluUXVldWUgPSBmdW5jdGlvbiBhbHJlYWR5SW5RdWV1ZShmcmFnKSB7XG4gICAgICAgIHJldHVybiBmcmFnUXVldWUuc29tZShmdW5jdGlvbiAoZnJhZ0luUXVldWUpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZ0luUXVldWUuc24gPT09IGZyYWcuc247XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgdGhhdCBoYXZlbid0IGJlZW4sIGFyZW4ndCBjdXJyZW50bHkgYmVpbmcgYW5kIGFyZW4ndCB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZCwgdG8gcXVldWUuXG4gICAgICBkYXRhLmRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgaWYgKCEoYWxyZWFkeVByb2Nlc3NlZChmcmFnKSB8fCBmcmFnLnNuID09PSBjdXJyZW50RnJhZ1NOIHx8IGFscmVhZHlJblF1ZXVlKGZyYWcpKSkge1xuICAgICAgICAgIC8vIEZyYWdzIGRvbid0IGtub3cgdGhlaXIgc3VidGl0bGUgdHJhY2sgSUQsIHNvIGxldCdzIGp1c3QgYWRkIHRoYXQuLi5cbiAgICAgICAgICBmcmFnLnRyYWNrSWQgPSBkYXRhLmlkO1xuICAgICAgICAgIGZyYWdRdWV1ZS5wdXNoKGZyYWcpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5uZXh0RnJhZygpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI7XG59KF9ldmVudEhhbmRsZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI7XG5cbn0se1wiMzJcIjozMixcIjMzXCI6MzMsXCI1MFwiOjUwfV0sMTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V2ZW50cyA9IF9kZXJlcV8oMzMpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX2V2ZW50SGFuZGxlciA9IF9kZXJlcV8oMzIpO1xuXG52YXIgX2V2ZW50SGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudEhhbmRsZXIpO1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBhdWRpbyB0cmFjayBjb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0V2ZW50SGFuZGxlcikge1xuICBfaW5oZXJpdHMoU3VidGl0bGVUcmFja0NvbnRyb2xsZXIsIF9FdmVudEhhbmRsZXIpO1xuXG4gIGZ1bmN0aW9uIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyKGhscykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3VidGl0bGVUcmFja0NvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikpLmNhbGwodGhpcywgaGxzLCBfZXZlbnRzMi5kZWZhdWx0Lk1FRElBX0FUVEFDSEVELCBfZXZlbnRzMi5kZWZhdWx0Lk1FRElBX0RFVEFDSElORywgX2V2ZW50czIuZGVmYXVsdC5NQU5JRkVTVF9MT0FESU5HLCBfZXZlbnRzMi5kZWZhdWx0Lk1BTklGRVNUX0xPQURFRCwgX2V2ZW50czIuZGVmYXVsdC5TVUJUSVRMRV9UUkFDS19MT0FERUQpKTtcblxuICAgIF90aGlzLnRyYWNrcyA9IFtdO1xuICAgIF90aGlzLnRyYWNrSWQgPSAtMTtcbiAgICBfdGhpcy5tZWRpYSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3VidGl0bGVUcmFja0NvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBfZXZlbnRIYW5kbGVyMi5kZWZhdWx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gTGlzdGVuIGZvciBzdWJ0aXRsZSB0cmFjayBjaGFuZ2UsIHRoZW4gZXh0cmFjdCB0aGUgY3VycmVudCB0cmFjayBJRC5cblxuICB9LCB7XG4gICAga2V5OiAnb25NZWRpYUF0dGFjaGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVkaWEudGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE1lZGlhIGlzIHVuZGVmaW5lZCB3aGVuIHN3aXRjaGluZyBzdHJlYW1zIHZpYSBsb2FkU291cmNlKClcbiAgICAgICAgaWYgKCFfdGhpczIubWVkaWEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhY2tJZCA9IC0xO1xuICAgICAgICB2YXIgdHJhY2tzID0gX3RoaXMyLm1lZGlhLnRleHRUcmFja3M7XG4gICAgICAgIGZvciAodmFyIGlkID0gMDsgaWQgPCB0cmFja3MubGVuZ3RoOyBpZCsrKSB7XG4gICAgICAgICAgaWYgKHRyYWNrc1tpZF0ubW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgICAgICB0cmFja0lkID0gaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNldHRpbmcgY3VycmVudCBzdWJ0aXRsZVRyYWNrIHdpbGwgaW52b2tlIGNvZGUuXG4gICAgICAgIF90aGlzMi5zdWJ0aXRsZVRyYWNrID0gdHJhY2tJZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWVkaWFEZXRhY2hpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgICAgLy8gVE9ETzogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgIHRoaXMubWVkaWEgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgc3VidGl0bGUgdHJhY2tzIG9uIG1hbmlmZXN0IGxvYWRpbmdcblxuICB9LCB7XG4gICAga2V5OiAnb25NYW5pZmVzdExvYWRpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB9XG5cbiAgICAvLyBGaXJlZCB3aGVuZXZlciBhIG5ldyBtYW5pZmVzdCBpcyBsb2FkZWQuXG5cbiAgfSwge1xuICAgIGtleTogJ29uTWFuaWZlc3RMb2FkZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGVkKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgdHJhY2tzID0gZGF0YS5zdWJ0aXRsZXMgfHwgW107XG4gICAgICB2YXIgZGVmYXVsdEZvdW5kID0gZmFsc2U7XG4gICAgICB0aGlzLnRyYWNrcyA9IHRyYWNrcztcbiAgICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB7IHN1YnRpdGxlVHJhY2tzOiB0cmFja3MgfSk7XG5cbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBhdmFpbGFibGUgc3VidGl0bGUgdHJhY2tzIGFuZCBhdXRvc2VsZWN0IGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgICAvLyBUT0RPOiBpbXByb3ZlIHNlbGVjdGlvbiBsb2dpYyB0byBoYW5kbGUgZm9yY2VkLCBldGNcbiAgICAgIHRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICBpZiAodHJhY2suZGVmYXVsdCkge1xuICAgICAgICAgIF90aGlzMy5zdWJ0aXRsZVRyYWNrID0gdHJhY2suaWQ7XG4gICAgICAgICAgZGVmYXVsdEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVHJpZ2dlciBzdWJ0aXRsZSB0cmFjayBwbGF5bGlzdCByZWxvYWQuXG5cbiAgfSwge1xuICAgIGtleTogJ29uVGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uVGljaygpIHtcbiAgICAgIHZhciB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja0lkXTtcbiAgICAgIGlmICghc3VidGl0bGVUcmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXRhaWxzID0gc3VidGl0bGVUcmFjay5kZXRhaWxzO1xuICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIHN1YnRpdGxlIFRyYWNrXG4gICAgICBpZiAoZGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGRldGFpbHMubGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnKHJlKWxvYWRpbmcgcGxheWxpc3QgZm9yIHN1YnRpdGxlIHRyYWNrICcgKyB0cmFja0lkKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHsgdXJsOiBzdWJ0aXRsZVRyYWNrLnVybCwgaWQ6IHRyYWNrSWQgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25TdWJ0aXRsZVRyYWNrTG9hZGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrTG9hZGVkKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAoZGF0YS5pZCA8IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3N1YnRpdGxlIHRyYWNrICcgKyBkYXRhLmlkICsgJyBsb2FkZWQnKTtcbiAgICAgICAgdGhpcy50cmFja3NbZGF0YS5pZF0uZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgICAgLy8gY2hlY2sgaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3RcbiAgICAgICAgaWYgKGRhdGEuZGV0YWlscy5saXZlICYmICF0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCB3ZSB3aWxsIGhhdmUgdG8gcmVsb2FkIGl0IHBlcmlvZGljYWxseVxuICAgICAgICAgIC8vIHNldCByZWxvYWQgcGVyaW9kIHRvIHBsYXlsaXN0IHRhcmdldCBkdXJhdGlvblxuICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczQub25UaWNrKCk7XG4gICAgICAgICAgfSwgMTAwMCAqIGRhdGEuZGV0YWlscy50YXJnZXRkdXJhdGlvbiwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhLmRldGFpbHMubGl2ZSAmJiB0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgLy8gcGxheWxpc3QgaXMgbm90IGxpdmUgYW5kIHRpbWVyIGlzIGFybWVkIDogc3RvcHBpbmcgaXRcbiAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0U3VidGl0bGVUcmFja0ludGVybmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3VidGl0bGVUcmFja0ludGVybmFsKG5ld0lkKSB7XG4gICAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICAgIGlmIChuZXdJZCA+PSAwICYmIG5ld0lkIDwgdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc3dpdGNoaW5nIHRvIHN1YnRpdGxlIHRyYWNrICcgKyBuZXdJZCk7XG4gICAgICAgIHZhciBzdWJ0aXRsZVRyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB7IGlkOiBuZXdJZCB9KTtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIHN1YnRpdGxlIFRyYWNrXG4gICAgICAgIHZhciBkZXRhaWxzID0gc3VidGl0bGVUcmFjay5kZXRhaWxzO1xuICAgICAgICBpZiAoZGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGRldGFpbHMubGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHRyYWNrIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJyhyZSlsb2FkaW5nIHBsYXlsaXN0IGZvciBzdWJ0aXRsZSB0cmFjayAnICsgbmV3SWQpO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB7IHVybDogc3VidGl0bGVUcmFjay51cmwsIGlkOiBuZXdJZCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N1YnRpdGxlVHJhY2tzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrcztcbiAgICB9XG5cbiAgICAvKiogZ2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzdWJ0aXRsZVRyYWNrJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gICAgfVxuXG4gICAgLyoqIHNlbGVjdCBhIHN1YnRpdGxlIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMqKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3VidGl0bGVUcmFja0lkKSB7XG4gICAgICBpZiAodGhpcy50cmFja0lkICE9PSBzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICAgICAgLy8gfHwgdGhpcy50cmFja3Nbc3VidGl0bGVUcmFja0lkXS5kZXRhaWxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZXRTdWJ0aXRsZVRyYWNrSW50ZXJuYWwoc3VidGl0bGVUcmFja0lkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG59KF9ldmVudEhhbmRsZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcblxufSx7XCIzMlwiOjMyLFwiMzNcIjozMyxcIjUwXCI6NTB9XSwxNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ldmVudHMgPSBfZGVyZXFfKDMzKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9ldmVudEhhbmRsZXIgPSBfZGVyZXFfKDMyKTtcblxudmFyIF9ldmVudEhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRIYW5kbGVyKTtcblxudmFyIF9jZWE2MDhQYXJzZXIgPSBfZGVyZXFfKDQ3KTtcblxudmFyIF9jZWE2MDhQYXJzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2VhNjA4UGFyc2VyKTtcblxudmFyIF93ZWJ2dHRQYXJzZXIgPSBfZGVyZXFfKDU0KTtcblxudmFyIF93ZWJ2dHRQYXJzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2VidnR0UGFyc2VyKTtcblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGltZWxpbmUgQ29udHJvbGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuZnVuY3Rpb24gY2xlYXJDdXJyZW50Q3Vlcyh0cmFjaykge1xuICBpZiAodHJhY2sgJiYgdHJhY2suY3Vlcykge1xuICAgIHdoaWxlICh0cmFjay5jdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRyYWNrLnJlbW92ZUN1ZSh0cmFjay5jdWVzWzBdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFjaywgbWFuaWZlc3RUcmFjaykge1xuICByZXR1cm4gaW5Vc2VUcmFjayAmJiBpblVzZVRyYWNrLmxhYmVsID09PSBtYW5pZmVzdFRyYWNrLm5hbWUgJiYgIShpblVzZVRyYWNrLnRleHRUcmFjazEgfHwgaW5Vc2VUcmFjay50ZXh0VHJhY2syKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKHgxLCB4MiwgeTEsIHkyKSB7XG4gIHJldHVybiBNYXRoLm1pbih4MiwgeTIpIC0gTWF0aC5tYXgoeDEsIHkxKTtcbn1cblxudmFyIFRpbWVsaW5lQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfRXZlbnRIYW5kbGVyKSB7XG4gIF9pbmhlcml0cyhUaW1lbGluZUNvbnRyb2xsZXIsIF9FdmVudEhhbmRsZXIpO1xuXG4gIGZ1bmN0aW9uIFRpbWVsaW5lQ29udHJvbGxlcihobHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZWxpbmVDb250cm9sbGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUaW1lbGluZUNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lbGluZUNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIGhscywgX2V2ZW50czIuZGVmYXVsdC5NRURJQV9BVFRBQ0hJTkcsIF9ldmVudHMyLmRlZmF1bHQuTUVESUFfREVUQUNISU5HLCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19VU0VSREFUQSwgX2V2ZW50czIuZGVmYXVsdC5NQU5JRkVTVF9MT0FESU5HLCBfZXZlbnRzMi5kZWZhdWx0Lk1BTklGRVNUX0xPQURFRCwgX2V2ZW50czIuZGVmYXVsdC5GUkFHX0xPQURFRCwgX2V2ZW50czIuZGVmYXVsdC5MRVZFTF9TV0lUQ0hJTkcsIF9ldmVudHMyLmRlZmF1bHQuSU5JVF9QVFNfRk9VTkQpKTtcblxuICAgIF90aGlzLmhscyA9IGhscztcbiAgICBfdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIF90aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIF90aGlzLkN1ZXMgPSBobHMuY29uZmlnLmN1ZUhhbmRsZXI7XG4gICAgX3RoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgIF90aGlzLnRyYWNrcyA9IFtdO1xuICAgIF90aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICBfdGhpcy5pbml0UFRTID0gdW5kZWZpbmVkO1xuICAgIF90aGlzLmN1ZVJhbmdlcyA9IFtdO1xuXG4gICAgaWYgKF90aGlzLmNvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSBfdGhpcztcbiAgICAgIHZhciBzZW5kQWRkVHJhY2tFdmVudCA9IGZ1bmN0aW9uIHNlbmRBZGRUcmFja0V2ZW50KHRyYWNrLCBtZWRpYSkge1xuICAgICAgICB2YXIgZSA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZSA9IG5ldyB3aW5kb3cuRXZlbnQoJ2FkZHRyYWNrJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vZm9yIElFMTFcbiAgICAgICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgZS5pbml0RXZlbnQoJ2FkZHRyYWNrJywgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlLnRyYWNrID0gdHJhY2s7XG4gICAgICAgIG1lZGlhLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hhbm5lbDEgPSB7XG4gICAgICAgICduZXdDdWUnOiBmdW5jdGlvbiBuZXdDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pIHtcbiAgICAgICAgICBpZiAoIXNlbGYudGV4dFRyYWNrMSkge1xuICAgICAgICAgICAgLy9FbmFibGUgcmV1c2Ugb2YgZXhpc3RpbmcgdGV4dCB0cmFjay5cbiAgICAgICAgICAgIHZhciBleGlzdGluZ1RyYWNrMSA9IHNlbGYuZ2V0RXhpc3RpbmdUcmFjaygnMScpO1xuICAgICAgICAgICAgaWYgKCFleGlzdGluZ1RyYWNrMSkge1xuICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazEgPSBzZWxmLmNyZWF0ZVRleHRUcmFjaygnY2FwdGlvbnMnLCAnRW5nbGlzaCcsICdlbicpO1xuICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazEudGV4dFRyYWNrMSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazEgPSBleGlzdGluZ1RyYWNrMTtcbiAgICAgICAgICAgICAgc2VsZi5jbGVhckN1cnJlbnRDdWVzKHNlbGYudGV4dFRyYWNrMSk7XG5cbiAgICAgICAgICAgICAgc2VuZEFkZFRyYWNrRXZlbnQoc2VsZi50ZXh0VHJhY2sxLCBzZWxmLm1lZGlhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5hZGRDdWVzKCd0ZXh0VHJhY2sxJywgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hhbm5lbDIgPSB7XG4gICAgICAgICduZXdDdWUnOiBmdW5jdGlvbiBuZXdDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pIHtcbiAgICAgICAgICBpZiAoIXNlbGYudGV4dFRyYWNrMikge1xuICAgICAgICAgICAgLy9FbmFibGUgcmV1c2Ugb2YgZXhpc3RpbmcgdGV4dCB0cmFjay5cbiAgICAgICAgICAgIHZhciBleGlzdGluZ1RyYWNrMiA9IHNlbGYuZ2V0RXhpc3RpbmdUcmFjaygnMicpO1xuICAgICAgICAgICAgaWYgKCFleGlzdGluZ1RyYWNrMikge1xuICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazIgPSBzZWxmLmNyZWF0ZVRleHRUcmFjaygnY2FwdGlvbnMnLCAnU3BhbmlzaCcsICdlcycpO1xuICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazIudGV4dFRyYWNrMiA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazIgPSBleGlzdGluZ1RyYWNrMjtcblxuICAgICAgICAgICAgICBzZW5kQWRkVHJhY2tFdmVudChzZWxmLnRleHRUcmFjazIsIHNlbGYubWVkaWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmFkZEN1ZXMoJ3RleHRUcmFjazInLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIF90aGlzLmNlYTYwOFBhcnNlciA9IG5ldyBfY2VhNjA4UGFyc2VyMi5kZWZhdWx0KDAsIGNoYW5uZWwxLCBjaGFubmVsMik7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUaW1lbGluZUNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnYWRkQ3VlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEN1ZXMoY2hhbm5lbCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pIHtcbiAgICAgIC8vIHNraXAgY3VlcyB3aGljaCBvdmVybGFwIG1vcmUgdGhhbiA1MCUgd2l0aCBwcmV2aW91c2x5IHBhcnNlZCB0aW1lIHJhbmdlc1xuICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuY3VlUmFuZ2VzO1xuICAgICAgdmFyIG1lcmdlZCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgdmFyIGN1ZVJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICB2YXIgb3ZlcmxhcCA9IGludGVyc2VjdGlvbihjdWVSYW5nZVswXSwgY3VlUmFuZ2VbMV0sIHN0YXJ0VGltZSwgZW5kVGltZSk7XG4gICAgICAgIGlmIChvdmVybGFwID49IDApIHtcbiAgICAgICAgICBjdWVSYW5nZVswXSA9IE1hdGgubWluKGN1ZVJhbmdlWzBdLCBzdGFydFRpbWUpO1xuICAgICAgICAgIGN1ZVJhbmdlWzFdID0gTWF0aC5tYXgoY3VlUmFuZ2VbMV0sIGVuZFRpbWUpO1xuICAgICAgICAgIG1lcmdlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKG92ZXJsYXAgLyAoZW5kVGltZSAtIHN0YXJ0VGltZSkgPiAwLjUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbWVyZ2VkKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKFtzdGFydFRpbWUsIGVuZFRpbWVdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuQ3Vlcy5uZXdDdWUodGhpc1tjaGFubmVsXSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pO1xuICAgIH1cblxuICAgIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGluaXRpYWwgUFRTIGlzIGZvdW5kOyB1c2VkIGZvciBzeW5jaHJvbmlzYXRpb24gb2YgV2ViVlRULlxuXG4gIH0sIHtcbiAgICBrZXk6ICdvbkluaXRQdHNGb3VuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uSW5pdFB0c0ZvdW5kKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuaW5pdFBUUyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5pbml0UFRTID0gZGF0YS5pbml0UFRTO1xuICAgICAgfVxuXG4gICAgICAvLyBEdWUgdG8gYXN5bmNocm9ueSwgaW5pdGlhbCBQVFMgbWF5IGFycml2ZSBsYXRlciB0aGFuIHRoZSBmaXJzdCBWVFQgZnJhZ21lbnRzIGFyZSBsb2FkZWQuXG4gICAgICAvLyBQYXJzZSBhbnkgdW5wYXJzZWQgZnJhZ21lbnRzIHVwb24gcmVjZWl2aW5nIHRoZSBpbml0aWFsIFBUUy5cbiAgICAgIGlmICh0aGlzLnVucGFyc2VkVnR0RnJhZ3MubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgICAgX3RoaXMyLm9uRnJhZ0xvYWRlZChmcmFnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEV4aXN0aW5nVHJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFeGlzdGluZ1RyYWNrKGNoYW5uZWxOdW1iZXIpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWRpYS50ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHRleHRUcmFjayA9IG1lZGlhLnRleHRUcmFja3NbaV07XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gJ3RleHRUcmFjaycgKyBjaGFubmVsTnVtYmVyO1xuICAgICAgICAgIGlmICh0ZXh0VHJhY2tbcHJvcE5hbWVdID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlVGV4dFRyYWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYS5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgX2V2ZW50SGFuZGxlcjIuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWVkaWFBdHRhY2hpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoaW5nKGRhdGEpIHtcbiAgICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWVkaWFEZXRhY2hpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgICAgY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLnRleHRUcmFjazEpO1xuICAgICAgY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLnRleHRUcmFjazIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTWFuaWZlc3RMb2FkaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgICB0aGlzLmxhc3RTbiA9IC0xOyAvLyBEZXRlY3QgZGlzY29udGlndWl0eSBpbiBmcmFnbWVudCBwYXJzaW5nXG4gICAgICB0aGlzLnByZXZDQyA9IC0xO1xuICAgICAgdGhpcy52dHRDQ3MgPSB7IGNjT2Zmc2V0OiAwLCBwcmVzZW50YXRpb25PZmZzZXQ6IDAgfTsgLy8gRGV0ZWN0IGRpc2NvbnRpbnVpdHkgaW4gc3VidGl0bGUgbWFuaWZlc3RzXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NYW5pZmVzdExvYWRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkZWQoZGF0YSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gdGhpcy51bnBhcnNlZFZ0dEZyYWdzIHx8IFtdO1xuICAgICAgdGhpcy5pbml0UFRTID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jdWVSYW5nZXMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZVdlYlZUVCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMy50cmFja3MgPSBkYXRhLnN1YnRpdGxlcyB8fCBbXTtcbiAgICAgICAgICB2YXIgaW5Vc2VUcmFja3MgPSBfdGhpczMubWVkaWEgPyBfdGhpczMubWVkaWEudGV4dFRyYWNrcyA6IFtdO1xuXG4gICAgICAgICAgX3RoaXMzLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaywgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0VHJhY2sgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgaW5Vc2VUcmFjayA9IGluVXNlVHJhY2tzW2luZGV4XTtcbiAgICAgICAgICAgIC8vIFJldXNlIHRyYWNrcyB3aXRoIHRoZSBzYW1lIGxhYmVsLCBidXQgZG8gbm90IHJldXNlIDYwOC83MDggdHJhY2tzXG4gICAgICAgICAgICBpZiAocmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFjaywgdHJhY2spKSB7XG4gICAgICAgICAgICAgIHRleHRUcmFjayA9IGluVXNlVHJhY2s7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0ZXh0VHJhY2sgPSBfdGhpczMuY3JlYXRlVGV4dFRyYWNrKCdzdWJ0aXRsZXMnLCB0cmFjay5uYW1lLCB0cmFjay5sYW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHRUcmFjay5tb2RlID0gdHJhY2suZGVmYXVsdCA/ICdzaG93aW5nJyA6ICdoaWRkZW4nO1xuICAgICAgICAgICAgX3RoaXMzLnRleHRUcmFja3MucHVzaCh0ZXh0VHJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTGV2ZWxTd2l0Y2hpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkxldmVsU3dpdGNoaW5nKCkge1xuICAgICAgdGhpcy5lbmFibGVkID0gdGhpcy5obHMuY3VycmVudExldmVsLmNsb3NlZENhcHRpb25zICE9PSAnTk9ORSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GcmFnTG9hZGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GcmFnTG9hZGVkKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgICBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICAgIHZhciBzbiA9IGZyYWcuc247XG4gICAgICAgIC8vIGlmIHRoaXMgZnJhZyBpc24ndCBjb250aWd1b3VzLCBjbGVhciB0aGUgcGFyc2VyIHNvIGN1ZXMgd2l0aCBiYWQgc3RhcnQvZW5kIHRpbWVzIGFyZW4ndCBhZGRlZCB0byB0aGUgdGV4dFRyYWNrXG4gICAgICAgIGlmIChzbiAhPT0gdGhpcy5sYXN0U24gKyAxKSB7XG4gICAgICAgICAgdGhpcy5jZWE2MDhQYXJzZXIucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RTbiA9IHNuO1xuICAgICAgfVxuICAgICAgLy8gSWYgZnJhZ21lbnQgaXMgc3VidGl0bGUgdHlwZSwgcGFyc2UgYXMgV2ViVlRULlxuICAgICAgZWxzZSBpZiAoZnJhZy50eXBlID09PSAnc3VidGl0bGUnKSB7XG4gICAgICAgICAgaWYgKHBheWxvYWQuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIF9yZXQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSBuZWVkIGFuIGluaXRpYWwgc3luY2hyb25pc2F0aW9uIFBUUy4gU3RvcmUgZnJhZ21lbnRzIGFzIGxvbmcgYXMgbm9uZSBoYXMgYXJyaXZlZC5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczQuaW5pdFBUUyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBfdGhpczQudW5wYXJzZWRWdHRGcmFncy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB2OiB2b2lkIDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciB2dHRDQ3MgPSBfdGhpczQudnR0Q0NzO1xuICAgICAgICAgICAgICBpZiAoIXZ0dENDc1tmcmFnLmNjXSkge1xuICAgICAgICAgICAgICAgIHZ0dENDc1tmcmFnLmNjXSA9IHsgc3RhcnQ6IGZyYWcuc3RhcnQsIHByZXZDQzogX3RoaXM0LnByZXZDQywgbmV3OiB0cnVlIH07XG4gICAgICAgICAgICAgICAgX3RoaXM0LnByZXZDQyA9IGZyYWcuY2M7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHRleHRUcmFja3MgPSBfdGhpczQudGV4dFRyYWNrcyxcbiAgICAgICAgICAgICAgICAgIGhscyA9IF90aGlzNC5obHM7XG5cbiAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIFdlYlZUVCBmaWxlIGNvbnRlbnRzLlxuICAgICAgICAgICAgICBfd2VidnR0UGFyc2VyMi5kZWZhdWx0LnBhcnNlKHBheWxvYWQsIF90aGlzNC5pbml0UFRTLCB2dHRDQ3MsIGZyYWcuY2MsIGZ1bmN0aW9uIChjdWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGN1ZXMgYW5kIHRyaWdnZXIgZXZlbnQgd2l0aCBzdWNjZXNzIHRydWUuXG4gICAgICAgICAgICAgICAgY3Vlcy5mb3JFYWNoKGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgICAgICAgICAgICAgIHRleHRUcmFja3NbZnJhZy50cmFja0lkXS5hZGRDdWUoY3VlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7IHN1Y2Nlc3M6IHRydWUsIGZyYWc6IGZyYWcgfSk7XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hpbGUgcGFyc2luZy4gVHJpZ2dlciBldmVudCB3aXRoIHN1Y2Nlc3MgZmFsc2UuXG4gICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdGYWlsZWQgdG8gcGFyc2UgVlRUIGN1ZTogJyArIGUpO1xuICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHsgc3VjY2VzczogZmFsc2UsIGZyYWc6IGZyYWcgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBfcmV0MiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoX3JldDIpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQyLnY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbm8gcGF5bG9hZCwgZmluaXNoIHVuc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7IHN1Y2Nlc3M6IGZhbHNlLCBmcmFnOiBmcmFnIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRnJhZ1BhcnNpbmdVc2VyZGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRnJhZ1BhcnNpbmdVc2VyZGF0YShkYXRhKSB7XG4gICAgICAvLyBwdXNoIGFsbCBvZiB0aGUgQ0VBLTcwOCBtZXNzYWdlcyBpbnRvIHRoZSBpbnRlcnByZXRlclxuICAgICAgLy8gaW1tZWRpYXRlbHkuIEl0IHdpbGwgY3JlYXRlIHRoZSBwcm9wZXIgdGltZXN0YW1wcyBiYXNlZCBvbiBvdXIgUFRTIHZhbHVlXG4gICAgICBpZiAodGhpcy5lbmFibGVkICYmIHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5zYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNjZGF0YXMgPSB0aGlzLmV4dHJhY3RDZWE2MDhEYXRhKGRhdGEuc2FtcGxlc1tpXS5ieXRlcyk7XG4gICAgICAgICAgdGhpcy5jZWE2MDhQYXJzZXIuYWRkRGF0YShkYXRhLnNhbXBsZXNbaV0ucHRzLCBjY2RhdGFzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2V4dHJhY3RDZWE2MDhEYXRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdENlYTYwOERhdGEoYnl0ZUFycmF5KSB7XG4gICAgICB2YXIgY291bnQgPSBieXRlQXJyYXlbMF0gJiAzMTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDI7XG4gICAgICB2YXIgdG1wQnl0ZSwgY2NieXRlMSwgY2NieXRlMiwgY2NWYWxpZCwgY2NUeXBlO1xuICAgICAgdmFyIGFjdHVhbENDQnl0ZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgIHRtcEJ5dGUgPSBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICAgIGNjYnl0ZTEgPSAweDdGICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgICBjY2J5dGUyID0gMHg3RiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgICAgY2NWYWxpZCA9ICg0ICYgdG1wQnl0ZSkgIT09IDA7XG4gICAgICAgIGNjVHlwZSA9IDMgJiB0bXBCeXRlO1xuXG4gICAgICAgIGlmIChjY2J5dGUxID09PSAwICYmIGNjYnl0ZTIgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjY1ZhbGlkKSB7XG4gICAgICAgICAgaWYgKGNjVHlwZSA9PT0gMCkgLy8gfHwgY2NUeXBlID09PSAxXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGFjdHVhbENDQnl0ZXMucHVzaChjY2J5dGUxKTtcbiAgICAgICAgICAgICAgYWN0dWFsQ0NCeXRlcy5wdXNoKGNjYnl0ZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0dWFsQ0NCeXRlcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGltZWxpbmVDb250cm9sbGVyO1xufShfZXZlbnRIYW5kbGVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVGltZWxpbmVDb250cm9sbGVyO1xuXG59LHtcIjMyXCI6MzIsXCIzM1wiOjMzLFwiNDdcIjo0NyxcIjUwXCI6NTAsXCI1NFwiOjU0fV0sMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQUVTQ3J5cHRvID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBRVNDcnlwdG8oc3VidGxlLCBpdikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBRVNDcnlwdG8pO1xuXG4gICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgdGhpcy5hZXNJViA9IGl2O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFFU0NyeXB0bywgW3tcbiAgICBrZXk6ICdkZWNyeXB0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcnlwdChkYXRhLCBrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHsgbmFtZTogJ0FFUy1DQkMnLCBpdjogdGhpcy5hZXNJViB9LCBrZXksIGRhdGEpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBRVNDcnlwdG87XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFFU0NyeXB0bztcblxufSx7fV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQUVTRGVjcnlwdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBRVNEZWNyeXB0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFFU0RlY3J5cHRvcik7XG5cbiAgICAvLyBTdGF0aWMgYWZ0ZXIgcnVubmluZyBpbml0VGFibGVcbiAgICB0aGlzLnJjb24gPSBbMHgwLCAweDEsIDB4MiwgMHg0LCAweDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuXG4gICAgdGhpcy5zdWJNaXggPSBbXTtcbiAgICB0aGlzLnN1Yk1peFswXSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMuc3ViTWl4WzFdID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5zdWJNaXhbMl0gPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLnN1Yk1peFszXSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuXG4gICAgdGhpcy5pbnZTdWJNaXggPSBbXTtcbiAgICB0aGlzLmludlN1Yk1peFswXSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMuaW52U3ViTWl4WzFdID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5pbnZTdWJNaXhbMl0gPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLmludlN1Yk1peFszXSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuXG4gICAgdGhpcy5zQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5pbnZTQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG5cbiAgICAvLyBDaGFuZ2VzIGR1cmluZyBydW50aW1lXG4gICAgdGhpcy5rZXkgPSBuZXcgVWludDMyQXJyYXkoMCk7XG5cbiAgICB0aGlzLmluaXRUYWJsZSgpO1xuICB9XG5cbiAgLy8gVXNpbmcgdmlldy5nZXRVaW50MzIoKSBhbHNvIHN3YXBzIHRoZSBieXRlIG9yZGVyLlxuXG5cbiAgX2NyZWF0ZUNsYXNzKEFFU0RlY3J5cHRvciwgW3tcbiAgICBrZXk6ICd1aW50OEFycmF5VG9VaW50MzJBcnJheV8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1aW50OEFycmF5VG9VaW50MzJBcnJheV8oYXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgICAgIHZhciBuZXdBcnJheSA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3QXJyYXlbaV0gPSB2aWV3LmdldFVpbnQzMihpICogNCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3QXJyYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5pdFRhYmxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFRhYmxlKCkge1xuICAgICAgdmFyIHNCb3ggPSB0aGlzLnNCb3g7XG4gICAgICB2YXIgaW52U0JveCA9IHRoaXMuaW52U0JveDtcbiAgICAgIHZhciBzdWJNaXgwID0gdGhpcy5zdWJNaXhbMF07XG4gICAgICB2YXIgc3ViTWl4MSA9IHRoaXMuc3ViTWl4WzFdO1xuICAgICAgdmFyIHN1Yk1peDIgPSB0aGlzLnN1Yk1peFsyXTtcbiAgICAgIHZhciBzdWJNaXgzID0gdGhpcy5zdWJNaXhbM107XG4gICAgICB2YXIgaW52U3ViTWl4MCA9IHRoaXMuaW52U3ViTWl4WzBdO1xuICAgICAgdmFyIGludlN1Yk1peDEgPSB0aGlzLmludlN1Yk1peFsxXTtcbiAgICAgIHZhciBpbnZTdWJNaXgyID0gdGhpcy5pbnZTdWJNaXhbMl07XG4gICAgICB2YXIgaW52U3ViTWl4MyA9IHRoaXMuaW52U3ViTWl4WzNdO1xuXG4gICAgICB2YXIgZCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgICAgdmFyIHggPSAwO1xuICAgICAgdmFyIHhpID0gMDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBpZiAoaSA8IDEyOCkge1xuICAgICAgICAgIGRbaV0gPSBpIDw8IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZFtpXSA9IGkgPDwgMSBeIDB4MTFiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICB2YXIgc3ggPSB4aSBeIHhpIDw8IDEgXiB4aSA8PCAyIF4geGkgPDwgMyBeIHhpIDw8IDQ7XG4gICAgICAgIHN4ID0gc3ggPj4+IDggXiBzeCAmIDB4ZmYgXiAweDYzO1xuICAgICAgICBzQm94W3hdID0gc3g7XG4gICAgICAgIGludlNCb3hbc3hdID0geDtcblxuICAgICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG4gICAgICAgIHZhciB4MiA9IGRbeF07XG4gICAgICAgIHZhciB4NCA9IGRbeDJdO1xuICAgICAgICB2YXIgeDggPSBkW3g0XTtcblxuICAgICAgICAvLyBDb21wdXRlIHN1Yi9pbnZTdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgICB2YXIgdCA9IGRbc3hdICogMHgxMDEgXiBzeCAqIDB4MTAxMDEwMDtcbiAgICAgICAgc3ViTWl4MFt4XSA9IHQgPDwgMjQgfCB0ID4+PiA4O1xuICAgICAgICBzdWJNaXgxW3hdID0gdCA8PCAxNiB8IHQgPj4+IDE2O1xuICAgICAgICBzdWJNaXgyW3hdID0gdCA8PCA4IHwgdCA+Pj4gMjQ7XG4gICAgICAgIHN1Yk1peDNbeF0gPSB0O1xuXG4gICAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgICB0ID0geDggKiAweDEwMTAxMDEgXiB4NCAqIDB4MTAwMDEgXiB4MiAqIDB4MTAxIF4geCAqIDB4MTAxMDEwMDtcbiAgICAgICAgaW52U3ViTWl4MFtzeF0gPSB0IDw8IDI0IHwgdCA+Pj4gODtcbiAgICAgICAgaW52U3ViTWl4MVtzeF0gPSB0IDw8IDE2IHwgdCA+Pj4gMTY7XG4gICAgICAgIGludlN1Yk1peDJbc3hdID0gdCA8PCA4IHwgdCA+Pj4gMjQ7XG4gICAgICAgIGludlN1Yk1peDNbc3hdID0gdDtcblxuICAgICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuICAgICAgICBpZiAoIXgpIHtcbiAgICAgICAgICB4ID0geGkgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG4gICAgICAgICAgeGkgXj0gZFtkW3hpXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdleHBhbmRLZXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBhbmRLZXkoa2V5QnVmZmVyKSB7XG4gICAgICAvLyBjb252ZXJ0IGtleUJ1ZmZlciB0byBVaW50MzJBcnJheVxuICAgICAgdmFyIGtleSA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGtleUJ1ZmZlcik7XG4gICAgICB2YXIgc2FtZUtleSA9IHRydWU7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgd2hpbGUgKG9mZnNldCA8IGtleS5sZW5ndGggJiYgc2FtZUtleSkge1xuICAgICAgICBzYW1lS2V5ID0ga2V5W29mZnNldF0gPT09IHRoaXMua2V5W29mZnNldF07XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2FtZUtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgdmFyIGtleVNpemUgPSB0aGlzLmtleVNpemUgPSBrZXkubGVuZ3RoO1xuXG4gICAgICBpZiAoa2V5U2l6ZSAhPT0gNCAmJiBrZXlTaXplICE9PSA2ICYmIGtleVNpemUgIT09IDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFlcyBrZXkgc2l6ZT0nICsga2V5U2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBrc1Jvd3MgPSB0aGlzLmtzUm93cyA9IChrZXlTaXplICsgNiArIDEpICogNDtcbiAgICAgIHZhciBrc1JvdyA9IHZvaWQgMDtcbiAgICAgIHZhciBpbnZLc1JvdyA9IHZvaWQgMDtcblxuICAgICAgdmFyIGtleVNjaGVkdWxlID0gdGhpcy5rZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheSh0aGlzLmtzUm93cyk7XG4gICAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KHRoaXMua3NSb3dzKTtcbiAgICAgIHZhciBzYm94ID0gdGhpcy5zQm94O1xuICAgICAgdmFyIHJjb24gPSB0aGlzLnJjb247XG5cbiAgICAgIHZhciBpbnZTdWJNaXgwID0gdGhpcy5pbnZTdWJNaXhbMF07XG4gICAgICB2YXIgaW52U3ViTWl4MSA9IHRoaXMuaW52U3ViTWl4WzFdO1xuICAgICAgdmFyIGludlN1Yk1peDIgPSB0aGlzLmludlN1Yk1peFsyXTtcbiAgICAgIHZhciBpbnZTdWJNaXgzID0gdGhpcy5pbnZTdWJNaXhbM107XG5cbiAgICAgIHZhciBwcmV2ID0gdm9pZCAwO1xuICAgICAgdmFyIHQgPSB2b2lkIDA7XG5cbiAgICAgIGZvciAoa3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuICAgICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG4gICAgICAgICAgcHJldiA9IGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVtrc1Jvd107XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdCA9IHByZXY7XG5cbiAgICAgICAgaWYgKGtzUm93ICUga2V5U2l6ZSA9PT0gMCkge1xuICAgICAgICAgIC8vIFJvdCB3b3JkXG4gICAgICAgICAgdCA9IHQgPDwgOCB8IHQgPj4+IDI0O1xuXG4gICAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgICB0ID0gc2JveFt0ID4+PiAyNF0gPDwgMjQgfCBzYm94W3QgPj4+IDE2ICYgMHhmZl0gPDwgMTYgfCBzYm94W3QgPj4+IDggJiAweGZmXSA8PCA4IHwgc2JveFt0ICYgMHhmZl07XG5cbiAgICAgICAgICAvLyBNaXggUmNvblxuICAgICAgICAgIHQgXj0gcmNvbltrc1JvdyAvIGtleVNpemUgfCAwXSA8PCAyNDtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT09IDQpIHtcbiAgICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICAgIHQgPSBzYm94W3QgPj4+IDI0XSA8PCAyNCB8IHNib3hbdCA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IHNib3hbdCA+Pj4gOCAmIDB4ZmZdIDw8IDggfCBzYm94W3QgJiAweGZmXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IHByZXYgPSAoa2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQpID4+PiAwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcbiAgICAgICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcbiAgICAgICAgaWYgKGludktzUm93ICYgMykge1xuICAgICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcbiAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludlN1Yk1peDBbc2JveFt0ID4+PiAyNF1dIF4gaW52U3ViTWl4MVtzYm94W3QgPj4+IDE2ICYgMHhmZl1dIF4gaW52U3ViTWl4MltzYm94W3QgPj4+IDggJiAweGZmXV0gXiBpbnZTdWJNaXgzW3Nib3hbdCAmIDB4ZmZdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludktleVNjaGVkdWxlW2ludktzUm93XSA+Pj4gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGRpbmcgdGhpcyBhcyBhIG1ldGhvZCBncmVhdGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlLlxuXG4gIH0sIHtcbiAgICBrZXk6ICduZXR3b3JrVG9Ib3N0T3JkZXJTd2FwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV0d29ya1RvSG9zdE9yZGVyU3dhcCh3b3JkKSB7XG4gICAgICByZXR1cm4gd29yZCA8PCAyNCB8ICh3b3JkICYgMHhmZjAwKSA8PCA4IHwgKHdvcmQgJiAweGZmMDAwMCkgPj4gOCB8IHdvcmQgPj4+IDI0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlY3J5cHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0KGlucHV0QXJyYXlCdWZmZXIsIG9mZnNldCwgYWVzSVYpIHtcbiAgICAgIHZhciBuUm91bmRzID0gdGhpcy5rZXlTaXplICsgNjtcbiAgICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGU7XG4gICAgICB2YXIgaW52U0JPWCA9IHRoaXMuaW52U0JveDtcblxuICAgICAgdmFyIGludlN1Yk1peDAgPSB0aGlzLmludlN1Yk1peFswXTtcbiAgICAgIHZhciBpbnZTdWJNaXgxID0gdGhpcy5pbnZTdWJNaXhbMV07XG4gICAgICB2YXIgaW52U3ViTWl4MiA9IHRoaXMuaW52U3ViTWl4WzJdO1xuICAgICAgdmFyIGludlN1Yk1peDMgPSB0aGlzLmludlN1Yk1peFszXTtcblxuICAgICAgdmFyIGluaXRWZWN0b3IgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhZXNJVik7XG4gICAgICB2YXIgaW5pdFZlY3RvcjAgPSBpbml0VmVjdG9yWzBdO1xuICAgICAgdmFyIGluaXRWZWN0b3IxID0gaW5pdFZlY3RvclsxXTtcbiAgICAgIHZhciBpbml0VmVjdG9yMiA9IGluaXRWZWN0b3JbMl07XG4gICAgICB2YXIgaW5pdFZlY3RvcjMgPSBpbml0VmVjdG9yWzNdO1xuXG4gICAgICB2YXIgaW5wdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0QXJyYXlCdWZmZXIpO1xuICAgICAgdmFyIG91dHB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRJbnQzMi5sZW5ndGgpO1xuXG4gICAgICB2YXIgdDAgPSB2b2lkIDAsXG4gICAgICAgICAgdDEgPSB2b2lkIDAsXG4gICAgICAgICAgdDIgPSB2b2lkIDAsXG4gICAgICAgICAgdDMgPSB2b2lkIDA7XG4gICAgICB2YXIgczAgPSB2b2lkIDAsXG4gICAgICAgICAgczEgPSB2b2lkIDAsXG4gICAgICAgICAgczIgPSB2b2lkIDAsXG4gICAgICAgICAgczMgPSB2b2lkIDA7XG4gICAgICB2YXIgaW5wdXRXb3JkczAgPSB2b2lkIDAsXG4gICAgICAgICAgaW5wdXRXb3JkczEgPSB2b2lkIDAsXG4gICAgICAgICAgaW5wdXRXb3JkczIgPSB2b2lkIDAsXG4gICAgICAgICAgaW5wdXRXb3JkczMgPSB2b2lkIDA7XG5cbiAgICAgIHZhciBrc1JvdywgaTtcblxuICAgICAgd2hpbGUgKG9mZnNldCA8IGlucHV0SW50MzIubGVuZ3RoKSB7XG4gICAgICAgIGlucHV0V29yZHMwID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKGlucHV0SW50MzJbb2Zmc2V0XSk7XG4gICAgICAgIGlucHV0V29yZHMxID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKGlucHV0SW50MzJbb2Zmc2V0ICsgMV0pO1xuICAgICAgICBpbnB1dFdvcmRzMiA9IHRoaXMubmV0d29ya1RvSG9zdE9yZGVyU3dhcChpbnB1dEludDMyW29mZnNldCArIDJdKTtcbiAgICAgICAgaW5wdXRXb3JkczMgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXAoaW5wdXRJbnQzMltvZmZzZXQgKyAzXSk7XG5cbiAgICAgICAgczAgPSBpbnB1dFdvcmRzMCBeIGludktleVNjaGVkdWxlWzBdO1xuICAgICAgICBzMSA9IGlucHV0V29yZHMzIF4gaW52S2V5U2NoZWR1bGVbMV07XG4gICAgICAgIHMyID0gaW5wdXRXb3JkczIgXiBpbnZLZXlTY2hlZHVsZVsyXTtcbiAgICAgICAgczMgPSBpbnB1dFdvcmRzMSBeIGludktleVNjaGVkdWxlWzNdO1xuXG4gICAgICAgIGtzUm93ID0gNDtcblxuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJvdW5kcyBvZiBkZWNyeXB0aW9uXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBuUm91bmRzOyBpKyspIHtcbiAgICAgICAgICB0MCA9IGludlN1Yk1peDBbczAgPj4+IDI0XSBeIGludlN1Yk1peDFbczEgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczIgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgICAgIHQxID0gaW52U3ViTWl4MFtzMSA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMiA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMyA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MwICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgICAgIHQyID0gaW52U3ViTWl4MFtzMiA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMyA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMCA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MxICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgICAgIHQzID0gaW52U3ViTWl4MFtzMyA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMCA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMSA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgICAgIHMwID0gdDA7XG4gICAgICAgICAgczEgPSB0MTtcbiAgICAgICAgICBzMiA9IHQyO1xuICAgICAgICAgIHMzID0gdDM7XG5cbiAgICAgICAgICBrc1JvdyA9IGtzUm93ICsgNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuICAgICAgICB0MCA9IGludlNCT1hbczAgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczEgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczIgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgIHQxID0gaW52U0JPWFtzMSA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMiA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMyA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczAgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICAgIHQyID0gaW52U0JPWFtzMiA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMyA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMCA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICAgIHQzID0gaW52U0JPWFtzMyA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMCA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMSA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107XG4gICAgICAgIGtzUm93ID0ga3NSb3cgKyAzO1xuXG4gICAgICAgIC8vIFdyaXRlXG4gICAgICAgIG91dHB1dEludDMyW29mZnNldF0gPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXAodDAgXiBpbml0VmVjdG9yMCk7XG4gICAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKHQzIF4gaW5pdFZlY3RvcjEpO1xuICAgICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAyXSA9IHRoaXMubmV0d29ya1RvSG9zdE9yZGVyU3dhcCh0MiBeIGluaXRWZWN0b3IyKTtcbiAgICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgM10gPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXAodDEgXiBpbml0VmVjdG9yMyk7XG5cbiAgICAgICAgLy8gcmVzZXQgaW5pdFZlY3RvciB0byBsYXN0IDQgdW5zaWduZWQgaW50XG4gICAgICAgIGluaXRWZWN0b3IwID0gaW5wdXRXb3JkczA7XG4gICAgICAgIGluaXRWZWN0b3IxID0gaW5wdXRXb3JkczE7XG4gICAgICAgIGluaXRWZWN0b3IyID0gaW5wdXRXb3JkczI7XG4gICAgICAgIGluaXRWZWN0b3IzID0gaW5wdXRXb3JkczM7XG5cbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgNDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dEludDMyLmJ1ZmZlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMua2V5ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5rZXlTaXplID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5rc1Jvd3MgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuc0JveCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuaW52U0JveCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuc3ViTWl4ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbnZTdWJNaXggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmtleVNjaGVkdWxlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbnZLZXlTY2hlZHVsZSA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5yY29uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBRVNEZWNyeXB0b3I7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFFU0RlY3J5cHRvcjtcblxufSx7fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2Flc0NyeXB0byA9IF9kZXJlcV8oMTcpO1xuXG52YXIgX2Flc0NyeXB0bzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZXNDcnlwdG8pO1xuXG52YXIgX2Zhc3RBZXNLZXkgPSBfZGVyZXFfKDIwKTtcblxudmFyIF9mYXN0QWVzS2V5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Zhc3RBZXNLZXkpO1xuXG52YXIgX2Flc0RlY3J5cHRvciA9IF9kZXJlcV8oMTgpO1xuXG52YXIgX2Flc0RlY3J5cHRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZXNEZWNyeXB0b3IpO1xuXG52YXIgX2Vycm9ycyA9IF9kZXJlcV8oMzEpO1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKmdsb2JhbHMgc2VsZjogZmFsc2UgKi9cblxudmFyIERlY3J5cHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVjcnlwdGVyKG9ic2VydmVyLCBjb25maWcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVjcnlwdGVyKTtcblxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmxvZ0VuYWJsZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICB2YXIgYnJvd3NlckNyeXB0byA9IGNyeXB0byA/IGNyeXB0byA6IHNlbGYuY3J5cHRvO1xuICAgICAgdGhpcy5zdWJ0bGUgPSBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fCBicm93c2VyQ3J5cHRvLndlYmtpdFN1YnRsZTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRoaXMuZGlzYWJsZVdlYkNyeXB0byA9ICF0aGlzLnN1YnRsZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEZWNyeXB0ZXIsIFt7XG4gICAga2V5OiAnaXNTeW5jJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTeW5jKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZVdlYkNyeXB0byAmJiB0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWNyeXB0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcnlwdChkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuZGlzYWJsZVdlYkNyeXB0byAmJiB0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xuICAgICAgICBpZiAodGhpcy5sb2dFbmFibGVkKSB7XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdKUyBBRVMgZGVjcnlwdCcpO1xuICAgICAgICAgIHRoaXMubG9nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWNyeXB0b3IgPSB0aGlzLmRlY3J5cHRvcjtcbiAgICAgICAgaWYgKCFkZWNyeXB0b3IpIHtcbiAgICAgICAgICB0aGlzLmRlY3J5cHRvciA9IGRlY3J5cHRvciA9IG5ldyBfYWVzRGVjcnlwdG9yMi5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjcnlwdG9yLmV4cGFuZEtleShrZXkpO1xuICAgICAgICBjYWxsYmFjayhkZWNyeXB0b3IuZGVjcnlwdChkYXRhLCAwLCBpdikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMubG9nRW5hYmxlZCkge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdXZWJDcnlwdG8gQUVTIGRlY3J5cHQnKTtcbiAgICAgICAgICAgIF90aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN1YnRsZSA9IF90aGlzLnN1YnRsZTtcbiAgICAgICAgICBpZiAoX3RoaXMua2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAgIF90aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIF90aGlzLmZhc3RBZXNLZXkgPSBuZXcgX2Zhc3RBZXNLZXkyLmRlZmF1bHQoc3VidGxlLCBrZXkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KCkudGhlbihmdW5jdGlvbiAoYWVzS2V5KSB7XG4gICAgICAgICAgICAvLyBkZWNyeXB0IHVzaW5nIHdlYiBjcnlwdG9cbiAgICAgICAgICAgIHZhciBjcnlwdG8gPSBuZXcgX2Flc0NyeXB0bzIuZGVmYXVsdChzdWJ0bGUsIGl2KTtcbiAgICAgICAgICAgIGNyeXB0by5kZWNyeXB0KGRhdGEsIGFlc0tleSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICBfdGhpcy5vbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBfdGhpcy5vbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uV2ViQ3J5cHRvRXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ1dlYkNyeXB0byBFcnJvciwgZGlzYWJsZSBXZWJDcnlwdG8gQVBJJyk7XG4gICAgICAgIHRoaXMuZGlzYWJsZVdlYkNyeXB0byA9IHRydWU7XG4gICAgICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVjcnlwdChkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5lcnJvcignZGVjcnlwdGluZyBlcnJvciA6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUiwgZmF0YWw6IHRydWUsIHJlYXNvbjogZXJyLm1lc3NhZ2UgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgZGVjcnlwdG9yID0gdGhpcy5kZWNyeXB0b3I7XG4gICAgICBpZiAoZGVjcnlwdG9yKSB7XG4gICAgICAgIGRlY3J5cHRvci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZGVjcnlwdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEZWNyeXB0ZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERlY3J5cHRlcjtcblxufSx7XCIxN1wiOjE3LFwiMThcIjoxOCxcIjIwXCI6MjAsXCIzMVwiOjMxLFwiNTBcIjo1MH1dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEZhc3RBRVNLZXkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZhc3RBRVNLZXkoc3VidGxlLCBrZXkpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmFzdEFFU0tleSk7XG5cbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGYXN0QUVTS2V5LCBbe1xuICAgIGtleTogJ2V4cGFuZEtleScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4cGFuZEtleSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHRoaXMua2V5LCB7IG5hbWU6ICdBRVMtQ0JDJyB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZhc3RBRVNLZXk7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEZhc3RBRVNLZXk7XG5cbn0se31dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQUFDIGRlbXV4ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuXG52YXIgX2FkdHMgPSBfZGVyZXFfKDIyKTtcblxudmFyIF9hZHRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkdHMpO1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG52YXIgX2lkID0gX2RlcmVxXygyNyk7XG5cbnZhciBfaWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaWQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQUFDRGVtdXhlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQUFDRGVtdXhlcihvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFBQ0RlbXV4ZXIpO1xuXG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQUFDRGVtdXhlciwgW3tcbiAgICBrZXk6ICdyZXNldEluaXRTZWdtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICAgIHRoaXMuX2FhY1RyYWNrID0geyBjb250YWluZXI6ICdhdWRpby9hZHRzJywgdHlwZTogJ2F1ZGlvJywgaWQ6IC0xLCBzZXF1ZW5jZU51bWJlcjogMCwgaXNBQUM6IHRydWUsIHNhbXBsZXM6IFtdLCBsZW46IDAsIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsIGR1cmF0aW9uOiBkdXJhdGlvbiB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0VGltZVN0YW1wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRUaW1lU3RhbXAoKSB7fVxuICB9LCB7XG4gICAga2V5OiAnYXBwZW5kJyxcblxuXG4gICAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICB2YXIgdHJhY2ssXG4gICAgICAgICAgaWQzID0gbmV3IF9pZDIuZGVmYXVsdChkYXRhKSxcbiAgICAgICAgICBwdHMgPSA5MCAqIGlkMy50aW1lU3RhbXAsXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIGZyYW1lTGVuZ3RoLFxuICAgICAgICAgIGZyYW1lRHVyYXRpb24sXG4gICAgICAgICAgZnJhbWVJbmRleCxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgaGVhZGVyTGVuZ3RoLFxuICAgICAgICAgIHN0YW1wLFxuICAgICAgICAgIGxlbixcbiAgICAgICAgICBhYWNTYW1wbGU7XG5cbiAgICAgIHRyYWNrID0gdGhpcy5fYWFjVHJhY2s7XG5cbiAgICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgICBmb3IgKG9mZnNldCA9IGlkMy5sZW5ndGgsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhmMCkgPT09IDB4ZjApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYWNrLmF1ZGlvc2FtcGxlcmF0ZSkge1xuICAgICAgICBjb25maWcgPSBfYWR0czIuZGVmYXVsdC5nZXRBdWRpb0NvbmZpZyh0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRyYWNrLm1hbmlmZXN0Q29kZWMpO1xuICAgICAgICB0cmFjay5jb25maWcgPSBjb25maWcuY29uZmlnO1xuICAgICAgICB0cmFjay5hdWRpb3NhbXBsZXJhdGUgPSBjb25maWcuc2FtcGxlcmF0ZTtcbiAgICAgICAgdHJhY2suY2hhbm5lbENvdW50ID0gY29uZmlnLmNoYW5uZWxDb3VudDtcbiAgICAgICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygncGFyc2VkIGNvZGVjOicgKyB0cmFjay5jb2RlYyArICcscmF0ZTonICsgY29uZmlnLnNhbXBsZXJhdGUgKyAnLG5iIGNoYW5uZWw6JyArIGNvbmZpZy5jaGFubmVsQ291bnQpO1xuICAgICAgfVxuICAgICAgZnJhbWVJbmRleCA9IDA7XG4gICAgICBmcmFtZUR1cmF0aW9uID0gMTAyNCAqIDkwMDAwIC8gdHJhY2suYXVkaW9zYW1wbGVyYXRlO1xuICAgICAgd2hpbGUgKG9mZnNldCArIDUgPCBsZW4pIHtcbiAgICAgICAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIEFEVFMgaGVhZGVyXG4gICAgICAgIGhlYWRlckxlbmd0aCA9ICEhKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDAxKSA/IDcgOiA5O1xuICAgICAgICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gICAgICAgIGZyYW1lTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSB8IGRhdGFbb2Zmc2V0ICsgNF0gPDwgMyB8IChkYXRhW29mZnNldCArIDVdICYgMHhFMCkgPj4+IDU7XG4gICAgICAgIGZyYW1lTGVuZ3RoIC09IGhlYWRlckxlbmd0aDtcbiAgICAgICAgLy9zdGFtcCA9IHBlcy5wdHM7XG5cbiAgICAgICAgaWYgKGZyYW1lTGVuZ3RoID4gMCAmJiBvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCA8PSBsZW4pIHtcbiAgICAgICAgICBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcbiAgICAgICAgICBhYWNTYW1wbGUgPSB7IHVuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCksIHB0czogc3RhbXAsIGR0czogc3RhbXAgfTtcbiAgICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYWFjU2FtcGxlKTtcbiAgICAgICAgICB0cmFjay5sZW4gKz0gZnJhbWVMZW5ndGg7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lTGVuZ3RoICsgaGVhZGVyTGVuZ3RoO1xuICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgICAgICAgIGZvciAoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjApID09PSAweGYwKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW11eGVyLnJlbXV4KHRyYWNrLCB7IHNhbXBsZXM6IFtdIH0sIHsgc2FtcGxlczogW3sgcHRzOiBwdHMsIGR0czogcHRzLCB1bml0OiBpZDMucGF5bG9hZCB9XSB9LCB7IHNhbXBsZXM6IFtdIH0sIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fVxuICB9XSwgW3tcbiAgICBrZXk6ICdwcm9iZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2JlKGRhdGEpIHtcbiAgICAgIC8vIGNoZWNrIGlmIGRhdGEgY29udGFpbnMgSUQzIHRpbWVzdGFtcCBhbmQgQURUUyBzeW5jIHdvcmNcbiAgICAgIHZhciBpZDMgPSBuZXcgX2lkMi5kZWZhdWx0KGRhdGEpLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICBsZW47XG4gICAgICBpZiAoaWQzLmhhc1RpbWVTdGFtcCkge1xuICAgICAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgICAgICBmb3IgKG9mZnNldCA9IGlkMy5sZW5ndGgsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGYwKSA9PT0gMHhmMCkge1xuICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdBRFRTIHN5bmMgd29yZCBmb3VuZCAhJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQUFDRGVtdXhlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQUFDRGVtdXhlcjtcblxufSx7XCIyMlwiOjIyLFwiMjdcIjoyNyxcIjUwXCI6NTB9XSwyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBBRFRTIHBhcnNlciBoZWxwZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG52YXIgX2Vycm9ycyA9IF9kZXJlcV8oMzEpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQURUUyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQURUUygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQURUUyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQURUUywgbnVsbCwgW3tcbiAgICBrZXk6ICdnZXRBdWRpb0NvbmZpZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgICAgIHZhciBhZHRzT2JqZWN0VHlwZSxcbiAgICAgICAgICAvLyA6aW50XG4gICAgICBhZHRzU2FtcGxlaW5nSW5kZXgsXG4gICAgICAgICAgLy8gOmludFxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4LFxuICAgICAgICAgIC8vIDppbnRcbiAgICAgIGFkdHNDaGFuZWxDb25maWcsXG4gICAgICAgICAgLy8gOmludFxuICAgICAgY29uZmlnLFxuICAgICAgICAgIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBtYW5pZmVzdENvZGVjID0gYXVkaW9Db2RlYyxcbiAgICAgICAgICBhZHRzU2FtcGxlaW5nUmF0ZXMgPSBbOTYwMDAsIDg4MjAwLCA2NDAwMCwgNDgwMDAsIDQ0MTAwLCAzMjAwMCwgMjQwMDAsIDIyMDUwLCAxNjAwMCwgMTIwMDAsIDExMDI1LCA4MDAwLCA3MzUwXTtcbiAgICAgIC8vIGJ5dGUgMlxuICAgICAgYWR0c09iamVjdFR5cGUgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweEMwKSA+Pj4gNikgKyAxO1xuICAgICAgYWR0c1NhbXBsZWluZ0luZGV4ID0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDNDKSA+Pj4gMjtcbiAgICAgIGlmIChhZHRzU2FtcGxlaW5nSW5kZXggPiBhZHRzU2FtcGxlaW5nUmF0ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiAnaW52YWxpZCBBRFRTIHNhbXBsaW5nIGluZGV4OicgKyBhZHRzU2FtcGxlaW5nSW5kZXggfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFkdHNDaGFuZWxDb25maWcgPSAoZGF0YVtvZmZzZXQgKyAyXSAmIDB4MDEpIDw8IDI7XG4gICAgICAvLyBieXRlIDNcbiAgICAgIGFkdHNDaGFuZWxDb25maWcgfD0gKGRhdGFbb2Zmc2V0ICsgM10gJiAweEMwKSA+Pj4gNjtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbWFuaWZlc3QgY29kZWM6JyArIGF1ZGlvQ29kZWMgKyAnLEFEVFMgZGF0YTp0eXBlOicgKyBhZHRzT2JqZWN0VHlwZSArICcsc2FtcGxlaW5nSW5kZXg6JyArIGFkdHNTYW1wbGVpbmdJbmRleCArICdbJyArIGFkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxlaW5nSW5kZXhdICsgJ0h6XSxjaGFubmVsQ29uZmlnOicgKyBhZHRzQ2hhbmVsQ29uZmlnKTtcbiAgICAgIC8vIGZpcmVmb3g6IGZyZXEgbGVzcyB0aGFuIDI0a0h6ID0gQUFDIFNCUiAoSEUtQUFDKVxuICAgICAgaWYgKC9maXJlZm94L2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgICAgIGlmIChhZHRzU2FtcGxlaW5nSW5kZXggPj0gNikge1xuICAgICAgICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQW5kcm9pZCA6IGFsd2F5cyB1c2UgQUFDXG4gICAgICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xKSB7XG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiAgZm9yIG90aGVyIGJyb3dzZXJzIChDaHJvbWUvVml2YWxkaS9PcGVyYSAuLi4pXG4gICAgICAgICAgICBhbHdheXMgZm9yY2UgYXVkaW8gdHlwZSB0byBiZSBIRS1BQUMgU0JSLCBhcyBzb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGF1ZGlvIGNvZGVjIHN3aXRjaCBwcm9wZXJseSAobGlrZSBDaHJvbWUgLi4uKVxuICAgICAgICAqL1xuICAgICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSg0KTtcbiAgICAgICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEhFLUFBQyBvciBIRS1BQUN2MikgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgQU5EIGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHopXG4gICAgICAgIGlmIChhdWRpb0NvZGVjICYmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMjknKSAhPT0gLTEgfHwgYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHx8ICFhdWRpb0NvZGVjICYmIGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2KSB7XG4gICAgICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEFBQykgQU5EIChmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6IEFORCBuYiBjaGFubmVsIGlzIDEpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIGFuZCBtb25vIGF1ZGlvKVxuICAgICAgICAgIC8vIENocm9tZSBmYWlscyB0byBwbGF5IGJhY2sgd2l0aCBsb3cgZnJlcXVlbmN5IEFBQyBMQyBtb25vIHdoZW4gaW5pdGlhbGl6ZWQgd2l0aCBIRS1BQUMuICBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2l0aCBzdGVyZW8uXG4gICAgICAgICAgaWYgKGF1ZGlvQ29kZWMgJiYgYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEgJiYgYWR0c1NhbXBsZWluZ0luZGV4ID49IDYgJiYgYWR0c0NoYW5lbENvbmZpZyA9PT0gMSB8fCAhYXVkaW9Db2RlYyAmJiBhZHRzQ2hhbmVsQ29uZmlnID09PSAxKSB7XG4gICAgICAgICAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogcmVmZXIgdG8gaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9TVBFRy00X0F1ZGlvI0F1ZGlvX1NwZWNpZmljX0NvbmZpZ1xuICAgICAgICAgIElTTyAxNDQ5Ni0zIChBQUMpLnBkZiAtIFRhYmxlIDEuMTMg4oCUIFN5bnRheCBvZiBBdWRpb1NwZWNpZmljQ29uZmlnKClcbiAgICAgICAgQXVkaW8gUHJvZmlsZSAvIEF1ZGlvIE9iamVjdCBUeXBlXG4gICAgICAgIDA6IE51bGxcbiAgICAgICAgMTogQUFDIE1haW5cbiAgICAgICAgMjogQUFDIExDIChMb3cgQ29tcGxleGl0eSlcbiAgICAgICAgMzogQUFDIFNTUiAoU2NhbGFibGUgU2FtcGxlIFJhdGUpXG4gICAgICAgIDQ6IEFBQyBMVFAgKExvbmcgVGVybSBQcmVkaWN0aW9uKVxuICAgICAgICA1OiBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pXG4gICAgICAgIDY6IEFBQyBTY2FsYWJsZVxuICAgICAgIHNhbXBsaW5nIGZyZXFcbiAgICAgICAgMDogOTYwMDAgSHpcbiAgICAgICAgMTogODgyMDAgSHpcbiAgICAgICAgMjogNjQwMDAgSHpcbiAgICAgICAgMzogNDgwMDAgSHpcbiAgICAgICAgNDogNDQxMDAgSHpcbiAgICAgICAgNTogMzIwMDAgSHpcbiAgICAgICAgNjogMjQwMDAgSHpcbiAgICAgICAgNzogMjIwNTAgSHpcbiAgICAgICAgODogMTYwMDAgSHpcbiAgICAgICAgOTogMTIwMDAgSHpcbiAgICAgICAgMTA6IDExMDI1IEh6XG4gICAgICAgIDExOiA4MDAwIEh6XG4gICAgICAgIDEyOiA3MzUwIEh6XG4gICAgICAgIDEzOiBSZXNlcnZlZFxuICAgICAgICAxNDogUmVzZXJ2ZWRcbiAgICAgICAgMTU6IGZyZXF1ZW5jeSBpcyB3cml0dGVuIGV4cGxpY3RseVxuICAgICAgICBDaGFubmVsIENvbmZpZ3VyYXRpb25zXG4gICAgICAgIFRoZXNlIGFyZSB0aGUgY2hhbm5lbCBjb25maWd1cmF0aW9uczpcbiAgICAgICAgMDogRGVmaW5lZCBpbiBBT1QgU3BlY2lmYyBDb25maWdcbiAgICAgICAgMTogMSBjaGFubmVsOiBmcm9udC1jZW50ZXJcbiAgICAgICAgMjogMiBjaGFubmVsczogZnJvbnQtbGVmdCwgZnJvbnQtcmlnaHRcbiAgICAgICovXG4gICAgICAvLyBhdWRpb09iamVjdFR5cGUgPSBwcm9maWxlID0+IHByb2ZpbGUsIHRoZSBNUEVHLTQgQXVkaW8gT2JqZWN0IFR5cGUgbWludXMgMVxuICAgICAgY29uZmlnWzBdID0gYWR0c09iamVjdFR5cGUgPDwgMztcbiAgICAgIC8vIHNhbXBsaW5nRnJlcXVlbmN5SW5kZXhcbiAgICAgIGNvbmZpZ1swXSB8PSAoYWR0c1NhbXBsZWluZ0luZGV4ICYgMHgwRSkgPj4gMTtcbiAgICAgIGNvbmZpZ1sxXSB8PSAoYWR0c1NhbXBsZWluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgICAgIC8vIGNoYW5uZWxDb25maWd1cmF0aW9uXG4gICAgICBjb25maWdbMV0gfD0gYWR0c0NoYW5lbENvbmZpZyA8PCAzO1xuICAgICAgaWYgKGFkdHNPYmplY3RUeXBlID09PSA1KSB7XG4gICAgICAgIC8vIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleFxuICAgICAgICBjb25maWdbMV0gfD0gKGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCAmIDB4MEUpID4+IDE7XG4gICAgICAgIGNvbmZpZ1syXSA9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgICAgICAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XG4gICAgICAgIC8vICAgIGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMuZ2l0LysvbWFzdGVyL21lZGlhL2Zvcm1hdHMvbXA0L2FhYy5jY1xuICAgICAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xuICAgICAgICBjb25maWdbM10gPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY29uZmlnOiBjb25maWcsIHNhbXBsZXJhdGU6IGFkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxlaW5nSW5kZXhdLCBjaGFubmVsQ291bnQ6IGFkdHNDaGFuZWxDb25maWcsIGNvZGVjOiAnbXA0YS40MC4nICsgYWR0c09iamVjdFR5cGUsIG1hbmlmZXN0Q29kZWM6IG1hbmlmZXN0Q29kZWMgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQURUUztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQURUUztcblxufSx7XCIzMVwiOjMxLFwiNTBcIjo1MH1dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyogIGlubGluZSBkZW11eGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgcHJvYmUgZnJhZ21lbnRzIGFuZCBpbnN0YW50aWF0ZSBhcHByb3ByaWF0ZSBkZW11eGVyIGRlcGVuZGluZyBvbiBjb250ZW50IHR5cGUgKFRTRGVtdXhlciwgQUFDRGVtdXhlciwgLi4uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgX2V2ZW50cyA9IF9kZXJlcV8oMzMpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX2Vycm9ycyA9IF9kZXJlcV8oMzEpO1xuXG52YXIgX2RlY3J5cHRlciA9IF9kZXJlcV8oMTkpO1xuXG52YXIgX2RlY3J5cHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWNyeXB0ZXIpO1xuXG52YXIgX2FhY2RlbXV4ZXIgPSBfZGVyZXFfKDIxKTtcblxudmFyIF9hYWNkZW11eGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FhY2RlbXV4ZXIpO1xuXG52YXIgX21wNGRlbXV4ZXIgPSBfZGVyZXFfKDI4KTtcblxudmFyIF9tcDRkZW11eGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21wNGRlbXV4ZXIpO1xuXG52YXIgX3RzZGVtdXhlciA9IF9kZXJlcV8oMzApO1xuXG52YXIgX3RzZGVtdXhlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90c2RlbXV4ZXIpO1xuXG52YXIgX21wNFJlbXV4ZXIgPSBfZGVyZXFfKDQzKTtcblxudmFyIF9tcDRSZW11eGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21wNFJlbXV4ZXIpO1xuXG52YXIgX3Bhc3N0aHJvdWdoUmVtdXhlciA9IF9kZXJlcV8oNDQpO1xuXG52YXIgX3Bhc3N0aHJvdWdoUmVtdXhlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXNzdGhyb3VnaFJlbXV4ZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgRGVtdXhlcklubGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVtdXhlcklubGluZShvYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlbXV4ZXJJbmxpbmUpO1xuXG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGVtdXhlcklubGluZSwgW3tcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgaWYgKGRlbXV4ZXIpIHtcbiAgICAgICAgZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHVzaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2goZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICAgIGlmIChkYXRhLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHRkYXRhICE9IG51bGwgJiYgZGVjcnlwdGRhdGEua2V5ICE9IG51bGwgJiYgZGVjcnlwdGRhdGEubWV0aG9kID09PSAnQUVTLTEyOCcpIHtcbiAgICAgICAgdmFyIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyO1xuICAgICAgICBpZiAoZGVjcnlwdGVyID09IG51bGwpIHtcbiAgICAgICAgICBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlciA9IG5ldyBfZGVjcnlwdGVyMi5kZWZhdWx0KHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9jYWx0aGlzID0gdGhpcztcbiAgICAgICAgLy8gcGVyZm9ybWFuY2Uubm93KCkgbm90IGF2YWlsYWJsZSBvbiBXZWJXb3JrZXIsIGF0IGxlYXN0IG9uIFNhZmFyaSBEZXNrdG9wXG4gICAgICAgIHZhciBzdGFydFRpbWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNyeXB0ZXIuZGVjcnlwdChkYXRhLCBkZWNyeXB0ZGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0ZGF0YS5pdi5idWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgICAgdmFyIGVuZFRpbWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZW5kVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvY2FsdGhpcy5vYnNlcnZlci50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlJBR19ERUNSWVBURUQsIHsgc3RhdHM6IHsgdHN0YXJ0OiBzdGFydFRpbWUsIHRkZWNyeXB0OiBlbmRUaW1lIH0gfSk7XG4gICAgICAgICAgbG9jYWx0aGlzLnB1c2hEZWNyeXB0ZWQobmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSksIGRlY3J5cHRkYXRhLCBuZXcgVWludDhBcnJheShpbml0U2VnbWVudCksIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoRGVjcnlwdGVkKG5ldyBVaW50OEFycmF5KGRhdGEpLCBkZWNyeXB0ZGF0YSwgbmV3IFVpbnQ4QXJyYXkoaW5pdFNlZ21lbnQpLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3B1c2hEZWNyeXB0ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoRGVjcnlwdGVkKGRhdGEsIGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKSB7XG4gICAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICAgIGlmICghZGVtdXhlciB8fFxuICAgICAgLy8gaW4gY2FzZSBvZiBjb250aW51aXR5IGNoYW5nZSwgd2UgbWlnaHQgc3dpdGNoIGZyb20gY29udGVudCB0eXBlIChBQUMgY29udGFpbmVyIHRvIFRTIGNvbnRhaW5lciBmb3IgZXhhbXBsZSlcbiAgICAgIC8vIHNvIGxldCdzIGNoZWNrIHRoYXQgY3VycmVudCBkZW11eGVyIGlzIHN0aWxsIHZhbGlkXG4gICAgICBkaXNjb250aW51aXR5ICYmICF0aGlzLnByb2JlKGRhdGEpKSB7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgICAgIHZhciB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkO1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIHZhciBtdXhDb25maWcgPSBbeyBkZW11eDogX3RzZGVtdXhlcjIuZGVmYXVsdCwgcmVtdXg6IF9tcDRSZW11eGVyMi5kZWZhdWx0IH0sIHsgZGVtdXg6IF9hYWNkZW11eGVyMi5kZWZhdWx0LCByZW11eDogX21wNFJlbXV4ZXIyLmRlZmF1bHQgfSwgeyBkZW11eDogX21wNGRlbXV4ZXIyLmRlZmF1bHQsIHJlbXV4OiBfcGFzc3Rocm91Z2hSZW11eGVyMi5kZWZhdWx0IH1dO1xuXG4gICAgICAgIC8vIHByb2JlIGZvciBjb250ZW50IHR5cGVcbiAgICAgICAgZm9yICh2YXIgaSBpbiBtdXhDb25maWcpIHtcbiAgICAgICAgICB2YXIgbXV4ID0gbXV4Q29uZmlnW2ldO1xuICAgICAgICAgIHZhciBwcm9iZSA9IG11eC5kZW11eC5wcm9iZTtcbiAgICAgICAgICBpZiAocHJvYmUoZGF0YSkpIHtcbiAgICAgICAgICAgIHZhciBfcmVtdXhlciA9IHRoaXMucmVtdXhlciA9IG5ldyBtdXgucmVtdXgob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCk7XG4gICAgICAgICAgICBkZW11eGVyID0gbmV3IG11eC5kZW11eChvYnNlcnZlciwgX3JlbXV4ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCk7XG4gICAgICAgICAgICB0aGlzLnByb2JlID0gcHJvYmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZW11eGVyKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiAnbm8gZGVtdXggbWF0Y2hpbmcgd2l0aCBjb250ZW50IGZvdW5kJyB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZW11eGVyID0gZGVtdXhlcjtcbiAgICAgIH1cbiAgICAgIHZhciByZW11eGVyID0gdGhpcy5yZW11eGVyO1xuXG4gICAgICBpZiAoZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaCkge1xuICAgICAgICBkZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKTtcbiAgICAgICAgcmVtdXhlci5yZXNldEluaXRTZWdtZW50KCk7XG4gICAgICB9XG4gICAgICBpZiAoZGlzY29udGludWl0eSkge1xuICAgICAgICBkZW11eGVyLnJlc2V0VGltZVN0YW1wKCk7XG4gICAgICAgIHJlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFMpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkZW11eGVyLnNldERlY3J5cHREYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRlbXV4ZXIuc2V0RGVjcnlwdERhdGEoZGVjcnlwdGRhdGEpO1xuICAgICAgfVxuICAgICAgZGVtdXhlci5hcHBlbmQoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGVtdXhlcklubGluZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRGVtdXhlcklubGluZTtcblxufSx7XCIxOVwiOjE5LFwiMjFcIjoyMSxcIjI4XCI6MjgsXCIzMFwiOjMwLFwiMzFcIjozMSxcIjMzXCI6MzMsXCI0M1wiOjQzLFwiNDRcIjo0NH1dLDI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9kZW11eGVySW5saW5lID0gX2RlcmVxXygyMyk7XG5cbnZhciBfZGVtdXhlcklubGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZW11eGVySW5saW5lKTtcblxudmFyIF9ldmVudHMgPSBfZGVyZXFfKDMzKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxudmFyIF9ldmVudHMzID0gX2RlcmVxXygxKTtcblxudmFyIF9ldmVudHM0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qIGRlbXV4ZXIgd2ViIHdvcmtlci5cbiAqICAtIGxpc3RlbiB0byB3b3JrZXIgbWVzc2FnZSwgYW5kIHRyaWdnZXIgRGVtdXhlcklubGluZSB1cG9uIHJlY2VwdGlvbiBvZiBGcmFnbWVudHMuXG4gKiAgLSBwcm92aWRlcyBNUDQgQm94ZXMgYmFjayB0byBtYWluIHRocmVhZCB1c2luZyBbdHJhbnNmZXJhYmxlIG9iamVjdHNdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTEvMTIvVHJhbnNmZXJhYmxlLU9iamVjdHMtTGlnaHRuaW5nLUZhc3QpIGluIG9yZGVyIHRvIG1pbmltaXplIG1lc3NhZ2UgcGFzc2luZyBvdmVyaGVhZC5cbiAqL1xuXG52YXIgRGVtdXhlcldvcmtlciA9IGZ1bmN0aW9uIERlbXV4ZXJXb3JrZXIoc2VsZikge1xuICAvLyBvYnNlcnZlciBzZXR1cFxuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgX2V2ZW50czQuZGVmYXVsdCgpO1xuICBvYnNlcnZlci50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlcihldmVudCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkYXRhID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgZGF0YVtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgb2JzZXJ2ZXIuZW1pdC5hcHBseShvYnNlcnZlciwgW2V2ZW50LCBldmVudF0uY29uY2F0KGRhdGEpKTtcbiAgfTtcblxuICBvYnNlcnZlci5vZmYgPSBmdW5jdGlvbiBvZmYoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGRhdGEgPSBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBkYXRhW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyLmFwcGx5KG9ic2VydmVyLCBbZXZlbnRdLmNvbmNhdChkYXRhKSk7XG4gIH07XG5cbiAgdmFyIGZvcndhcmRNZXNzYWdlID0gZnVuY3Rpb24gZm9yd2FyZE1lc3NhZ2UoZXYsIGRhdGEpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHsgZXZlbnQ6IGV2LCBkYXRhOiBkYXRhIH0pO1xuICB9O1xuXG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgIHZhciBkYXRhID0gZXYuZGF0YTtcbiAgICAvL2NvbnNvbGUubG9nKCdkZW11eGVyIGNtZDonICsgZGF0YS5jbWQpO1xuICAgIHN3aXRjaCAoZGF0YS5jbWQpIHtcbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICB2YXIgY29uZmlnID0gSlNPTi5wYXJzZShkYXRhLmNvbmZpZyk7XG4gICAgICAgIHNlbGYuZGVtdXhlciA9IG5ldyBfZGVtdXhlcklubGluZTIuZGVmYXVsdChvYnNlcnZlciwgZGF0YS50eXBlU3VwcG9ydGVkLCBjb25maWcpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICgwLCBfbG9nZ2VyLmVuYWJsZUxvZ3MpKGNvbmZpZy5kZWJ1ZyA9PT0gdHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignZGVtdXhlcldvcmtlcjogdW5hYmxlIHRvIGVuYWJsZSBsb2dzJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2lnbmFsIGVuZCBvZiB3b3JrZXIgaW5pdFxuICAgICAgICBmb3J3YXJkTWVzc2FnZSgnaW5pdCcsIG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RlbXV4JzpcbiAgICAgICAgc2VsZi5kZW11eGVyLnB1c2goZGF0YS5kYXRhLCBkYXRhLmRlY3J5cHRkYXRhLCBkYXRhLmluaXRTZWdtZW50LCBkYXRhLmF1ZGlvQ29kZWMsIGRhdGEudmlkZW9Db2RlYywgZGF0YS50aW1lT2Zmc2V0LCBkYXRhLmRpc2NvbnRpbnVpdHksIGRhdGEudHJhY2tTd2l0Y2gsIGRhdGEuY29udGlndW91cywgZGF0YS5kdXJhdGlvbiwgZGF0YS5hY2N1cmF0ZVRpbWVPZmZzZXQsIGRhdGEuZGVmYXVsdEluaXRQVFMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcbiAgb2JzZXJ2ZXIub24oX2V2ZW50czIuZGVmYXVsdC5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICBvYnNlcnZlci5vbihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICBvYnNlcnZlci5vbihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKF9ldmVudHMyLmRlZmF1bHQuSU5JVF9QVFNfRk9VTkQsIGZvcndhcmRNZXNzYWdlKTtcblxuICAvLyBzcGVjaWFsIGNhc2UgZm9yIEZSQUdfUEFSU0lOR19EQVRBOiBwYXNzIGRhdGExL2RhdGEyIGFzIHRyYW5zZmVyYWJsZSBvYmplY3QgKG5vIGNvcHkpXG4gIG9ic2VydmVyLm9uKF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTSU5HX0RBVEEsIGZ1bmN0aW9uIChldiwgZGF0YSkge1xuICAgIHZhciB0cmFuc2ZlcmFibGUgPSBbXTtcbiAgICB2YXIgbWVzc2FnZSA9IHsgZXZlbnQ6IGV2LCBkYXRhOiBkYXRhIH07XG4gICAgaWYgKGRhdGEuZGF0YTEpIHtcbiAgICAgIG1lc3NhZ2UuZGF0YTEgPSBkYXRhLmRhdGExLmJ1ZmZlcjtcbiAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKGRhdGEuZGF0YTEuYnVmZmVyKTtcbiAgICAgIGRlbGV0ZSBkYXRhLmRhdGExO1xuICAgIH1cbiAgICBpZiAoZGF0YS5kYXRhMikge1xuICAgICAgbWVzc2FnZS5kYXRhMiA9IGRhdGEuZGF0YTIuYnVmZmVyO1xuICAgICAgdHJhbnNmZXJhYmxlLnB1c2goZGF0YS5kYXRhMi5idWZmZXIpO1xuICAgICAgZGVsZXRlIGRhdGEuZGF0YTI7XG4gICAgfVxuICAgIHNlbGYucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJhYmxlKTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEZW11eGVyV29ya2VyO1xuXG59LHtcIjFcIjoxLFwiMjNcIjoyMyxcIjMzXCI6MzMsXCI1MFwiOjUwfV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V2ZW50cyA9IF9kZXJlcV8oMzMpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX2RlbXV4ZXJJbmxpbmUgPSBfZGVyZXFfKDIzKTtcblxudmFyIF9kZW11eGVySW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlbXV4ZXJJbmxpbmUpO1xuXG52YXIgX2RlbXV4ZXJXb3JrZXIgPSBfZGVyZXFfKDI0KTtcblxudmFyIF9kZW11eGVyV29ya2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlbXV4ZXJXb3JrZXIpO1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG52YXIgX2Vycm9ycyA9IF9kZXJlcV8oMzEpO1xuXG52YXIgX2V2ZW50czMgPSBfZGVyZXFfKDEpO1xuXG52YXIgX2V2ZW50czQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIERlbXV4ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERlbXV4ZXIoaGxzLCBpZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZW11eGVyKTtcblxuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICAvLyBvYnNlcnZlciBzZXR1cFxuICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIgPSBuZXcgX2V2ZW50czQuZGVmYXVsdCgpO1xuICAgIHZhciBjb25maWcgPSBobHMuY29uZmlnO1xuICAgIG9ic2VydmVyLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZGF0YSA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgZGF0YVtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIG9ic2VydmVyLmVtaXQuYXBwbHkob2JzZXJ2ZXIsIFtldmVudCwgZXZlbnRdLmNvbmNhdChkYXRhKSk7XG4gICAgfTtcblxuICAgIG9ic2VydmVyLm9mZiA9IGZ1bmN0aW9uIG9mZihldmVudCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBkYXRhID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBkYXRhW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBvYnNlcnZlci5yZW1vdmVMaXN0ZW5lci5hcHBseShvYnNlcnZlciwgW2V2ZW50XS5jb25jYXQoZGF0YSkpO1xuICAgIH07XG5cbiAgICB2YXIgZm9yd2FyZE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcbiAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xuICAgICAgZGF0YS5pZCA9IHRoaXMuaWQ7XG4gICAgICBobHMudHJpZ2dlcihldiwgZGF0YSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcbiAgICBvYnNlcnZlci5vbihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfREVDUllQVEVELCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNJTkdfREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTRUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKF9ldmVudHMyLmRlZmF1bHQuSU5JVF9QVFNfRk9VTkQsIGZvcndhcmRNZXNzYWdlKTtcblxuICAgIHZhciB0eXBlU3VwcG9ydGVkID0ge1xuICAgICAgbXA0OiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNCcpLFxuICAgICAgbXBlZzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcGVnJyksXG4gICAgICBtcDM6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXA0OyBjb2RlY3M9XCJtcDNcIicpXG4gICAgfTtcbiAgICBpZiAoY29uZmlnLmVuYWJsZVdvcmtlciAmJiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdkZW11eGluZyBpbiB3ZWJ3b3JrZXInKTtcbiAgICAgIHZhciB3ID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHdvcmsgPSBfZGVyZXFfKDMpO1xuICAgICAgICB3ID0gdGhpcy53ID0gd29yayhfZGVtdXhlcldvcmtlcjIuZGVmYXVsdCk7XG4gICAgICAgIHRoaXMub253bXNnID0gdGhpcy5vbldvcmtlck1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xuICAgICAgICB3Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5PVEhFUl9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLCBmYXRhbDogdHJ1ZSwgZXZlbnQ6ICdkZW11eGVyV29ya2VyJywgZXJyOiB7IG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UgKyAnICgnICsgZXZlbnQuZmlsZW5hbWUgKyAnOicgKyBldmVudC5saW5lbm8gKyAnKScgfSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdy5wb3N0TWVzc2FnZSh7IGNtZDogJ2luaXQnLCB0eXBlU3VwcG9ydGVkOiB0eXBlU3VwcG9ydGVkLCBpZDogaWQsIGNvbmZpZzogSlNPTi5zdHJpbmdpZnkoY29uZmlnKSB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5lcnJvcignZXJyb3Igd2hpbGUgaW5pdGlhbGl6aW5nIERlbXV4ZXJXb3JrZXIsIGZhbGxiYWNrIG9uIERlbXV4ZXJJbmxpbmUnKTtcbiAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgZGVtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh3Lm9iamVjdFVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IF9kZW11eGVySW5saW5lMi5kZWZhdWx0KG9ic2VydmVyLCBpZCwgdHlwZVN1cHBvcnRlZCwgY29uZmlnKTtcbiAgICAgICAgdGhpcy53ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgX2RlbXV4ZXJJbmxpbmUyLmRlZmF1bHQob2JzZXJ2ZXIsIGlkLCB0eXBlU3VwcG9ydGVkLCBjb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEZW11eGVyLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICBpZiAodykge1xuICAgICAgICB3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG4gICAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICAgIHRoaXMudyA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICAgICAgaWYgKGRlbXV4ZXIpIHtcbiAgICAgICAgICBkZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgIG9ic2VydmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZnJhZywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHRpbWVPZmZzZXQgPSAhaXNOYU4oZnJhZy5zdGFydERUUykgPyBmcmFnLnN0YXJ0RFRTIDogZnJhZy5zdGFydDtcbiAgICAgIHZhciBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgICB2YXIgbGFzdEZyYWcgPSB0aGlzLmZyYWc7XG4gICAgICB2YXIgZGlzY29udGludWl0eSA9ICEobGFzdEZyYWcgJiYgZnJhZy5jYyA9PT0gbGFzdEZyYWcuY2MpO1xuICAgICAgdmFyIHRyYWNrU3dpdGNoID0gIShsYXN0RnJhZyAmJiBmcmFnLmxldmVsID09PSBsYXN0RnJhZy5sZXZlbCk7XG4gICAgICB2YXIgbmV4dFNOID0gbGFzdEZyYWcgJiYgZnJhZy5zbiA9PT0gbGFzdEZyYWcuc24gKyAxO1xuICAgICAgdmFyIGNvbnRpZ3VvdXMgPSAhZGlzY29udGludWl0eSAmJiAhdHJhY2tTd2l0Y2ggJiYgbmV4dFNOO1xuICAgICAgaWYgKGRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKHRoaXMuaWQgKyAnOmRpc2NvbnRpbnVpdHkgZGV0ZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFja1N3aXRjaCkge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2codGhpcy5pZCArICc6c3dpdGNoIGRldGVjdGVkJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWcgPSBmcmFnO1xuICAgICAgaWYgKHcpIHtcbiAgICAgICAgLy8gcG9zdCBmcmFnbWVudCBwYXlsb2FkIGFzIHRyYW5zZmVyYWJsZSBvYmplY3RzIChubyBjb3B5KVxuICAgICAgICB3LnBvc3RNZXNzYWdlKHsgY21kOiAnZGVtdXgnLCBkYXRhOiBkYXRhLCBkZWNyeXB0ZGF0YTogZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50OiBpbml0U2VnbWVudCwgYXVkaW9Db2RlYzogYXVkaW9Db2RlYywgdmlkZW9Db2RlYzogdmlkZW9Db2RlYywgdGltZU9mZnNldDogdGltZU9mZnNldCwgZGlzY29udGludWl0eTogZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2g6IHRyYWNrU3dpdGNoLCBjb250aWd1b3VzOiBjb250aWd1b3VzLCBkdXJhdGlvbjogZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldDogYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUzogZGVmYXVsdEluaXRQVFMgfSwgW2RhdGFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgICBpZiAoZGVtdXhlcikge1xuICAgICAgICAgIGRlbXV4ZXIucHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbldvcmtlck1lc3NhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbldvcmtlck1lc3NhZ2UoZXYpIHtcbiAgICAgIHZhciBkYXRhID0gZXYuZGF0YSxcbiAgICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAgIC8vY29uc29sZS5sb2coJ29uV29ya2VyTWVzc2FnZTonICsgZGF0YS5ldmVudCk7XG4gICAgICBzd2l0Y2ggKGRhdGEuZXZlbnQpIHtcbiAgICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIGRlbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy53Lm9iamVjdFVSTCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgRlJBR19QQVJTSU5HX0RBVEE6IGRhdGExIGFuZCBkYXRhMiBhcmUgdHJhbnNmZXJhYmxlIG9iamVjdHNcbiAgICAgICAgY2FzZSBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19EQVRBOlxuICAgICAgICAgIGRhdGEuZGF0YS5kYXRhMSA9IG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YTEpO1xuICAgICAgICAgIGlmIChkYXRhLmRhdGEyKSB7XG4gICAgICAgICAgICBkYXRhLmRhdGEuZGF0YTIgPSBuZXcgVWludDhBcnJheShkYXRhLmRhdGEyKTtcbiAgICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwge307XG4gICAgICAgICAgZGF0YS5kYXRhLmZyYWcgPSB0aGlzLmZyYWc7XG4gICAgICAgICAgZGF0YS5kYXRhLmlkID0gdGhpcy5pZDtcbiAgICAgICAgICBobHMudHJpZ2dlcihkYXRhLmV2ZW50LCBkYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEZW11eGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEZW11eGVyO1xuXG59LHtcIjFcIjoxLFwiMjNcIjoyMyxcIjI0XCI6MjQsXCIzXCI6MyxcIjMxXCI6MzEsXCIzM1wiOjMzLFwiNTBcIjo1MH1dLDI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUGFyc2VyIGZvciBleHBvbmVudGlhbCBHb2xvbWIgY29kZXMsIGEgdmFyaWFibGUtYml0d2lkdGggbnVtYmVyIGVuY29kaW5nIHNjaGVtZSB1c2VkIGJ5IGgyNjQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEV4cEdvbG9tYiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXhwR29sb21iKGRhdGEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhwR29sb21iKTtcblxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAvLyB0aGUgY3VycmVudCB3b3JkIGJlaW5nIGV4YW1pbmVkXG4gICAgdGhpcy53b3JkID0gMDsgLy8gOnVpbnRcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJpdHMgbGVmdCB0byBleGFtaW5lIGluIHRoZSBjdXJyZW50IHdvcmRcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSAwOyAvLyA6dWludFxuICB9XG5cbiAgLy8gKCk6dm9pZFxuXG5cbiAgX2NyZWF0ZUNsYXNzKEV4cEdvbG9tYiwgW3tcbiAgICBrZXk6ICdsb2FkV29yZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRXb3JkKCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgYnl0ZXNBdmFpbGFibGUgPSB0aGlzLmJ5dGVzQXZhaWxhYmxlLFxuICAgICAgICAgIHBvc2l0aW9uID0gZGF0YS5ieXRlTGVuZ3RoIC0gYnl0ZXNBdmFpbGFibGUsXG4gICAgICAgICAgd29ya2luZ0J5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCksXG4gICAgICAgICAgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCBieXRlc0F2YWlsYWJsZSk7XG4gICAgICBpZiAoYXZhaWxhYmxlQnl0ZXMgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBieXRlcyBhdmFpbGFibGUnKTtcbiAgICAgIH1cbiAgICAgIHdvcmtpbmdCeXRlcy5zZXQoZGF0YS5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBhdmFpbGFibGVCeXRlcykpO1xuICAgICAgdGhpcy53b3JkID0gbmV3IERhdGFWaWV3KHdvcmtpbmdCeXRlcy5idWZmZXIpLmdldFVpbnQzMigwKTtcbiAgICAgIC8vIHRyYWNrIHRoZSBhbW91bnQgb2YgdGhpcy5kYXRhIHRoYXQgaGFzIGJlZW4gcHJvY2Vzc2VkXG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSBhdmFpbGFibGVCeXRlcyAqIDg7XG4gICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IGF2YWlsYWJsZUJ5dGVzO1xuICAgIH1cblxuICAgIC8vIChjb3VudDppbnQpOnZvaWRcblxuICB9LCB7XG4gICAga2V5OiAnc2tpcEJpdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBza2lwQml0cyhjb3VudCkge1xuICAgICAgdmFyIHNraXBCeXRlczsgLy8gOmludFxuICAgICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IGNvdW50KSB7XG4gICAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50IC09IHRoaXMuYml0c0F2YWlsYWJsZTtcbiAgICAgICAgc2tpcEJ5dGVzID0gY291bnQgPj4gMztcbiAgICAgICAgY291bnQgLT0gc2tpcEJ5dGVzID4+IDM7XG4gICAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuICAgICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAoc2l6ZTppbnQpOnVpbnRcblxuICB9LCB7XG4gICAga2V5OiAncmVhZEJpdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkQml0cyhzaXplKSB7XG4gICAgICB2YXIgYml0cyA9IE1hdGgubWluKHRoaXMuYml0c0F2YWlsYWJsZSwgc2l6ZSksXG4gICAgICAgICAgLy8gOnVpbnRcbiAgICAgIHZhbHUgPSB0aGlzLndvcmQgPj4+IDMyIC0gYml0czsgLy8gOnVpbnRcbiAgICAgIGlmIChzaXplID4gMzIpIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIuZXJyb3IoJ0Nhbm5vdCByZWFkIG1vcmUgdGhhbiAzMiBiaXRzIGF0IGEgdGltZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGJpdHM7XG4gICAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gMCkge1xuICAgICAgICB0aGlzLndvcmQgPDw9IGJpdHM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNBdmFpbGFibGUgPiAwKSB7XG4gICAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgIH1cbiAgICAgIGJpdHMgPSBzaXplIC0gYml0cztcbiAgICAgIGlmIChiaXRzID4gMCAmJiB0aGlzLmJpdHNBdmFpbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHUgPDwgYml0cyB8IHRoaXMucmVhZEJpdHMoYml0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAoKTp1aW50XG5cbiAgfSwge1xuICAgIGtleTogJ3NraXBMWicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNraXBMWigpIHtcbiAgICAgIHZhciBsZWFkaW5nWmVyb0NvdW50OyAvLyA6dWludFxuICAgICAgZm9yIChsZWFkaW5nWmVyb0NvdW50ID0gMDsgbGVhZGluZ1plcm9Db3VudCA8IHRoaXMuYml0c0F2YWlsYWJsZTsgKytsZWFkaW5nWmVyb0NvdW50KSB7XG4gICAgICAgIGlmICgwICE9PSAodGhpcy53b3JkICYgMHg4MDAwMDAwMCA+Pj4gbGVhZGluZ1plcm9Db3VudCkpIHtcbiAgICAgICAgICAvLyB0aGUgZmlyc3QgYml0IG9mIHdvcmtpbmcgd29yZCBpcyAxXG4gICAgICAgICAgdGhpcy53b3JkIDw8PSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyB3ZSBleGhhdXN0ZWQgd29yZCBhbmQgc3RpbGwgaGF2ZSBub3QgZm91bmQgYSAxXG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudCArIHRoaXMuc2tpcExaKCk7XG4gICAgfVxuXG4gICAgLy8gKCk6dm9pZFxuXG4gIH0sIHtcbiAgICBrZXk6ICdza2lwVUVHJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2tpcFVFRygpIHtcbiAgICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICAgIH1cblxuICAgIC8vICgpOnZvaWRcblxuICB9LCB7XG4gICAga2V5OiAnc2tpcEVHJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2tpcEVHKCkge1xuICAgICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gICAgfVxuXG4gICAgLy8gKCk6dWludFxuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWFkVUVHJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFVFRygpIHtcbiAgICAgIHZhciBjbHogPSB0aGlzLnNraXBMWigpOyAvLyA6dWludFxuICAgICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoY2x6ICsgMSkgLSAxO1xuICAgIH1cblxuICAgIC8vICgpOmludFxuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWFkRUcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkRUcoKSB7XG4gICAgICB2YXIgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG4gICAgICBpZiAoMHgwMSAmIHZhbHUpIHtcbiAgICAgICAgLy8gdGhlIG51bWJlciBpcyBvZGQgaWYgdGhlIGxvdyBvcmRlciBiaXQgaXMgc2V0XG4gICAgICAgIHJldHVybiAxICsgdmFsdSA+Pj4gMTsgLy8gYWRkIDEgdG8gbWFrZSBpdCBldmVuLCBhbmQgZGl2aWRlIGJ5IDJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xuICAgIC8vIDpCb29sZWFuXG5cbiAgfSwge1xuICAgIGtleTogJ3JlYWRCb29sZWFuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZEJvb2xlYW4oKSB7XG4gICAgICByZXR1cm4gMSA9PT0gdGhpcy5yZWFkQml0cygxKTtcbiAgICB9XG5cbiAgICAvLyAoKTppbnRcblxuICB9LCB7XG4gICAga2V5OiAncmVhZFVCeXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFVCeXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoOCk7XG4gICAgfVxuXG4gICAgLy8gKCk6aW50XG5cbiAgfSwge1xuICAgIGtleTogJ3JlYWRVU2hvcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkVVNob3J0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMTYpO1xuICAgIH1cbiAgICAvLyAoKTppbnRcblxuICB9LCB7XG4gICAga2V5OiAncmVhZFVJbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkVUludCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDMyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlIHRoZSBFeHBHb2xvbWIgZGVjb2RlciBwYXN0IGEgc2NhbGluZyBsaXN0LiBUaGUgc2NhbGluZ1xuICAgICAqIGxpc3QgaXMgb3B0aW9uYWxseSB0cmFuc21pdHRlZCBhcyBwYXJ0IG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyXG4gICAgICogc2V0IGFuZCBpcyBub3QgcmVsZXZhbnQgdG8gdHJhbnNtdXhpbmcuXG4gICAgICogQHBhcmFtIGNvdW50IHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgICAqIEBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQsIFNlY3Rpb24gNy4zLjIuMS4xLjFcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2tpcFNjYWxpbmdMaXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2tpcFNjYWxpbmdMaXN0KGNvdW50KSB7XG4gICAgICB2YXIgbGFzdFNjYWxlID0gOCxcbiAgICAgICAgICBuZXh0U2NhbGUgPSA4LFxuICAgICAgICAgIGosXG4gICAgICAgICAgZGVsdGFTY2FsZTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgIGlmIChuZXh0U2NhbGUgIT09IDApIHtcbiAgICAgICAgICBkZWx0YVNjYWxlID0gdGhpcy5yZWFkRUcoKTtcbiAgICAgICAgICBuZXh0U2NhbGUgPSAobGFzdFNjYWxlICsgZGVsdGFTY2FsZSArIDI1NikgJSAyNTY7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFNjYWxlID0gbmV4dFNjYWxlID09PSAwID8gbGFzdFNjYWxlIDogbmV4dFNjYWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGFuZCByZXR1cm4gc29tZSBpbnRlcmVzdGluZyB2aWRlb1xuICAgICAqIHByb3BlcnRpZXMuIEEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBpcyB0aGUgSDI2NCBtZXRhZGF0YSB0aGF0XG4gICAgICogZGVzY3JpYmVzIHRoZSBwcm9wZXJ0aWVzIG9mIHVwY29taW5nIHZpZGVvIGZyYW1lcy5cbiAgICAgKiBAcGFyYW0gZGF0YSB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldFxuICAgICAqIEByZXR1cm4ge29iamVjdH0gYW4gb2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBwYXJzZWQgZnJvbSB0aGVcbiAgICAgKiBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0LCBpbmNsdWRpbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlXG4gICAgICogYXNzb2NpYXRlZCB2aWRlbyBmcmFtZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlYWRTUFMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkU1BTKCkge1xuICAgICAgdmFyIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSAwLFxuICAgICAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gMCxcbiAgICAgICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSAwLFxuICAgICAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IDAsXG4gICAgICAgICAgcHJvZmlsZUlkYyxcbiAgICAgICAgICBwcm9maWxlQ29tcGF0LFxuICAgICAgICAgIGxldmVsSWRjLFxuICAgICAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSxcbiAgICAgICAgICBwaWNXaWR0aEluTWJzTWludXMxLFxuICAgICAgICAgIHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEsXG4gICAgICAgICAgZnJhbWVNYnNPbmx5RmxhZyxcbiAgICAgICAgICBzY2FsaW5nTGlzdENvdW50LFxuICAgICAgICAgIGksXG4gICAgICAgICAgcmVhZFVCeXRlID0gdGhpcy5yZWFkVUJ5dGUuYmluZCh0aGlzKSxcbiAgICAgICAgICByZWFkQml0cyA9IHRoaXMucmVhZEJpdHMuYmluZCh0aGlzKSxcbiAgICAgICAgICByZWFkVUVHID0gdGhpcy5yZWFkVUVHLmJpbmQodGhpcyksXG4gICAgICAgICAgcmVhZEJvb2xlYW4gPSB0aGlzLnJlYWRCb29sZWFuLmJpbmQodGhpcyksXG4gICAgICAgICAgc2tpcEJpdHMgPSB0aGlzLnNraXBCaXRzLmJpbmQodGhpcyksXG4gICAgICAgICAgc2tpcEVHID0gdGhpcy5za2lwRUcuYmluZCh0aGlzKSxcbiAgICAgICAgICBza2lwVUVHID0gdGhpcy5za2lwVUVHLmJpbmQodGhpcyksXG4gICAgICAgICAgc2tpcFNjYWxpbmdMaXN0ID0gdGhpcy5za2lwU2NhbGluZ0xpc3QuYmluZCh0aGlzKTtcblxuICAgICAgcmVhZFVCeXRlKCk7XG4gICAgICBwcm9maWxlSWRjID0gcmVhZFVCeXRlKCk7IC8vIHByb2ZpbGVfaWRjXG4gICAgICBwcm9maWxlQ29tcGF0ID0gcmVhZEJpdHMoNSk7IC8vIGNvbnN0cmFpbnRfc2V0WzAtNF1fZmxhZywgdSg1KVxuICAgICAgc2tpcEJpdHMoMyk7IC8vIHJlc2VydmVkX3plcm9fM2JpdHMgdSgzKSxcbiAgICAgIGxldmVsSWRjID0gcmVhZFVCeXRlKCk7IC8vbGV2ZWxfaWRjIHUoOClcbiAgICAgIHNraXBVRUcoKTsgLy8gc2VxX3BhcmFtZXRlcl9zZXRfaWRcbiAgICAgIC8vIHNvbWUgcHJvZmlsZXMgaGF2ZSBtb3JlIG9wdGlvbmFsIGRhdGEgd2UgZG9uJ3QgbmVlZFxuICAgICAgaWYgKHByb2ZpbGVJZGMgPT09IDEwMCB8fCBwcm9maWxlSWRjID09PSAxMTAgfHwgcHJvZmlsZUlkYyA9PT0gMTIyIHx8IHByb2ZpbGVJZGMgPT09IDI0NCB8fCBwcm9maWxlSWRjID09PSA0NCB8fCBwcm9maWxlSWRjID09PSA4MyB8fCBwcm9maWxlSWRjID09PSA4NiB8fCBwcm9maWxlSWRjID09PSAxMTggfHwgcHJvZmlsZUlkYyA9PT0gMTI4KSB7XG4gICAgICAgIHZhciBjaHJvbWFGb3JtYXRJZGMgPSByZWFkVUVHKCk7XG4gICAgICAgIGlmIChjaHJvbWFGb3JtYXRJZGMgPT09IDMpIHtcbiAgICAgICAgICBza2lwQml0cygxKTsgLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcbiAgICAgICAgfVxuICAgICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxuICAgICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4XG4gICAgICAgIHNraXBCaXRzKDEpOyAvLyBxcHByaW1lX3lfemVyb190cmFuc2Zvcm1fYnlwYXNzX2ZsYWdcbiAgICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgICAvLyBzZXFfc2NhbGluZ19tYXRyaXhfcHJlc2VudF9mbGFnXG4gICAgICAgICAgc2NhbGluZ0xpc3RDb3VudCA9IGNocm9tYUZvcm1hdElkYyAhPT0gMyA/IDggOiAxMjtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbGluZ0xpc3RDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgICAgICAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXG4gICAgICAgICAgICAgIGlmIChpIDwgNikge1xuICAgICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCgxNik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDY0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2tpcFVFRygpOyAvLyBsb2cyX21heF9mcmFtZV9udW1fbWludXM0XG4gICAgICB2YXIgcGljT3JkZXJDbnRUeXBlID0gcmVhZFVFRygpO1xuICAgICAgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMCkge1xuICAgICAgICByZWFkVUVHKCk7IC8vbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0XG4gICAgICB9IGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xuICAgICAgICBza2lwQml0cygxKTsgLy8gZGVsdGFfcGljX29yZGVyX2Fsd2F5c196ZXJvX2ZsYWdcbiAgICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3Jfbm9uX3JlZl9waWNcbiAgICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZFxuICAgICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUgPSByZWFkVUVHKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGU7IGkrKykge1xuICAgICAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVsgaSBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNraXBVRUcoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG4gICAgICBza2lwQml0cygxKTsgLy8gZ2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnXG4gICAgICBwaWNXaWR0aEluTWJzTWludXMxID0gcmVhZFVFRygpO1xuICAgICAgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lTWJzT25seUZsYWcgPSByZWFkQml0cygxKTtcbiAgICAgIGlmIChmcmFtZU1ic09ubHlGbGFnID09PSAwKSB7XG4gICAgICAgIHNraXBCaXRzKDEpOyAvLyBtYl9hZGFwdGl2ZV9mcmFtZV9maWVsZF9mbGFnXG4gICAgICB9XG4gICAgICBza2lwQml0cygxKTsgLy8gZGlyZWN0Xzh4OF9pbmZlcmVuY2VfZmxhZ1xuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICB9XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIHZ1aV9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZ1xuICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICAgIHZhciBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xuICAgICAgICAgIHN3aXRjaCAoYXNwZWN0UmF0aW9JZGMpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxLCAxXTticmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxMiwgMTFdO2JyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEwLCAxMV07YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTYsIDExXTticmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs0MCwgMzNdO2JyZWFrO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzI0LCAxMV07YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjAsIDExXTticmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFszMiwgMTFdO2JyZWFrO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzgwLCAzM107YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE4LCAxMV07YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE1LCAxMV07YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzY0LCAzM107YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2MCwgOTldO2JyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs0LCAzXTticmVhaztcbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMywgMl07YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIsIDFdO2JyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNTU6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gW3JlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKSwgcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IE1hdGguY2VpbCgocGljV2lkdGhJbk1ic01pbnVzMSArIDEpICogMTYgLSBmcmFtZUNyb3BMZWZ0T2Zmc2V0ICogMiAtIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ICogMiksXG4gICAgICAgIGhlaWdodDogKDIgLSBmcmFtZU1ic09ubHlGbGFnKSAqIChwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxICsgMSkgKiAxNiAtIChmcmFtZU1ic09ubHlGbGFnID8gMiA6IDQpICogKGZyYW1lQ3JvcFRvcE9mZnNldCArIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCksXG4gICAgICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW9cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVhZFNsaWNlVHlwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRTbGljZVR5cGUoKSB7XG4gICAgICAvLyBza2lwIE5BTHUgdHlwZVxuICAgICAgdGhpcy5yZWFkVUJ5dGUoKTtcbiAgICAgIC8vIGRpc2NhcmQgZmlyc3RfbWJfaW5fc2xpY2VcbiAgICAgIHRoaXMucmVhZFVFRygpO1xuICAgICAgLy8gcmV0dXJuIHNsaWNlX3R5cGVcbiAgICAgIHJldHVybiB0aGlzLnJlYWRVRUcoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXhwR29sb21iO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBFeHBHb2xvbWI7XG5cbn0se1wiNTBcIjo1MH1dLDI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSUQzIHBhcnNlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8vaW1wb3J0IEhleCBmcm9tICcuLi91dGlscy9oZXgnO1xuXG52YXIgSUQzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJRDMoZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJRDMpO1xuXG4gICAgdGhpcy5faGFzVGltZVN0YW1wID0gZmFsc2U7XG4gICAgdmFyIG9mZnNldCA9IDAsXG4gICAgICAgIGJ5dGUxLFxuICAgICAgICBieXRlMixcbiAgICAgICAgYnl0ZTMsXG4gICAgICAgIGJ5dGU0LFxuICAgICAgICB0YWdTaXplLFxuICAgICAgICBlbmRQb3MsXG4gICAgICAgIGhlYWRlcixcbiAgICAgICAgbGVuO1xuICAgIGRvIHtcbiAgICAgIGhlYWRlciA9IHRoaXMucmVhZFVURihkYXRhLCBvZmZzZXQsIDMpO1xuICAgICAgb2Zmc2V0ICs9IDM7XG4gICAgICAvLyBmaXJzdCBjaGVjayBmb3IgSUQzIGhlYWRlclxuICAgICAgaWYgKGhlYWRlciA9PT0gJ0lEMycpIHtcbiAgICAgICAgLy8gc2tpcCAyNCBiaXRzXG4gICAgICAgIG9mZnNldCArPSAzO1xuICAgICAgICAvLyByZXRyaWV2ZSB0YWcocykgbGVuZ3RoXG4gICAgICAgIGJ5dGUxID0gZGF0YVtvZmZzZXQrK10gJiAweDdmO1xuICAgICAgICBieXRlMiA9IGRhdGFbb2Zmc2V0KytdICYgMHg3ZjtcbiAgICAgICAgYnl0ZTMgPSBkYXRhW29mZnNldCsrXSAmIDB4N2Y7XG4gICAgICAgIGJ5dGU0ID0gZGF0YVtvZmZzZXQrK10gJiAweDdmO1xuICAgICAgICB0YWdTaXplID0gKGJ5dGUxIDw8IDIxKSArIChieXRlMiA8PCAxNCkgKyAoYnl0ZTMgPDwgNykgKyBieXRlNDtcbiAgICAgICAgZW5kUG9zID0gb2Zmc2V0ICsgdGFnU2l6ZTtcbiAgICAgICAgLy9sb2dnZXIubG9nKGBJRDMgdGFnIGZvdW5kLCBzaXplL2VuZDogJHt0YWdTaXplfS8ke2VuZFBvc31gKTtcblxuICAgICAgICAvLyByZWFkIElEMyB0YWdzXG4gICAgICAgIHRoaXMuX3BhcnNlSUQzRnJhbWVzKGRhdGEsIG9mZnNldCwgZW5kUG9zKTtcbiAgICAgICAgb2Zmc2V0ID0gZW5kUG9zO1xuICAgICAgfSBlbHNlIGlmIChoZWFkZXIgPT09ICczREknKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjQuMC1zdHJ1Y3R1cmUgY2hhcHRlciAzLjQuICAgSUQzdjIgZm9vdGVyXG4gICAgICAgIG9mZnNldCArPSA3O1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJzNESSBmb290ZXIgZm91bmQsIGVuZDogJyArIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgLT0gMztcbiAgICAgICAgbGVuID0gb2Zmc2V0O1xuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgLy9sb2dnZXIubG9nKGBJRDMgbGVuOiAke2xlbn1gKTtcbiAgICAgICAgICBpZiAoIXRoaXMuaGFzVGltZVN0YW1wKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdJRDMgdGFnIGZvdW5kLCBidXQgbm8gdGltZXN0YW1wJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbjtcbiAgICAgICAgICB0aGlzLl9wYXlsb2FkID0gZGF0YS5zdWJhcnJheSgwLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0cnVlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJRDMsIFt7XG4gICAga2V5OiAncmVhZFVURicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRVVEYoZGF0YSwgc3RhcnQsIGxlbikge1xuXG4gICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQsXG4gICAgICAgICAgZW5kID0gc3RhcnQgKyBsZW47XG4gICAgICBkbyB7XG4gICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbb2Zmc2V0KytdKTtcbiAgICAgIH0gd2hpbGUgKG9mZnNldCA8IGVuZCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19wYXJzZUlEM0ZyYW1lcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZUlEM0ZyYW1lcyhkYXRhLCBvZmZzZXQsIGVuZFBvcykge1xuICAgICAgdmFyIHRhZ0lkLCB0YWdMZW4sIHRhZ1N0YXJ0LCB0YWdGbGFncywgdGltZXN0YW1wO1xuICAgICAgd2hpbGUgKG9mZnNldCArIDggPD0gZW5kUG9zKSB7XG4gICAgICAgIHRhZ0lkID0gdGhpcy5yZWFkVVRGKGRhdGEsIG9mZnNldCwgNCk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuXG4gICAgICAgIHRhZ0xlbiA9IGRhdGFbb2Zmc2V0KytdIDw8IDI0ICsgZGF0YVtvZmZzZXQrK10gPDwgMTYgKyBkYXRhW29mZnNldCsrXSA8PCA4ICsgZGF0YVtvZmZzZXQrK107XG5cbiAgICAgICAgdGFnRmxhZ3MgPSBkYXRhW29mZnNldCsrXSA8PCA4ICsgZGF0YVtvZmZzZXQrK107XG5cbiAgICAgICAgdGFnU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgIC8vbG9nZ2VyLmxvZyhcIklEMyB0YWcgaWQ6XCIgKyB0YWdJZCk7XG4gICAgICAgIHN3aXRjaCAodGFnSWQpIHtcbiAgICAgICAgICBjYXNlICdQUklWJzpcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygncGFyc2UgZnJhbWU6JyArIEhleC5oZXhEdW1wKGRhdGEuc3ViYXJyYXkob2Zmc2V0LGVuZFBvcykpKTtcbiAgICAgICAgICAgIC8vIG93bmVyIHNob3VsZCBiZSBcImNvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wXCJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRVVEYoZGF0YSwgb2Zmc2V0LCA0NCkgPT09ICdjb20uYXBwbGUuc3RyZWFtaW5nLnRyYW5zcG9ydFN0cmVhbVRpbWVzdGFtcCcpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ0O1xuICAgICAgICAgICAgICAvLyBzbWVsbGluZyBldmVuIGJldHRlciAhIHdlIGZvdW5kIHRoZSByaWdodCBkZXNjcmlwdG9yXG4gICAgICAgICAgICAgIC8vIHNraXAgbnVsbCBjaGFyYWN0ZXIgKHN0cmluZyBlbmQpICsgMyBmaXJzdCBieXRlc1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcblxuICAgICAgICAgICAgICAvLyB0aW1lc3RhbXAgaXMgMzMgYml0IGV4cHJlc3NlZCBhcyBhIGJpZy1lbmRpYW4gZWlnaHQtb2N0ZXQgbnVtYmVyLCB3aXRoIHRoZSB1cHBlciAzMSBiaXRzIHNldCB0byB6ZXJvLlxuICAgICAgICAgICAgICB2YXIgcHRzMzNCaXQgPSBkYXRhW29mZnNldCsrXSAmIDB4MTtcbiAgICAgICAgICAgICAgdGhpcy5faGFzVGltZVN0YW1wID0gdHJ1ZTtcblxuICAgICAgICAgICAgICB0aW1lc3RhbXAgPSAoKGRhdGFbb2Zmc2V0KytdIDw8IDIzKSArIChkYXRhW29mZnNldCsrXSA8PCAxNSkgKyAoZGF0YVtvZmZzZXQrK10gPDwgNykgKyBkYXRhW29mZnNldCsrXSkgLyA0NTtcblxuICAgICAgICAgICAgICBpZiAocHRzMzNCaXQpIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgKz0gNDc3MjE4NTguODQ7IC8vIDJeMzIgLyA5MFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRpbWVzdGFtcCA9IE1hdGgucm91bmQodGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIudHJhY2UoJ0lEMyB0aW1lc3RhbXAgZm91bmQ6ICcgKyB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICB0aGlzLl90aW1lU3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYXNUaW1lU3RhbXAnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1RpbWVTdGFtcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0aW1lU3RhbXAnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpbWVTdGFtcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsZW5ndGgnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwYXlsb2FkJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXlsb2FkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJRDM7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IElEMztcblxufSx7XCI1MFwiOjUwfV0sMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpOyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNUDQgZGVtdXhlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLy9pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuXG52YXIgX2V2ZW50cyA9IF9kZXJlcV8oMzMpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgTVA0RGVtdXhlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTVA0RGVtdXhlcihvYnNlcnZlciwgcmVtdXhlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNUDREZW11eGVyKTtcblxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnJlbXV4ZXIgPSByZW11eGVyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1QNERlbXV4ZXIsIFt7XG4gICAga2V5OiAncmVzZXRUaW1lU3RhbXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFRpbWVTdGFtcCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldEluaXRTZWdtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICAgIC8vanNoaW50IHVudXNlZDpmYWxzZVxuICAgICAgdmFyIGluaXREYXRhID0gdGhpcy5pbml0RGF0YSA9IE1QNERlbXV4ZXIucGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCk7XG4gICAgICB2YXIgdHJhY2tzID0ge307XG4gICAgICBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgICAgdHJhY2tzLmF1ZGlvID0geyBjb250YWluZXI6ICdhdWRpby9tcDQnLCBjb2RlYzogYXVkaW9Db2RlYywgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50IH07XG4gICAgICB9XG4gICAgICBpZiAoaW5pdERhdGEudmlkZW8pIHtcbiAgICAgICAgdHJhY2tzLnZpZGVvID0geyBjb250YWluZXI6ICd2aWRlby9tcDQnLCBjb2RlYzogdmlkZW9Db2RlYywgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50IH07XG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCB7IHVuaXF1ZTogZmFsc2UsIHRyYWNrczogdHJhY2tzIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FwcGVuZCcsXG5cblxuICAgIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgdmFyIGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICAgIHZhciBzdGFydERUUyA9IE1QNERlbXV4ZXIuc3RhcnREVFMoaW5pdERhdGEsIGRhdGEpO1xuICAgICAgdGhpcy5yZW11eGVyLnJlbXV4KGluaXREYXRhLmF1ZGlvLCBpbml0RGF0YS52aWRlbywgbnVsbCwgbnVsbCwgc3RhcnREVFMsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgZGF0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fVxuICB9XSwgW3tcbiAgICBrZXk6ICdwcm9iZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2JlKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA+PSA4KSB7XG4gICAgICAgIHZhciBkYXRhVHlwZSA9IE1QNERlbXV4ZXIuYmluMnN0cihkYXRhLnN1YmFycmF5KDQsIDgpKTtcbiAgICAgICAgcmV0dXJuIFsnbW9vZicsICdmdHlwJywgJ3N0eXAnXS5pbmRleE9mKGRhdGFUeXBlKSA+PSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2JpbjJzdHInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW4yc3RyKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmZmVyKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBkYXRhIGZvciBhIGJveCBzcGVjaWZpZWQgYnkgaXRzIHBhdGhcblxuICB9LCB7XG4gICAga2V5OiAnZmluZEJveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRCb3goZGF0YSwgcGF0aCkge1xuICAgICAgdmFyIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBlbmQsXG4gICAgICAgICAgc3VicmVzdWx0cztcblxuICAgICAgaWYgKCFwYXRoLmxlbmd0aCkge1xuICAgICAgICAvLyBzaG9ydC1jaXJjdWl0IHRoZSBzZWFyY2ggZm9yIGVtcHR5IHBhdGhzXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5ieXRlTGVuZ3RoOykge1xuICAgICAgICBzaXplID0gZGF0YVtpXSA8PCAyNDtcbiAgICAgICAgc2l6ZSB8PSBkYXRhW2kgKyAxXSA8PCAxNjtcbiAgICAgICAgc2l6ZSB8PSBkYXRhW2kgKyAyXSA8PCA4O1xuICAgICAgICBzaXplIHw9IGRhdGFbaSArIDNdO1xuXG4gICAgICAgIHR5cGUgPSBNUDREZW11eGVyLmJpbjJzdHIoZGF0YS5zdWJhcnJheShpICsgNCwgaSArIDgpKTtcblxuICAgICAgICBlbmQgPSBzaXplID4gMSA/IGkgKyBzaXplIDogZGF0YS5ieXRlTGVuZ3RoO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBwYXRoWzBdKSB7XG4gICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGggYW5kIHdlJ3ZlIGZvdW5kIHRoZSBib3ggd2Ugd2VyZVxuICAgICAgICAgICAgLy8gbG9va2luZyBmb3JcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmQpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCBib3ggYWxvbmcgdGhlIHBhdGhcbiAgICAgICAgICAgIHN1YnJlc3VsdHMgPSBNUDREZW11eGVyLmZpbmRCb3goZGF0YS5zdWJhcnJheShpICsgOCwgZW5kKSwgcGF0aC5zbGljZSgxKSk7XG4gICAgICAgICAgICBpZiAoc3VicmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHN1YnJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpID0gZW5kO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSd2ZSBmaW5pc2hlZCBzZWFyY2hpbmcgYWxsIG9mIGRhdGFcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiBNUDQgaW5pdGlhbGl6YXRpb24gc2VnbWVudCBhbmQgZXh0cmFjdHMgc3RyZWFtIHR5cGUgYW5kXG4gICAgICogdGltZXNjYWxlIHZhbHVlcyBmb3IgYW55IGRlY2xhcmVkIHRyYWNrcy4gVGltZXNjYWxlIHZhbHVlcyBpbmRpY2F0ZSB0aGVcbiAgICAgKiBudW1iZXIgb2YgY2xvY2sgdGlja3MgcGVyIHNlY29uZCB0byBhc3N1bWUgZm9yIHRpbWUtYmFzZWQgdmFsdWVzXG4gICAgICogZWxzZXdoZXJlIGluIHRoZSBNUDQuXG4gICAgICpcbiAgICAgKiBUbyBkZXRlcm1pbmUgdGhlIHN0YXJ0IHRpbWUgb2YgYW4gTVA0LCB5b3UgbmVlZCB0d28gcGllY2VzIG9mXG4gICAgICogaW5mb3JtYXRpb246IHRoZSB0aW1lc2NhbGUgdW5pdCBhbmQgdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlXG4gICAgICogdGltZS4gTXVsdGlwbGUgdGltZXNjYWxlcyBjYW4gYmUgc3BlY2lmaWVkIHdpdGhpbiBhbiBNUDQgYnV0IHRoZVxuICAgICAqIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgaXMgYWx3YXlzIGV4cHJlc3NlZCBpbiB0aGUgdGltZXNjYWxlIGZyb21cbiAgICAgKiB0aGUgbWVkaWEgaGVhZGVyIGJveCBmb3IgdGhlIHRyYWNrOlxuICAgICAqIGBgYFxuICAgICAqIG1vb3YgPiB0cmFrID4gbWRpYSA+IG1kaGQudGltZXNjYWxlXG4gICAgICogbW9vdiA+IHRyYWsgPiBtZGlhID4gaGRsclxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBpbml0IHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgdGhlIGluaXQgc2VnbWVudFxuICAgICAqIEByZXR1cm4ge29iamVjdH0gYSBoYXNoIG9mIHRyYWNrIHR5cGUgdG8gdGltZXNjYWxlIHZhbHVlcyBvciBudWxsIGlmXG4gICAgICogdGhlIGluaXQgc2VnbWVudCBpcyBtYWxmb3JtZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BhcnNlSW5pdFNlZ21lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgdHJha3MgPSBNUDREZW11eGVyLmZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuXG4gICAgICB0cmFrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFrKSB7XG4gICAgICAgIHZhciB0a2hkID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWssIFsndGtoZCddKVswXTtcbiAgICAgICAgaWYgKHRraGQpIHtcbiAgICAgICAgICB2YXIgdmVyc2lvbiA9IHRraGRbMF07XG4gICAgICAgICAgdmFyIGluZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDEyIDogMjA7XG4gICAgICAgICAgdmFyIHRyYWNrSWQgPSB0a2hkW2luZGV4XSA8PCAyNCB8IHRraGRbaW5kZXggKyAxXSA8PCAxNiB8IHRraGRbaW5kZXggKyAyXSA8PCA4IHwgdGtoZFtpbmRleCArIDNdO1xuXG4gICAgICAgICAgdHJhY2tJZCA9IHRyYWNrSWQgPCAwID8gNDI5NDk2NzI5NiArIHRyYWNrSWQgOiB0cmFja0lkO1xuXG4gICAgICAgICAgdmFyIG1kaGQgPSBNUDREZW11eGVyLmZpbmRCb3godHJhaywgWydtZGlhJywgJ21kaGQnXSlbMF07XG4gICAgICAgICAgaWYgKG1kaGQpIHtcbiAgICAgICAgICAgIHZlcnNpb24gPSBtZGhkWzBdO1xuICAgICAgICAgICAgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gMTIgOiAyMDtcbiAgICAgICAgICAgIHZhciB0aW1lc2NhbGUgPSBtZGhkW2luZGV4XSA8PCAyNCB8IG1kaGRbaW5kZXggKyAxXSA8PCAxNiB8IG1kaGRbaW5kZXggKyAyXSA8PCA4IHwgbWRoZFtpbmRleCArIDNdO1xuXG4gICAgICAgICAgICB2YXIgaGRsciA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnaGRsciddKVswXTtcbiAgICAgICAgICAgIGlmIChoZGxyKSB7XG4gICAgICAgICAgICAgIHZhciBoZGxyVHlwZSA9IE1QNERlbXV4ZXIuYmluMnN0cihoZGxyLnN1YmFycmF5KDgsIDEyKSk7XG4gICAgICAgICAgICAgIHZhciB0eXBlID0geyAnc291bic6ICdhdWRpbycsICd2aWRlJzogJ3ZpZGVvJyB9W2hkbHJUeXBlXTtcbiAgICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbdHJhY2tJZF0gPSB7IHRpbWVzY2FsZTogdGltZXNjYWxlLCB0eXBlOiB0eXBlIH07XG4gICAgICAgICAgICAgICAgcmVzdWx0W3R5cGVdID0geyB0aW1lc2NhbGU6IHRpbWVzY2FsZSwgaWQ6IHRyYWNrSWQgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSwgaW4gc2Vjb25kcywgZm9yIGFuIE1QNFxuICAgICAqIGZyYWdtZW50LiBJZiBtdWx0aXBsZSBmcmFnbWVudHMgYXJlIHNwZWNpZmllZCwgdGhlIGVhcmxpZXN0IHRpbWUgaXNcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIFRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGNhbiBiZSBwYXJzZWQgZnJvbSB0cmFjayBmcmFnbWVudFxuICAgICAqIG1ldGFkYXRhOlxuICAgICAqIGBgYFxuICAgICAqIG1vb2YgPiB0cmFmID4gdGZkdC5iYXNlTWVkaWFEZWNvZGVUaW1lXG4gICAgICogYGBgXG4gICAgICogSXQgcmVxdWlyZXMgdGhlIHRpbWVzY2FsZSB2YWx1ZSBmcm9tIHRoZSBtZGhkIHRvIGludGVycHJldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lc2NhbGUge29iamVjdH0gYSBoYXNoIG9mIHRyYWNrIGlkcyB0byB0aW1lc2NhbGUgdmFsdWVzLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlIHN0YXJ0IHRpbWUgZm9yIHRoZVxuICAgICAqIGZyYWdtZW50LCBpbiBzZWNvbmRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0YXJ0RFRTJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnREVFMoaW5pdERhdGEsIGZyYWdtZW50KSB7XG4gICAgICB2YXIgdHJhZnMsIGJhc2VUaW1lcywgcmVzdWx0O1xuXG4gICAgICAvLyB3ZSBuZWVkIGluZm8gZnJvbSB0d28gY2hpbGRyZW5kIG9mIGVhY2ggdHJhY2sgZnJhZ21lbnQgYm94XG4gICAgICB0cmFmcyA9IE1QNERlbXV4ZXIuZmluZEJveChmcmFnbWVudCwgWydtb29mJywgJ3RyYWYnXSk7XG5cbiAgICAgIC8vIGRldGVybWluZSB0aGUgc3RhcnQgdGltZXMgZm9yIGVhY2ggdHJhY2tcbiAgICAgIGJhc2VUaW1lcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgdHJhZnMubWFwKGZ1bmN0aW9uICh0cmFmKSB7XG4gICAgICAgIHJldHVybiBNUDREZW11eGVyLmZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLm1hcChmdW5jdGlvbiAodGZoZCkge1xuICAgICAgICAgIHZhciBpZCwgc2NhbGUsIGJhc2VUaW1lO1xuXG4gICAgICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgICAgICAgaWQgPSB0ZmhkWzRdIDw8IDI0IHwgdGZoZFs1XSA8PCAxNiB8IHRmaGRbNl0gPDwgOCB8IHRmaGRbN107XG4gICAgICAgICAgLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgICBzY2FsZSA9IGluaXREYXRhW2lkXS50aW1lc2NhbGUgfHwgOTBlMztcblxuICAgICAgICAgIC8vIGdldCB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBmcm9tIHRoZSB0ZmR0XG4gICAgICAgICAgYmFzZVRpbWUgPSBNUDREZW11eGVyLmZpbmRCb3godHJhZiwgWyd0ZmR0J10pLm1hcChmdW5jdGlvbiAodGZkdCkge1xuICAgICAgICAgICAgdmFyIHZlcnNpb24sIHJlc3VsdDtcblxuICAgICAgICAgICAgdmVyc2lvbiA9IHRmZHRbMF07XG4gICAgICAgICAgICByZXN1bHQgPSB0ZmR0WzRdIDw8IDI0IHwgdGZkdFs1XSA8PCAxNiB8IHRmZHRbNl0gPDwgOCB8IHRmZHRbN107XG4gICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgICAgICByZXN1bHQgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgICAgICByZXN1bHQgKz0gdGZkdFs4XSA8PCAyNCB8IHRmZHRbOV0gPDwgMTYgfCB0ZmR0WzEwXSA8PCA4IHwgdGZkdFsxMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgIGJhc2VUaW1lID0gYmFzZVRpbWUgfHwgSW5maW5pdHk7XG5cbiAgICAgICAgICAvLyBjb252ZXJ0IGJhc2UgdGltZSB0byBzZWNvbmRzXG4gICAgICAgICAgcmV0dXJuIGJhc2VUaW1lIC8gc2NhbGU7XG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuXG4gICAgICAvLyByZXR1cm4gdGhlIG1pbmltdW1cbiAgICAgIHJlc3VsdCA9IE1hdGgubWluLmFwcGx5KG51bGwsIGJhc2VUaW1lcyk7XG4gICAgICByZXR1cm4gaXNGaW5pdGUocmVzdWx0KSA/IHJlc3VsdCA6IDA7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1QNERlbXV4ZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1QNERlbXV4ZXI7XG5cbn0se1wiMzNcIjozM31dLDI5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU0FNUExFLUFFUyBkZWNyeXB0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgX2RlY3J5cHRlciA9IF9kZXJlcV8oMTkpO1xuXG52YXIgX2RlY3J5cHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWNyeXB0ZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgU2FtcGxlQWVzRGVjcnlwdGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTYW1wbGVBZXNEZWNyeXB0ZXIob2JzZXJ2ZXIsIGNvbmZpZywgZGVjcnlwdGRhdGEsIGRpc2NhcmRFUEIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2FtcGxlQWVzRGVjcnlwdGVyKTtcblxuICAgIHRoaXMuZGVjcnlwdGRhdGEgPSBkZWNyeXB0ZGF0YTtcbiAgICB0aGlzLmRpc2NhcmRFUEIgPSBkaXNjYXJkRVBCO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gbmV3IF9kZWNyeXB0ZXIyLmRlZmF1bHQob2JzZXJ2ZXIsIGNvbmZpZyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2FtcGxlQWVzRGVjcnlwdGVyLCBbe1xuICAgIGtleTogJ2RlY3J5cHRCdWZmZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0QnVmZmVyKGVuY3J5cHRlZERhdGEsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGVuY3J5cHRlZERhdGEsIHRoaXMuZGVjcnlwdGRhdGEua2V5LmJ1ZmZlciwgdGhpcy5kZWNyeXB0ZGF0YS5pdi5idWZmZXIsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvLyBBQUMgLSBlbmNyeXB0IGFsbCBmdWxsIDE2IGJ5dGVzIGJsb2NrcyBzdGFydGluZyBmcm9tIG9mZnNldCAxNlxuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWNyeXB0QWFjU2FtcGxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2ssIHN5bmMpIHtcbiAgICAgIHZhciBjdXJVbml0ID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdDtcbiAgICAgIHZhciBlbmNyeXB0ZWREYXRhID0gY3VyVW5pdC5zdWJhcnJheSgxNiwgY3VyVW5pdC5sZW5ndGggLSBjdXJVbml0Lmxlbmd0aCAlIDE2KTtcbiAgICAgIHZhciBlbmNyeXB0ZWRCdWZmZXIgPSBlbmNyeXB0ZWREYXRhLmJ1ZmZlci5zbGljZShlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQsIGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCArIGVuY3J5cHRlZERhdGEubGVuZ3RoKTtcblxuICAgICAgdmFyIGxvY2FsdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkQnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgICAgIGN1clVuaXQuc2V0KGRlY3J5cHRlZERhdGEsIDE2KTtcblxuICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICBsb2NhbHRoaXMuZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlY3J5cHRBYWNTYW1wbGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICBmb3IgKDs7IHNhbXBsZUluZGV4KyspIHtcbiAgICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdC5sZW5ndGggPCAzMikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN5bmMgPSB0aGlzLmRlY3J5cHRlci5pc1N5bmMoKTtcblxuICAgICAgICB0aGlzLmRlY3J5cHRBYWNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrLCBzeW5jKTtcblxuICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBVkMgLSBlbmNyeXB0IG9uZSAxNiBieXRlcyBibG9jayBvdXQgb2YgdGVuLCBzdGFydGluZyBmcm9tIG9mZnNldCAzMlxuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRBdmNFbmNyeXB0ZWREYXRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YSkge1xuICAgICAgdmFyIGVuY3J5cHRlZERhdGFMZW4gPSBNYXRoLmZsb29yKChkZWNvZGVkRGF0YS5sZW5ndGggLSA0OCkgLyAxNjApICogMTYgKyAxNjtcbiAgICAgIHZhciBlbmNyeXB0ZWREYXRhID0gbmV3IEludDhBcnJheShlbmNyeXB0ZWREYXRhTGVuKTtcbiAgICAgIHZhciBvdXRwdXRQb3MgPSAwO1xuICAgICAgZm9yICh2YXIgaW5wdXRQb3MgPSAzMjsgaW5wdXRQb3MgPD0gZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IGlucHV0UG9zICs9IDE2MCwgb3V0cHV0UG9zICs9IDE2KSB7XG4gICAgICAgIGVuY3J5cHRlZERhdGEuc2V0KGRlY29kZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmNyeXB0ZWREYXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEF2Y0RlY3J5cHRlZFVuaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdmNEZWNyeXB0ZWRVbml0KGRlY29kZWREYXRhLCBkZWNyeXB0ZWREYXRhKSB7XG4gICAgICBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgICB2YXIgaW5wdXRQb3MgPSAwO1xuICAgICAgZm9yICh2YXIgb3V0cHV0UG9zID0gMzI7IG91dHB1dFBvcyA8PSBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjsgb3V0cHV0UG9zICs9IDE2MCwgaW5wdXRQb3MgKz0gMTYpIHtcbiAgICAgICAgZGVjb2RlZERhdGEuc2V0KGRlY3J5cHRlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY29kZWREYXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlY3J5cHRBdmNTYW1wbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0LCBzeW5jKSB7XG4gICAgICB2YXIgZGVjb2RlZERhdGEgPSB0aGlzLmRpc2NhcmRFUEIoY3VyVW5pdC5kYXRhKTtcbiAgICAgIHZhciBlbmNyeXB0ZWREYXRhID0gdGhpcy5nZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKTtcbiAgICAgIHZhciBsb2NhbHRoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YS5idWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgIGN1clVuaXQuZGF0YSA9IGxvY2FsdGhpcy5nZXRBdmNEZWNyeXB0ZWRVbml0KGRlY29kZWREYXRhLCBkZWNyeXB0ZWREYXRhKTtcblxuICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICBsb2NhbHRoaXMuZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVjcnlwdEF2Y1NhbXBsZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0QXZjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaykge1xuICAgICAgZm9yICg7OyBzYW1wbGVJbmRleCsrLCB1bml0SW5kZXggPSAwKSB7XG4gICAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1clVuaXRzID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdHMudW5pdHM7XG4gICAgICAgIGZvciAoOzsgdW5pdEluZGV4KyspIHtcbiAgICAgICAgICBpZiAodW5pdEluZGV4ID49IGN1clVuaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGN1clVuaXQgPSBjdXJVbml0c1t1bml0SW5kZXhdO1xuICAgICAgICAgIGlmIChjdXJVbml0Lmxlbmd0aCA8PSA0OCB8fCBjdXJVbml0LnR5cGUgIT09IDEgJiYgY3VyVW5pdC50eXBlICE9PSA1KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3luYyA9IHRoaXMuZGVjcnlwdGVyLmlzU3luYygpO1xuXG4gICAgICAgICAgdGhpcy5kZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0LCBzeW5jKTtcblxuICAgICAgICAgIGlmICghc3luYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTYW1wbGVBZXNEZWNyeXB0ZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNhbXBsZUFlc0RlY3J5cHRlcjtcblxufSx7XCIxOVwiOjE5fV0sMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpOyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBoaWdobHkgb3B0aW1pemVkIFRTIGRlbXV4ZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogcGFyc2UgUEFULCBQTVRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBleHRyYWN0IFBFUyBwYWNrZXQgZnJvbSBhdWRpbyBhbmQgdmlkZW8gUElEc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGV4dHJhY3QgQVZDL0gyNjQgTkFMIHVuaXRzIGFuZCBBQUMvQURUUyBzYW1wbGVzIGZyb20gUEVTIHBhY2tldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRyaWdnZXIgdGhlIHJlbXV4ZXIgdXBvbiBwYXJzaW5nIGNvbXBsZXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBpdCBhbHNvIHRyaWVzIHRvIHdvcmthcm91bmQgYXMgYmVzdCBhcyBpdCBjYW4gYXVkaW8gY29kZWMgc3dpdGNoIChIRS1BQUMgdG8gQUFDIGFuZCB2aWNlIHZlcnNhKSwgd2l0aG91dCBoYXZpbmcgdG8gcmVzdGFydCB0aGUgTWVkaWFTb3VyY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaXQgYWxzbyBjb250cm9scyB0aGUgcmVtdXhpbmcgcHJvY2VzcyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogdXBvbiBkaXNjb250aW51aXR5IG9yIGxldmVsIHN3aXRjaCBkZXRlY3Rpb24sIGl0IHdpbGwgYWxzbyBub3RpZmllcyB0aGUgcmVtdXhlciBzbyB0aGF0IGl0IGNhbiByZXNldCBpdHMgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuLy8gaW1wb3J0IEhleCBmcm9tICcuLi91dGlscy9oZXgnO1xuXG5cbnZhciBfYWR0cyA9IF9kZXJlcV8oMjIpO1xuXG52YXIgX2FkdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWR0cyk7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZXhwR29sb21iID0gX2RlcmVxXygyNik7XG5cbnZhciBfZXhwR29sb21iMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4cEdvbG9tYik7XG5cbnZhciBfc2FtcGxlQWVzID0gX2RlcmVxXygyOSk7XG5cbnZhciBfc2FtcGxlQWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NhbXBsZUFlcyk7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbnZhciBfZXJyb3JzID0gX2RlcmVxXygzMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBUU0RlbXV4ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRTRGVtdXhlcihvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRTRGVtdXhlcik7XG5cbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLnJlbXV4ZXIgPSByZW11eGVyO1xuICAgIHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUU0RlbXV4ZXIsIFt7XG4gICAga2V5OiAnc2V0RGVjcnlwdERhdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREZWNyeXB0RGF0YShkZWNyeXB0ZGF0YSkge1xuICAgICAgaWYgKGRlY3J5cHRkYXRhICE9IG51bGwgJiYgZGVjcnlwdGRhdGEua2V5ICE9IG51bGwgJiYgZGVjcnlwdGRhdGEubWV0aG9kID09PSAnU0FNUExFLUFFUycpIHtcbiAgICAgICAgdGhpcy5zYW1wbGVBZXMgPSBuZXcgX3NhbXBsZUFlczIuZGVmYXVsdCh0aGlzLm9ic2VydmVyLCB0aGlzLmNvbmZpZywgZGVjcnlwdGRhdGEsIHRoaXMuZGlzY2FyZEVQQik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVzZXRJbml0U2VnbWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgICB0aGlzLnBtdFBhcnNlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcG10SWQgPSAtMTtcbiAgICAgIHRoaXMuX2F2Y1RyYWNrID0geyBjb250YWluZXI6ICd2aWRlby9tcDJ0JywgdHlwZTogJ3ZpZGVvJywgaWQ6IC0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlczogW10sIGxlbjogMCwgZHJvcHBlZDogMCB9O1xuICAgICAgdGhpcy5fYXVkaW9UcmFjayA9IHsgY29udGFpbmVyOiAndmlkZW8vbXAydCcsIHR5cGU6ICdhdWRpbycsIGlkOiAtMSwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXM6IFtdLCBsZW46IDAsIGlzQUFDOiB0cnVlIH07XG4gICAgICB0aGlzLl9pZDNUcmFjayA9IHsgdHlwZTogJ2lkMycsIGlkOiAtMSwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXM6IFtdLCBsZW46IDAgfTtcbiAgICAgIHRoaXMuX3R4dFRyYWNrID0geyB0eXBlOiAndGV4dCcsIGlkOiAtMSwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXM6IFtdLCBsZW46IDAgfTtcbiAgICAgIC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcbiAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgICAgdGhpcy5hYWNMYXN0UFRTID0gbnVsbDtcbiAgICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICB0aGlzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldFRpbWVTdGFtcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKCkge31cblxuICAgIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcblxuICB9LCB7XG4gICAga2V5OiAnYXBwZW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgdmFyIHN0YXJ0LFxuICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHN0dCxcbiAgICAgICAgICBwaWQsXG4gICAgICAgICAgYXRmLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICBwZXMsXG4gICAgICAgICAgdW5rbm93blBJRHMgPSBmYWxzZTtcbiAgICAgIHRoaXMuY29udGlndW91cyA9IGNvbnRpZ3VvdXM7XG4gICAgICB2YXIgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQsXG4gICAgICAgICAgYXZjVHJhY2sgPSB0aGlzLl9hdmNUcmFjayxcbiAgICAgICAgICBhdWRpb1RyYWNrID0gdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgICAgICBpZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrLFxuICAgICAgICAgIGF2Y0lkID0gYXZjVHJhY2suaWQsXG4gICAgICAgICAgYXVkaW9JZCA9IGF1ZGlvVHJhY2suaWQsXG4gICAgICAgICAgaWQzSWQgPSBpZDNUcmFjay5pZCxcbiAgICAgICAgICBwbXRJZCA9IHRoaXMuX3BtdElkLFxuICAgICAgICAgIGF2Y0RhdGEgPSBhdmNUcmFjay5wZXNEYXRhLFxuICAgICAgICAgIGF1ZGlvRGF0YSA9IGF1ZGlvVHJhY2sucGVzRGF0YSxcbiAgICAgICAgICBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YSxcbiAgICAgICAgICBwYXJzZVBBVCA9IHRoaXMuX3BhcnNlUEFULFxuICAgICAgICAgIHBhcnNlUE1UID0gdGhpcy5fcGFyc2VQTVQsXG4gICAgICAgICAgcGFyc2VQRVMgPSB0aGlzLl9wYXJzZVBFUyxcbiAgICAgICAgICBwYXJzZUFWQ1BFUyA9IHRoaXMuX3BhcnNlQVZDUEVTLmJpbmQodGhpcyksXG4gICAgICAgICAgcGFyc2VBQUNQRVMgPSB0aGlzLl9wYXJzZUFBQ1BFUy5iaW5kKHRoaXMpLFxuICAgICAgICAgIHBhcnNlTVBFR1BFUyA9IHRoaXMuX3BhcnNlTVBFR1BFUy5iaW5kKHRoaXMpLFxuICAgICAgICAgIHBhcnNlSUQzUEVTID0gdGhpcy5fcGFyc2VJRDNQRVMuYmluZCh0aGlzKTtcblxuICAgICAgLy8gZG9uJ3QgcGFyc2UgbGFzdCBUUyBwYWNrZXQgaWYgaW5jb21wbGV0ZVxuICAgICAgbGVuIC09IGxlbiAlIDE4ODtcbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBUUyBwYWNrZXRzXG4gICAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBsZW47IHN0YXJ0ICs9IDE4OCkge1xuICAgICAgICBpZiAoZGF0YVtzdGFydF0gPT09IDB4NDcpIHtcbiAgICAgICAgICBzdHQgPSAhIShkYXRhW3N0YXJ0ICsgMV0gJiAweDQwKTtcbiAgICAgICAgICAvLyBwaWQgaXMgYSAxMy1iaXQgZmllbGQgc3RhcnRpbmcgYXQgdGhlIGxhc3QgYml0IG9mIFRTWzFdXG4gICAgICAgICAgcGlkID0gKChkYXRhW3N0YXJ0ICsgMV0gJiAweDFmKSA8PCA4KSArIGRhdGFbc3RhcnQgKyAyXTtcbiAgICAgICAgICBhdGYgPSAoZGF0YVtzdGFydCArIDNdICYgMHgzMCkgPj4gNDtcbiAgICAgICAgICAvLyBpZiBhbiBhZGFwdGlvbiBmaWVsZCBpcyBwcmVzZW50LCBpdHMgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGUgZmlmdGggYnl0ZSBvZiB0aGUgVFMgcGFja2V0IGhlYWRlci5cbiAgICAgICAgICBpZiAoYXRmID4gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA1ICsgZGF0YVtzdGFydCArIDRdO1xuICAgICAgICAgICAgLy8gY29udGludWUgaWYgdGhlcmUgaXMgb25seSBhZGFwdGF0aW9uIGZpZWxkXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBzdGFydCArIDE4OCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKHBpZCkge1xuICAgICAgICAgICAgY2FzZSBhdmNJZDpcbiAgICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlQVZDUEVTKHBlcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdmNEYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhdmNEYXRhKSB7XG4gICAgICAgICAgICAgICAgYXZjRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgICAgYXZjRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhdWRpb0lkOlxuICAgICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlQUFDUEVTKHBlcyk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZU1QRUdQRVMocGVzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXVkaW9EYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhdWRpb0RhdGEpIHtcbiAgICAgICAgICAgICAgICBhdWRpb0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xuICAgICAgICAgICAgICAgIGF1ZGlvRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBpZDNJZDpcbiAgICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlSUQzUEVTKHBlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkM0RhdGEgPSB7IGRhdGE6IFtdLCBzaXplOiAwIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlkM0RhdGEpIHtcbiAgICAgICAgICAgICAgICBpZDNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgICAgICBpZDNEYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwbXRJZCA9IHRoaXMuX3BtdElkID0gcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBtdElkOlxuICAgICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHBhcnNlZFBJRHMgPSBwYXJzZVBNVChkYXRhLCBvZmZzZXQsIHRoaXMudHlwZVN1cHBvcnRlZC5tcGVnID09PSB0cnVlIHx8IHRoaXMudHlwZVN1cHBvcnRlZC5tcDMgPT09IHRydWUsIHRoaXMuc2FtcGxlQWVzICE9IG51bGwpO1xuXG4gICAgICAgICAgICAgIC8vIG9ubHkgdXBkYXRlIHRyYWNrIGlkIGlmIHRyYWNrIFBJRCBmb3VuZCB3aGlsZSBwYXJzaW5nIFBNVFxuICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGF2b2lkIHJlc2V0dGluZyB0aGUgUElEIHRvIC0xIGluIGNhc2VcbiAgICAgICAgICAgICAgLy8gdHJhY2sgUElEIHRyYW5zaWVudGx5IGRpc2FwcGVhcnMgZnJvbSB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGluIGNhc2Ugb2YgdHJhbnNpZW50IG1pc3NpbmcgYXVkaW8gc2FtcGxlcyBmb3IgZXhhbXBsZVxuICAgICAgICAgICAgICBhdmNJZCA9IHBhcnNlZFBJRHMuYXZjO1xuICAgICAgICAgICAgICBpZiAoYXZjSWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgYXZjVHJhY2suaWQgPSBhdmNJZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhdWRpb0lkID0gcGFyc2VkUElEcy5hdWRpbztcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvSWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgYXVkaW9UcmFjay5pZCA9IGF1ZGlvSWQ7XG4gICAgICAgICAgICAgICAgYXVkaW9UcmFjay5pc0FBQyA9IHBhcnNlZFBJRHMuaXNBQUM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWQzSWQgPSBwYXJzZWRQSURzLmlkMztcbiAgICAgICAgICAgICAgaWYgKGlkM0lkID4gMCkge1xuICAgICAgICAgICAgICAgIGlkM1RyYWNrLmlkID0gaWQzSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHVua25vd25QSURzICYmICFwbXRQYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3JlcGFyc2UgZnJvbSBiZWdpbm5pbmcnKTtcbiAgICAgICAgICAgICAgICB1bmtub3duUElEcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIHdlIHNldCBpdCB0byAtMTg4LCB0aGUgKz0gMTg4IGluIHRoZSBmb3IgbG9vcCB3aWxsIHJlc2V0IHN0YXJ0IHRvIDBcbiAgICAgICAgICAgICAgICBzdGFydCA9IC0xODg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICBjYXNlIDB4MWZmZjpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB1bmtub3duUElEcyA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdUUyBwYWNrZXQgZGlkIG5vdCBzdGFydCB3aXRoIDB4NDcnIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyB0cnkgdG8gcGFyc2UgbGFzdCBQRVMgcGFja2V0c1xuICAgICAgaWYgKGF2Y0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF2Y0RhdGEpKSkge1xuICAgICAgICBwYXJzZUFWQ1BFUyhwZXMsIHRydWUpO1xuICAgICAgICBhdmNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVpdGhlciBhdmNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgICAgYXZjVHJhY2sucGVzRGF0YSA9IGF2Y0RhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpKSB7XG4gICAgICAgIGlmIChhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgICAgcGFyc2VBQUNQRVMocGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJzZU1QRUdQRVMocGVzKTtcbiAgICAgICAgfVxuICAgICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGF1ZGlvRGF0YSAmJiBhdWRpb0RhdGEuc2l6ZSkge1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbGFzdCBBQUMgUEVTIHBhY2tldCB0cnVuY2F0ZWQsbWlnaHQgb3ZlcmxhcCBiZXR3ZWVuIGZyYWdtZW50cycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVpdGhlciBhdWRpb0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBhdWRpb0RhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgICAgcGFyc2VJRDNQRVMocGVzKTtcbiAgICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlaXRoZXIgaWQzRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBpZDNEYXRhO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zYW1wbGVBZXMgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgYXZjVHJhY2ssIGlkM1RyYWNrLCB0aGlzLl90eHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdEFuZFJlbXV4KGF1ZGlvVHJhY2ssIGF2Y1RyYWNrLCBpZDNUcmFjaywgdGhpcy5fdHh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVjcnlwdEFuZFJlbXV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcnlwdEFuZFJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKGF1ZGlvVHJhY2suc2FtcGxlcyAmJiBhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGxvY2FsdGhpcyA9IF90aGlzO1xuICAgICAgICAgIF90aGlzLnNhbXBsZUFlcy5kZWNyeXB0QWFjU2FtcGxlcyhhdWRpb1RyYWNrLnNhbXBsZXMsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvY2FsdGhpcy5kZWNyeXB0QW5kUmVtdXhBdmMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdEFuZFJlbXV4QXZjKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVjcnlwdEFuZFJlbXV4QXZjJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcnlwdEFuZFJlbXV4QXZjKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbG9jYWx0aGlzID0gX3RoaXMyO1xuICAgICAgICAgIF90aGlzMi5zYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2NhbHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfcGFyc2VQQVQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICAvLyBza2lwIHRoZSBQU0kgaGVhZGVyIGFuZCBwYXJzZSB0aGUgZmlyc3QgUE1UIGVudHJ5XG4gICAgICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgxRikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xuICAgICAgLy9sb2dnZXIubG9nKCdQTVQgUElEOicgICsgdGhpcy5fcG10SWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19wYXJzZVBNVCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZVBNVChkYXRhLCBvZmZzZXQsIG1wZWdTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzKSB7XG4gICAgICB2YXIgc2VjdGlvbkxlbmd0aCxcbiAgICAgICAgICB0YWJsZUVuZCxcbiAgICAgICAgICBwcm9ncmFtSW5mb0xlbmd0aCxcbiAgICAgICAgICBwaWQsXG4gICAgICAgICAgcmVzdWx0ID0geyBhdWRpbzogLTEsIGF2YzogLTEsIGlkMzogLTEsIGlzQUFDOiB0cnVlIH07XG4gICAgICBzZWN0aW9uTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcbiAgICAgIHRhYmxlRW5kID0gb2Zmc2V0ICsgMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSB0YWJsZSBpcywgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvd1xuICAgICAgLy8gbG9uZyB0aGUgcHJvZ3JhbSBpbmZvIGRlc2NyaXB0b3JzIGFyZVxuICAgICAgcHJvZ3JhbUluZm9MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gICAgICAvLyBhZHZhbmNlIHRoZSBvZmZzZXQgdG8gdGhlIGZpcnN0IGVudHJ5IGluIHRoZSBtYXBwaW5nIHRhYmxlXG4gICAgICBvZmZzZXQgKz0gMTIgKyBwcm9ncmFtSW5mb0xlbmd0aDtcbiAgICAgIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgICAgICBwaWQgPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MUYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICAgICAgICBzd2l0Y2ggKGRhdGFbb2Zmc2V0XSkge1xuICAgICAgICAgIGNhc2UgMHhjZjpcbiAgICAgICAgICAgIC8vIFNBTVBMRS1BRVMgQUFDXG4gICAgICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICAgICAgICAvLyBJU08vSUVDIDEzODE4LTcgQURUUyBBQUMgKE1QRUctMiBsb3dlciBiaXQtcmF0ZSBhdWRpbylcbiAgICAgICAgICBjYXNlIDB4MGY6XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coJ0FBQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmF1ZGlvID0gcGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBQYWNrZXRpemVkIG1ldGFkYXRhIChJRDMpXG4gICAgICAgICAgY2FzZSAweDE1OlxuICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdJRDMgUElEOicgICsgcGlkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuaWQzID09PSAtMSkge1xuICAgICAgICAgICAgICByZXN1bHQuaWQzID0gcGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4ZGI6XG4gICAgICAgICAgICAvLyBTQU1QTEUtQUVTIEFWQ1xuICAgICAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3Vua293biBzdHJlYW0gdHlwZTonICsgZGF0YVtvZmZzZXRdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgICAgICAgLy8gSVRVLVQgUmVjLiBILjI2NCBhbmQgSVNPL0lFQyAxNDQ5Ni0xMCAobG93ZXIgYml0LXJhdGUgdmlkZW8pXG4gICAgICAgICAgY2FzZSAweDFiOlxuICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdBVkMgUElEOicgICsgcGlkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuYXZjID09PSAtMSkge1xuICAgICAgICAgICAgICByZXN1bHQuYXZjID0gcGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBJU08vSUVDIDExMTcyLTMgKE1QRUctMSBhdWRpbylcbiAgICAgICAgICAvLyBvciBJU08vSUVDIDEzODE4LTMgKE1QRUctMiBoYWx2ZWQgc2FtcGxlIHJhdGUgYXVkaW8pXG4gICAgICAgICAgY2FzZSAweDAzOlxuICAgICAgICAgIGNhc2UgMHgwNDpcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnTVBFRyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgICAgaWYgKCFtcGVnU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnTVBFRyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIgZm9yIG5vdycpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuYXVkaW8gPT09IC0xKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgICAgICAgcmVzdWx0LmlzQUFDID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHgyNDpcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ0hFVkMgc3RyZWFtIHR5cGUgZm91bmQsIG5vdCBzdXBwb3J0ZWQgZm9yIG5vdycpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCd1bmtvd24gc3RyZWFtIHR5cGU6JyArIGRhdGFbb2Zmc2V0XSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBtb3ZlIHRvIHRoZSBuZXh0IHRhYmxlIGVudHJ5XG4gICAgICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcbiAgICAgICAgb2Zmc2V0ICs9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MEYpIDw8IDggfCBkYXRhW29mZnNldCArIDRdKSArIDU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19wYXJzZVBFUycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZVBFUyhzdHJlYW0pIHtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIHBlc0ZsYWdzLFxuICAgICAgICAgIHBlc1ByZWZpeCxcbiAgICAgICAgICBwZXNMZW4sXG4gICAgICAgICAgcGVzSGRyTGVuLFxuICAgICAgICAgIHBlc0RhdGEsXG4gICAgICAgICAgcGVzUHRzLFxuICAgICAgICAgIHBlc0R0cyxcbiAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQsXG4gICAgICAgICAgZGF0YSA9IHN0cmVhbS5kYXRhO1xuICAgICAgLy8gc2FmZXR5IGNoZWNrXG4gICAgICBpZiAoIXN0cmVhbSB8fCBzdHJlYW0uc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgbWlnaHQgbmVlZCB1cCB0byAxOSBieXRlcyB0byByZWFkIFBFUyBoZWFkZXJcbiAgICAgIC8vIGlmIGZpcnN0IGNodW5rIG9mIGRhdGEgaXMgbGVzcyB0aGFuIDE5IGJ5dGVzLCBsZXQncyBtZXJnZSBpdCB3aXRoIGZvbGxvd2luZyBvbmVzIHVudGlsIHdlIGdldCAxOSBieXRlc1xuICAgICAgLy8gdXN1YWxseSBvbmx5IG9uZSBtZXJnZSBpcyBuZWVkZWQgKGFuZCB0aGlzIGlzIHJhcmUgLi4uKVxuICAgICAgd2hpbGUgKGRhdGFbMF0ubGVuZ3RoIDwgMTkgJiYgZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YVswXS5sZW5ndGggKyBkYXRhWzFdLmxlbmd0aCk7XG4gICAgICAgIG5ld0RhdGEuc2V0KGRhdGFbMF0pO1xuICAgICAgICBuZXdEYXRhLnNldChkYXRhWzFdLCBkYXRhWzBdLmxlbmd0aCk7XG4gICAgICAgIGRhdGFbMF0gPSBuZXdEYXRhO1xuICAgICAgICBkYXRhLnNwbGljZSgxLCAxKTtcbiAgICAgIH1cbiAgICAgIC8vcmV0cmlldmUgUFRTL0RUUyBmcm9tIGZpcnN0IGZyYWdtZW50XG4gICAgICBmcmFnID0gZGF0YVswXTtcbiAgICAgIHBlc1ByZWZpeCA9IChmcmFnWzBdIDw8IDE2KSArIChmcmFnWzFdIDw8IDgpICsgZnJhZ1syXTtcbiAgICAgIGlmIChwZXNQcmVmaXggPT09IDEpIHtcbiAgICAgICAgcGVzTGVuID0gKGZyYWdbNF0gPDwgOCkgKyBmcmFnWzVdO1xuICAgICAgICAvLyBpZiBQRVMgcGFyc2VkIGxlbmd0aCBpcyBub3QgemVybyBhbmQgZ3JlYXRlciB0aGFuIHRvdGFsIHJlY2VpdmVkIGxlbmd0aCwgc3RvcCBwYXJzaW5nLiBQRVMgbWlnaHQgYmUgdHJ1bmNhdGVkXG4gICAgICAgIC8vIG1pbnVzIDYgOiBQRVMgaGVhZGVyIHNpemVcbiAgICAgICAgaWYgKHBlc0xlbiAmJiBwZXNMZW4gPiBzdHJlYW0uc2l6ZSAtIDYpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwZXNGbGFncyA9IGZyYWdbN107XG4gICAgICAgIGlmIChwZXNGbGFncyAmIDB4QzApIHtcbiAgICAgICAgICAvKiBQRVMgaGVhZGVyIGRlc2NyaWJlZCBoZXJlIDogaHR0cDovL2R2ZC5zb3VyY2Vmb3JnZS5uZXQvZHZkaW5mby9wZXMtaGRyLmh0bWxcbiAgICAgICAgICAgICAgYXMgUFRTIC8gRFRTIGlzIDMzIGJpdCB3ZSBjYW5ub3QgdXNlIGJpdHdpc2Ugb3BlcmF0b3IgaW4gSlMsXG4gICAgICAgICAgICAgIGFzIEJpdHdpc2Ugb3BlcmF0b3JzIHRyZWF0IHRoZWlyIG9wZXJhbmRzIGFzIGEgc2VxdWVuY2Ugb2YgMzIgYml0cyAqL1xuICAgICAgICAgIHBlc1B0cyA9IChmcmFnWzldICYgMHgwRSkgKiA1MzY4NzA5MTIgKyAvLyAxIDw8IDI5XG4gICAgICAgICAgKGZyYWdbMTBdICYgMHhGRikgKiA0MTk0MzA0ICsgLy8gMSA8PCAyMlxuICAgICAgICAgIChmcmFnWzExXSAmIDB4RkUpICogMTYzODQgKyAvLyAxIDw8IDE0XG4gICAgICAgICAgKGZyYWdbMTJdICYgMHhGRikgKiAxMjggKyAvLyAxIDw8IDdcbiAgICAgICAgICAoZnJhZ1sxM10gJiAweEZFKSAvIDI7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgZ3JlYXRlciB0aGFuIDJeMzIgLTFcbiAgICAgICAgICBpZiAocGVzUHRzID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgLy8gZGVjcmVtZW50IDJeMzNcbiAgICAgICAgICAgIHBlc1B0cyAtPSA4NTg5OTM0NTkyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGVzRmxhZ3MgJiAweDQwKSB7XG4gICAgICAgICAgICBwZXNEdHMgPSAoZnJhZ1sxNF0gJiAweDBFKSAqIDUzNjg3MDkxMiArIC8vIDEgPDwgMjlcbiAgICAgICAgICAgIChmcmFnWzE1XSAmIDB4RkYpICogNDE5NDMwNCArIC8vIDEgPDwgMjJcbiAgICAgICAgICAgIChmcmFnWzE2XSAmIDB4RkUpICogMTYzODQgKyAvLyAxIDw8IDE0XG4gICAgICAgICAgICAoZnJhZ1sxN10gJiAweEZGKSAqIDEyOCArIC8vIDEgPDwgN1xuICAgICAgICAgICAgKGZyYWdbMThdICYgMHhGRSkgLyAyO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgZ3JlYXRlciB0aGFuIDJeMzIgLTFcbiAgICAgICAgICAgIGlmIChwZXNEdHMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAgIC8vIGRlY3JlbWVudCAyXjMzXG4gICAgICAgICAgICAgIHBlc0R0cyAtPSA4NTg5OTM0NTkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBlc1B0cyAtIHBlc0R0cyA+IDYwICogOTAwMDApIHtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybihNYXRoLnJvdW5kKChwZXNQdHMgLSBwZXNEdHMpIC8gOTAwMDApICsgJ3MgZGVsdGEgYmV0d2VlbiBQVFMgYW5kIERUUywgYWxpZ24gdGhlbScpO1xuICAgICAgICAgICAgICBwZXNQdHMgPSBwZXNEdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlc0R0cyA9IHBlc1B0cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGVzSGRyTGVuID0gZnJhZ1s4XTtcbiAgICAgICAgLy8gOSBieXRlcyA6IDYgYnl0ZXMgZm9yIFBFUyBoZWFkZXIgKyAzIGJ5dGVzIGZvciBQRVMgZXh0ZW5zaW9uXG4gICAgICAgIHBheWxvYWRTdGFydE9mZnNldCA9IHBlc0hkckxlbiArIDk7XG5cbiAgICAgICAgc3RyZWFtLnNpemUgLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xuICAgICAgICAvL3JlYXNzZW1ibGUgUEVTIHBhY2tldFxuICAgICAgICBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgZGF0YUxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgZGF0YUxlbjsgaisrKSB7XG4gICAgICAgICAgZnJhZyA9IGRhdGFbal07XG4gICAgICAgICAgdmFyIGxlbiA9IGZyYWcuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0ID4gbGVuKSB7XG4gICAgICAgICAgICAgIC8vIHRyaW0gZnVsbCBmcmFnIGlmIFBFUyBoZWFkZXIgYmlnZ2VyIHRoYW4gZnJhZ1xuICAgICAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgLT0gbGVuO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRyaW0gcGFydGlhbCBmcmFnIGlmIFBFUyBoZWFkZXIgc21hbGxlciB0aGFuIGZyYWdcbiAgICAgICAgICAgICAgZnJhZyA9IGZyYWcuc3ViYXJyYXkocGF5bG9hZFN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgbGVuIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGVzRGF0YS5zZXQoZnJhZywgaSk7XG4gICAgICAgICAgaSArPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlc0xlbikge1xuICAgICAgICAgIC8vIHBheWxvYWQgc2l6ZSA6IHJlbW92ZSBQRVMgaGVhZGVyICsgUEVTIGV4dGVuc2lvblxuICAgICAgICAgIHBlc0xlbiAtPSBwZXNIZHJMZW4gKyAzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHBlc0RhdGEsIHB0czogcGVzUHRzLCBkdHM6IHBlc0R0cywgbGVuOiBwZXNMZW4gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3B1c2hBY2Nlc1VuaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoQWNjZXNVbml0KGF2Y1NhbXBsZSwgYXZjVHJhY2spIHtcbiAgICAgIGlmIChhdmNTYW1wbGUudW5pdHMudW5pdHMubGVuZ3RoICYmIGF2Y1NhbXBsZS5mcmFtZSkge1xuICAgICAgICAvLyBvbmx5IHB1c2ggQVZDIHNhbXBsZSBpZiBzdGFydGluZyB3aXRoIGEga2V5ZnJhbWUgaXMgbm90IG1hbmRhdG9yeSBPUlxuICAgICAgICAvLyAgICBpZiBrZXlmcmFtZSBhbHJlYWR5IGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgT1JcbiAgICAgICAgLy8gICAgICAga2V5ZnJhbWUgZm91bmQgaW4gbGFzdCBmcmFnbWVudCAodHJhY2suc3BzKSBBTkRcbiAgICAgICAgLy8gICAgICAgICAgc2FtcGxlcyBhbHJlYWR5IGFwcGVuZGVkICh3ZSBhbHJlYWR5IGZvdW5kIGEga2V5ZnJhbWUgaW4gdGhpcyBmcmFnbWVudCkgT1IgZnJhZ21lbnQgaXMgY29udGlndW91c1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkgfHwgYXZjU2FtcGxlLmtleSA9PT0gdHJ1ZSB8fCBhdmNUcmFjay5zcHMgJiYgKGF2Y1RyYWNrLnNhbXBsZXMubGVuZ3RoIHx8IHRoaXMuY29udGlndW91cykpIHtcbiAgICAgICAgICBhdmNUcmFjay5zYW1wbGVzLnB1c2goYXZjU2FtcGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkcm9wcGVkIHNhbXBsZXMsIHRyYWNrIGl0XG4gICAgICAgICAgYXZjVHJhY2suZHJvcHBlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXZjU2FtcGxlLmRlYnVnLmxlbmd0aCkge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coYXZjU2FtcGxlLnB0cyArICcvJyArIGF2Y1NhbXBsZS5kdHMgKyAnOicgKyBhdmNTYW1wbGUuZGVidWcgKyAnLCcgKyBhdmNTYW1wbGUudW5pdHMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfcGFyc2VBVkNQRVMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VBVkNQRVMocGVzLCBsYXN0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgLy9sb2dnZXIubG9nKCdwYXJzZSBuZXcgUEVTJyk7XG4gICAgICB2YXIgdHJhY2sgPSB0aGlzLl9hdmNUcmFjayxcbiAgICAgICAgICB1bml0cyA9IHRoaXMuX3BhcnNlQVZDTkFMdShwZXMuZGF0YSksXG4gICAgICAgICAgZGVidWcgPSBmYWxzZSxcbiAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyLFxuICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlLFxuICAgICAgICAgIHB1c2gsXG4gICAgICAgICAgaTtcbiAgICAgIC8vZnJlZSBwZXMuZGF0YSB0byBzYXZlIHVwIHNvbWUgbWVtb3J5XG4gICAgICBwZXMuZGF0YSA9IG51bGw7XG5cbiAgICAgIHVuaXRzLmZvckVhY2goZnVuY3Rpb24gKHVuaXQpIHtcbiAgICAgICAgc3dpdGNoICh1bml0LnR5cGUpIHtcbiAgICAgICAgICAvL05EUlxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ05EUiAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXZjU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHJldHJpZXZlIHNsaWNlIHR5cGUgYnkgcGFyc2luZyBiZWdpbm5pbmcgb2YgTkFMIHVuaXQgKGZvbGxvdyBIMjY0IHNwZWMsIHNsaWNlX2hlYWRlciBkZWZpbml0aW9uKSB0byBkZXRlY3Qga2V5ZnJhbWUgZW1iZWRkZWQgaW4gTkRSXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHVuaXQuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgdmFyIHNsaWNlVHlwZSA9IG5ldyBfZXhwR29sb21iMi5kZWZhdWx0KGRhdGEpLnJlYWRTbGljZVR5cGUoKTtcbiAgICAgICAgICAgICAgLy8gMiA6IEkgc2xpY2UsIDQgOiBTSSBzbGljZSwgNyA6IEkgc2xpY2UsIDk6IFNJIHNsaWNlXG4gICAgICAgICAgICAgIC8vIFNJIHNsaWNlIDogQSBzbGljZSB0aGF0IGlzIGNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seSBhbmQgdXNpbmcgcXVhbnRpc2F0aW9uIG9mIHRoZSBwcmVkaWN0aW9uIHNhbXBsZXMuXG4gICAgICAgICAgICAgIC8vIEFuIFNJIHNsaWNlIGNhbiBiZSBjb2RlZCBzdWNoIHRoYXQgaXRzIGRlY29kZWQgc2FtcGxlcyBjYW4gYmUgY29uc3RydWN0ZWQgaWRlbnRpY2FsbHkgdG8gYW4gU1Agc2xpY2UuXG4gICAgICAgICAgICAgIC8vIEkgc2xpY2U6IEEgc2xpY2UgdGhhdCBpcyBub3QgYW4gU0kgc2xpY2UgdGhhdCBpcyBkZWNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seS5cbiAgICAgICAgICAgICAgLy9pZiAoc2xpY2VUeXBlID09PSAyIHx8IHNsaWNlVHlwZSA9PT0gNykge1xuICAgICAgICAgICAgICBpZiAoc2xpY2VUeXBlID09PSAyIHx8IHNsaWNlVHlwZSA9PT0gNCB8fCBzbGljZVR5cGUgPT09IDcgfHwgc2xpY2VUeXBlID09PSA5KSB7XG4gICAgICAgICAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vSURSXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICAvLyBoYW5kbGUgUEVTIG5vdCBzdGFydGluZyB3aXRoIEFVRFxuICAgICAgICAgICAgaWYgKCFhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgICAgYXZjU2FtcGxlID0gX3RoaXMzLmF2Y1NhbXBsZSA9IF90aGlzMy5fY3JlYXRlQVZDU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ0lEUiAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgICBhdmNTYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy9TRUlcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdTRUkgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIgPSBuZXcgX2V4cEdvbG9tYjIuZGVmYXVsdChfdGhpczMuZGlzY2FyZEVQQih1bml0LmRhdGEpKTtcblxuICAgICAgICAgICAgLy8gc2tpcCBmcmFtZVR5cGVcbiAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgIHZhciBwYXlsb2FkVHlwZSA9IDA7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZFNpemUgPSAwO1xuICAgICAgICAgICAgdmFyIGVuZE9mQ2FwdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBiID0gMDtcblxuICAgICAgICAgICAgd2hpbGUgKCFlbmRPZkNhcHRpb25zICYmIGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUgPiAxKSB7XG4gICAgICAgICAgICAgIHBheWxvYWRUeXBlID0gMDtcbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGIgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlICs9IGI7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGIgPT09IDB4RkYpO1xuXG4gICAgICAgICAgICAgIC8vIFBhcnNlIHBheWxvYWQgc2l6ZS5cbiAgICAgICAgICAgICAgcGF5bG9hZFNpemUgPSAwO1xuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgYiA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFNpemUgKz0gYjtcbiAgICAgICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XG5cbiAgICAgICAgICAgICAgLy8gVE9ETzogdGhlcmUgY2FuIGJlIG1vcmUgdGhhbiBvbmUgcGF5bG9hZCBpbiBhbiBTRUkgcGFja2V0Li4uXG4gICAgICAgICAgICAgIC8vIFRPRE86IG5lZWQgdG8gcmVhZCB0eXBlIGFuZCBzaXplIGluIGEgd2hpbGUgbG9vcCB0byBnZXQgdGhlbSBhbGxcbiAgICAgICAgICAgICAgaWYgKHBheWxvYWRUeXBlID09PSA0ICYmIGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUgIT09IDApIHtcblxuICAgICAgICAgICAgICAgIGVuZE9mQ2FwdGlvbnMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvdW50cnlDb2RlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb3VudHJ5Q29kZSA9PT0gMTgxKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJDb2RlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVVNob3J0KCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlckNvZGUgPT09IDQ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1c2VyU3RydWN0dXJlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUludCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyU3RydWN0dXJlID09PSAweDQ3NDEzOTM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJEYXRhVHlwZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBSYXcgQ0VBLTYwOCBieXRlcyB3cmFwcGVkIGluIENFQS03MDggcGFja2V0XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJEYXRhVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0Qnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbENDcyA9IDMxICYgZmlyc3RCeXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVBcnJheSA9IFtmaXJzdEJ5dGUsIHNlY29uZEJ5dGVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDQ3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzIGJ5dGVzIHBlciBDQ1xuICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczMuX2luc2VydFNhbXBsZUluT3JkZXIoX3RoaXMzLl90eHRUcmFjay5zYW1wbGVzLCB7IHR5cGU6IDMsIHB0czogcGVzLnB0cywgYnl0ZXM6IGJ5dGVBcnJheSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZFNpemUgPCBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBheWxvYWRTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvL1NQU1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1NQUyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0cmFjay5zcHMpIHtcbiAgICAgICAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBfZXhwR29sb21iMi5kZWZhdWx0KHVuaXQuZGF0YSk7XG4gICAgICAgICAgICAgIHZhciBjb25maWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRTUFMoKTtcbiAgICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICAgIHRyYWNrLmhlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XG4gICAgICAgICAgICAgIHRyYWNrLnBpeGVsUmF0aW8gPSBjb25maWcucGl4ZWxSYXRpbztcbiAgICAgICAgICAgICAgdHJhY2suc3BzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgICAgIHRyYWNrLmR1cmF0aW9uID0gX3RoaXMzLl9kdXJhdGlvbjtcbiAgICAgICAgICAgICAgdmFyIGNvZGVjYXJyYXkgPSB1bml0LmRhdGEuc3ViYXJyYXkoMSwgNCk7XG4gICAgICAgICAgICAgIHZhciBjb2RlY3N0cmluZyA9ICdhdmMxLic7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IGNvZGVjYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2RlY3N0cmluZyArPSBoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWNzdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvL1BQU1xuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1BQUyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcbiAgICAgICAgICAgICAgdHJhY2sucHBzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBBVURcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5wdXNoQWNjZXNVbml0KGF2Y1NhbXBsZSwgdHJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXZjU2FtcGxlID0gX3RoaXMzLmF2Y1NhbXBsZSA9IF90aGlzMy5fY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCBkZWJ1ZyA/ICdBVUQgJyA6ICcnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIEZpbGxlciBEYXRhXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAndW5rbm93biBOQUwgJyArIHVuaXQudHlwZSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdmNTYW1wbGUgJiYgcHVzaCkge1xuICAgICAgICAgIHZhciBfdW5pdHMgPSBhdmNTYW1wbGUudW5pdHM7XG4gICAgICAgICAgX3VuaXRzLnVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gaWYgbGFzdCBQRVMgcGFja2V0LCBwdXNoIHNhbXBsZXNcbiAgICAgIGlmIChsYXN0ICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICB0aGlzLnB1c2hBY2Nlc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfY3JlYXRlQVZDU2FtcGxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUFWQ1NhbXBsZShrZXksIHB0cywgZHRzLCBkZWJ1Zykge1xuICAgICAgcmV0dXJuIHsga2V5OiBrZXksIHB0czogcHRzLCBkdHM6IGR0cywgdW5pdHM6IHsgdW5pdHM6IFtdLCBsZW5ndGg6IDAgfSwgZGVidWc6IGRlYnVnIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2luc2VydFNhbXBsZUluT3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5zZXJ0U2FtcGxlSW5PcmRlcihhcnIsIGRhdGEpIHtcbiAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgaWYgKGRhdGEucHRzID49IGFycltsZW4gLSAxXS5wdHMpIHtcbiAgICAgICAgICBhcnIucHVzaChkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBwb3MgPSBsZW4gLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnB0cyA8IGFycltwb3NdLnB0cykge1xuICAgICAgICAgICAgICBhcnIuc3BsaWNlKHBvcywgMCwgZGF0YSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyLnB1c2goZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2dldExhc3ROYWxVbml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldExhc3ROYWxVbml0KCkge1xuICAgICAgdmFyIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlLFxuICAgICAgICAgIGxhc3RVbml0ID0gdm9pZCAwO1xuICAgICAgLy8gdHJ5IHRvIGZhbGxiYWNrIHRvIHByZXZpb3VzIHNhbXBsZSBpZiBjdXJyZW50IG9uZSBpcyBlbXB0eVxuICAgICAgaWYgKCFhdmNTYW1wbGUgfHwgYXZjU2FtcGxlLnVuaXRzLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLl9hdmNUcmFjayxcbiAgICAgICAgICAgIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgICAgICBhdmNTYW1wbGUgPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgICBpZiAoYXZjU2FtcGxlKSB7XG4gICAgICAgIHZhciB1bml0cyA9IGF2Y1NhbXBsZS51bml0cy51bml0cztcbiAgICAgICAgbGFzdFVuaXQgPSB1bml0c1t1bml0cy5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXN0VW5pdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfcGFyc2VBVkNOQUx1JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlQVZDTkFMdShhcnJheSkge1xuICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIGxlbiA9IGFycmF5LmJ5dGVMZW5ndGgsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgb3ZlcmZsb3csXG4gICAgICAgICAgdHJhY2sgPSB0aGlzLl9hdmNUcmFjayxcbiAgICAgICAgICBzdGF0ZSA9IHRyYWNrLm5hbHVTdGF0ZSB8fCAwLFxuICAgICAgICAgIGxhc3RTdGF0ZSA9IHN0YXRlO1xuICAgICAgdmFyIHVuaXRzID0gW10sXG4gICAgICAgICAgdW5pdCxcbiAgICAgICAgICB1bml0VHlwZSxcbiAgICAgICAgICBsYXN0VW5pdFN0YXJ0ID0gLTEsXG4gICAgICAgICAgbGFzdFVuaXRUeXBlO1xuICAgICAgLy9sb2dnZXIubG9nKCdQRVM6JyArIEhleC5oZXhEdW1wKGFycmF5KSk7XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gLTEpIHtcbiAgICAgICAgLy8gc3BlY2lhbCB1c2UgY2FzZSB3aGVyZSB3ZSBmb3VuZCAzIG9yIDQtYnl0ZSBzdGFydCBjb2RlcyBleGFjdGx5IGF0IHRoZSBlbmQgb2YgcHJldmlvdXMgUEVTIHBhY2tldFxuICAgICAgICBsYXN0VW5pdFN0YXJ0ID0gMDtcbiAgICAgICAgLy8gTkFMdSB0eXBlIGlzIHZhbHVlIHJlYWQgZnJvbSBvZmZzZXQgMFxuICAgICAgICBsYXN0VW5pdFR5cGUgPSBhcnJheVswXSAmIDB4MWY7XG4gICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgaSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIHZhbHVlID0gYXJyYXlbaSsrXTtcbiAgICAgICAgLy8gb3B0aW1pemF0aW9uLiBzdGF0ZSAwIGFuZCAxIGFyZSB0aGUgcHJlZG9taW5hbnQgY2FzZS4gbGV0J3MgaGFuZGxlIHRoZW0gb3V0c2lkZSBvZiB0aGUgc3dpdGNoL2Nhc2VcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT09IDEpIHtcbiAgICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGVyZSB3ZSBoYXZlIHN0YXRlIGVpdGhlciBlcXVhbCB0byAyIG9yIDNcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgIHVuaXQgPSB7IGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGkgLSBzdGF0ZSAtIDEpLCB0eXBlOiBsYXN0VW5pdFR5cGUgfTtcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGxhc3RVbml0U3RhcnQgaXMgdW5kZWZpbmVkID0+IHRoaXMgaXMgdGhlIGZpcnN0IHN0YXJ0IGNvZGUgZm91bmQgaW4gdGhpcyBQRVMgcGFja2V0XG4gICAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiBzdGFydCBjb2RlIGRlbGltaXRlciBpcyBvdmVybGFwcGluZyBiZXR3ZWVuIDIgUEVTIHBhY2tldHMsXG4gICAgICAgICAgICAvLyBpZSBpdCBzdGFydGVkIGluIGxhc3QgcGFja2V0IChsYXN0U3RhdGUgbm90IHplcm8pXG4gICAgICAgICAgICAvLyBhbmQgZW5kZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIFBFUyBwYWNrZXQgKGkgPD0gNCAtIGxhc3RTdGF0ZSlcbiAgICAgICAgICAgIHZhciBsYXN0VW5pdCA9IHRoaXMuX2dldExhc3ROYWxVbml0KCk7XG4gICAgICAgICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZSAmJiBpIDw9IDQgLSBsYXN0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBkZWxpbWl0ZXIgb3ZlcmxhcHBpbmcgYmV0d2VlbiBQRVMgcGFja2V0c1xuICAgICAgICAgICAgICAgIC8vIHN0cmlwIHN0YXJ0IGRlbGltaXRlciBieXRlcyBmcm9tIHRoZSBlbmQgb2YgbGFzdCBOQUwgdW5pdFxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGxhc3RVbml0IGhhZCBhIHN0YXRlIGRpZmZlcmVudCBmcm9tIHplcm9cbiAgICAgICAgICAgICAgICBpZiAobGFzdFVuaXQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxhc3QgYnl0ZXNcbiAgICAgICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSBsYXN0VW5pdC5kYXRhLnN1YmFycmF5KDAsIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCAtIGxhc3RTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIElmIE5BTCB1bml0cyBhcmUgbm90IHN0YXJ0aW5nIHJpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYWNrZXQsIHB1c2ggcHJlY2VkaW5nIGRhdGEgaW50byBwcmV2aW91cyBOQUwgdW5pdC5cbiAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBpIC0gc3RhdGUgLSAxO1xuICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdmaXJzdCBOQUxVIGZvdW5kIHdpdGggb3ZlcmZsb3c6JyArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgICAgICAgICAgdG1wLnNldChhcnJheS5zdWJhcnJheSgwLCBvdmVyZmxvdyksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gcmVhZCB1bml0IHR5cGVcbiAgICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgICAgdW5pdFR5cGUgPSBhcnJheVtpXSAmIDB4MWY7XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coJ2ZpbmQgTkFMVSBAIG9mZnNldDonICsgaSArICcsdHlwZTonICsgdW5pdFR5cGUpO1xuICAgICAgICAgICAgbGFzdFVuaXRTdGFydCA9IGk7XG4gICAgICAgICAgICBsYXN0VW5pdFR5cGUgPSB1bml0VHlwZTtcbiAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm90IGVub3VnaCBieXRlIHRvIHJlYWQgdW5pdCB0eXBlLiBsZXQncyByZWFkIGl0IG9uIG5leHQgUEVTIHBhcnNpbmdcbiAgICAgICAgICAgIHN0YXRlID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCAmJiBzdGF0ZSA+PSAwKSB7XG4gICAgICAgIHVuaXQgPSB7IGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGxlbiksIHR5cGU6IGxhc3RVbml0VHlwZSwgc3RhdGU6IHN0YXRlIH07XG4gICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgIC8vbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemUvc3RhdGU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgJy8nICsgc3RhdGUpO1xuICAgICAgfVxuICAgICAgLy8gbm8gTkFMdSBmb3VuZFxuICAgICAgaWYgKHVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBhcHBlbmQgcGVzLmRhdGEgdG8gcHJldmlvdXMgTkFMIHVuaXRcbiAgICAgICAgdmFyIF9sYXN0VW5pdCA9IHRoaXMuX2dldExhc3ROYWxVbml0KCk7XG4gICAgICAgIGlmIChfbGFzdFVuaXQpIHtcbiAgICAgICAgICB2YXIgX3RtcCA9IG5ldyBVaW50OEFycmF5KF9sYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBhcnJheS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICBfdG1wLnNldChfbGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgICAgX3RtcC5zZXQoYXJyYXksIF9sYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIF9sYXN0VW5pdC5kYXRhID0gX3RtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJhY2submFsdVN0YXRlID0gc3RhdGU7XG4gICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIEVtdWxhdGlvbiBQcmV2ZW50aW9uIGJ5dGVzIGZyb20gYSBSQlNQXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc2NhcmRFUEInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjYXJkRVBCKGRhdGEpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgRVBCUG9zaXRpb25zID0gW10sXG4gICAgICAgICAgaSA9IDEsXG4gICAgICAgICAgbmV3TGVuZ3RoLFxuICAgICAgICAgIG5ld0RhdGE7XG5cbiAgICAgIC8vIEZpbmQgYWxsIGBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlc2BcbiAgICAgIHdoaWxlIChpIDwgbGVuZ3RoIC0gMikge1xuICAgICAgICBpZiAoZGF0YVtpXSA9PT0gMCAmJiBkYXRhW2kgKyAxXSA9PT0gMCAmJiBkYXRhW2kgKyAyXSA9PT0gMHgwMykge1xuICAgICAgICAgIEVQQlBvc2l0aW9ucy5wdXNoKGkgKyAyKTtcbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgICAvLyBhcnJheVxuICAgICAgaWYgKEVQQlBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byBob2xkIHRoZSBOQUwgdW5pdCBkYXRhXG4gICAgICBuZXdMZW5ndGggPSBsZW5ndGggLSBFUEJQb3NpdGlvbnMubGVuZ3RoO1xuICAgICAgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gICAgICB2YXIgc291cmNlSW5kZXggPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcbiAgICAgICAgaWYgKHNvdXJjZUluZGV4ID09PSBFUEJQb3NpdGlvbnNbMF0pIHtcbiAgICAgICAgICAvLyBTa2lwIHRoaXMgYnl0ZVxuICAgICAgICAgIHNvdXJjZUluZGV4Kys7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgcG9zaXRpb24gaW5kZXhcbiAgICAgICAgICBFUEJQb3NpdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdEYXRhW2ldID0gZGF0YVtzb3VyY2VJbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfcGFyc2VBQUNQRVMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VBQUNQRVMocGVzKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgICAgIGRhdGEgPSBwZXMuZGF0YSxcbiAgICAgICAgICBwdHMgPSBwZXMucHRzLFxuICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gMCxcbiAgICAgICAgICBhYWNPdmVyRmxvdyA9IHRoaXMuYWFjT3ZlckZsb3csXG4gICAgICAgICAgYWFjTGFzdFBUUyA9IHRoaXMuYWFjTGFzdFBUUyxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgZnJhbWVMZW5ndGgsXG4gICAgICAgICAgZnJhbWVEdXJhdGlvbixcbiAgICAgICAgICBmcmFtZUluZGV4LFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICBoZWFkZXJMZW5ndGgsXG4gICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgbGVuLFxuICAgICAgICAgIGFhY1NhbXBsZTtcbiAgICAgIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYWFjT3ZlckZsb3cuYnl0ZUxlbmd0aCArIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRtcC5zZXQoYWFjT3ZlckZsb3csIDApO1xuICAgICAgICB0bXAuc2V0KGRhdGEsIGFhY092ZXJGbG93LmJ5dGVMZW5ndGgpO1xuICAgICAgICAvL2xvZ2dlci5sb2coYEFBQzogYXBwZW5kIG92ZXJmbG93aW5nICR7YWFjT3ZlckZsb3cuYnl0ZUxlbmd0aH0gYnl0ZXMgdG8gYmVnaW5uaW5nIG9mIG5ldyBQRVNgKTtcbiAgICAgICAgZGF0YSA9IHRtcDtcbiAgICAgIH1cbiAgICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgICBmb3IgKG9mZnNldCA9IHN0YXJ0T2Zmc2V0LCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjApID09PSAweGYwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIEFEVFMgaGVhZGVyIGRvZXMgbm90IHN0YXJ0IHN0cmFpZ2h0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBheWxvYWQsIHJhaXNlIGFuIGVycm9yXG4gICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciByZWFzb24sIGZhdGFsO1xuICAgICAgICBpZiAob2Zmc2V0IDwgbGVuIC0gMSkge1xuICAgICAgICAgIHJlYXNvbiA9ICdBQUMgUEVTIGRpZCBub3Qgc3RhcnQgd2l0aCBBRFRTIGhlYWRlcixvZmZzZXQ6JyArIG9mZnNldDtcbiAgICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlYXNvbiA9ICdubyBBRFRTIGhlYWRlciBmb3VuZCBpbiBBQUMgUEVTJztcbiAgICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybigncGFyc2luZyBlcnJvcjonICsgcmVhc29uKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYXRhbCwgcmVhc29uOiByZWFzb24gfSk7XG4gICAgICAgIGlmIChmYXRhbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0cmFjay5hdWRpb3NhbXBsZXJhdGUpIHtcbiAgICAgICAgdmFyIGF1ZGlvQ29kZWMgPSB0aGlzLmF1ZGlvQ29kZWM7XG4gICAgICAgIGNvbmZpZyA9IF9hZHRzMi5kZWZhdWx0LmdldEF1ZGlvQ29uZmlnKHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYyk7XG4gICAgICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgICAgIHRyYWNrLmF1ZGlvc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgICAgICB0cmFjay5jaGFubmVsQ291bnQgPSBjb25maWcuY2hhbm5lbENvdW50O1xuICAgICAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlYztcbiAgICAgICAgdHJhY2subWFuaWZlc3RDb2RlYyA9IGNvbmZpZy5tYW5pZmVzdENvZGVjO1xuICAgICAgICB0cmFjay5kdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3BhcnNlZCBjb2RlYzonICsgdHJhY2suY29kZWMgKyAnLHJhdGU6JyArIGNvbmZpZy5zYW1wbGVyYXRlICsgJyxuYiBjaGFubmVsOicgKyBjb25maWcuY2hhbm5lbENvdW50KTtcbiAgICAgIH1cbiAgICAgIGZyYW1lSW5kZXggPSAwO1xuICAgICAgZnJhbWVEdXJhdGlvbiA9IDEwMjQgKiA5MDAwMCAvIHRyYWNrLmF1ZGlvc2FtcGxlcmF0ZTtcblxuICAgICAgLy8gaWYgbGFzdCBBQUMgZnJhbWUgaXMgb3ZlcmZsb3dpbmcsIHdlIHNob3VsZCBlbnN1cmUgdGltZXN0YW1wcyBhcmUgY29udGlndW91czpcbiAgICAgIC8vIGZpcnN0IHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGZyYW1lRHVyYXRpb25cbiAgICAgIGlmIChhYWNPdmVyRmxvdyAmJiBhYWNMYXN0UFRTKSB7XG4gICAgICAgIHZhciBuZXdQVFMgPSBhYWNMYXN0UFRTICsgZnJhbWVEdXJhdGlvbjtcbiAgICAgICAgaWYgKE1hdGguYWJzKG5ld1BUUyAtIHB0cykgPiAxKSB7XG4gICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdBQUM6IGFsaWduIFBUUyBmb3Igb3ZlcmxhcHBpbmcgZnJhbWVzIGJ5ICcgKyBNYXRoLnJvdW5kKChuZXdQVFMgLSBwdHMpIC8gOTApKTtcbiAgICAgICAgICBwdHMgPSBuZXdQVFM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG9mZnNldCArIDUgPCBsZW4pIHtcbiAgICAgICAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIEFEVFMgaGVhZGVyXG4gICAgICAgIGhlYWRlckxlbmd0aCA9ICEhKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDAxKSA/IDcgOiA5O1xuICAgICAgICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gICAgICAgIGZyYW1lTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSB8IGRhdGFbb2Zmc2V0ICsgNF0gPDwgMyB8IChkYXRhW29mZnNldCArIDVdICYgMHhFMCkgPj4+IDU7XG4gICAgICAgIGZyYW1lTGVuZ3RoIC09IGhlYWRlckxlbmd0aDtcbiAgICAgICAgLy9zdGFtcCA9IHBlcy5wdHM7XG5cbiAgICAgICAgaWYgKGZyYW1lTGVuZ3RoID4gMCAmJiBvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCA8PSBsZW4pIHtcbiAgICAgICAgICBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcbiAgICAgICAgICBhYWNTYW1wbGUgPSB7IHVuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCksIHB0czogc3RhbXAsIGR0czogc3RhbXAgfTtcbiAgICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYWFjU2FtcGxlKTtcbiAgICAgICAgICB0cmFjay5sZW4gKz0gZnJhbWVMZW5ndGg7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lTGVuZ3RoICsgaGVhZGVyTGVuZ3RoO1xuICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgICAgICAgIGZvciAoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjApID09PSAweGYwKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA8IGxlbikge1xuICAgICAgICBhYWNPdmVyRmxvdyA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBsZW4pO1xuICAgICAgICAvL2xvZ2dlci5sb2coYEFBQzogb3ZlcmZsb3cgZGV0ZWN0ZWQ6JHtsZW4tb2Zmc2V0fWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5hYWNPdmVyRmxvdyA9IGFhY092ZXJGbG93O1xuICAgICAgdGhpcy5hYWNMYXN0UFRTID0gc3RhbXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3BhcnNlTVBFR1BFUycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZU1QRUdQRVMocGVzKSB7XG4gICAgICB2YXIgZGF0YSA9IHBlcy5kYXRhO1xuICAgICAgdmFyIHB0cyA9IHBlcy5wdHM7XG4gICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB2YXIgZnJhbWVJbmRleCA9IDA7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBwYXJzZWQ7XG5cbiAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGggJiYgKHBhcnNlZCA9IHRoaXMuX3BhcnNlTXBlZyhkYXRhLCBvZmZzZXQsIGxlbmd0aCwgZnJhbWVJbmRleCsrLCBwdHMpKSA+IDApIHtcbiAgICAgICAgb2Zmc2V0ICs9IHBhcnNlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfb25NcGVnRnJhbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NcGVnRnJhbWUoZGF0YSwgYml0UmF0ZSwgc2FtcGxlUmF0ZSwgY2hhbm5lbENvdW50LCBmcmFtZUluZGV4LCBwdHMpIHtcbiAgICAgIHZhciBmcmFtZUR1cmF0aW9uID0gMTE1MiAvIHNhbXBsZVJhdGUgKiAxMDAwO1xuICAgICAgdmFyIHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgICB2YXIgdHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuXG4gICAgICB0cmFjay5jb25maWcgPSBbXTtcbiAgICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNoYW5uZWxDb3VudDtcbiAgICAgIHRyYWNrLmF1ZGlvc2FtcGxlcmF0ZSA9IHNhbXBsZVJhdGU7XG4gICAgICB0cmFjay5kdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKHsgdW5pdDogZGF0YSwgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcCB9KTtcbiAgICAgIHRyYWNrLmxlbiArPSBkYXRhLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfb25NcGVnTm9pc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NcGVnTm9pc2UoZGF0YSkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignbXBlZyBhdWRpbyBoYXMgbm9pc2U6ICcgKyBkYXRhLmxlbmd0aCArICcgYnl0ZXMnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfcGFyc2VNcGVnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlTXBlZyhkYXRhLCBzdGFydCwgZW5kLCBmcmFtZUluZGV4LCBwdHMpIHtcbiAgICAgIHZhciBCaXRyYXRlc01hcCA9IFszMiwgNjQsIDk2LCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMjg4LCAzMjAsIDM1MiwgMzg0LCA0MTYsIDQ0OCwgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzODQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MCwgMTc2LCAxOTIsIDIyNCwgMjU2LCA4LCAxNiwgMjQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjBdO1xuICAgICAgdmFyIFNhbXBsaW5nUmF0ZU1hcCA9IFs0NDEwMCwgNDgwMDAsIDMyMDAwLCAyMjA1MCwgMjQwMDAsIDE2MDAwLCAxMTAyNSwgMTIwMDAsIDgwMDBdO1xuXG4gICAgICBpZiAoc3RhcnQgKyAyID4gZW5kKSB7XG4gICAgICAgIHJldHVybiAtMTsgLy8gd2UgbmVlZCBhdCBsZWFzdCAyIGJ5dGVzIHRvIGRldGVjdCBzeW5jIHBhdHRlcm5cbiAgICAgIH1cbiAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHhGRiB8fCAoZGF0YVtzdGFydCArIDFdICYgMHhFMCkgPT09IDB4RTApIHtcbiAgICAgICAgLy8gVXNpbmcgaHR0cDovL3d3dy5kYXRhdm95YWdlLmNvbS9tcGdzY3JpcHQvbXBlZ2hkci5odG0gYXMgYSByZWZlcmVuY2VcbiAgICAgICAgaWYgKHN0YXJ0ICsgMjQgPiBlbmQpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlckIgPSBkYXRhW3N0YXJ0ICsgMV0gPj4gMyAmIDM7XG4gICAgICAgIHZhciBoZWFkZXJDID0gZGF0YVtzdGFydCArIDFdID4+IDEgJiAzO1xuICAgICAgICB2YXIgaGVhZGVyRSA9IGRhdGFbc3RhcnQgKyAyXSA+PiA0ICYgMTU7XG4gICAgICAgIHZhciBoZWFkZXJGID0gZGF0YVtzdGFydCArIDJdID4+IDIgJiAzO1xuICAgICAgICB2YXIgaGVhZGVyRyA9ICEhKGRhdGFbc3RhcnQgKyAyXSAmIDIpO1xuICAgICAgICBpZiAoaGVhZGVyQiAhPT0gMSAmJiBoZWFkZXJFICE9PSAwICYmIGhlYWRlckUgIT09IDE1ICYmIGhlYWRlckYgIT09IDMpIHtcbiAgICAgICAgICB2YXIgY29sdW1uSW5CaXRyYXRlcyA9IGhlYWRlckIgPT09IDMgPyAzIC0gaGVhZGVyQyA6IGhlYWRlckMgPT09IDMgPyAzIDogNDtcbiAgICAgICAgICB2YXIgYml0UmF0ZSA9IEJpdHJhdGVzTWFwW2NvbHVtbkluQml0cmF0ZXMgKiAxNCArIGhlYWRlckUgLSAxXSAqIDEwMDA7XG4gICAgICAgICAgdmFyIGNvbHVtbkluU2FtcGxlUmF0ZXMgPSBoZWFkZXJCID09PSAzID8gMCA6IGhlYWRlckIgPT09IDIgPyAxIDogMjtcbiAgICAgICAgICB2YXIgc2FtcGxlUmF0ZSA9IFNhbXBsaW5nUmF0ZU1hcFtjb2x1bW5JblNhbXBsZVJhdGVzICogMyArIGhlYWRlckZdO1xuICAgICAgICAgIHZhciBwYWRkaW5nID0gaGVhZGVyRyA/IDEgOiAwO1xuICAgICAgICAgIHZhciBjaGFubmVsQ291bnQgPSBkYXRhW3N0YXJ0ICsgM10gPj4gNiA9PT0gMyA/IDEgOiAyOyAvLyBJZiBiaXRzIG9mIGNoYW5uZWwgbW9kZSBhcmUgYDExYCB0aGVuIGl0IGlzIGEgc2luZ2xlIGNoYW5uZWwgKE1vbm8pXG4gICAgICAgICAgdmFyIGZyYW1lTGVuZ3RoID0gaGVhZGVyQyA9PT0gMyA/IChoZWFkZXJCID09PSAzID8gMTIgOiA2KSAqIGJpdFJhdGUgLyBzYW1wbGVSYXRlICsgcGFkZGluZyA8PCAyIDogKGhlYWRlckIgPT09IDMgPyAxNDQgOiA3MikgKiBiaXRSYXRlIC8gc2FtcGxlUmF0ZSArIHBhZGRpbmcgfCAwO1xuICAgICAgICAgIGlmIChzdGFydCArIGZyYW1lTGVuZ3RoID4gZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9vbk1wZWdGcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fb25NcGVnRnJhbWUoZGF0YS5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBmcmFtZUxlbmd0aCksIGJpdFJhdGUsIHNhbXBsZVJhdGUsIGNoYW5uZWxDb3VudCwgZnJhbWVJbmRleCwgcHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZyYW1lTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBub2lzZSBvciBJRDMsIHRyeWluZyB0byBza2lwXG4gICAgICB2YXIgb2Zmc2V0ID0gc3RhcnQgKyAyO1xuICAgICAgd2hpbGUgKG9mZnNldCA8IGVuZCkge1xuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgLSAxXSA9PT0gMHhGRiAmJiAoZGF0YVtvZmZzZXRdICYgMHhFMCkgPT09IDB4RTApIHtcbiAgICAgICAgICAvLyBzeW5jIHBhdHRlcm4gaXMgZm91bmRcbiAgICAgICAgICBpZiAodGhpcy5fb25NcGVnTm9pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX29uTXBlZ05vaXNlKGRhdGEuc3ViYXJyYXkoc3RhcnQsIG9mZnNldCAtIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfcGFyc2VJRDNQRVMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VJRDNQRVMocGVzKSB7XG4gICAgICB0aGlzLl9pZDNUcmFjay5zYW1wbGVzLnB1c2gocGVzKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ3Byb2JlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvYmUoZGF0YSkge1xuICAgICAgLy8gYSBUUyBmcmFnbWVudCBzaG91bGQgY29udGFpbiBhdCBsZWFzdCAzIFRTIHBhY2tldHMsIGEgUEFULCBhIFBNVCwgYW5kIG9uZSBQSUQsIGVhY2ggc3RhcnRpbmcgd2l0aCAweDQ3XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPj0gMyAqIDE4OCAmJiBkYXRhWzBdID09PSAweDQ3ICYmIGRhdGFbMTg4XSA9PT0gMHg0NyAmJiBkYXRhWzIgKiAxODhdID09PSAweDQ3KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUU0RlbXV4ZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRTRGVtdXhlcjtcblxufSx7XCIyMlwiOjIyLFwiMjZcIjoyNixcIjI5XCI6MjksXCIzMVwiOjMxLFwiMzNcIjozMyxcIjUwXCI6NTB9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgRXJyb3JUeXBlcyA9IGV4cG9ydHMuRXJyb3JUeXBlcyA9IHtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBuZXR3b3JrIGVycm9yIChsb2FkaW5nIGVycm9yIC8gdGltZW91dCAuLi4pXG4gIE5FVFdPUktfRVJST1I6ICduZXR3b3JrRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1lZGlhIEVycm9yICh2aWRlby9wYXJzaW5nL21lZGlhc291cmNlIGVycm9yKVxuICBNRURJQV9FUlJPUjogJ21lZGlhRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG11eCBFcnJvciAoZGVtdXhpbmcvcmVtdXhpbmcpXG4gIE1VWF9FUlJPUjogJ211eEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYWxsIG90aGVyIGVycm9yc1xuICBPVEhFUl9FUlJPUjogJ290aGVyRXJyb3InXG59O1xuXG52YXIgRXJyb3JEZXRhaWxzID0gZXhwb3J0cy5FcnJvckRldGFpbHMgPSB7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTUFOSUZFU1RfTE9BRF9FUlJPUjogJ21hbmlmZXN0TG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIE1BTklGRVNUX0xPQURfVElNRU9VVDogJ21hbmlmZXN0TG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IHBhcnNpbmcgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbn1cbiAgTUFOSUZFU1RfUEFSU0lOR19FUlJPUjogJ21hbmlmZXN0UGFyc2luZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCB3aXRoIG9ubHkgaW5jb21wYXRpYmxlIGNvZGVjcyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICBNQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SOiAnbWFuaWZlc3RJbmNvbXBhdGlibGVDb2RlY3NFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTEVWRUxfTE9BRF9FUlJPUjogJ2xldmVsTG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIExFVkVMX0xPQURfVElNRU9VVDogJ2xldmVsTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIHN3aXRjaCBlcnJvciAtIGRhdGE6IHsgbGV2ZWwgOiBmYXVsdHkgbGV2ZWwgSWQsIGV2ZW50IDogZXJyb3IgZGVzY3JpcHRpb259XG4gIExFVkVMX1NXSVRDSF9FUlJPUjogJ2xldmVsU3dpdGNoRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBBVURJT19UUkFDS19MT0FEX0VSUk9SOiAnYXVkaW9UcmFja0xvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGF1ZGlvIHRyYWNrIGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOiAnYXVkaW9UcmFja0xvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgRlJBR19MT0FEX0VSUk9SOiAnZnJhZ0xvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvb3AgbG9hZGluZyBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgRlJBR19MT09QX0xPQURJTkdfRVJST1I6ICdmcmFnTG9vcExvYWRpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgRlJBR19MT0FEX1RJTUVPVVQ6ICdmcmFnTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IGRlY3J5cHRpb24gZXJyb3IgZXZlbnQgLSBkYXRhOiB7aWQgOiBkZW11eGVyIElkLGZyYWc6IGZyYWdtZW50IG9iamVjdCwgcmVhc29uIDogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvbiB9XG4gIEZSQUdfREVDUllQVF9FUlJPUjogJ2ZyYWdEZWNyeXB0RXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IHBhcnNpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgcmVhc29uIDogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvbiB9XG4gIC8vIHdpbGwgYmUgcmVuYW1lZCBERU1VWF9QQVJTSU5HX0VSUk9SIGFuZCBzd2l0Y2hlZCB0byBNVVhfRVJST1IgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxuICBGUkFHX1BBUlNJTkdfRVJST1I6ICdmcmFnUGFyc2luZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSByZW11eCBhbGxvYyBlcnJvciBldmVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIElkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBieXRlcyA6IG5iIG9mIGJ5dGVzIG9uIHdoaWNoIGFsbG9jYXRpb24gZmFpbGVkICwgcmVhc29uIDogZXJyb3IgdGV4dCB9XG4gIFJFTVVYX0FMTE9DX0VSUk9SOiAncmVtdXhBbGxvY0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZGVjcnlwdCBrZXkgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgS0VZX0xPQURfRVJST1I6ICdrZXlMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEtFWV9MT0FEX1RJTUVPVVQ6ICdrZXlMb2FkVGltZU91dCcsXG4gIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGV4Y2VwdGlvbiBvY2N1cnMgd2hpbGUgYWRkaW5nIGEgc291cmNlQnVmZmVyIHRvIE1lZGlhU291cmNlIC0gZGF0YSA6IHsgIGVyciA6IGV4Y2VwdGlvbiAsIG1pbWVUeXBlIDogbWltZVR5cGUgfVxuICBCVUZGRVJfQUREX0NPREVDX0VSUk9SOiAnYnVmZmVyQWRkQ29kZWNFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZCBlcnJvciAtIGRhdGE6IGFwcGVuZCBlcnJvciBkZXNjcmlwdGlvblxuICBCVUZGRVJfQVBQRU5EX0VSUk9SOiAnYnVmZmVyQXBwZW5kRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmRpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiBhcHBlbmRpbmcgZXJyb3IgZGVzY3JpcHRpb25cbiAgQlVGRkVSX0FQUEVORElOR19FUlJPUjogJ2J1ZmZlckFwcGVuZGluZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgc3RhbGxlZCBlcnJvciBldmVudFxuICBCVUZGRVJfU1RBTExFRF9FUlJPUjogJ2J1ZmZlclN0YWxsZWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGZ1bGwgZXZlbnRcbiAgQlVGRkVSX0ZVTExfRVJST1I6ICdidWZmZXJGdWxsRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzZWVrIG92ZXIgaG9sZSBldmVudFxuICBCVUZGRVJfU0VFS19PVkVSX0hPTEU6ICdidWZmZXJTZWVrT3ZlckhvbGUnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBudWRnZSBvbiBzdGFsbCAocGxheWJhY2sgaXMgc3R1Y2sgYWx0aG91Z2ggY3VycmVudFRpbWUgaXMgaW4gYSBidWZmZXJlZCBhcmVhKVxuICBCVUZGRVJfTlVER0VfT05fU1RBTEw6ICdidWZmZXJOdWRnZU9uU3RhbGwnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBpbnRlcm5hbCBleGNlcHRpb24gaGFwcGVuaW5nIGluc2lkZSBobHMuanMgd2hpbGUgaGFuZGxpbmcgYW4gZXZlbnRcbiAgSU5URVJOQUxfRVhDRVBUSU9OOiAnaW50ZXJuYWxFeGNlcHRpb24nLFxuICAvLyBNYWxmb3JtZWQgV2ViVlRUIGNvbnRlbnRzXG4gIFdFQlZUVF9FWENFUFRJT046ICd3ZWJWVFRFeGNlcHRpb24nXG59O1xuXG59LHt9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBBbGwgb2JqZWN0cyBpbiB0aGUgZXZlbnQgaGFuZGxpbmcgY2hhaW4gc2hvdWxkIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbnZhciBfZXJyb3JzID0gX2RlcmVxXygzMSk7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlcihobHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRIYW5kbGVyKTtcblxuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMub25FdmVudCA9IHRoaXMub25FdmVudC5iaW5kKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGV2ZW50cyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGV2ZW50c1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdGhpcy5oYW5kbGVkRXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMudXNlR2VuZXJpY0hhbmRsZXIgPSB0cnVlO1xuXG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEV2ZW50SGFuZGxlciwgW3tcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lzRXZlbnRIYW5kbGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFdmVudEhhbmRsZXIoKSB7XG4gICAgICByZXR1cm4gX3R5cGVvZih0aGlzLmhhbmRsZWRFdmVudHMpID09PSAnb2JqZWN0JyAmJiB0aGlzLmhhbmRsZWRFdmVudHMubGVuZ3RoICYmIHR5cGVvZiB0aGlzLm9uRXZlbnQgPT09ICdmdW5jdGlvbic7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVnaXN0ZXJMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIGlmICh0aGlzLmlzRXZlbnRIYW5kbGVyKCkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50ID09PSAnaGxzRXZlbnRHZW5lcmljJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JiaWRkZW4gZXZlbnQgbmFtZTogJyArIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5obHMub24oZXZlbnQsIHRoaXMub25FdmVudCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW5yZWdpc3Rlckxpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICBpZiAodGhpcy5pc0V2ZW50SGFuZGxlcigpKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHRoaXMuaGxzLm9mZihldmVudCwgdGhpcy5vbkV2ZW50KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhcmd1bWVudHM6IGV2ZW50IChzdHJpbmcpLCBkYXRhIChhbnkpXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uRXZlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLm9uRXZlbnRHZW5lcmljKGV2ZW50LCBkYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkV2ZW50R2VuZXJpYycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRXZlbnRHZW5lcmljKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgZXZlbnRUb0Z1bmN0aW9uID0gZnVuY3Rpb24gZXZlbnRUb0Z1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIHZhciBmdW5jTmFtZSA9ICdvbicgKyBldmVudC5yZXBsYWNlKCdobHMnLCAnJyk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1tmdW5jTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50ICcgKyBldmVudCArICcgaGFzIG5vIGdlbmVyaWMgaGFuZGxlciBpbiB0aGlzICcgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnIGNsYXNzICh0cmllZCAnICsgZnVuY05hbWUgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2Z1bmNOYW1lXS5iaW5kKHRoaXMsIGRhdGEpO1xuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGV2ZW50VG9GdW5jdGlvbi5jYWxsKHRoaXMsIGV2ZW50LCBkYXRhKS5jYWxsKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2xvZ2dlci5sb2dnZXIuZXJyb3IoJ2ludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIHByb2Nlc3NpbmcgJyArIGV2ZW50ICsgJzonICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sIGZhdGFsOiBmYWxzZSwgZXZlbnQ6IGV2ZW50LCBlcnI6IGVyciB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXZlbnRIYW5kbGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEhhbmRsZXI7XG5cbn0se1wiMzFcIjozMSxcIjMzXCI6MzMsXCI1MFwiOjUwfV0sMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZmlyZWQgYmVmb3JlIE1lZGlhU291cmNlIGlzIGF0dGFjaGluZyB0byBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyBtZWRpYSB9XG4gIE1FRElBX0FUVEFDSElORzogJ2hsc01lZGlhQXR0YWNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBzdWNjZXNmdWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gIE1FRElBX0FUVEFDSEVEOiAnaGxzTWVkaWFBdHRhY2hlZCcsXG4gIC8vIGZpcmVkIGJlZm9yZSBkZXRhY2hpbmcgTWVkaWFTb3VyY2UgZnJvbSBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gIE1FRElBX0RFVEFDSElORzogJ2hsc01lZGlhRGV0YWNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBkZXRhY2hlZCBmcm9tIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IH1cbiAgTUVESUFfREVUQUNIRUQ6ICdobHNNZWRpYURldGFjaGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBidWZmZXIgaXMgZ29pbmcgdG8gYmUgcmVzZXR0ZWRcbiAgQlVGRkVSX1JFU0VUOiAnaGxzQnVmZmVyUmVzZXQnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGtub3cgYWJvdXQgdGhlIGNvZGVjcyB0aGF0IHdlIG5lZWQgYnVmZmVycyBmb3IgdG8gcHVzaCBpbnRvIC0gZGF0YToge3RyYWNrcyA6IHsgY29udGFpbmVyLCBjb2RlYywgbGV2ZWxDb2RlYywgaW5pdFNlZ21lbnQsIG1ldGFkYXRhIH19XG4gIEJVRkZFUl9DT0RFQ1M6ICdobHNCdWZmZXJDb2RlY3MnLFxuICAvLyBmaXJlZCB3aGVuIHNvdXJjZWJ1ZmZlcnMgaGF2ZSBiZWVuIGNyZWF0ZWQgZGF0YTogeyB0cmFja3MgOiB0cmFja3N9XG4gIEJVRkZFUl9DUkVBVEVEOiAnaGxzQnVmZmVyQ3JlYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gd2UgYXBwZW5kIGEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YTogeyBzZWdtZW50OiBzZWdtZW50IG9iamVjdCB9XG4gIEJVRkZFUl9BUFBFTkRJTkc6ICdobHNCdWZmZXJBcHBlbmRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGFyZSBkb25lIHdpdGggYXBwZW5kaW5nIGEgbWVkaWEgc2VnbWVudCB0byB0aGUgYnVmZmVyIGRhdGEgOiB7IHBhcmVudCA6IHNlZ21lbnQgcGFyZW50IHRoYXQgdHJpZ2dlcmVkIEJVRkZFUl9BUFBFTkRJTkcgLCBwZW5kaW5nIDogbmIgb2Ygc2VnbWVudHMgd2FpdGluZyBmb3IgYXBwZW5kaW5nIGZvciB0aGlzIHNlZ21lbnQgcGFyZW50fVxuICBCVUZGRVJfQVBQRU5ERUQ6ICdobHNCdWZmZXJBcHBlbmRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgd2Ugd2FudCB0byBub3RpZnkgdGhlIG1lZGlhIGJ1ZmZlciB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gbW9yZSBkYXRhXG4gIEJVRkZFUl9FT1M6ICdobHNCdWZmZXJFb3MnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBidWZmZXIgc2hvdWxkIGJlIGZsdXNoZWQgLSBkYXRhIHtzdGFydE9mZnNldCwgZW5kT2Zmc2V0fVxuICBCVUZGRVJfRkxVU0hJTkc6ICdobHNCdWZmZXJGbHVzaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGhhcyBiZWVuIGZsdXNoZWRcbiAgQlVGRkVSX0ZMVVNIRUQ6ICdobHNCdWZmZXJGbHVzaGVkJyxcbiAgLy8gZmlyZWQgdG8gc2lnbmFsIHRoYXQgYSBtYW5pZmVzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbWFuaWZlc3RVUkx9XG4gIE1BTklGRVNUX0xPQURJTkc6ICdobHNNYW5pZmVzdExvYWRpbmcnLFxuICAvLyBmaXJlZCBhZnRlciBtYW5pZmVzdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IGxldmVscyA6IFthdmFpbGFibGUgcXVhbGl0eSBsZXZlbHNdICwgYXVkaW9UcmFja3MgOiBbIGF2YWlsYWJsZSBhdWRpbyB0cmFja3NdLCB1cmwgOiBtYW5pZmVzdFVSTCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX19XG4gIE1BTklGRVNUX0xPQURFRDogJ2hsc01hbmlmZXN0TG9hZGVkJyxcbiAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gcGFyc2VkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSAsIGZpcnN0TGV2ZWwgOiBpbmRleCBvZiBmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiBNYW5pZmVzdH1cbiAgTUFOSUZFU1RfUEFSU0VEOiAnaGxzTWFuaWZlc3RQYXJzZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfSAvLyBkZXByZWNhdGVkIGluIGZhdm9yIExFVkVMX1NXSVRDSElOR1xuICBMRVZFTF9TV0lUQ0g6ICdobHNMZXZlbFN3aXRjaCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBzd2l0Y2ggaXMgcmVxdWVzdGVkIC0gZGF0YTogeyBsZXZlbCA6IGlkIG9mIG5ldyBsZXZlbCB9XG4gIExFVkVMX1NXSVRDSElORzogJ2hsc0xldmVsU3dpdGNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyBlZmZlY3RpdmUgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cbiAgTEVWRUxfU1dJVENIRUQ6ICdobHNMZXZlbFN3aXRjaGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHBsYXlsaXN0IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBsZXZlbCBVUkwgIGxldmVsIDogaWQgb2YgbGV2ZWwgYmVpbmcgbG9hZGVkfVxuICBMRVZFTF9MT0FESU5HOiAnaGxzTGV2ZWxMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHBsYXlsaXN0IGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIGxvYWRlZCBsZXZlbCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX0gfVxuICBMRVZFTF9MT0FERUQ6ICdobHNMZXZlbExvYWRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIGRldGFpbHMgaGF2ZSBiZWVuIHVwZGF0ZWQgYmFzZWQgb24gcHJldmlvdXMgZGV0YWlscywgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkLiAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCB9XG4gIExFVkVMX1VQREFURUQ6ICdobHNMZXZlbFVwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBQVFMgaW5mb3JtYXRpb24gaGFzIGJlZW4gdXBkYXRlZCBhZnRlciBwYXJzaW5nIGEgZnJhZ21lbnQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIHVwZGF0ZWQgbGV2ZWwsIGRyaWZ0OiBQVFMgZHJpZnQgb2JzZXJ2ZWQgd2hlbiBwYXJzaW5nIGxhc3QgZnJhZ21lbnQgfVxuICBMRVZFTF9QVFNfVVBEQVRFRDogJ2hsc0xldmVsUHRzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IGF1ZGlvIHRyYWNrIGxpc3RzIGhhcyBiZWVuIHVwZGF0ZWQgZGF0YTogeyBhdWRpb1RyYWNrcyA6IGF1ZGlvVHJhY2tzfVxuICBBVURJT19UUkFDS1NfVVBEQVRFRDogJ2hsc0F1ZGlvVHJhY2tzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgc3dpdGNoIG9jY3VycyAtIGRhdGE6IHsgIGlkIDogYXVkaW8gdHJhY2sgaWR9IC8vIGRlcHJlY2F0ZWQgaW4gZmF2b3IgQVVESU9fVFJBQ0tfU1dJVENISU5HXG4gIEFVRElPX1RSQUNLX1NXSVRDSDogJ2hsc0F1ZGlvVHJhY2tTd2l0Y2gnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaGluZyBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7ICBpZCA6IGF1ZGlvIHRyYWNrIGlkfVxuICBBVURJT19UUkFDS19TV0lUQ0hJTkc6ICdobHNBdWRpb1RyYWNrU3dpdGNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2ggYWN0dWFsbHkgb2NjdXJzIC0gZGF0YTogeyAgaWQgOiBhdWRpbyB0cmFjayBpZH1cbiAgQVVESU9fVFJBQ0tfU1dJVENIRUQ6ICdobHNBdWRpb1RyYWNrU3dpdGNoZWQnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBhdWRpbyB0cmFjayBVUkwgIGlkIDogYXVkaW8gdHJhY2sgaWR9XG4gIEFVRElPX1RSQUNLX0xPQURJTkc6ICdobHNBdWRpb1RyYWNrTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyAgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IGF1ZGlvIHRyYWNrIGlkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfSB9XG4gIEFVRElPX1RSQUNLX0xPQURFRDogJ2hsc0F1ZGlvVHJhY2tMb2FkZWQnLFxuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBzdWJ0aXRsZSB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIGRhdGE6IHsgc3VidGl0bGVUcmFja3MgOiBzdWJ0aXRsZVRyYWNrc31cbiAgU1VCVElUTEVfVFJBQ0tTX1VQREFURUQ6ICdobHNTdWJ0aXRsZVRyYWNrc1VwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGFuIHN1YnRpdGxlIHRyYWNrIHN3aXRjaCBvY2N1cnMgLSBkYXRhOiB7ICBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkfVxuICBTVUJUSVRMRV9UUkFDS19TV0lUQ0g6ICdobHNTdWJ0aXRsZVRyYWNrU3dpdGNoJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBzdWJ0aXRsZSB0cmFjayBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogc3VidGl0bGUgdHJhY2sgVVJMICBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkfVxuICBTVUJUSVRMRV9UUkFDS19MT0FESU5HOiAnaGxzU3VidGl0bGVUcmFja0xvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGFuIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX0gfVxuICBTVUJUSVRMRV9UUkFDS19MT0FERUQ6ICdobHNTdWJ0aXRsZVRyYWNrTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIGZyYWdtZW50IGhhcyBiZWVuIHByb2Nlc3NlZCAtIGRhdGE6IHsgc3VjY2VzcyA6IGJvb2xlYW4sIGZyYWcgOiB0aGUgcHJvY2Vzc2VkIGZyYWd9XG4gIFNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VEOiAnaGxzU3VidGl0bGVGcmFnUHJvY2Vzc2VkJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgZmlyc3QgdGltZXN0YW1wIGlzIGZvdW5kLiAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBpbml0UFRTOiBpbml0UFRTICwgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgSU5JVF9QVFNfRk9VTkQ6ICdobHNJbml0UHRzRm91bmQnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEZSQUdfTE9BRElORzogJ2hsc0ZyYWdMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgcHJvZ3Jlc3NpbmcgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHsgdHJlcXVlc3QsIHRmaXJzdCwgbG9hZGVkfX1cbiAgRlJBR19MT0FEX1BST0dSRVNTOiAnaGxzRnJhZ0xvYWRQcm9ncmVzcycsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgYWJvcnRpbmcgZm9yIGVtZXJnZW5jeSBzd2l0Y2ggZG93biAtIGRhdGE6IHtmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBGUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQ6ICdobHNGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBmcmFnbWVudCBwYXlsb2FkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIGxlbmd0aH19XG4gIEZSQUdfTE9BREVEOiAnaGxzRnJhZ0xvYWRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBoYXMgZmluaXNoZWQgZGVjcnlwdGluZyAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHN0YXRzIDoge3RzdGFydCx0ZGVjcnlwdH0gfVxuICBGUkFHX0RFQ1JZUFRFRDogJ2hsc0ZyYWdEZWNyeXB0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIEluaXQgU2VnbWVudCBoYXMgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIG1vb3YgOiBtb292IE1QNCBib3gsIGNvZGVjcyA6IGNvZGVjcyBmb3VuZCB3aGlsZSBwYXJzaW5nIGZyYWdtZW50fVxuICBGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UOiAnaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudCcsXG4gIC8vIGZpcmVkIHdoZW4gcGFyc2luZyBzZWkgdGV4dCBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHNhbXBsZXMgOiBbIHNlaSBzYW1wbGVzIHBlcyBdIH1cbiAgRlJBR19QQVJTSU5HX1VTRVJEQVRBOiAnaGxzRnJhZ1BhcnNpbmdVc2VyZGF0YScsXG4gIC8vIGZpcmVkIHdoZW4gcGFyc2luZyBpZDMgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgc2FtcGxlcyA6IFsgaWQzIHNhbXBsZXMgcGVzIF0gfVxuICBGUkFHX1BBUlNJTkdfTUVUQURBVEE6ICdobHNGcmFnUGFyc2luZ01ldGFkYXRhJyxcbiAgLy8gZmlyZWQgd2hlbiBkYXRhIGhhdmUgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIGRhdGExIDogbW9vZiBNUDQgYm94IG9yIFRTIGZyYWdtZW50cywgZGF0YTIgOiBtZGF0IE1QNCBib3ggb3IgbnVsbH1cbiAgRlJBR19QQVJTSU5HX0RBVEE6ICdobHNGcmFnUGFyc2luZ0RhdGEnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHBhcnNpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsZnJhZzogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRlJBR19QQVJTRUQ6ICdobHNGcmFnUGFyc2VkJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCByZW11eGVkIE1QNCBib3hlcyBoYXZlIGFsbCBiZWVuIGFwcGVuZGVkIGludG8gU291cmNlQnVmZmVyIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCB0cGFyc2VkLCB0YnVmZmVyZWQsIGxlbmd0aH0gfVxuICBGUkFHX0JVRkZFUkVEOiAnaGxzRnJhZ0J1ZmZlcmVkJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCBtYXRjaGluZyB3aXRoIGN1cnJlbnQgbWVkaWEgcG9zaXRpb24gaXMgY2hhbmdpbmcgLSBkYXRhIDogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBGUkFHX0NIQU5HRUQ6ICdobHNGcmFnQ2hhbmdlZCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgRlBTIGRyb3AgZXZlbnQgLSBkYXRhOiB7Y3VyZW50RHJvcHBlZCwgY3VycmVudERlY29kZWQsIHRvdGFsRHJvcHBlZEZyYW1lc31cbiAgRlBTX0RST1A6ICdobHNGcHNEcm9wJyxcbiAgLy90cmlnZ2VyZWQgd2hlbiBGUFMgZHJvcCB0cmlnZ2VycyBhdXRvIGxldmVsIGNhcHBpbmcgLSBkYXRhOiB7bGV2ZWwsIGRyb3BwZWRsZXZlbH1cbiAgRlBTX0RST1BfTEVWRUxfQ0FQUElORzogJ2hsc0Zwc0Ryb3BMZXZlbENhcHBpbmcnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBlcnJvciBldmVudCAtIGRhdGE6IHsgdHlwZSA6IGVycm9yIHR5cGUsIGRldGFpbHMgOiBlcnJvciBkZXRhaWxzLCBmYXRhbCA6IGlmIHRydWUsIGhscy5qcyBjYW5ub3Qvd2lsbCBub3QgdHJ5IHRvIHJlY292ZXIsIGlmIGZhbHNlLCBobHMuanMgd2lsbCB0cnkgdG8gcmVjb3ZlcixvdGhlciBlcnJvciBzcGVjaWZpYyBkYXRhfVxuICBFUlJPUjogJ2hsc0Vycm9yJyxcbiAgLy8gZmlyZWQgd2hlbiBobHMuanMgaW5zdGFuY2Ugc3RhcnRzIGRlc3Ryb3lpbmcuIERpZmZlcmVudCBmcm9tIE1FRElBX0RFVEFDSEVEIGFzIG9uZSBjb3VsZCB3YW50IHRvIGRldGFjaCBhbmQgcmVhdHRhY2ggYSBtZWRpYSB0byB0aGUgaW5zdGFuY2Ugb2YgaGxzLmpzIHRvIGhhbmRsZSBtaWQtcm9sbHMgZm9yIGV4YW1wbGVcbiAgREVTVFJPWUlORzogJ2hsc0Rlc3Ryb3lpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgZGVjcnlwdCBrZXkgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEtFWV9MT0FESU5HOiAnaGxzS2V5TG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGtleSBwYXlsb2FkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIGxlbmd0aH19XG4gIEtFWV9MT0FERUQ6ICdobHNLZXlMb2FkZWQnLFxuICAvLyBmaXJlZCB1cG9uIHN0cmVhbSBjb250cm9sbGVyIHN0YXRlIHRyYW5zaXRpb25zIC0gZGF0YToge3ByZXZpb3VzU3RhdGUsIG5leHRTdGF0ZX1cbiAgU1RSRUFNX1NUQVRFX1RSQU5TSVRJT046ICdobHNTdHJlYW1TdGF0ZVRyYW5zaXRpb24nXG59O1xuXG59LHt9XSwzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogIEFBQyBoZWxwZXJcbiAqL1xuXG52YXIgQUFDID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBQUMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFBQyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQUFDLCBudWxsLCBbe1xuICAgIGtleTogJ2dldFNpbGVudEZyYW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2lsZW50RnJhbWUoY29kZWMsIGNoYW5uZWxDb3VudCkge1xuICAgICAgc3dpdGNoIChjb2RlYykge1xuICAgICAgICBjYXNlICdtcDRhLjQwLjInOlxuICAgICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMywgMHg4MF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MjEsIDB4MDAsIDB4NDksIDB4OTAsIDB4MDIsIDB4MTksIDB4MDAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDhlXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MCwgMHgyYywgMHg4MCwgMHgwOCwgMHgwMiwgMHgzOF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MzhdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLCAweDAwLCAweDIwLCAweDA4LCAweGUwXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBoYW5kbGUgSEUtQUFDIGJlbG93IChtcDRhLjQwLjUgLyBtcDRhLjQwLjI5KVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg0ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDFjLCAweDYsIDB4ZjEsIDB4YzEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQUFDO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBBQUM7XG5cbn0se31dLDM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEJ1ZmZlciBIZWxwZXIgY2xhc3MsIHByb3ZpZGluZyBtZXRob2RzIGRlYWxpbmcgYnVmZmVyIGxlbmd0aCByZXRyaWV2YWxcbiovXG5cbnZhciBCdWZmZXJIZWxwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckhlbHBlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVySGVscGVyKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdWZmZXJIZWxwZXIsIG51bGwsIFt7XG4gICAga2V5OiBcImlzQnVmZmVyZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNCdWZmZXJlZChtZWRpYSwgcG9zaXRpb24pIHtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICB2YXIgYnVmZmVyZWQgPSBtZWRpYS5idWZmZXJlZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBidWZmZXJlZC5zdGFydChpKSAmJiBwb3NpdGlvbiA8PSBidWZmZXJlZC5lbmQoaSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWZmZXJJbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1ZmZlckluZm8obWVkaWEsIHBvcywgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgdmFyIHZidWZmZXJlZCA9IG1lZGlhLmJ1ZmZlcmVkLFxuICAgICAgICAgICAgYnVmZmVyZWQgPSBbXSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWZmZXJlZC5wdXNoKHsgc3RhcnQ6IHZidWZmZXJlZC5zdGFydChpKSwgZW5kOiB2YnVmZmVyZWQuZW5kKGkpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgbGVuOiAwLCBzdGFydDogcG9zLCBlbmQ6IHBvcywgbmV4dFN0YXJ0OiB1bmRlZmluZWQgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVmZmVyZWRJbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgIHZhciBidWZmZXJlZDIgPSBbXSxcblxuICAgICAgLy8gYnVmZmVyU3RhcnQgYW5kIGJ1ZmZlckVuZCBhcmUgYnVmZmVyIGJvdW5kYXJpZXMgYXJvdW5kIGN1cnJlbnQgdmlkZW8gcG9zaXRpb25cbiAgICAgIGJ1ZmZlckxlbixcbiAgICAgICAgICBidWZmZXJTdGFydCxcbiAgICAgICAgICBidWZmZXJFbmQsXG4gICAgICAgICAgYnVmZmVyU3RhcnROZXh0LFxuICAgICAgICAgIGk7XG4gICAgICAvLyBzb3J0IG9uIGJ1ZmZlci5zdGFydC9zbWFsbGVyIGVuZCAoSUUgZG9lcyBub3QgYWx3YXlzIHJldHVybiBzb3J0ZWQgYnVmZmVyZWQgcmFuZ2UpXG4gICAgICBidWZmZXJlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBkaWZmID0gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGIuZW5kIC0gYS5lbmQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgc29tZSBzbWFsbCBob2xlcyBiZXR3ZWVuIGJ1ZmZlciB0aW1lIHJhbmdlXG4gICAgICAvLyBjb25zaWRlciB0aGF0IGhvbGVzIHNtYWxsZXIgdGhhbiBtYXhIb2xlRHVyYXRpb24gYXJlIGlycmVsZXZhbnQgYW5kIGJ1aWxkIGFub3RoZXJcbiAgICAgIC8vIGJ1ZmZlciB0aW1lIHJhbmdlIHJlcHJlc2VudGF0aW9ucyB0aGF0IGRpc2NhcmRzIHRob3NlIGhvbGVzXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZjJsZW4gPSBidWZmZXJlZDIubGVuZ3RoO1xuICAgICAgICBpZiAoYnVmMmxlbikge1xuICAgICAgICAgIHZhciBidWYyZW5kID0gYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQ7XG4gICAgICAgICAgLy8gaWYgc21hbGwgaG9sZSAodmFsdWUgYmV0d2VlbiAwIG9yIG1heEhvbGVEdXJhdGlvbiApIG9yIG92ZXJsYXBwaW5nIChuZWdhdGl2ZSlcbiAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uc3RhcnQgLSBidWYyZW5kIDwgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBtZXJnZSBvdmVybGFwcGluZyB0aW1lIHJhbmdlc1xuICAgICAgICAgICAgLy8gdXBkYXRlIGxhc3RSYW5nZS5lbmQgb25seSBpZiBzbWFsbGVyIHRoYW4gaXRlbS5lbmRcbiAgICAgICAgICAgIC8vIGUuZy4gIFsgMSwgMTVdIHdpdGggIFsgMiw4XSA9PiBbIDEsMTVdIChubyBuZWVkIHRvIG1vZGlmeSBsYXN0UmFuZ2UuZW5kKVxuICAgICAgICAgICAgLy8gd2hlcmVhcyBbIDEsIDhdIHdpdGggIFsgMiwxNV0gPT4gWyAxLDE1XSAoIGxhc3RSYW5nZSBzaG91bGQgc3dpdGNoIGZyb20gWzEsOF0gdG8gWzEsMTVdKVxuICAgICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLmVuZCA+IGJ1ZjJlbmQpIHtcbiAgICAgICAgICAgICAgYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQgPSBidWZmZXJlZFtpXS5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJpZyBob2xlXG4gICAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZpcnN0IHZhbHVlXG4gICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwLCBidWZmZXJMZW4gPSAwLCBidWZmZXJTdGFydCA9IGJ1ZmZlckVuZCA9IHBvczsgaSA8IGJ1ZmZlcmVkMi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3RhcnQgPSBidWZmZXJlZDJbaV0uc3RhcnQsXG4gICAgICAgICAgICBlbmQgPSBidWZmZXJlZDJbaV0uZW5kO1xuICAgICAgICAvL2xvZ2dlci5sb2coJ2J1ZiBzdGFydC9lbmQ6JyArIGJ1ZmZlcmVkLnN0YXJ0KGkpICsgJy8nICsgYnVmZmVyZWQuZW5kKGkpKTtcbiAgICAgICAgaWYgKHBvcyArIG1heEhvbGVEdXJhdGlvbiA+PSBzdGFydCAmJiBwb3MgPCBlbmQpIHtcbiAgICAgICAgICAvLyBwbGF5IHBvc2l0aW9uIGlzIGluc2lkZSB0aGlzIGJ1ZmZlciBUaW1lUmFuZ2UsIHJldHJpZXZlIGVuZCBvZiBidWZmZXIgcG9zaXRpb24gYW5kIGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgICBidWZmZXJTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGJ1ZmZlckVuZCA9IGVuZDtcbiAgICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJFbmQgLSBwb3M7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zICsgbWF4SG9sZUR1cmF0aW9uIDwgc3RhcnQpIHtcbiAgICAgICAgICBidWZmZXJTdGFydE5leHQgPSBzdGFydDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbGVuOiBidWZmZXJMZW4sIHN0YXJ0OiBidWZmZXJTdGFydCwgZW5kOiBidWZmZXJFbmQsIG5leHRTdGFydDogYnVmZmVyU3RhcnROZXh0IH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJ1ZmZlckhlbHBlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQnVmZmVySGVscGVyO1xuXG59LHt9XSwzNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIExldmVsIEhlbHBlciBjbGFzcywgcHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyB3aXRoIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGRyaWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIExldmVsSGVscGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMZXZlbEhlbHBlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGV2ZWxIZWxwZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExldmVsSGVscGVyLCBudWxsLCBbe1xuICAgIGtleTogJ21lcmdlRGV0YWlscycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlRGV0YWlscyhvbGREZXRhaWxzLCBuZXdEZXRhaWxzKSB7XG4gICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChvbGREZXRhaWxzLnN0YXJ0U04sIG5ld0RldGFpbHMuc3RhcnRTTikgLSBuZXdEZXRhaWxzLnN0YXJ0U04sXG4gICAgICAgICAgZW5kID0gTWF0aC5taW4ob2xkRGV0YWlscy5lbmRTTiwgbmV3RGV0YWlscy5lbmRTTikgLSBuZXdEZXRhaWxzLnN0YXJ0U04sXG4gICAgICAgICAgZGVsdGEgPSBuZXdEZXRhaWxzLnN0YXJ0U04gLSBvbGREZXRhaWxzLnN0YXJ0U04sXG4gICAgICAgICAgb2xkZnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgICAgbmV3ZnJhZ21lbnRzID0gbmV3RGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgICAgY2NPZmZzZXQgPSAwLFxuICAgICAgICAgIFBUU0ZyYWc7XG5cbiAgICAgIC8vIGNoZWNrIGlmIG9sZC9uZXcgcGxheWxpc3RzIGhhdmUgZnJhZ21lbnRzIGluIGNvbW1vblxuICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gbG9vcCB0aHJvdWdoIG92ZXJsYXBwaW5nIFNOIGFuZCB1cGRhdGUgc3RhcnRQVFMgLCBjYywgYW5kIGR1cmF0aW9uIGlmIGFueSBmb3VuZFxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgIHZhciBvbGRGcmFnID0gb2xkZnJhZ21lbnRzW2RlbHRhICsgaV0sXG4gICAgICAgICAgICBuZXdGcmFnID0gbmV3ZnJhZ21lbnRzW2ldO1xuICAgICAgICBpZiAobmV3RnJhZyAmJiBvbGRGcmFnKSB7XG4gICAgICAgICAgY2NPZmZzZXQgPSBvbGRGcmFnLmNjIC0gbmV3RnJhZy5jYztcbiAgICAgICAgICBpZiAoIWlzTmFOKG9sZEZyYWcuc3RhcnRQVFMpKSB7XG4gICAgICAgICAgICBuZXdGcmFnLnN0YXJ0ID0gbmV3RnJhZy5zdGFydFBUUyA9IG9sZEZyYWcuc3RhcnRQVFM7XG4gICAgICAgICAgICBuZXdGcmFnLmVuZFBUUyA9IG9sZEZyYWcuZW5kUFRTO1xuICAgICAgICAgICAgbmV3RnJhZy5kdXJhdGlvbiA9IG9sZEZyYWcuZHVyYXRpb247XG4gICAgICAgICAgICBQVFNGcmFnID0gbmV3RnJhZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNjT2Zmc2V0KSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnZGlzY29udGludWl0eSBzbGlkaW5nIGZyb20gcGxheWxpc3QsIHRha2UgZHJpZnQgaW50byBhY2NvdW50Jyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXdmcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBuZXdmcmFnbWVudHNbaV0uY2MgKz0gY2NPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgYXQgbGVhc3Qgb25lIGZyYWdtZW50IGNvbnRhaW5zIFBUUyBpbmZvLCByZWNvbXB1dGUgUFRTIGluZm9ybWF0aW9uIGZvciBhbGwgZnJhZ21lbnRzXG4gICAgICBpZiAoUFRTRnJhZykge1xuICAgICAgICBMZXZlbEhlbHBlci51cGRhdGVGcmFnUFRTRFRTKG5ld0RldGFpbHMsIFBUU0ZyYWcuc24sIFBUU0ZyYWcuc3RhcnRQVFMsIFBUU0ZyYWcuZW5kUFRTLCBQVFNGcmFnLnN0YXJ0RFRTLCBQVFNGcmFnLmVuZERUUyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbnN1cmUgdGhhdCBkZWx0YSBpcyB3aXRoaW4gb2xkZnJhZ21lbnRzIHJhbmdlXG4gICAgICAgIC8vIGFsc28gYWRqdXN0IHNsaWRpbmcgaW4gY2FzZSBkZWx0YSBpcyAwICh3ZSBjb3VsZCBoYXZlIG9sZD1bNTAtNjBdIGFuZCBuZXc9b2xkPVs1MC02MV0pXG4gICAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBhbHNvIG5lZWQgdG8gYWRqdXN0IHN0YXJ0IG9mZnNldCBvZiBhbGwgZnJhZ21lbnRzXG4gICAgICAgIGlmIChkZWx0YSA+PSAwICYmIGRlbHRhIDwgb2xkZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGFkanVzdCBzdGFydCBieSBzbGlkaW5nIG9mZnNldFxuICAgICAgICAgIHZhciBzbGlkaW5nID0gb2xkZnJhZ21lbnRzW2RlbHRhXS5zdGFydDtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3ZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdmcmFnbWVudHNbaV0uc3RhcnQgKz0gc2xpZGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGFyZSBoZXJlLCBpdCBtZWFucyB3ZSBoYXZlIGZyYWdtZW50cyBvdmVybGFwcGluZyBiZXR3ZWVuXG4gICAgICAvLyBvbGQgYW5kIG5ldyBsZXZlbC4gcmVsaWFibGUgUFRTIGluZm8gaXMgdGh1cyByZWx5aW5nIG9uIG9sZCBsZXZlbFxuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IG9sZERldGFpbHMuUFRTS25vd247XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRnJhZ1BUU0RUUycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUZyYWdQVFNEVFMoZGV0YWlscywgc24sIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpIHtcbiAgICAgIHZhciBmcmFnSWR4LCBmcmFnbWVudHMsIGZyYWcsIGk7XG4gICAgICAvLyBleGl0IGlmIHNuIG91dCBvZiByYW5nZVxuICAgICAgaWYgKCFkZXRhaWxzIHx8IHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGZyYWdJZHggPSBzbiAtIGRldGFpbHMuc3RhcnRTTjtcbiAgICAgIGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgICAgZnJhZyA9IGZyYWdtZW50c1tmcmFnSWR4XTtcbiAgICAgIGlmICghaXNOYU4oZnJhZy5zdGFydFBUUykpIHtcbiAgICAgICAgLy8gZGVsdGEgUFRTIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvXG4gICAgICAgIHZhciBkZWx0YVBUUyA9IE1hdGguYWJzKGZyYWcuc3RhcnRQVFMgLSBzdGFydFBUUyk7XG4gICAgICAgIGlmIChpc05hTihmcmFnLmRlbHRhUFRTKSkge1xuICAgICAgICAgIGZyYWcuZGVsdGFQVFMgPSBkZWx0YVBUUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnLmRlbHRhUFRTID0gTWF0aC5tYXgoZGVsdGFQVFMsIGZyYWcuZGVsdGFQVFMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0UFRTID0gTWF0aC5taW4oc3RhcnRQVFMsIGZyYWcuc3RhcnRQVFMpO1xuICAgICAgICBlbmRQVFMgPSBNYXRoLm1heChlbmRQVFMsIGZyYWcuZW5kUFRTKTtcbiAgICAgICAgc3RhcnREVFMgPSBNYXRoLm1pbihzdGFydERUUywgZnJhZy5zdGFydERUUyk7XG4gICAgICAgIGVuZERUUyA9IE1hdGgubWF4KGVuZERUUywgZnJhZy5lbmREVFMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHJpZnQgPSBzdGFydFBUUyAtIGZyYWcuc3RhcnQ7XG5cbiAgICAgIGZyYWcuc3RhcnQgPSBmcmFnLnN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gICAgICBmcmFnLmVuZFBUUyA9IGVuZFBUUztcbiAgICAgIGZyYWcuc3RhcnREVFMgPSBzdGFydERUUztcbiAgICAgIGZyYWcuZW5kRFRTID0gZW5kRFRTO1xuICAgICAgZnJhZy5kdXJhdGlvbiA9IGVuZFBUUyAtIHN0YXJ0UFRTO1xuICAgICAgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bS0xIHRvIGZyYWcgMFxuICAgICAgZm9yIChpID0gZnJhZ0lkeDsgaSA+IDA7IGktLSkge1xuICAgICAgICBMZXZlbEhlbHBlci51cGRhdGVQVFMoZnJhZ21lbnRzLCBpLCBpIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0gdG8gbGFzdCBmcmFnXG4gICAgICBmb3IgKGkgPSBmcmFnSWR4OyBpIDwgZnJhZ21lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBMZXZlbEhlbHBlci51cGRhdGVQVFMoZnJhZ21lbnRzLCBpLCBpICsgMSk7XG4gICAgICB9XG4gICAgICBkZXRhaWxzLlBUU0tub3duID0gdHJ1ZTtcbiAgICAgIC8vbG9nZ2VyLmxvZyhgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnIHN0YXJ0L2VuZDoke3N0YXJ0UFRTLnRvRml4ZWQoMyl9LyR7ZW5kUFRTLnRvRml4ZWQoMyl9YCk7XG5cbiAgICAgIHJldHVybiBkcmlmdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVQVFMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQVFMoZnJhZ21lbnRzLCBmcm9tSWR4LCB0b0lkeCkge1xuICAgICAgdmFyIGZyYWdGcm9tID0gZnJhZ21lbnRzW2Zyb21JZHhdLFxuICAgICAgICAgIGZyYWdUbyA9IGZyYWdtZW50c1t0b0lkeF0sXG4gICAgICAgICAgZnJhZ1RvUFRTID0gZnJhZ1RvLnN0YXJ0UFRTO1xuICAgICAgLy8gaWYgd2Uga25vdyBzdGFydFBUU1t0b0lkeF1cbiAgICAgIGlmICghaXNOYU4oZnJhZ1RvUFRTKSkge1xuICAgICAgICAvLyB1cGRhdGUgZnJhZ21lbnQgZHVyYXRpb24uXG4gICAgICAgIC8vIGl0IGhlbHBzIHRvIGZpeCBkcmlmdHMgYmV0d2VlbiBwbGF5bGlzdCByZXBvcnRlZCBkdXJhdGlvbiBhbmQgZnJhZ21lbnQgcmVhbCBkdXJhdGlvblxuICAgICAgICBpZiAodG9JZHggPiBmcm9tSWR4KSB7XG4gICAgICAgICAgZnJhZ0Zyb20uZHVyYXRpb24gPSBmcmFnVG9QVFMgLSBmcmFnRnJvbS5zdGFydDtcbiAgICAgICAgICBpZiAoZnJhZ0Zyb20uZHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCduZWdhdGl2ZSBkdXJhdGlvbiBjb21wdXRlZCBmb3IgZnJhZyAnICsgZnJhZ0Zyb20uc24gKyAnLGxldmVsICcgKyBmcmFnRnJvbS5sZXZlbCArICcsIHRoZXJlIHNob3VsZCBiZSBzb21lIGR1cmF0aW9uIGRyaWZ0IGJldHdlZW4gcGxheWxpc3QgYW5kIGZyYWdtZW50IScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnVG8uZHVyYXRpb24gPSBmcmFnRnJvbS5zdGFydCAtIGZyYWdUb1BUUztcbiAgICAgICAgICBpZiAoZnJhZ1RvLmR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignbmVnYXRpdmUgZHVyYXRpb24gY29tcHV0ZWQgZm9yIGZyYWcgJyArIGZyYWdUby5zbiArICcsbGV2ZWwgJyArIGZyYWdUby5sZXZlbCArICcsIHRoZXJlIHNob3VsZCBiZSBzb21lIGR1cmF0aW9uIGRyaWZ0IGJldHdlZW4gcGxheWxpc3QgYW5kIGZyYWdtZW50IScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICAgICAgICBpZiAodG9JZHggPiBmcm9tSWR4KSB7XG4gICAgICAgICAgZnJhZ1RvLnN0YXJ0ID0gZnJhZ0Zyb20uc3RhcnQgKyBmcmFnRnJvbS5kdXJhdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCAtIGZyYWdUby5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMZXZlbEhlbHBlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTGV2ZWxIZWxwZXI7XG5cbn0se1wiNTBcIjo1MH1dLDM3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogSExTIGludGVyZmFjZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXZlbnRzID0gX2RlcmVxXygzMyk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfZXJyb3JzID0gX2RlcmVxXygzMSk7XG5cbnZhciBfcGxheWxpc3RMb2FkZXIgPSBfZGVyZXFfKDQxKTtcblxudmFyIF9wbGF5bGlzdExvYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF5bGlzdExvYWRlcik7XG5cbnZhciBfZnJhZ21lbnRMb2FkZXIgPSBfZGVyZXFfKDM5KTtcblxudmFyIF9mcmFnbWVudExvYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mcmFnbWVudExvYWRlcik7XG5cbnZhciBfa2V5TG9hZGVyID0gX2RlcmVxXyg0MCk7XG5cbnZhciBfa2V5TG9hZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleUxvYWRlcik7XG5cbnZhciBfc3RyZWFtQ29udHJvbGxlciA9IF9kZXJlcV8oMTMpO1xuXG52YXIgX3N0cmVhbUNvbnRyb2xsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyZWFtQ29udHJvbGxlcik7XG5cbnZhciBfbGV2ZWxDb250cm9sbGVyID0gX2RlcmVxXygxMik7XG5cbnZhciBfbGV2ZWxDb250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xldmVsQ29udHJvbGxlcik7XG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbnZhciBfZXZlbnRzMyA9IF9kZXJlcV8oMSk7XG5cbnZhciBfZXZlbnRzNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50czMpO1xuXG52YXIgX2NvbmZpZyA9IF9kZXJlcV8oNCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBIbHMgPSBmdW5jdGlvbiAoKSB7XG4gIF9jcmVhdGVDbGFzcyhIbHMsIG51bGwsIFt7XG4gICAga2V5OiAnaXNTdXBwb3J0ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgICAgIHdpbmRvdy5NZWRpYVNvdXJjZSA9IHdpbmRvdy5NZWRpYVNvdXJjZSB8fCB3aW5kb3cuV2ViS2l0TWVkaWFTb3VyY2U7XG4gICAgICByZXR1cm4gd2luZG93Lk1lZGlhU291cmNlICYmIHR5cGVvZiB3aW5kb3cuTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkID09PSAnZnVuY3Rpb24nICYmIHdpbmRvdy5NZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUUsbXA0YS40MC4yXCInKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd2ZXJzaW9uJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIC8vIHJlcGxhY2VkIHdpdGggYnJvd3NlcmlmeS12ZXJzaW9uaWZ5IHRyYW5zZm9ybVxuICAgICAgcmV0dXJuICcwLjcuMic7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnRXZlbnRzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZXZlbnRzMi5kZWZhdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ0Vycm9yVHlwZXMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lcnJvcnMuRXJyb3JUeXBlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdFcnJvckRldGFpbHMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lcnJvcnMuRXJyb3JEZXRhaWxzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ0RlZmF1bHRDb25maWcnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFIbHMuZGVmYXVsdENvbmZpZykge1xuICAgICAgICByZXR1cm4gX2NvbmZpZy5obHNEZWZhdWx0Q29uZmlnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEhscy5kZWZhdWx0Q29uZmlnO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoZGVmYXVsdENvbmZpZykge1xuICAgICAgSGxzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIEhscygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGxzKTtcblxuICAgIHZhciBkZWZhdWx0Q29uZmlnID0gSGxzLkRlZmF1bHRDb25maWc7XG5cbiAgICBpZiAoKGNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHwgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCkgJiYgKGNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IGRvblxcJ3QgbWl4IHVwIGxpdmVTeW5jRHVyYXRpb25Db3VudC9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgYW5kIGxpdmVTeW5jRHVyYXRpb24vbGl2ZU1heExhdGVuY3lEdXJhdGlvbicpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHByb3AgaW4gZGVmYXVsdENvbmZpZykge1xuICAgICAgaWYgKHByb3AgaW4gY29uZmlnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uZmlnW3Byb3BdID0gZGVmYXVsdENvbmZpZ1twcm9wXTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgPD0gY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50XCIgbXVzdCBiZSBndCBcImxpdmVTeW5jRHVyYXRpb25Db3VudFwiJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDw9IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uID09PSB1bmRlZmluZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBndCBcImxpdmVTeW5jRHVyYXRpb25cIicpO1xuICAgIH1cblxuICAgICgwLCBfbG9nZ2VyLmVuYWJsZUxvZ3MpKGNvbmZpZy5kZWJ1Zyk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgIC8vIG9ic2VydmVyIHNldHVwXG4gICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlciA9IG5ldyBfZXZlbnRzNC5kZWZhdWx0KCk7XG4gICAgb2JzZXJ2ZXIudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIoZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkYXRhID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBkYXRhW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgb2JzZXJ2ZXIuZW1pdC5hcHBseShvYnNlcnZlciwgW2V2ZW50LCBldmVudF0uY29uY2F0KGRhdGEpKTtcbiAgICB9O1xuXG4gICAgb2JzZXJ2ZXIub2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGRhdGEgPSBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGRhdGFbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyLmFwcGx5KG9ic2VydmVyLCBbZXZlbnRdLmNvbmNhdChkYXRhKSk7XG4gICAgfTtcbiAgICB0aGlzLm9uID0gb2JzZXJ2ZXIub24uYmluZChvYnNlcnZlcik7XG4gICAgdGhpcy5vZmYgPSBvYnNlcnZlci5vZmYuYmluZChvYnNlcnZlcik7XG4gICAgdGhpcy50cmlnZ2VyID0gb2JzZXJ2ZXIudHJpZ2dlci5iaW5kKG9ic2VydmVyKTtcblxuICAgIC8vIGNvcmUgY29udHJvbGxlcnMgYW5kIG5ldHdvcmsgbG9hZGVyc1xuICAgIHZhciBhYnJDb250cm9sbGVyID0gdGhpcy5hYnJDb250cm9sbGVyID0gbmV3IGNvbmZpZy5hYnJDb250cm9sbGVyKHRoaXMpO1xuICAgIHZhciBidWZmZXJDb250cm9sbGVyID0gbmV3IGNvbmZpZy5idWZmZXJDb250cm9sbGVyKHRoaXMpO1xuICAgIHZhciBjYXBMZXZlbENvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmNhcExldmVsQ29udHJvbGxlcih0aGlzKTtcbiAgICB2YXIgZnBzQ29udHJvbGxlciA9IG5ldyBjb25maWcuZnBzQ29udHJvbGxlcih0aGlzKTtcbiAgICB2YXIgcGxheUxpc3RMb2FkZXIgPSBuZXcgX3BsYXlsaXN0TG9hZGVyMi5kZWZhdWx0KHRoaXMpO1xuICAgIHZhciBmcmFnbWVudExvYWRlciA9IG5ldyBfZnJhZ21lbnRMb2FkZXIyLmRlZmF1bHQodGhpcyk7XG4gICAgdmFyIGtleUxvYWRlciA9IG5ldyBfa2V5TG9hZGVyMi5kZWZhdWx0KHRoaXMpO1xuXG4gICAgLy8gbmV0d29yayBjb250cm9sbGVyc1xuICAgIHZhciBsZXZlbENvbnRyb2xsZXIgPSB0aGlzLmxldmVsQ29udHJvbGxlciA9IG5ldyBfbGV2ZWxDb250cm9sbGVyMi5kZWZhdWx0KHRoaXMpO1xuICAgIHZhciBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5zdHJlYW1Db250cm9sbGVyID0gbmV3IF9zdHJlYW1Db250cm9sbGVyMi5kZWZhdWx0KHRoaXMpO1xuICAgIHZhciBuZXR3b3JrQ29udHJvbGxlcnMgPSBbbGV2ZWxDb250cm9sbGVyLCBzdHJlYW1Db250cm9sbGVyXTtcblxuICAgIC8vIG9wdGlvbmFsIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyXG4gICAgdmFyIENvbnRyb2xsZXIgPSBjb25maWcuYXVkaW9TdHJlYW1Db250cm9sbGVyO1xuICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChuZXcgQ29udHJvbGxlcih0aGlzKSk7XG4gICAgfVxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzID0gbmV0d29ya0NvbnRyb2xsZXJzO1xuXG4gICAgdmFyIGNvcmVDb21wb25lbnRzID0gW3BsYXlMaXN0TG9hZGVyLCBmcmFnbWVudExvYWRlciwga2V5TG9hZGVyLCBhYnJDb250cm9sbGVyLCBidWZmZXJDb250cm9sbGVyLCBjYXBMZXZlbENvbnRyb2xsZXIsIGZwc0NvbnRyb2xsZXJdO1xuXG4gICAgLy8gb3B0aW9uYWwgYXVkaW8gdHJhY2sgYW5kIHN1YnRpdGxlIGNvbnRyb2xsZXJcbiAgICBDb250cm9sbGVyID0gY29uZmlnLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICB2YXIgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcih0aGlzKTtcbiAgICAgIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSBhdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgIGNvcmVDb21wb25lbnRzLnB1c2goYXVkaW9UcmFja0NvbnRyb2xsZXIpO1xuICAgIH1cblxuICAgIENvbnRyb2xsZXIgPSBjb25maWcuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKHRoaXMpO1xuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgY29yZUNvbXBvbmVudHMucHVzaChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcik7XG4gICAgfVxuXG4gICAgLy8gb3B0aW9uYWwgc3VidGl0bGUgY29udHJvbGxlclxuICAgIFtjb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBjb25maWcudGltZWxpbmVDb250cm9sbGVyXS5mb3JFYWNoKGZ1bmN0aW9uIChDb250cm9sbGVyKSB7XG4gICAgICBpZiAoQ29udHJvbGxlcikge1xuICAgICAgICBjb3JlQ29tcG9uZW50cy5wdXNoKG5ldyBDb250cm9sbGVyKF90aGlzKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IGNvcmVDb21wb25lbnRzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEhscywgW3tcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnZGVzdHJveScpO1xuICAgICAgdGhpcy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuREVTVFJPWUlORyk7XG4gICAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgICB0aGlzLmNvcmVDb21wb25lbnRzLmNvbmNhdCh0aGlzLm5ldHdvcmtDb250cm9sbGVycykuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIGNvbXBvbmVudC5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICAgIHRoaXMub2JzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXR0YWNoTWVkaWEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hNZWRpYShtZWRpYSkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdhdHRhY2hNZWRpYScpO1xuICAgICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgICAgdGhpcy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuTUVESUFfQVRUQUNISU5HLCB7IG1lZGlhOiBtZWRpYSB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXRhY2hNZWRpYScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaE1lZGlhKCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdkZXRhY2hNZWRpYScpO1xuICAgICAgdGhpcy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuTUVESUFfREVUQUNISU5HKTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRTb3VyY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkU291cmNlKHVybCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdsb2FkU291cmNlOicgKyB1cmwpO1xuICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAvLyB3aGVuIGF0dGFjaGluZyB0byBhIHNvdXJjZSBVUkwsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkXG4gICAgICB0aGlzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5NQU5JRkVTVF9MT0FESU5HLCB7IHVybDogdXJsIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0YXJ0TG9hZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0TG9hZCgpIHtcbiAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAtMTtcblxuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzdGFydExvYWQoJyArIHN0YXJ0UG9zaXRpb24gKyAnKScpO1xuICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLnN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0b3BMb2FkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcExvYWQoKSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3N0b3BMb2FkJyk7XG4gICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc3RvcExvYWQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N3YXBBdWRpb0NvZGVjJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3N3YXBBdWRpb0NvZGVjJyk7XG4gICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuc3dhcEF1ZGlvQ29kZWMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWNvdmVyTWVkaWFFcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY292ZXJNZWRpYUVycm9yKCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdyZWNvdmVyTWVkaWFFcnJvcicpO1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICAgIHRoaXMuYXR0YWNoTWVkaWEobWVkaWEpO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm4gYWxsIHF1YWxpdHkgbGV2ZWxzICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdsZXZlbHMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVscztcbiAgICB9XG5cbiAgICAvKiogUmV0dXJuIGN1cnJlbnQgcGxheWJhY2sgcXVhbGl0eSBsZXZlbCAqKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3VycmVudExldmVsJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuY3VycmVudExldmVsO1xuICAgIH1cblxuICAgIC8qIHNldCBxdWFsaXR5IGxldmVsIGltbWVkaWF0ZWx5ICgtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbikgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc2V0IGN1cnJlbnRMZXZlbDonICsgbmV3TGV2ZWwpO1xuICAgICAgdGhpcy5sb2FkTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm4gbmV4dCBwbGF5YmFjayBxdWFsaXR5IGxldmVsIChxdWFsaXR5IGxldmVsIG9mIG5leHQgZnJhZ21lbnQpICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICduZXh0TGV2ZWwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWw7XG4gICAgfVxuXG4gICAgLyogc2V0IHF1YWxpdHkgbGV2ZWwgZm9yIG5leHQgZnJhZ21lbnQgKC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uKSAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzZXQgbmV4dExldmVsOicgKyBuZXdMZXZlbCk7XG4gICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm4gdGhlIHF1YWxpdHkgbGV2ZWwgb2YgY3VycmVudC9sYXN0IGxvYWRlZCBmcmFnbWVudCAqKi9cblxuICB9LCB7XG4gICAga2V5OiAnbG9hZExldmVsJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbDtcbiAgICB9XG5cbiAgICAvKiBzZXQgcXVhbGl0eSBsZXZlbCBmb3IgY3VycmVudC9uZXh0IGxvYWRlZCBmcmFnbWVudCAoLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24pICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3NldCBsb2FkTGV2ZWw6JyArIG5ld0xldmVsKTtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybiB0aGUgcXVhbGl0eSBsZXZlbCBvZiBuZXh0IGxvYWRlZCBmcmFnbWVudCAqKi9cblxuICB9LCB7XG4gICAga2V5OiAnbmV4dExvYWRMZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbDtcbiAgICB9XG5cbiAgICAvKiogc2V0IHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBsb2FkZWQgZnJhZ21lbnQgKiovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGxldmVsKSB7XG4gICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybiBmaXJzdCBsZXZlbCAoaW5kZXggb2YgZmlyc3QgbGV2ZWwgcmVmZXJlbmNlZCBpbiBtYW5pZmVzdClcbiAgICAqKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmlyc3RMZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpO1xuICAgIH1cblxuICAgIC8qKiBzZXQgZmlyc3QgbGV2ZWwgKGluZGV4IG9mIGZpcnN0IGxldmVsIHJlZmVyZW5jZWQgaW4gbWFuaWZlc3QpXG4gICAgKiovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ3NldCBmaXJzdExldmVsOicgKyBuZXdMZXZlbCk7XG4gICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybiBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxuICAgICAgICBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICAgICAgaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgICAqKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3RhcnRMZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbDtcbiAgICB9XG5cbiAgICAvKiogc2V0ICBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxuICAgICAgICBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICAgICAgaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgICAqKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnc2V0IHN0YXJ0TGV2ZWw6JyArIG5ld0xldmVsKTtcbiAgICAgIHZhciBobHMgPSB0aGlzO1xuICAgICAgLy8gaWYgbm90IGluIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBkZXRlY3Rpb24sIGVuc3VyZSBzdGFydExldmVsIGlzIGdyZWF0ZXIgdGhhbiBtaW5BdXRvTGV2ZWxcbiAgICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1heChuZXdMZXZlbCwgaGxzLm1pbkF1dG9MZXZlbCk7XG4gICAgICB9XG4gICAgICBobHMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJuIHRoZSBjYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IGNvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKiovXG5cbiAgfSwge1xuICAgIGtleTogJ2F1dG9MZXZlbENhcHBpbmcnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2F1dG9MZXZlbENhcHBpbmc7XG4gICAgfVxuXG4gICAgLyoqIHNldCB0aGUgY2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBjb3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtICoqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdzZXQgYXV0b0xldmVsQ2FwcGluZzonICsgbmV3TGV2ZWwpO1xuICAgICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IG5ld0xldmVsO1xuICAgIH1cblxuICAgIC8qIGNoZWNrIGlmIHdlIGFyZSBpbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIG1vZGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXV0b0xldmVsRW5hYmxlZCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xO1xuICAgIH1cblxuICAgIC8qIHJldHVybiBtYW51YWwgbGV2ZWwgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWFudWFsTGV2ZWwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsO1xuICAgIH1cblxuICAgIC8qIHJldHVybiBtaW4gbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGNvbmZpZy5taW5BdXRvQml0cmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtaW5BdXRvTGV2ZWwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMsXG4gICAgICAgICAgbGV2ZWxzID0gaGxzLmxldmVscyxcbiAgICAgICAgICBtaW5BdXRvQml0cmF0ZSA9IGhscy5jb25maWcubWluQXV0b0JpdHJhdGUsXG4gICAgICAgICAgbGVuID0gbGV2ZWxzID8gbGV2ZWxzLmxlbmd0aCA6IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW2ldLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWxzW2ldLnJlYWxCaXRyYXRlLCBsZXZlbHNbaV0uYml0cmF0ZSkgOiBsZXZlbHNbaV0uYml0cmF0ZTtcbiAgICAgICAgaWYgKGxldmVsTmV4dEJpdHJhdGUgPiBtaW5BdXRvQml0cmF0ZSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKiByZXR1cm4gbWF4IGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBhdXRvTGV2ZWxDYXBwaW5nICovXG5cbiAgfSwge1xuICAgIGtleTogJ21heEF1dG9MZXZlbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcztcbiAgICAgIHZhciBsZXZlbHMgPSBobHMubGV2ZWxzO1xuICAgICAgdmFyIGF1dG9MZXZlbENhcHBpbmcgPSBobHMuYXV0b0xldmVsQ2FwcGluZztcbiAgICAgIHZhciBtYXhBdXRvTGV2ZWwgPSB2b2lkIDA7XG4gICAgICBpZiAoYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgJiYgbGV2ZWxzICYmIGxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgbWF4QXV0b0xldmVsID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhBdXRvTGV2ZWwgPSBhdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1heEF1dG9MZXZlbDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gbmV4dCBhdXRvIGxldmVsXG5cbiAgfSwge1xuICAgIGtleTogJ25leHRBdXRvTGV2ZWwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGhscyA9IHRoaXM7XG4gICAgICAvLyBlbnN1cmUgbmV4dCBhdXRvIGxldmVsIGlzIGJldHdlZW4gIG1pbiBhbmQgbWF4IGF1dG8gbGV2ZWxcbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChobHMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsLCBobHMubWluQXV0b0xldmVsKSwgaGxzLm1heEF1dG9MZXZlbCk7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBzZXR0ZXIgaXMgdXNlZCB0byBmb3JjZSBuZXh0IGF1dG8gbGV2ZWxcbiAgICAvLyB0aGlzIGlzIHVzZWZ1bCB0byBmb3JjZSBhIHN3aXRjaCBkb3duIGluIGF1dG8gbW9kZSA6IGluIGNhc2Ugb2YgbG9hZCBlcnJvciBvbiBsZXZlbCBOLCBobHMuanMgY2FuIHNldCBuZXh0QXV0b0xldmVsIHRvIE4tMSBmb3IgZXhhbXBsZSlcbiAgICAvLyBmb3JjZWQgdmFsdWUgaXMgdmFsaWQgZm9yIG9uZSBmcmFnbWVudC4gdXBvbiBzdWNjZXNmdWwgZnJhZyBsb2FkaW5nIGF0IGZvcmNlZCBsZXZlbCwgdGhpcyB2YWx1ZSB3aWxsIGJlIHJlc2V0dGVkIHRvIC0xIGJ5IEFCUiBjb250cm9sbGVyXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5leHRMZXZlbCkge1xuICAgICAgdmFyIGhscyA9IHRoaXM7XG4gICAgICBobHMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsID0gTWF0aC5tYXgoaGxzLm1pbkF1dG9MZXZlbCwgbmV4dExldmVsKTtcbiAgICB9XG5cbiAgICAvKiogZ2V0IGFsdGVybmF0ZSBhdWRpbyB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhdWRpb1RyYWNrcycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFja3MgOiBbXTtcbiAgICB9XG5cbiAgICAvKiogZ2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBhdWRpbyB0cmFjayAoaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHMpICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhdWRpb1RyYWNrJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrIDogLTE7XG4gICAgfVxuXG4gICAgLyoqIHNlbGVjdCBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKiovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGF1ZGlvVHJhY2tJZCkge1xuICAgICAgdmFyIGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgIGlmIChhdWRpb1RyYWNrQ29udHJvbGxlcikge1xuICAgICAgICBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrID0gYXVkaW9UcmFja0lkO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xpdmVTeW5jUG9zaXRpb24nLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXG5cbiAgfSwge1xuICAgIGtleTogJ3N1YnRpdGxlVHJhY2tzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrcyA6IFtdO1xuICAgIH1cblxuICAgIC8qKiBnZXQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cykgKiovXG5cbiAgfSwge1xuICAgIGtleTogJ3N1YnRpdGxlVHJhY2snLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgOiAtMTtcbiAgICB9XG5cbiAgICAvKiogc2VsZWN0IGFuIHN1YnRpdGxlIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMqKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3VidGl0bGVUcmFja0lkKSB7XG4gICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgPSBzdWJ0aXRsZVRyYWNrSWQ7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhscztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSGxzO1xuXG59LHtcIjFcIjoxLFwiMTJcIjoxMixcIjEzXCI6MTMsXCIzMVwiOjMxLFwiMzNcIjozMyxcIjM5XCI6MzksXCI0XCI6NCxcIjQwXCI6NDAsXCI0MVwiOjQxLFwiNTBcIjo1MH1dLDM4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBpcyBtb3N0bHkgZm9yIHN1cHBvcnQgb2YgdGhlIGVzNiBtb2R1bGUgZXhwb3J0XG4vLyBzeW50YXggd2l0aCB0aGUgYmFiZWwgY29tcGlsZXIsIGl0IGxvb2tzIGxpa2UgaXQgZG9lc250IHN1cHBvcnRcbi8vIGZ1bmN0aW9uIGV4cG9ydHMgbGlrZSB3ZSBhcmUgdXNlZCB0byBpbiBub2RlL2NvbW1vbmpzXG5tb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oMzcpLmRlZmF1bHQ7XG5cbn0se1wiMzdcIjozN31dLDM5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ldmVudHMgPSBfZGVyZXFfKDMzKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9ldmVudEhhbmRsZXIgPSBfZGVyZXFfKDMyKTtcblxudmFyIF9ldmVudEhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRIYW5kbGVyKTtcblxudmFyIF9lcnJvcnMgPSBfZGVyZXFfKDMxKTtcblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRnJhZ21lbnQgTG9hZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgRnJhZ21lbnRMb2FkZXIgPSBmdW5jdGlvbiAoX0V2ZW50SGFuZGxlcikge1xuICBfaW5oZXJpdHMoRnJhZ21lbnRMb2FkZXIsIF9FdmVudEhhbmRsZXIpO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50TG9hZGVyKGhscykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGcmFnbWVudExvYWRlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRnJhZ21lbnRMb2FkZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGcmFnbWVudExvYWRlcikpLmNhbGwodGhpcywgaGxzLCBfZXZlbnRzMi5kZWZhdWx0LkZSQUdfTE9BRElORykpO1xuXG4gICAgX3RoaXMubG9hZGVycyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGcmFnbWVudExvYWRlciwgW3tcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBsb2FkZXJzID0gdGhpcy5sb2FkZXJzO1xuICAgICAgZm9yICh2YXIgbG9hZGVyTmFtZSBpbiBsb2FkZXJzKSB7XG4gICAgICAgIHZhciBsb2FkZXIgPSBsb2FkZXJzW2xvYWRlck5hbWVdO1xuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgICBfZXZlbnRIYW5kbGVyMi5kZWZhdWx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GcmFnTG9hZGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRnJhZ0xvYWRpbmcoZGF0YSkge1xuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgICAgdHlwZSA9IGZyYWcudHlwZSxcbiAgICAgICAgICBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbdHlwZV0sXG4gICAgICAgICAgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuXG4gICAgICBmcmFnLmxvYWRlZCA9IDA7XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2Fib3J0IHByZXZpb3VzIGZyYWdtZW50IGxvYWRlciBmb3IgdHlwZTonICsgdHlwZSk7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgbG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdID0gZnJhZy5sb2FkZXIgPSB0eXBlb2YgY29uZmlnLmZMb2FkZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IGNvbmZpZy5mTG9hZGVyKGNvbmZpZykgOiBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xuXG4gICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IHZvaWQgMCxcbiAgICAgICAgICBsb2FkZXJDb25maWcgPSB2b2lkIDAsXG4gICAgICAgICAgbG9hZGVyQ2FsbGJhY2tzID0gdm9pZCAwO1xuICAgICAgbG9hZGVyQ29udGV4dCA9IHsgdXJsOiBmcmFnLnVybCwgZnJhZzogZnJhZywgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLCBwcm9ncmVzc0RhdGE6IGZhbHNlIH07XG4gICAgICB2YXIgc3RhcnQgPSBmcmFnLmJ5dGVSYW5nZVN0YXJ0T2Zmc2V0LFxuICAgICAgICAgIGVuZCA9IGZyYWcuYnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgICAgaWYgKCFpc05hTihzdGFydCkgJiYgIWlzTmFOKGVuZCkpIHtcbiAgICAgICAgbG9hZGVyQ29udGV4dC5yYW5nZVN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGxvYWRlckNvbnRleHQucmFuZ2VFbmQgPSBlbmQ7XG4gICAgICB9XG4gICAgICBsb2FkZXJDb25maWcgPSB7IHRpbWVvdXQ6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsIG1heFJldHJ5OiAwLCByZXRyeURlbGF5OiAwLCBtYXhSZXRyeURlbGF5OiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQgfTtcbiAgICAgIGxvYWRlckNhbGxiYWNrcyA9IHsgb25TdWNjZXNzOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksIG9uRXJyb3I6IHRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksIG9uVGltZW91dDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBvblByb2dyZXNzOiB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpIH07XG4gICAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZHN1Y2Nlc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2Fkc3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXlsb2FkID0gcmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICAgIGZyYWcubG9hZGVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlJBR19MT0FERUQsIHsgcGF5bG9hZDogcGF5bG9hZCwgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRlcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRlcnJvcihyZXNwb25zZSwgY29udGV4dCkge1xuICAgICAgdmFyIGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogY29udGV4dC5mcmFnLCByZXNwb25zZTogcmVzcG9uc2UgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZHRpbWVvdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkdGltZW91dChzdGF0cywgY29udGV4dCkge1xuICAgICAgdmFyIGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCwgZmF0YWw6IGZhbHNlLCBmcmFnOiBjb250ZXh0LmZyYWcgfSk7XG4gICAgfVxuXG4gICAgLy8gZGF0YSB3aWxsIGJlIHVzZWQgZm9yIHByb2dyZXNzaXZlIHBhcnNpbmdcblxuICB9LCB7XG4gICAga2V5OiAnbG9hZHByb2dyZXNzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZHByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBkYXRhKSB7XG4gICAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgICAgZnJhZy5sb2FkZWQgPSBzdGF0cy5sb2FkZWQ7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlJBR19MT0FEX1BST0dSRVNTLCB7IGZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0cyB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRnJhZ21lbnRMb2FkZXI7XG59KF9ldmVudEhhbmRsZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBGcmFnbWVudExvYWRlcjtcblxufSx7XCIzMVwiOjMxLFwiMzJcIjozMixcIjMzXCI6MzMsXCI1MFwiOjUwfV0sNDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V2ZW50cyA9IF9kZXJlcV8oMzMpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX2V2ZW50SGFuZGxlciA9IF9kZXJlcV8oMzIpO1xuXG52YXIgX2V2ZW50SGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudEhhbmRsZXIpO1xuXG52YXIgX2Vycm9ycyA9IF9kZXJlcV8oMzEpO1xuXG52YXIgX2xvZ2dlciA9IF9kZXJlcV8oNTApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZWNyeXB0IGtleSBMb2FkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBLZXlMb2FkZXIgPSBmdW5jdGlvbiAoX0V2ZW50SGFuZGxlcikge1xuICBfaW5oZXJpdHMoS2V5TG9hZGVyLCBfRXZlbnRIYW5kbGVyKTtcblxuICBmdW5jdGlvbiBLZXlMb2FkZXIoaGxzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEtleUxvYWRlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoS2V5TG9hZGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoS2V5TG9hZGVyKSkuY2FsbCh0aGlzLCBobHMsIF9ldmVudHMyLmRlZmF1bHQuS0VZX0xPQURJTkcpKTtcblxuICAgIF90aGlzLmxvYWRlcnMgPSB7fTtcbiAgICBfdGhpcy5kZWNyeXB0a2V5ID0gbnVsbDtcbiAgICBfdGhpcy5kZWNyeXB0dXJsID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoS2V5TG9hZGVyLCBbe1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgZm9yICh2YXIgbG9hZGVyTmFtZSBpbiB0aGlzLmxvYWRlcnMpIHtcbiAgICAgICAgdmFyIGxvYWRlciA9IHRoaXMubG9hZGVyc1tsb2FkZXJOYW1lXTtcbiAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICAgICAgX2V2ZW50SGFuZGxlcjIuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uS2V5TG9hZGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uS2V5TG9hZGluZyhkYXRhKSB7XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgICB0eXBlID0gZnJhZy50eXBlLFxuICAgICAgICAgIGxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSxcbiAgICAgICAgICBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGEsXG4gICAgICAgICAgdXJpID0gZGVjcnlwdGRhdGEudXJpO1xuICAgICAgLy8gaWYgdXJpIGlzIGRpZmZlcmVudCBmcm9tIHByZXZpb3VzIG9uZSBvciBpZiBkZWNyeXB0IGtleSBub3QgcmV0cmlldmVkIHlldFxuICAgICAgaWYgKHVyaSAhPT0gdGhpcy5kZWNyeXB0dXJsIHx8IHRoaXMuZGVjcnlwdGtleSA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuXG4gICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKCdhYm9ydCBwcmV2aW91cyBrZXkgbG9hZGVyIGZvciB0eXBlOicgKyB0eXBlKTtcbiAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBmcmFnLmxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSA9IG5ldyBjb25maWcubG9hZGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuZGVjcnlwdHVybCA9IHVyaTtcbiAgICAgICAgdGhpcy5kZWNyeXB0a2V5ID0gbnVsbDtcblxuICAgICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IHZvaWQgMCxcbiAgICAgICAgICAgIGxvYWRlckNvbmZpZyA9IHZvaWQgMCxcbiAgICAgICAgICAgIGxvYWRlckNhbGxiYWNrcyA9IHZvaWQgMDtcbiAgICAgICAgbG9hZGVyQ29udGV4dCA9IHsgdXJsOiB1cmksIGZyYWc6IGZyYWcsIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyB9O1xuICAgICAgICBsb2FkZXJDb25maWcgPSB7IHRpbWVvdXQ6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsIG1heFJldHJ5OiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSwgcmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0IH07XG4gICAgICAgIGxvYWRlckNhbGxiYWNrcyA9IHsgb25TdWNjZXNzOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksIG9uRXJyb3I6IHRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksIG9uVGltZW91dDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpIH07XG4gICAgICAgIGZyYWcubG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRlY3J5cHRrZXkpIHtcbiAgICAgICAgLy8gd2UgYWxyZWFkeSBsb2FkZWQgdGhpcyBrZXksIHJldHVybiBpdFxuICAgICAgICBkZWNyeXB0ZGF0YS5rZXkgPSB0aGlzLmRlY3J5cHRrZXk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5LRVlfTE9BREVELCB7IGZyYWc6IGZyYWcgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZHN1Y2Nlc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2Fkc3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpIHtcbiAgICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgICAgdGhpcy5kZWNyeXB0a2V5ID0gZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPSBuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKTtcbiAgICAgIC8vIGRldGFjaCBmcmFnbWVudCBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG4gICAgICBmcmFnLmxvYWRlciA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LktFWV9MT0FERUQsIHsgZnJhZzogZnJhZyB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkZXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkZXJyb3IocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgICAgIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnLCByZXNwb25zZTogcmVzcG9uc2UgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZHRpbWVvdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkdGltZW91dChzdGF0cywgY29udGV4dCkge1xuICAgICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICAgICAgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gS2V5TG9hZGVyO1xufShfZXZlbnRIYW5kbGVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2V5TG9hZGVyO1xuXG59LHtcIjMxXCI6MzEsXCIzMlwiOjMyLFwiMzNcIjozMyxcIjUwXCI6NTB9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFBsYXlsaXN0IExvYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBfdXJsVG9vbGtpdCA9IF9kZXJlcV8oMik7XG5cbnZhciBfdXJsVG9vbGtpdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91cmxUb29sa2l0KTtcblxudmFyIF9ldmVudHMgPSBfZGVyZXFfKDMzKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9ldmVudEhhbmRsZXIgPSBfZGVyZXFfKDMyKTtcblxudmFyIF9ldmVudEhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRIYW5kbGVyKTtcblxudmFyIF9lcnJvcnMgPSBfZGVyZXFfKDMxKTtcblxudmFyIF9hdHRyTGlzdCA9IF9kZXJlcV8oNDUpO1xuXG52YXIgX2F0dHJMaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F0dHJMaXN0KTtcblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vLyBodHRwczovL3JlZ2V4MTAxLmNvbSBpcyB5b3VyIGZyaWVuZFxudmFyIE1BU1RFUl9QTEFZTElTVF9SRUdFWCA9IC8jRVhULVgtU1RSRUFNLUlORjooW15cXG5cXHJdKilbXFxyXFxuXSsoW15cXHJcXG5dKykvZztcbnZhciBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVggPSAvI0VYVC1YLU1FRElBOiguKikvZztcbnZhciBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNUID0gLyNFWFRJTkY6KFxcZCooPzpcXC5cXGQrKT8pKD86LCguKikpP3woPyEjKShcXFMuKyl8I0VYVC1YLUJZVEVSQU5HRTogKiguKyl8I0VYVC1YLVBST0dSQU0tREFURS1USU1FOiguKyl8Iy4qL2c7XG52YXIgTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyA9IC8oPzooPzojKEVYVE0zVSkpfCg/OiNFWFQtWC0oUExBWUxJU1QtVFlQRSk6KC4rKSl8KD86I0VYVC1YLShNRURJQS1TRVFVRU5DRSk6ICooXFxkKykpfCg/OiNFWFQtWC0oVEFSR0VURFVSQVRJT04pOiAqKFxcZCspKXwoPzojRVhULVgtKEtFWSk6KC4rKSl8KD86I0VYVC1YLShTVEFSVCk6KC4rKSl8KD86I0VYVC1YLShFTkRMSVNUKSl8KD86I0VYVC1YLShESVNDT05USU5VSVRZLVNFUSlVRU5DRTooXFxkKykpfCg/OiNFWFQtWC0oRElTKUNPTlRJTlVJVFkpKXwoPzojRVhULVgtKFZFUlNJT04pOihcXGQrKSl8KD86I0VYVC1YLShNQVApOiguKykpfCg/OigjKSguKik6KC4qKSl8KD86KCMpKC4qKSkoPzouKilcXHI/XFxuPy87XG5cbnZhciBMZXZlbEtleSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGV2ZWxLZXkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExldmVsS2V5KTtcblxuICAgIHRoaXMubWV0aG9kID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5pdiA9IG51bGw7XG4gICAgdGhpcy5fdXJpID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMZXZlbEtleSwgW3tcbiAgICBrZXk6ICd1cmknLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLl91cmkgJiYgdGhpcy5yZWx1cmkpIHtcbiAgICAgICAgdGhpcy5fdXJpID0gX3VybFRvb2xraXQyLmRlZmF1bHQuYnVpbGRBYnNvbHV0ZVVSTCh0aGlzLmJhc2V1cmksIHRoaXMucmVsdXJpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl91cmk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExldmVsS2V5O1xufSgpO1xuXG52YXIgRnJhZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZyYWdtZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGcmFnbWVudCk7XG5cbiAgICB0aGlzLl91cmwgPSBudWxsO1xuICAgIHRoaXMuX2J5dGVSYW5nZSA9IG51bGw7XG4gICAgdGhpcy5fZGVjcnlwdGRhdGEgPSBudWxsO1xuICAgIHRoaXMudGFnTGlzdCA9IFtdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZyYWdtZW50LCBbe1xuICAgIGtleTogJ2NyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yJyxcblxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSBtZXRob2QgZm9yIHBhcnNlTGV2ZWxQbGF5bGlzdCB0byBjcmVhdGUgYW4gaW5pdGlhbGl6YXRpb24gdmVjdG9yIGZvciBhIGdpdmVuIHNlZ21lbnRcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc2VnbWVudE51bWJlcikge1xuICAgICAgdmFyIHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KDE2KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xuICAgICAgICB1aW50OFZpZXdbaV0gPSBzZWdtZW50TnVtYmVyID4+IDggKiAoMTUgLSBpKSAmIDB4ZmY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1aW50OFZpZXc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSBtZXRob2QgZm9yIHBhcnNlTGV2ZWxQbGF5bGlzdCB0byBnZXQgYSBmcmFnbWVudCdzIGRlY3J5cHRpb24gZGF0YSBmcm9tIHRoZSBjdXJyZW50bHkgcGFyc2VkIGVuY3J5cHRpb24ga2V5IGRhdGFcbiAgICAgKiBAcGFyYW0gbGV2ZWxrZXkgLSBhIHBsYXlsaXN0J3MgZW5jcnlwdGlvbiBpbmZvXG4gICAgICogQHBhcmFtIHNlZ21lbnROdW1iZXIgLSB0aGUgZnJhZ21lbnQncyBzZWdtZW50IG51bWJlclxuICAgICAqIEByZXR1cm5zIHsqfSAtIGFuIG9iamVjdCB0byBiZSBhcHBsaWVkIGFzIGEgZnJhZ21lbnQncyBkZWNyeXB0ZGF0YVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmcmFnbWVudERlY3J5cHRkYXRhRnJvbUxldmVsa2V5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJhZ21lbnREZWNyeXB0ZGF0YUZyb21MZXZlbGtleShsZXZlbGtleSwgc2VnbWVudE51bWJlcikge1xuICAgICAgdmFyIGRlY3J5cHRkYXRhID0gbGV2ZWxrZXk7XG5cbiAgICAgIGlmIChsZXZlbGtleSAmJiBsZXZlbGtleS5tZXRob2QgJiYgbGV2ZWxrZXkudXJpICYmICFsZXZlbGtleS5pdikge1xuICAgICAgICBkZWNyeXB0ZGF0YSA9IG5ldyBMZXZlbEtleSgpO1xuICAgICAgICBkZWNyeXB0ZGF0YS5tZXRob2QgPSBsZXZlbGtleS5tZXRob2Q7XG4gICAgICAgIGRlY3J5cHRkYXRhLmJhc2V1cmkgPSBsZXZlbGtleS5iYXNldXJpO1xuICAgICAgICBkZWNyeXB0ZGF0YS5yZWx1cmkgPSBsZXZlbGtleS5yZWx1cmk7XG4gICAgICAgIGRlY3J5cHRkYXRhLml2ID0gdGhpcy5jcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihzZWdtZW50TnVtYmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Nsb25lT2JqJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmVPYmoob2JqKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cmwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLl91cmwgJiYgdGhpcy5yZWx1cmwpIHtcbiAgICAgICAgdGhpcy5fdXJsID0gX3VybFRvb2xraXQyLmRlZmF1bHQuYnVpbGRBYnNvbHV0ZVVSTCh0aGlzLmJhc2V1cmwsIHRoaXMucmVsdXJsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl91cmw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5fdXJsID0gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHJvZ3JhbURhdGVUaW1lJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghdGhpcy5fcHJvZ3JhbURhdGVUaW1lICYmIHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgIHRoaXMuX3Byb2dyYW1EYXRlVGltZSA9IG5ldyBEYXRlKERhdGUucGFyc2UodGhpcy5yYXdQcm9ncmFtRGF0ZVRpbWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9wcm9ncmFtRGF0ZVRpbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnl0ZVJhbmdlJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghdGhpcy5fYnl0ZVJhbmdlKSB7XG4gICAgICAgIHZhciBieXRlUmFuZ2UgPSB0aGlzLl9ieXRlUmFuZ2UgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucmF3Qnl0ZVJhbmdlKSB7XG4gICAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucmF3Qnl0ZVJhbmdlLnNwbGl0KCdAJywgMik7XG4gICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0ID0gdGhpcy5sYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgICAgICAgICAgYnl0ZVJhbmdlWzBdID0gbGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA/IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgOiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlUmFuZ2VbMF0gPSBwYXJzZUludChwYXJhbXNbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBieXRlUmFuZ2VbMV0gPSBwYXJzZUludChwYXJhbXNbMF0pICsgYnl0ZVJhbmdlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fYnl0ZVJhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J5dGVSYW5nZVN0YXJ0T2Zmc2V0JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVswXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdieXRlUmFuZ2VFbmRPZmZzZXQnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzFdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlY3J5cHRkYXRhJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghdGhpcy5fZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgdGhpcy5fZGVjcnlwdGRhdGEgPSB0aGlzLmZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXkodGhpcy5sZXZlbGtleSwgdGhpcy5zbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fZGVjcnlwdGRhdGE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZyYWdtZW50O1xufSgpO1xuXG52YXIgUGxheWxpc3RMb2FkZXIgPSBmdW5jdGlvbiAoX0V2ZW50SGFuZGxlcikge1xuICBfaW5oZXJpdHMoUGxheWxpc3RMb2FkZXIsIF9FdmVudEhhbmRsZXIpO1xuXG4gIGZ1bmN0aW9uIFBsYXlsaXN0TG9hZGVyKGhscykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5bGlzdExvYWRlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUGxheWxpc3RMb2FkZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQbGF5bGlzdExvYWRlcikpLmNhbGwodGhpcywgaGxzLCBfZXZlbnRzMi5kZWZhdWx0Lk1BTklGRVNUX0xPQURJTkcsIF9ldmVudHMyLmRlZmF1bHQuTEVWRUxfTE9BRElORywgX2V2ZW50czIuZGVmYXVsdC5BVURJT19UUkFDS19MT0FESU5HLCBfZXZlbnRzMi5kZWZhdWx0LlNVQlRJVExFX1RSQUNLX0xPQURJTkcpKTtcblxuICAgIF90aGlzLmxvYWRlcnMgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGxheWxpc3RMb2FkZXIsIFt7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBmb3IgKHZhciBsb2FkZXJOYW1lIGluIHRoaXMubG9hZGVycykge1xuICAgICAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2xvYWRlck5hbWVdO1xuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgICBfZXZlbnRIYW5kbGVyMi5kZWZhdWx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25NYW5pZmVzdExvYWRpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZyhkYXRhKSB7XG4gICAgICB0aGlzLmxvYWQoZGF0YS51cmwsIHsgdHlwZTogJ21hbmlmZXN0JyB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkxldmVsTG9hZGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkaW5nKGRhdGEpIHtcbiAgICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlOiAnbGV2ZWwnLCBsZXZlbDogZGF0YS5sZXZlbCwgaWQ6IGRhdGEuaWQgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25BdWRpb1RyYWNrTG9hZGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQXVkaW9UcmFja0xvYWRpbmcoZGF0YSkge1xuICAgICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGU6ICdhdWRpb1RyYWNrJywgaWQ6IGRhdGEuaWQgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25TdWJ0aXRsZVRyYWNrTG9hZGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3VidGl0bGVUcmFja0xvYWRpbmcoZGF0YSkge1xuICAgICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGU6ICdzdWJ0aXRsZVRyYWNrJywgaWQ6IGRhdGEuaWQgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQodXJsLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV07XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIHZhciBsb2FkZXJDb250ZXh0ID0gbG9hZGVyLmNvbnRleHQ7XG4gICAgICAgIGlmIChsb2FkZXJDb250ZXh0ICYmIGxvYWRlckNvbnRleHQudXJsID09PSB1cmwpIHtcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci50cmFjZSgncGxheWxpc3QgcmVxdWVzdCBvbmdvaW5nJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2Fib3J0IHByZXZpb3VzIGxvYWRlciBmb3IgdHlwZTonICsgY29udGV4dC50eXBlKTtcbiAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZyxcbiAgICAgICAgICByZXRyeSA9IHZvaWQgMCxcbiAgICAgICAgICB0aW1lb3V0ID0gdm9pZCAwLFxuICAgICAgICAgIHJldHJ5RGVsYXkgPSB2b2lkIDAsXG4gICAgICAgICAgbWF4UmV0cnlEZWxheSA9IHZvaWQgMDtcbiAgICAgIGlmIChjb250ZXh0LnR5cGUgPT09ICdtYW5pZmVzdCcpIHtcbiAgICAgICAgcmV0cnkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk7XG4gICAgICAgIHRpbWVvdXQgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nVGltZU91dDtcbiAgICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgICBtYXhSZXRyeURlbGF5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHJ5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5O1xuICAgICAgICB0aW1lb3V0ID0gY29uZmlnLmxldmVsTG9hZGluZ1RpbWVPdXQ7XG4gICAgICAgIHJldHJ5RGVsYXkgPSBjb25maWcubGV2ZWxMb2FkaW5nUmV0cnlEZWxheTtcbiAgICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnbG9hZGluZyBwbGF5bGlzdCBmb3IgJyArIGNvbnRleHQudHlwZSArICcgJyArIChjb250ZXh0LmxldmVsIHx8IGNvbnRleHQuaWQpKTtcbiAgICAgIH1cbiAgICAgIGxvYWRlciA9IHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gY29udGV4dC5sb2FkZXIgPSB0eXBlb2YgY29uZmlnLnBMb2FkZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IGNvbmZpZy5wTG9hZGVyKGNvbmZpZykgOiBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xuICAgICAgY29udGV4dC51cmwgPSB1cmw7XG4gICAgICBjb250ZXh0LnJlc3BvbnNlVHlwZSA9ICcnO1xuXG4gICAgICB2YXIgbG9hZGVyQ29uZmlnID0gdm9pZCAwLFxuICAgICAgICAgIGxvYWRlckNhbGxiYWNrcyA9IHZvaWQgMDtcbiAgICAgIGxvYWRlckNvbmZpZyA9IHsgdGltZW91dDogdGltZW91dCwgbWF4UmV0cnk6IHJldHJ5LCByZXRyeURlbGF5OiByZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5OiBtYXhSZXRyeURlbGF5IH07XG4gICAgICBsb2FkZXJDYWxsYmFja3MgPSB7IG9uU3VjY2VzczogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLCBvbkVycm9yOiB0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLCBvblRpbWVvdXQ6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSB9O1xuICAgICAgbG9hZGVyLmxvYWQoY29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc29sdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKHVybCwgYmFzZVVybCkge1xuICAgICAgcmV0dXJuIF91cmxUb29sa2l0Mi5kZWZhdWx0LmJ1aWxkQWJzb2x1dGVVUkwoYmFzZVVybCwgdXJsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwYXJzZU1hc3RlclBsYXlsaXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VNYXN0ZXJQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwpIHtcbiAgICAgIHZhciBsZXZlbHMgPSBbXSxcbiAgICAgICAgICByZXN1bHQgPSB2b2lkIDA7XG4gICAgICBNQVNURVJfUExBWUxJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbGV2ZWwgPSB7fTtcblxuICAgICAgICB2YXIgYXR0cnMgPSBsZXZlbC5hdHRycyA9IG5ldyBfYXR0ckxpc3QyLmRlZmF1bHQocmVzdWx0WzFdKTtcbiAgICAgICAgbGV2ZWwudXJsID0gdGhpcy5yZXNvbHZlKHJlc3VsdFsyXSwgYmFzZXVybCk7XG5cbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBhdHRycy5kZWNpbWFsUmVzb2x1dGlvbignUkVTT0xVVElPTicpO1xuICAgICAgICBpZiAocmVzb2x1dGlvbikge1xuICAgICAgICAgIGxldmVsLndpZHRoID0gcmVzb2x1dGlvbi53aWR0aDtcbiAgICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBsZXZlbC5iaXRyYXRlID0gYXR0cnMuZGVjaW1hbEludGVnZXIoJ0FWRVJBR0UtQkFORFdJRFRIJykgfHwgYXR0cnMuZGVjaW1hbEludGVnZXIoJ0JBTkRXSURUSCcpO1xuICAgICAgICBsZXZlbC5uYW1lID0gYXR0cnMuTkFNRTtcblxuICAgICAgICB2YXIgY29kZWNzID0gYXR0cnMuQ09ERUNTO1xuICAgICAgICBpZiAoY29kZWNzKSB7XG4gICAgICAgICAgY29kZWNzID0gY29kZWNzLnNwbGl0KC9bICxdKy8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29kZWMgPSBjb2RlY3NbaV07XG4gICAgICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignYXZjMScpICE9PSAtMSkge1xuICAgICAgICAgICAgICBsZXZlbC52aWRlb0NvZGVjID0gdGhpcy5hdmMxdG9hdmNvdGkoY29kZWMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV2ZWwuYXVkaW9Db2RlYyA9IGNvZGVjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldmVscy5wdXNoKGxldmVsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZXZlbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgYmFzZXVybCwgdHlwZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMCxcbiAgICAgICAgICBtZWRpYXMgPSBbXSxcbiAgICAgICAgICBpZCA9IDA7XG4gICAgICBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbWVkaWEgPSB7fTtcbiAgICAgICAgdmFyIGF0dHJzID0gbmV3IF9hdHRyTGlzdDIuZGVmYXVsdChyZXN1bHRbMV0pO1xuICAgICAgICBpZiAoYXR0cnMuVFlQRSA9PT0gdHlwZSkge1xuICAgICAgICAgIG1lZGlhLmdyb3VwSWQgPSBhdHRyc1snR1JPVVAtSUQnXTtcbiAgICAgICAgICBtZWRpYS5uYW1lID0gYXR0cnMuTkFNRTtcbiAgICAgICAgICBtZWRpYS50eXBlID0gdHlwZTtcbiAgICAgICAgICBtZWRpYS5kZWZhdWx0ID0gYXR0cnMuREVGQVVMVCA9PT0gJ1lFUyc7XG4gICAgICAgICAgbWVkaWEuYXV0b3NlbGVjdCA9IGF0dHJzLkFVVE9TRUxFQ1QgPT09ICdZRVMnO1xuICAgICAgICAgIG1lZGlhLmZvcmNlZCA9IGF0dHJzLkZPUkNFRCA9PT0gJ1lFUyc7XG4gICAgICAgICAgaWYgKGF0dHJzLlVSSSkge1xuICAgICAgICAgICAgbWVkaWEudXJsID0gdGhpcy5yZXNvbHZlKGF0dHJzLlVSSSwgYmFzZXVybCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lZGlhLmxhbmcgPSBhdHRycy5MQU5HVUFHRTtcbiAgICAgICAgICBpZiAoIW1lZGlhLm5hbWUpIHtcbiAgICAgICAgICAgIG1lZGlhLm5hbWUgPSBtZWRpYS5sYW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZWRpYS5pZCA9IGlkKys7XG4gICAgICAgICAgbWVkaWFzLnB1c2gobWVkaWEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVkaWFzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2F2YzF0b2F2Y290aScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF2YzF0b2F2Y290aShjb2RlYykge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBhdmNkYXRhID0gY29kZWMuc3BsaXQoJy4nKTtcbiAgICAgIGlmIChhdmNkYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgcmVzdWx0ID0gYXZjZGF0YS5zaGlmdCgpICsgJy4nO1xuICAgICAgICByZXN1bHQgKz0gcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpKS50b1N0cmluZygxNik7XG4gICAgICAgIHJlc3VsdCArPSAoJzAwMCcgKyBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNvZGVjO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwYXJzZUxldmVsUGxheWxpc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUxldmVsUGxheWxpc3Qoc3RyaW5nLCBiYXNldXJsLCBpZCwgdHlwZSkge1xuICAgICAgdmFyIGN1cnJlbnRTTiA9IDAsXG4gICAgICAgICAgdG90YWxkdXJhdGlvbiA9IDAsXG4gICAgICAgICAgbGV2ZWwgPSB7IHR5cGU6IG51bGwsIHZlcnNpb246IG51bGwsIHVybDogYmFzZXVybCwgZnJhZ21lbnRzOiBbXSwgbGl2ZTogdHJ1ZSwgc3RhcnRTTjogMCB9LFxuICAgICAgICAgIGxldmVsa2V5ID0gbmV3IExldmVsS2V5KCksXG4gICAgICAgICAgY2MgPSAwLFxuICAgICAgICAgIHByZXZGcmFnID0gbnVsbCxcbiAgICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KCksXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIGk7XG5cbiAgICAgIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QubGFzdEluZGV4ID0gMDtcblxuICAgICAgd2hpbGUgKChyZXN1bHQgPSBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gcmVzdWx0WzFdO1xuICAgICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBJTkZcbiAgICAgICAgICBmcmFnLmR1cmF0aW9uID0gcGFyc2VGbG9hdChkdXJhdGlvbik7XG4gICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL2RhaWx5bW90aW9uL2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgICAgdmFyIHRpdGxlID0gKCcgJyArIHJlc3VsdFsyXSkuc2xpY2UoMSk7XG4gICAgICAgICAgZnJhZy50aXRsZSA9IHRpdGxlID8gdGl0bGUgOiBudWxsO1xuICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHRpdGxlID8gWydJTkYnLCBkdXJhdGlvbiwgdGl0bGVdIDogWydJTkYnLCBkdXJhdGlvbl0pO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdFszXSkge1xuICAgICAgICAgIC8vIHVybFxuICAgICAgICAgIGlmICghaXNOYU4oZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHZhciBzbiA9IGN1cnJlbnRTTisrO1xuICAgICAgICAgICAgZnJhZy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xuICAgICAgICAgICAgZnJhZy5sZXZlbGtleSA9IGxldmVsa2V5O1xuICAgICAgICAgICAgZnJhZy5zbiA9IHNuO1xuICAgICAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICAgICAgZnJhZy5jYyA9IGNjO1xuICAgICAgICAgICAgZnJhZy5iYXNldXJsID0gYmFzZXVybDtcbiAgICAgICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9kYWlseW1vdGlvbi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgICAgZnJhZy5yZWx1cmwgPSAoJyAnICsgcmVzdWx0WzNdKS5zbGljZSgxKTtcblxuICAgICAgICAgICAgbGV2ZWwuZnJhZ21lbnRzLnB1c2goZnJhZyk7XG4gICAgICAgICAgICBwcmV2RnJhZyA9IGZyYWc7XG4gICAgICAgICAgICB0b3RhbGR1cmF0aW9uICs9IGZyYWcuZHVyYXRpb247XG5cbiAgICAgICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzRdKSB7XG4gICAgICAgICAgLy8gWC1CWVRFUkFOR0VcbiAgICAgICAgICBmcmFnLnJhd0J5dGVSYW5nZSA9ICgnICcgKyByZXN1bHRbNF0pLnNsaWNlKDEpO1xuICAgICAgICAgIGlmIChwcmV2RnJhZykge1xuICAgICAgICAgICAgdmFyIGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgPSBwcmV2RnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgICBpZiAobGFzdEJ5dGVSYW5nZUVuZE9mZnNldCkge1xuICAgICAgICAgICAgICBmcmFnLmxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgPSBsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNV0pIHtcbiAgICAgICAgICAvLyBQUk9HUkFNLURBVEUtVElNRVxuICAgICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9kYWlseW1vdGlvbi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gKCcgJyArIHJlc3VsdFs1XSkuc2xpY2UoMSk7XG4gICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydQUk9HUkFNLURBVEUtVElNRScsIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdLm1hdGNoKExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cpO1xuICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vZGFpbHltb3Rpb24vaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgICB2YXIgdmFsdWUxID0gKCcgJyArIHJlc3VsdFtpICsgMV0pLnNsaWNlKDEpO1xuICAgICAgICAgIHZhciB2YWx1ZTIgPSAoJyAnICsgcmVzdWx0W2kgKyAyXSkuc2xpY2UoMSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKHJlc3VsdFtpXSkge1xuICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFt2YWx1ZTEsIHZhbHVlMl0gOiBbdmFsdWUxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUExBWUxJU1QtVFlQRSc6XG4gICAgICAgICAgICAgIGxldmVsLnR5cGUgPSB2YWx1ZTEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdNRURJQS1TRVFVRU5DRSc6XG4gICAgICAgICAgICAgIGN1cnJlbnRTTiA9IGxldmVsLnN0YXJ0U04gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1RBUkdFVERVUkFUSU9OJzpcbiAgICAgICAgICAgICAgbGV2ZWwudGFyZ2V0ZHVyYXRpb24gPSBwYXJzZUZsb2F0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVkVSU0lPTic6XG4gICAgICAgICAgICAgIGxldmVsLnZlcnNpb24gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0VYVE0zVSc6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRU5ETElTVCc6XG4gICAgICAgICAgICAgIGxldmVsLmxpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdESVMnOlxuICAgICAgICAgICAgICBjYysrO1xuICAgICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0RJUyddKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZLVNFUSc6XG4gICAgICAgICAgICAgIGNjID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdLRVknOlxuICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMDgjc2VjdGlvbi0zLjQuNFxuICAgICAgICAgICAgICB2YXIgZGVjcnlwdHBhcmFtcyA9IHZhbHVlMTtcbiAgICAgICAgICAgICAgdmFyIGtleUF0dHJzID0gbmV3IF9hdHRyTGlzdDIuZGVmYXVsdChkZWNyeXB0cGFyYW1zKTtcbiAgICAgICAgICAgICAgdmFyIGRlY3J5cHRtZXRob2QgPSBrZXlBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdNRVRIT0QnKSxcbiAgICAgICAgICAgICAgICAgIGRlY3J5cHR1cmkgPSBrZXlBdHRycy5VUkksXG4gICAgICAgICAgICAgICAgICBkZWNyeXB0aXYgPSBrZXlBdHRycy5oZXhhZGVjaW1hbEludGVnZXIoJ0lWJyk7XG4gICAgICAgICAgICAgIGlmIChkZWNyeXB0bWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWxrZXkgPSBuZXcgTGV2ZWxLZXkoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVjcnlwdHVyaSAmJiBbJ0FFUy0xMjgnLCAnU0FNUExFLUFFUyddLmluZGV4T2YoZGVjcnlwdG1ldGhvZCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgbGV2ZWxrZXkubWV0aG9kID0gZGVjcnlwdG1ldGhvZDtcbiAgICAgICAgICAgICAgICAgIC8vIFVSSSB0byBnZXQgdGhlIGtleVxuICAgICAgICAgICAgICAgICAgbGV2ZWxrZXkuYmFzZXVyaSA9IGJhc2V1cmw7XG4gICAgICAgICAgICAgICAgICBsZXZlbGtleS5yZWx1cmkgPSBkZWNyeXB0dXJpO1xuICAgICAgICAgICAgICAgICAgbGV2ZWxrZXkua2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemF0aW9uIFZlY3RvciAoSVYpXG4gICAgICAgICAgICAgICAgICBsZXZlbGtleS5pdiA9IGRlY3J5cHRpdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTVEFSVCc6XG4gICAgICAgICAgICAgIHZhciBzdGFydFBhcmFtcyA9IHZhbHVlMTtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0QXR0cnMgPSBuZXcgX2F0dHJMaXN0Mi5kZWZhdWx0KHN0YXJ0UGFyYW1zKTtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1RJTUUtT0ZGU0VUJyk7XG4gICAgICAgICAgICAgIC8vVElNRS1PRkZTRVQgY2FuIGJlIDBcbiAgICAgICAgICAgICAgaWYgKCFpc05hTihzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwuc3RhcnRUaW1lT2Zmc2V0ID0gc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTUFQJzpcbiAgICAgICAgICAgICAgdmFyIG1hcEF0dHJzID0gbmV3IF9hdHRyTGlzdDIuZGVmYXVsdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICBmcmFnLnJlbHVybCA9IG1hcEF0dHJzLlVSSTtcbiAgICAgICAgICAgICAgZnJhZy5yYXdCeXRlUmFuZ2UgPSBtYXBBdHRycy5CWVRFUkFOR0U7XG4gICAgICAgICAgICAgIGZyYWcuYmFzZXVybCA9IGJhc2V1cmw7XG4gICAgICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICAgICAgZnJhZy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgZnJhZy5zbiA9ICdpbml0U2VnbWVudCc7XG4gICAgICAgICAgICAgIGxldmVsLmluaXRTZWdtZW50ID0gZnJhZztcbiAgICAgICAgICAgICAgZnJhZyA9IG5ldyBGcmFnbWVudCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ2xpbmUgcGFyc2VkIGJ1dCBub3QgaGFuZGxlZDogJyArIHJlc3VsdCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnJhZyA9IHByZXZGcmFnO1xuICAgICAgLy9sb2dnZXIubG9nKCdmb3VuZCAnICsgbGV2ZWwuZnJhZ21lbnRzLmxlbmd0aCArICcgZnJhZ21lbnRzJyk7XG4gICAgICBpZiAoZnJhZyAmJiAhZnJhZy5yZWx1cmwpIHtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRzLnBvcCgpO1xuICAgICAgICB0b3RhbGR1cmF0aW9uIC09IGZyYWcuZHVyYXRpb247XG4gICAgICB9XG4gICAgICBsZXZlbC50b3RhbGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbjtcbiAgICAgIGxldmVsLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb24gLyBsZXZlbC5mcmFnbWVudHMubGVuZ3RoO1xuICAgICAgbGV2ZWwuZW5kU04gPSBjdXJyZW50U04gLSAxO1xuICAgICAgcmV0dXJuIGxldmVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRzdWNjZXNzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZHN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gcmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICB1cmwgPSByZXNwb25zZS51cmwsXG4gICAgICAgICAgdHlwZSA9IGNvbnRleHQudHlwZSxcbiAgICAgICAgICBpZCA9IGNvbnRleHQuaWQsXG4gICAgICAgICAgbGV2ZWwgPSBjb250ZXh0LmxldmVsLFxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xuXG4gICAgICB0aGlzLmxvYWRlcnNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICAvLyByZXNwb25zZVVSTCBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMgKGl0IGlzIHVzZWQgdG8gZGV0ZWN0IFVSTCByZWRpcmVjdGlvbilcbiAgICAgIC8vIGRhdGEtdXJpIG1vZGUgYWxzbyBub3Qgc3VwcG9ydGVkIChidXQgbm8gbmVlZCB0byBkZXRlY3QgcmVkaXJlY3Rpb24pXG4gICAgICBpZiAodXJsID09PSB1bmRlZmluZWQgfHwgdXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gaW5pdGlhbCBVUkxcbiAgICAgICAgdXJsID0gY29udGV4dC51cmw7XG4gICAgICB9XG4gICAgICBzdGF0cy50bG9hZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgLy9zdGF0cy5tdGltZSA9IG5ldyBEYXRlKHRhcmdldC5nZXRSZXNwb25zZUhlYWRlcignTGFzdC1Nb2RpZmllZCcpKTtcbiAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVE0zVScpID09PSAwKSB7XG4gICAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVElORjonKSA+IDApIHtcbiAgICAgICAgICB2YXIgaXNMZXZlbCA9IHR5cGUgIT09ICdhdWRpb1RyYWNrJyAmJiB0eXBlICE9PSAnc3VidGl0bGVUcmFjaycsXG4gICAgICAgICAgICAgIGxldmVsSWQgPSAhaXNOYU4obGV2ZWwpID8gbGV2ZWwgOiAhaXNOYU4oaWQpID8gaWQgOiAwLFxuICAgICAgICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLnBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIHVybCwgbGV2ZWxJZCwgdHlwZSA9PT0gJ2F1ZGlvVHJhY2snID8gJ2F1ZGlvJyA6IHR5cGUgPT09ICdzdWJ0aXRsZVRyYWNrJyA/ICdzdWJ0aXRsZScgOiAnbWFpbicpO1xuICAgICAgICAgIGxldmVsRGV0YWlscy50bG9hZCA9IHN0YXRzLnRsb2FkO1xuICAgICAgICAgIGlmICh0eXBlID09PSAnbWFuaWZlc3QnKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCByZXF1ZXN0LCBzdHJlYW0gbWFuaWZlc3QgKG5vIG1hc3RlciBwbGF5bGlzdCksIGZpcmUgbWFuaWZlc3QgbG9hZGVkIGV2ZW50IHdpdGggbGV2ZWwgZGV0YWlsc1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5NQU5JRkVTVF9MT0FERUQsIHsgbGV2ZWxzOiBbeyB1cmw6IHVybCwgZGV0YWlsczogbGV2ZWxEZXRhaWxzIH1dLCBhdWRpb1RyYWNrczogW10sIHVybDogdXJsLCBzdGF0czogc3RhdHMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRzLnRwYXJzZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBpZiAobGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoaXNMZXZlbCkge1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkxFVkVMX0xPQURFRCwgeyBkZXRhaWxzOiBsZXZlbERldGFpbHMsIGxldmVsOiBsZXZlbCB8fCAwLCBpZDogaWQgfHwgMCwgc3RhdHM6IHN0YXRzIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdhdWRpb1RyYWNrJykge1xuICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuQVVESU9fVFJBQ0tfTE9BREVELCB7IGRldGFpbHM6IGxldmVsRGV0YWlscywgaWQ6IGlkLCBzdGF0czogc3RhdHMgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N1YnRpdGxlVHJhY2snKSB7XG4gICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHsgZGV0YWlsczogbGV2ZWxEZXRhaWxzLCBpZDogaWQsIHN0YXRzOiBzdGF0cyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgdXJsOiB1cmwsIHJlYXNvbjogJ2ludmFsaWQgdGFyZ2V0ZHVyYXRpb24nIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbGV2ZWxzID0gdGhpcy5wYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgdXJsKTtcbiAgICAgICAgICAvLyBtdWx0aSBsZXZlbCBwbGF5bGlzdCwgcGFyc2UgbGV2ZWwgaW5mb1xuICAgICAgICAgIGlmIChsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYXVkaW9UcmFja3MgPSB0aGlzLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgJ0FVRElPJyk7XG4gICAgICAgICAgICB2YXIgc3VidGl0bGVzID0gdGhpcy5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsICdTVUJUSVRMRVMnKTtcbiAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSBmb3VuZCBhbiBhdWRpbyB0cmFjayBlbWJlZGRlZCBpbiBtYWluIHBsYXlsaXN0IChhdWRpbyB0cmFjayB3aXRob3V0IFVSSSBhdHRyaWJ1dGUpXG4gICAgICAgICAgICAgIHZhciBlbWJlZGRlZEF1ZGlvRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYXVkaW9UcmFja3MuZm9yRWFjaChmdW5jdGlvbiAoYXVkaW9UcmFjaykge1xuICAgICAgICAgICAgICAgIGlmICghYXVkaW9UcmFjay51cmwpIHtcbiAgICAgICAgICAgICAgICAgIGVtYmVkZGVkQXVkaW9Gb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLy8gaWYgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgYnV0IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsIHdlIG5lZWQgdG8gc2lnbmFsIHRoaXMgbWFpbiBhdWRpbyB0cmFja1xuICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiB3aXRoIHBsYXlsaXN0cyB3aXRoIGFsdCBhdWRpbyByZW5kaXRpb24gaW4gd2hpY2ggcXVhbGl0eSBsZXZlbHMgKG1haW4pIGNvbnRhaW5zIGJvdGggYXVkaW8rdmlkZW8uIGJ1dCB3aXRoIG1peGVkIGF1ZGlvIHRyYWNrIG5vdCBzaWduYWxlZFxuICAgICAgICAgICAgICBpZiAoZW1iZWRkZWRBdWRpb0ZvdW5kID09PSBmYWxzZSAmJiBsZXZlbHNbMF0uYXVkaW9Db2RlYyAmJiAhbGV2ZWxzWzBdLmF0dHJzLkFVRElPKSB7XG4gICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLCBidXQgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgc2lnbmFsZWQsIGNyZWF0ZSBvbmUnKTtcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrcy51bnNoaWZ0KHsgdHlwZTogJ21haW4nLCBuYW1lOiAnbWFpbicgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuTUFOSUZFU1RfTE9BREVELCB7IGxldmVsczogbGV2ZWxzLCBhdWRpb1RyYWNrczogYXVkaW9UcmFja3MsIHN1YnRpdGxlczogc3VidGl0bGVzLCB1cmw6IHVybCwgc3RhdHM6IHN0YXRzIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IF9lcnJvcnMuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgdXJsOiB1cmwsIHJlYXNvbjogJ25vIGxldmVsIGZvdW5kIGluIG1hbmlmZXN0JyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IF9lcnJvcnMuRXJyb3JEZXRhaWxzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCB1cmw6IHVybCwgcmVhc29uOiAnbm8gRVhUTTNVIGRlbGltaXRlcicgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZGVycm9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZGVycm9yKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgZGV0YWlscyxcbiAgICAgICAgICBmYXRhbCxcbiAgICAgICAgICBsb2FkZXIgPSBjb250ZXh0LmxvYWRlcjtcbiAgICAgIHN3aXRjaCAoY29udGV4dC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ21hbmlmZXN0JzpcbiAgICAgICAgICBkZXRhaWxzID0gX2Vycm9ycy5FcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9FUlJPUjtcbiAgICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xldmVsJzpcbiAgICAgICAgICBkZXRhaWxzID0gX2Vycm9ycy5FcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjtcbiAgICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhdWRpb1RyYWNrJzpcbiAgICAgICAgICBkZXRhaWxzID0gX2Vycm9ycy5FcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjtcbiAgICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IGRldGFpbHMsIGZhdGFsOiBmYXRhbCwgdXJsOiBsb2FkZXIudXJsLCBsb2FkZXI6IGxvYWRlciwgcmVzcG9uc2U6IHJlc3BvbnNlLCBjb250ZXh0OiBjb250ZXh0IH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWR0aW1lb3V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZHRpbWVvdXQoc3RhdHMsIGNvbnRleHQpIHtcbiAgICAgIHZhciBkZXRhaWxzLFxuICAgICAgICAgIGZhdGFsLFxuICAgICAgICAgIGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xuICAgICAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnbWFuaWZlc3QnOlxuICAgICAgICAgIGRldGFpbHMgPSBfZXJyb3JzLkVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVQ7XG4gICAgICAgICAgZmF0YWwgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZXZlbCc6XG4gICAgICAgICAgZGV0YWlscyA9IF9lcnJvcnMuRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDtcbiAgICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhdWRpb1RyYWNrJzpcbiAgICAgICAgICBkZXRhaWxzID0gX2Vycm9ycy5FcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUO1xuICAgICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBfZXJyb3JzLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogZGV0YWlscywgZmF0YWw6IGZhdGFsLCB1cmw6IGxvYWRlci51cmwsIGxvYWRlcjogbG9hZGVyLCBjb250ZXh0OiBjb250ZXh0IH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQbGF5bGlzdExvYWRlcjtcbn0oX2V2ZW50SGFuZGxlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBsYXlsaXN0TG9hZGVyO1xuXG59LHtcIjJcIjoyLFwiMzFcIjozMSxcIjMyXCI6MzIsXCIzM1wiOjMzLFwiNDVcIjo0NSxcIjUwXCI6NTB9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogR2VuZXJhdGUgTVA0IEJveFxuKi9cblxuLy9pbXBvcnQgSGV4IGZyb20gJy4uL3V0aWxzL2hleCc7XG52YXIgTVA0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNUDQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1QNCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTVA0LCBudWxsLCBbe1xuICAgIGtleTogJ2luaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgTVA0LnR5cGVzID0ge1xuICAgICAgICBhdmMxOiBbXSwgLy8gY29kaW5nbmFtZVxuICAgICAgICBhdmNDOiBbXSxcbiAgICAgICAgYnRydDogW10sXG4gICAgICAgIGRpbmY6IFtdLFxuICAgICAgICBkcmVmOiBbXSxcbiAgICAgICAgZXNkczogW10sXG4gICAgICAgIGZ0eXA6IFtdLFxuICAgICAgICBoZGxyOiBbXSxcbiAgICAgICAgbWRhdDogW10sXG4gICAgICAgIG1kaGQ6IFtdLFxuICAgICAgICBtZGlhOiBbXSxcbiAgICAgICAgbWZoZDogW10sXG4gICAgICAgIG1pbmY6IFtdLFxuICAgICAgICBtb29mOiBbXSxcbiAgICAgICAgbW9vdjogW10sXG4gICAgICAgIG1wNGE6IFtdLFxuICAgICAgICAnLm1wMyc6IFtdLFxuICAgICAgICBtdmV4OiBbXSxcbiAgICAgICAgbXZoZDogW10sXG4gICAgICAgIHBhc3A6IFtdLFxuICAgICAgICBzZHRwOiBbXSxcbiAgICAgICAgc3RibDogW10sXG4gICAgICAgIHN0Y286IFtdLFxuICAgICAgICBzdHNjOiBbXSxcbiAgICAgICAgc3RzZDogW10sXG4gICAgICAgIHN0c3o6IFtdLFxuICAgICAgICBzdHRzOiBbXSxcbiAgICAgICAgdGZkdDogW10sXG4gICAgICAgIHRmaGQ6IFtdLFxuICAgICAgICB0cmFmOiBbXSxcbiAgICAgICAgdHJhazogW10sXG4gICAgICAgIHRydW46IFtdLFxuICAgICAgICB0cmV4OiBbXSxcbiAgICAgICAgdGtoZDogW10sXG4gICAgICAgIHZtaGQ6IFtdLFxuICAgICAgICBzbWhkOiBbXVxuICAgICAgfTtcblxuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgaW4gTVA0LnR5cGVzKSB7XG4gICAgICAgIGlmIChNUDQudHlwZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICBNUDQudHlwZXNbaV0gPSBbaS5jaGFyQ29kZUF0KDApLCBpLmNoYXJDb2RlQXQoMSksIGkuY2hhckNvZGVBdCgyKSwgaS5jaGFyQ29kZUF0KDMpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmlkZW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDc2LCAweDY5LCAweDY0LCAweDY1LCAvLyBoYW5kbGVyX3R5cGU6ICd2aWRlJ1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHg1NiwgMHg2OSwgMHg2NCwgMHg2NSwgMHg2ZiwgMHg0OCwgMHg2MSwgMHg2ZSwgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnVmlkZW9IYW5kbGVyJ1xuICAgICAgXSk7XG5cbiAgICAgIHZhciBhdWRpb0hkbHIgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4NzMsIDB4NmYsIDB4NzUsIDB4NmUsIC8vIGhhbmRsZXJfdHlwZTogJ3NvdW4nXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDUzLCAweDZmLCAweDc1LCAweDZlLCAweDY0LCAweDQ4LCAweDYxLCAweDZlLCAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdTb3VuZEhhbmRsZXInXG4gICAgICBdKTtcblxuICAgICAgTVA0LkhETFJfVFlQRVMgPSB7XG4gICAgICAgICd2aWRlbyc6IHZpZGVvSGRscixcbiAgICAgICAgJ2F1ZGlvJzogYXVkaW9IZGxyXG4gICAgICB9O1xuXG4gICAgICB2YXIgZHJlZiA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBlbnRyeV9jb3VudFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYywgLy8gZW50cnlfc2l6ZVxuICAgICAgMHg3NSwgMHg3MiwgMHg2YywgMHgyMCwgLy8gJ3VybCcgdHlwZVxuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXG4gICAgICBdKTtcblxuICAgICAgdmFyIHN0Y28gPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcbiAgICAgIF0pO1xuXG4gICAgICBNUDQuU1RUUyA9IE1QNC5TVFNDID0gTVA0LlNUQ08gPSBzdGNvO1xuXG4gICAgICBNUDQuU1RTWiA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gc2FtcGxlX3NpemVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdKTtcbiAgICAgIE1QNC5WTUhEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAvLyBncmFwaGljc21vZGVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gb3Bjb2xvclxuICAgICAgXSk7XG4gICAgICBNUDQuU01IRCA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgLy8gYmFsYW5jZVxuICAgICAgMHgwMCwgMHgwMCAvLyByZXNlcnZlZFxuICAgICAgXSk7XG5cbiAgICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDFdKTsgLy8gZW50cnlfY291bnRcblxuICAgICAgdmFyIG1ham9yQnJhbmQgPSBuZXcgVWludDhBcnJheShbMTA1LCAxMTUsIDExMSwgMTA5XSk7IC8vIGlzb21cbiAgICAgIHZhciBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsIDExOCwgOTksIDQ5XSk7IC8vIGF2YzFcbiAgICAgIHZhciBtaW5vclZlcnNpb24gPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMV0pO1xuXG4gICAgICBNUDQuRlRZUCA9IE1QNC5ib3goTVA0LnR5cGVzLmZ0eXAsIG1ham9yQnJhbmQsIG1pbm9yVmVyc2lvbiwgbWFqb3JCcmFuZCwgYXZjMUJyYW5kKTtcbiAgICAgIE1QNC5ESU5GID0gTVA0LmJveChNUDQudHlwZXMuZGluZiwgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgZHJlZikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJveCh0eXBlKSB7XG4gICAgICB2YXIgcGF5bG9hZCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgc2l6ZSA9IDgsXG4gICAgICAgICAgaSA9IHBheWxvYWQubGVuZ3RoLFxuICAgICAgICAgIGxlbiA9IGksXG4gICAgICAgICAgcmVzdWx0O1xuICAgICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgIHJlc3VsdFswXSA9IHNpemUgPj4gMjQgJiAweGZmO1xuICAgICAgcmVzdWx0WzFdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG4gICAgICByZXN1bHRbMl0gPSBzaXplID4+IDggJiAweGZmO1xuICAgICAgcmVzdWx0WzNdID0gc2l6ZSAmIDB4ZmY7XG4gICAgICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICAgICAgLy8gY29weSB0aGUgcGF5bG9hZCBpbnRvIHRoZSByZXN1bHRcbiAgICAgIGZvciAoaSA9IDAsIHNpemUgPSA4OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gY29weSBwYXlsb2FkW2ldIGFycmF5IEAgb2Zmc2V0IHNpemVcbiAgICAgICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hkbHInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZGxyKHR5cGUpIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5oZGxyLCBNUDQuSERMUl9UWVBFU1t0eXBlXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWRhdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1kYXQoZGF0YSkge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kYXQsIGRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21kaGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZGhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGhkLCBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMiwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgIHRpbWVzY2FsZSA+PiAyNCAmIDB4RkYsIHRpbWVzY2FsZSA+PiAxNiAmIDB4RkYsIHRpbWVzY2FsZSA+PiA4ICYgMHhGRiwgdGltZXNjYWxlICYgMHhGRiwgLy8gdGltZXNjYWxlXG4gICAgICBkdXJhdGlvbiA+PiAyNCwgZHVyYXRpb24gPj4gMTYgJiAweEZGLCBkdXJhdGlvbiA+PiA4ICYgMHhGRiwgZHVyYXRpb24gJiAweEZGLCAvLyBkdXJhdGlvblxuICAgICAgMHg1NSwgMHhjNCwgLy8gJ3VuZCcgbGFuZ3VhZ2UgKHVuZGV0ZXJtaW5lZClcbiAgICAgIDB4MDAsIDB4MDBdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWRpYScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1kaWEodHJhY2spIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGlhLCBNUDQubWRoZCh0cmFjay50aW1lc2NhbGUsIHRyYWNrLmR1cmF0aW9uKSwgTVA0LmhkbHIodHJhY2sudHlwZSksIE1QNC5taW5mKHRyYWNrKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWZoZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1maGQoc2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZmhkLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIHNlcXVlbmNlTnVtYmVyID4+IDI0LCBzZXF1ZW5jZU51bWJlciA+PiAxNiAmIDB4RkYsIHNlcXVlbmNlTnVtYmVyID4+IDggJiAweEZGLCBzZXF1ZW5jZU51bWJlciAmIDB4RkZdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWluZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1pbmYodHJhY2spIHtcbiAgICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy5zbWhkLCBNUDQuU01IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnZtaGQsIE1QNC5WTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbW9vZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vb2Yoc24sIGJhc2VNZWRpYURlY29kZVRpbWUsIHRyYWNrKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubW9vZiwgTVA0Lm1maGQoc24pLCBNUDQudHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdHJhY2tzLi4uIChvcHRpb25hbCkge2FycmF5fSB0aGUgdHJhY2tzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1vdmllXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ21vb3YnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb292KHRyYWNrcykge1xuICAgICAgdmFyIGkgPSB0cmFja3MubGVuZ3RoLFxuICAgICAgICAgIGJveGVzID0gW107XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgYm94ZXNbaV0gPSBNUDQudHJhayh0cmFja3NbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm1vb3YsIE1QNC5tdmhkKHRyYWNrc1swXS50aW1lc2NhbGUsIHRyYWNrc1swXS5kdXJhdGlvbildLmNvbmNhdChib3hlcykuY29uY2F0KE1QNC5tdmV4KHRyYWNrcykpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtdmV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXZleCh0cmFja3MpIHtcbiAgICAgIHZhciBpID0gdHJhY2tzLmxlbmd0aCxcbiAgICAgICAgICBib3hlcyA9IFtdO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGJveGVzW2ldID0gTVA0LnRyZXgodHJhY2tzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleF0uY29uY2F0KGJveGVzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbXZoZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG12aGQodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICB0aW1lc2NhbGUgPj4gMjQgJiAweEZGLCB0aW1lc2NhbGUgPj4gMTYgJiAweEZGLCB0aW1lc2NhbGUgPj4gOCAmIDB4RkYsIHRpbWVzY2FsZSAmIDB4RkYsIC8vIHRpbWVzY2FsZVxuICAgICAgZHVyYXRpb24gPj4gMjQgJiAweEZGLCBkdXJhdGlvbiA+PiAxNiAmIDB4RkYsIGR1cmF0aW9uID4+IDggJiAweEZGLCBkdXJhdGlvbiAmIDB4RkYsIC8vIGR1cmF0aW9uXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAvLyAxLjAgcmF0ZVxuICAgICAgMHgwMSwgMHgwMCwgLy8gMS4wIHZvbHVtZVxuICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYgLy8gbmV4dF90cmFja19JRFxuICAgICAgXSk7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXZoZCwgYnl0ZXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NkdHAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZHRwKHRyYWNrKSB7XG4gICAgICB2YXIgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW10sXG4gICAgICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpLFxuICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgIGk7XG4gICAgICAvLyBsZWF2ZSB0aGUgZnVsbCBib3ggaGVhZGVyICg0IGJ5dGVzKSBhbGwgemVyb1xuICAgICAgLy8gd3JpdGUgdGhlIHNhbXBsZSB0YWJsZVxuICAgICAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xuICAgICAgICBieXRlc1tpICsgNF0gPSBmbGFncy5kZXBlbmRzT24gPDwgNCB8IGZsYWdzLmlzRGVwZW5kZWRPbiA8PCAyIHwgZmxhZ3MuaGFzUmVkdW5kYW5jeTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnNkdHAsIGJ5dGVzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGJsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RibCh0cmFjaykge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0YmwsIE1QNC5zdHNkKHRyYWNrKSwgTVA0LmJveChNUDQudHlwZXMuc3R0cywgTVA0LlNUVFMpLCBNUDQuYm94KE1QNC50eXBlcy5zdHNjLCBNUDQuU1RTQyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c3osIE1QNC5TVFNaKSwgTVA0LmJveChNUDQudHlwZXMuc3RjbywgTVA0LlNUQ08pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhdmMxJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXZjMSh0cmFjaykge1xuICAgICAgdmFyIHNwcyA9IFtdLFxuICAgICAgICAgIHBwcyA9IFtdLFxuICAgICAgICAgIGksXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBsZW47XG4gICAgICAvLyBhc3NlbWJsZSB0aGUgU1BTc1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2suc3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGEgPSB0cmFjay5zcHNbaV07XG4gICAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgc3BzLnB1c2gobGVuID4+PiA4ICYgMHhGRik7XG4gICAgICAgIHNwcy5wdXNoKGxlbiAmIDB4RkYpO1xuICAgICAgICBzcHMgPSBzcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTsgLy8gU1BTXG4gICAgICB9XG5cbiAgICAgIC8vIGFzc2VtYmxlIHRoZSBQUFNzXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2sucHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGEgPSB0cmFjay5wcHNbaV07XG4gICAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgcHBzLnB1c2gobGVuID4+PiA4ICYgMHhGRik7XG4gICAgICAgIHBwcy5wdXNoKGxlbiAmIDB4RkYpO1xuICAgICAgICBwcHMgPSBwcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF2Y2MgPSBNUDQuYm94KE1QNC50eXBlcy5hdmNDLCBuZXcgVWludDhBcnJheShbMHgwMSwgLy8gdmVyc2lvblxuICAgICAgc3BzWzNdLCAvLyBwcm9maWxlXG4gICAgICBzcHNbNF0sIC8vIHByb2ZpbGUgY29tcGF0XG4gICAgICBzcHNbNV0sIC8vIGxldmVsXG4gICAgICAweGZjIHwgMywgLy8gbGVuZ3RoU2l6ZU1pbnVzT25lLCBoYXJkLWNvZGVkIHRvIDQgYnl0ZXNcbiAgICAgIDB4RTAgfCB0cmFjay5zcHMubGVuZ3RoIC8vIDNiaXQgcmVzZXJ2ZWQgKDExMSkgKyBudW1PZlNlcXVlbmNlUGFyYW1ldGVyU2V0c1xuICAgICAgXS5jb25jYXQoc3BzKS5jb25jYXQoW3RyYWNrLnBwcy5sZW5ndGggLy8gbnVtT2ZQaWN0dXJlUGFyYW1ldGVyU2V0c1xuICAgICAgXSkuY29uY2F0KHBwcykpKSxcbiAgICAgICAgICAvLyBcIlBQU1wiXG4gICAgICB3aWR0aCA9IHRyYWNrLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IHRyYWNrLmhlaWdodCxcbiAgICAgICAgICBoU3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMF0sXG4gICAgICAgICAgdlNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzFdO1xuICAgICAgLy9jb25zb2xlLmxvZygnYXZjYzonICsgSGV4LmhleER1bXAoYXZjYykpO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmF2YzEsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICB3aWR0aCA+PiA4ICYgMHhGRiwgd2lkdGggJiAweGZmLCAvLyB3aWR0aFxuICAgICAgaGVpZ2h0ID4+IDggJiAweEZGLCBoZWlnaHQgJiAweGZmLCAvLyBoZWlnaHRcbiAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIGhvcml6cmVzb2x1dGlvblxuICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCwgLy8gdmVydHJlc29sdXRpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAvLyBmcmFtZV9jb3VudFxuICAgICAgMHgxMiwgMHg2NCwgMHg2MSwgMHg2OSwgMHg2QywgLy9kYWlseW1vdGlvbi9obHMuanNcbiAgICAgIDB4NzksIDB4NkQsIDB4NkYsIDB4NzQsIDB4NjksIDB4NkYsIDB4NkUsIDB4MkYsIDB4NjgsIDB4NkMsIDB4NzMsIDB4MkUsIDB4NkEsIDB4NzMsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNvbXByZXNzb3JuYW1lXG4gICAgICAweDAwLCAweDE4LCAvLyBkZXB0aCA9IDI0XG4gICAgICAweDExLCAweDExXSksIC8vIHByZV9kZWZpbmVkID0gLTFcbiAgICAgIGF2Y2MsIE1QNC5ib3goTVA0LnR5cGVzLmJ0cnQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDFjLCAweDljLCAweDgwLCAvLyBidWZmZXJTaXplREJcbiAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAsIC8vIG1heEJpdHJhdGVcbiAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzBdKSksIC8vIGF2Z0JpdHJhdGVcbiAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnBhc3AsIG5ldyBVaW50OEFycmF5KFtoU3BhY2luZyA+PiAyNCwgLy8gaFNwYWNpbmdcbiAgICAgIGhTcGFjaW5nID4+IDE2ICYgMHhGRiwgaFNwYWNpbmcgPj4gOCAmIDB4RkYsIGhTcGFjaW5nICYgMHhGRiwgdlNwYWNpbmcgPj4gMjQsIC8vIHZTcGFjaW5nXG4gICAgICB2U3BhY2luZyA+PiAxNiAmIDB4RkYsIHZTcGFjaW5nID4+IDggJiAweEZGLCB2U3BhY2luZyAmIDB4RkZdKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VzZHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlc2RzKHRyYWNrKSB7XG4gICAgICB2YXIgY29uZmlnbGVuID0gdHJhY2suY29uZmlnLmxlbmd0aDtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuXG4gICAgICAweDAzLCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIDB4MTcgKyBjb25maWdsZW4sIC8vIGxlbmd0aFxuICAgICAgMHgwMCwgMHgwMSwgLy9lc19pZFxuICAgICAgMHgwMCwgLy8gc3RyZWFtX3ByaW9yaXR5XG5cbiAgICAgIDB4MDQsIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgMHgwZiArIGNvbmZpZ2xlbiwgLy8gbGVuZ3RoXG4gICAgICAweDQwLCAvL2NvZGVjIDogbXBlZzRfYXVkaW9cbiAgICAgIDB4MTUsIC8vIHN0cmVhbV90eXBlXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBidWZmZXJfc2l6ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gbWF4Qml0cmF0ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gYXZnQml0cmF0ZVxuXG4gICAgICAweDA1IC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgXS5jb25jYXQoW2NvbmZpZ2xlbl0pLmNvbmNhdCh0cmFjay5jb25maWcpLmNvbmNhdChbMHgwNiwgMHgwMSwgMHgwMl0pKTsgLy8gR0FTcGVjaWZpY0NvbmZpZykpOyAvLyBsZW5ndGggKyBhdWRpbyBjb25maWcgZGVzY3JpcHRvclxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21wNGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtcDRhKHRyYWNrKSB7XG4gICAgICB2YXIgYXVkaW9zYW1wbGVyYXRlID0gdHJhY2suYXVkaW9zYW1wbGVyYXRlO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1wNGEsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcbiAgICAgIDB4MDAsIDB4MTAsIC8vIHNhbXBsZVNpemU6MTZiaXRzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDJcbiAgICAgIGF1ZGlvc2FtcGxlcmF0ZSA+PiA4ICYgMHhGRiwgYXVkaW9zYW1wbGVyYXRlICYgMHhmZiwgLy9cbiAgICAgIDB4MDAsIDB4MDBdKSwgTVA0LmJveChNUDQudHlwZXMuZXNkcywgTVA0LmVzZHModHJhY2spKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbXAzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXAzKHRyYWNrKSB7XG4gICAgICB2YXIgYXVkaW9zYW1wbGVyYXRlID0gdHJhY2suYXVkaW9zYW1wbGVyYXRlO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzWycubXAzJ10sIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcbiAgICAgIDB4MDAsIDB4MTAsIC8vIHNhbXBsZVNpemU6MTZiaXRzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDJcbiAgICAgIGF1ZGlvc2FtcGxlcmF0ZSA+PiA4ICYgMHhGRiwgYXVkaW9zYW1wbGVyYXRlICYgMHhmZiwgLy9cbiAgICAgIDB4MDAsIDB4MDBdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RzZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0c2QodHJhY2spIHtcbiAgICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgIGlmICghdHJhY2suaXNBQUMgJiYgdHJhY2suY29kZWMgPT09ICdtcDMnKSB7XG4gICAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXAzKHRyYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXA0YSh0cmFjaykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQuYXZjMSh0cmFjaykpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RraGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0a2hkKHRyYWNrKSB7XG4gICAgICB2YXIgaWQgPSB0cmFjay5pZCxcbiAgICAgICAgICBkdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uICogdHJhY2sudGltZXNjYWxlLFxuICAgICAgICAgIHdpZHRoID0gdHJhY2sud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0O1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRraGQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDcsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgaWQgPj4gMjQgJiAweEZGLCBpZCA+PiAxNiAmIDB4RkYsIGlkID4+IDggJiAweEZGLCBpZCAmIDB4RkYsIC8vIHRyYWNrX0lEXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgZHVyYXRpb24gPj4gMjQsIGR1cmF0aW9uID4+IDE2ICYgMHhGRiwgZHVyYXRpb24gPj4gOCAmIDB4RkYsIGR1cmF0aW9uICYgMHhGRiwgLy8gZHVyYXRpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAvLyBsYXllclxuICAgICAgMHgwMCwgMHgwMCwgLy8gYWx0ZXJuYXRlX2dyb3VwXG4gICAgICAweDAwLCAweDAwLCAvLyBub24tYXVkaW8gdHJhY2sgdm9sdW1lXG4gICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgd2lkdGggPj4gOCAmIDB4RkYsIHdpZHRoICYgMHhGRiwgMHgwMCwgMHgwMCwgLy8gd2lkdGhcbiAgICAgIGhlaWdodCA+PiA4ICYgMHhGRiwgaGVpZ2h0ICYgMHhGRiwgMHgwMCwgMHgwMCAvLyBoZWlnaHRcbiAgICAgIF0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0cmFmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkge1xuICAgICAgdmFyIHNhbXBsZURlcGVuZGVuY3lUYWJsZSA9IE1QNC5zZHRwKHRyYWNrKSxcbiAgICAgICAgICBpZCA9IHRyYWNrLmlkO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWYsIE1QNC5ib3goTVA0LnR5cGVzLnRmaGQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICBpZCA+PiAyNCwgaWQgPj4gMTYgJiAwWEZGLCBpZCA+PiA4ICYgMFhGRiwgaWQgJiAweEZGXSkpLCBNUDQuYm94KE1QNC50eXBlcy50ZmR0LCBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCwgYmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNiAmIDBYRkYsIGJhc2VNZWRpYURlY29kZVRpbWUgPj4gOCAmIDBYRkYsIGJhc2VNZWRpYURlY29kZVRpbWUgJiAweEZGXSkpLCBNUDQudHJ1bih0cmFjaywgc2FtcGxlRGVwZW5kZW5jeVRhYmxlLmxlbmd0aCArIDE2ICsgLy8gdGZoZFxuICAgICAgMTYgKyAvLyB0ZmR0XG4gICAgICA4ICsgLy8gdHJhZiBoZWFkZXJcbiAgICAgIDE2ICsgLy8gbWZoZFxuICAgICAgOCArIC8vIG1vb2YgaGVhZGVyXG4gICAgICA4KSwgLy8gbWRhdCBoZWFkZXJcbiAgICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB0cmFjayBib3guXG4gICAgICogQHBhcmFtIHRyYWNrIHtvYmplY3R9IGEgdHJhY2sgZGVmaW5pdGlvblxuICAgICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSB0cmFjayBib3hcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndHJhaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYWsodHJhY2spIHtcbiAgICAgIHRyYWNrLmR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gfHwgMHhmZmZmZmZmZjtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFrLCBNUDQudGtoZCh0cmFjayksIE1QNC5tZGlhKHRyYWNrKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHJleCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyZXgodHJhY2spIHtcbiAgICAgIHZhciBpZCA9IHRyYWNrLmlkO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyZXgsIG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICBpZCA+PiAyNCwgaWQgPj4gMTYgJiAwWEZGLCBpZCA+PiA4ICYgMFhGRiwgaWQgJiAweEZGLCAvLyB0cmFja19JRFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9zaXplXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAxIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gICAgICBdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHJ1bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRydW4odHJhY2ssIG9mZnNldCkge1xuICAgICAgdmFyIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdLFxuICAgICAgICAgIGxlbiA9IHNhbXBsZXMubGVuZ3RoLFxuICAgICAgICAgIGFycmF5bGVuID0gMTIgKyAxNiAqIGxlbixcbiAgICAgICAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5bGVuKSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHNhbXBsZSxcbiAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgIGN0cztcbiAgICAgIG9mZnNldCArPSA4ICsgYXJyYXlsZW47XG4gICAgICBhcnJheS5zZXQoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwZiwgMHgwMSwgLy8gZmxhZ3NcbiAgICAgIGxlbiA+Pj4gMjQgJiAweEZGLCBsZW4gPj4+IDE2ICYgMHhGRiwgbGVuID4+PiA4ICYgMHhGRiwgbGVuICYgMHhGRiwgLy8gc2FtcGxlX2NvdW50XG4gICAgICBvZmZzZXQgPj4+IDI0ICYgMHhGRiwgb2Zmc2V0ID4+PiAxNiAmIDB4RkYsIG9mZnNldCA+Pj4gOCAmIDB4RkYsIG9mZnNldCAmIDB4RkYgLy8gZGF0YV9vZmZzZXRcbiAgICAgIF0sIDApO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XG4gICAgICAgIGR1cmF0aW9uID0gc2FtcGxlLmR1cmF0aW9uO1xuICAgICAgICBzaXplID0gc2FtcGxlLnNpemU7XG4gICAgICAgIGZsYWdzID0gc2FtcGxlLmZsYWdzO1xuICAgICAgICBjdHMgPSBzYW1wbGUuY3RzO1xuICAgICAgICBhcnJheS5zZXQoW2R1cmF0aW9uID4+PiAyNCAmIDB4RkYsIGR1cmF0aW9uID4+PiAxNiAmIDB4RkYsIGR1cmF0aW9uID4+PiA4ICYgMHhGRiwgZHVyYXRpb24gJiAweEZGLCAvLyBzYW1wbGVfZHVyYXRpb25cbiAgICAgICAgc2l6ZSA+Pj4gMjQgJiAweEZGLCBzaXplID4+PiAxNiAmIDB4RkYsIHNpemUgPj4+IDggJiAweEZGLCBzaXplICYgMHhGRiwgLy8gc2FtcGxlX3NpemVcbiAgICAgICAgZmxhZ3MuaXNMZWFkaW5nIDw8IDIgfCBmbGFncy5kZXBlbmRzT24sIGZsYWdzLmlzRGVwZW5kZWRPbiA8PCA2IHwgZmxhZ3MuaGFzUmVkdW5kYW5jeSA8PCA0IHwgZmxhZ3MucGFkZGluZ1ZhbHVlIDw8IDEgfCBmbGFncy5pc05vblN5bmMsIGZsYWdzLmRlZ3JhZFByaW8gJiAweEYwIDw8IDgsIGZsYWdzLmRlZ3JhZFByaW8gJiAweDBGLCAvLyBzYW1wbGVfZmxhZ3NcbiAgICAgICAgY3RzID4+PiAyNCAmIDB4RkYsIGN0cyA+Pj4gMTYgJiAweEZGLCBjdHMgPj4+IDggJiAweEZGLCBjdHMgJiAweEZGIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgICBdLCAxMiArIDE2ICogaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJ1biwgYXJyYXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luaXRTZWdtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFNlZ21lbnQodHJhY2tzKSB7XG4gICAgICBpZiAoIU1QNC50eXBlcykge1xuICAgICAgICBNUDQuaW5pdCgpO1xuICAgICAgfVxuICAgICAgdmFyIG1vdmllID0gTVA0Lm1vb3YodHJhY2tzKSxcbiAgICAgICAgICByZXN1bHQ7XG4gICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShNUDQuRlRZUC5ieXRlTGVuZ3RoICsgbW92aWUuYnl0ZUxlbmd0aCk7XG4gICAgICByZXN1bHQuc2V0KE1QNC5GVFlQKTtcbiAgICAgIHJlc3VsdC5zZXQobW92aWUsIE1QNC5GVFlQLmJ5dGVMZW5ndGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTVA0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNUDQ7XG5cbn0se31dLDQzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZk1QNCByZW11eGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIF9hYWMgPSBfZGVyZXFfKDM0KTtcblxudmFyIF9hYWMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWFjKTtcblxudmFyIF9ldmVudHMgPSBfZGVyZXFfKDMzKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9sb2dnZXIgPSBfZGVyZXFfKDUwKTtcblxudmFyIF9tcDRHZW5lcmF0b3IgPSBfZGVyZXFfKDQyKTtcblxudmFyIF9tcDRHZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbXA0R2VuZXJhdG9yKTtcblxudmFyIF9lcnJvcnMgPSBfZGVyZXFfKDMxKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIE1QNFJlbXV4ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1QNFJlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNUDRSZW11eGVyKTtcblxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLlBFUzJNUDRTQ0FMRUZBQ1RPUiA9IDQ7XG4gICAgdGhpcy5QRVNfVElNRVNDQUxFID0gOTAwMDA7XG4gICAgdGhpcy5NUDRfVElNRVNDQUxFID0gdGhpcy5QRVNfVElNRVNDQUxFIC8gdGhpcy5QRVMyTVA0U0NBTEVGQUNUT1I7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTVA0UmVtdXhlciwgW3tcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldFRpbWVTdGFtcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKGRlZmF1bHRUaW1lU3RhbXApIHtcbiAgICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gZGVmYXVsdFRpbWVTdGFtcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldEluaXRTZWdtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudCgpIHtcbiAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW11eCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgLy8gZ2VuZXJhdGUgSW5pdCBTZWdtZW50IGlmIG5lZWRlZFxuICAgICAgaWYgKCF0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgLy8gUHVycG9zZWZ1bGx5IHJlbXV4aW5nIGF1ZGlvIGJlZm9yZSB2aWRlbywgc28gdGhhdCByZW11eFZpZGVvIGNhbiB1c2UgbmV4dEF1ZGlvUHRzLCB3aGljaCBpc1xuICAgICAgICAvLyBjYWxjdWxhdGVkIGluIHJlbXV4QXVkaW8uXG4gICAgICAgIC8vbG9nZ2VyLmxvZygnbmIgQUFDIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICBpZiAoYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBhdWRpb0RhdGEgPSB0aGlzLnJlbXV4QXVkaW8oYXVkaW9UcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ25iIEFWQyBzYW1wbGVzOicgKyB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGF1ZGlvVHJhY2tMZW5ndGggPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoYXVkaW9EYXRhKSB7XG4gICAgICAgICAgICAgIGF1ZGlvVHJhY2tMZW5ndGggPSBhdWRpb0RhdGEuZW5kUFRTIC0gYXVkaW9EYXRhLnN0YXJ0UFRTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdmlkZW9EYXRhID0gdm9pZCAwO1xuICAgICAgICAgIC8vbG9nZ2VyLmxvZygnbmIgQVZDIHNhbXBsZXM6JyArIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2aWRlb0RhdGEgPSB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2aWRlb0RhdGEgJiYgYXVkaW9UcmFjay5jb2RlYykge1xuICAgICAgICAgICAgdGhpcy5yZW11eEVtcHR5QXVkaW8oYXVkaW9UcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgdmlkZW9EYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vbG9nZ2VyLmxvZygnbmIgSUQzIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgaWYgKGlkM1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVtdXhJRDMoaWQzVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgfVxuICAgICAgLy9sb2dnZXIubG9nKCduYiBJRDMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVtdXhUZXh0KHRleHRUcmFjaywgdGltZU9mZnNldCk7XG4gICAgICB9XG4gICAgICAvL25vdGlmeSBlbmQgb2YgcGFyc2luZ1xuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTRUQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dlbmVyYXRlSVMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpIHtcbiAgICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIsXG4gICAgICAgICAgYXVkaW9TYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzLFxuICAgICAgICAgIHZpZGVvU2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcyxcbiAgICAgICAgICBwZXNUaW1lU2NhbGUgPSB0aGlzLlBFU19USU1FU0NBTEUsXG4gICAgICAgICAgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZCxcbiAgICAgICAgICBjb250YWluZXIgPSAnYXVkaW8vbXA0JyxcbiAgICAgICAgICB0cmFja3MgPSB7fSxcbiAgICAgICAgICBkYXRhID0geyB0cmFja3M6IHRyYWNrcywgdW5pcXVlOiBmYWxzZSB9LFxuICAgICAgICAgIGNvbXB1dGVQVFNEVFMgPSB0aGlzLl9pbml0UFRTID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgaW5pdFBUUyxcbiAgICAgICAgICBpbml0RFRTO1xuXG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IEluZmluaXR5O1xuICAgICAgfVxuICAgICAgaWYgKGF1ZGlvVHJhY2suY29uZmlnICYmIGF1ZGlvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSBhdWRpb1RyYWNrLmF1ZGlvc2FtcGxlcmF0ZTtcbiAgICAgICAgLy8gTVA0IGR1cmF0aW9uICh0cmFjayBkdXJhdGlvbiBpbiBzZWNvbmRzIG11bHRpcGxpZWQgYnkgdGltZXNjYWxlKSBpcyBjb2RlZCBvbiAzMiBiaXRzXG4gICAgICAgIC8vIHdlIGtub3cgdGhhdCBlYWNoIEFBQyBzYW1wbGUgY29udGFpbnMgMTAyNCBmcmFtZXMuLi4uXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGF2b2lkIG92ZXJmbG93aW5nIHRoZSAzMiBiaXQgY291bnRlciBmb3IgbGFyZ2UgZHVyYXRpb24sIHdlIHVzZSBzbWFsbGVyIHRpbWVzY2FsZSAodGltZXNjYWxlL2djZClcbiAgICAgICAgLy8gd2UganVzdCBuZWVkIHRvIGVuc3VyZSB0aGF0IEFBQyBzYW1wbGUgZHVyYXRpb24gd2lsbCBzdGlsbCBiZSBhbiBpbnRlZ2VyICh3aWxsIGJlIDEwMjQvZ2NkKVxuICAgICAgICBpZiAoYXVkaW9UcmFjay50aW1lc2NhbGUgKiBhdWRpb1RyYWNrLmR1cmF0aW9uID4gTWF0aC5wb3coMiwgMzIpKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBncmVhdGVzdENvbW1vbkRpdmlzb3IgPSBmdW5jdGlvbiBncmVhdGVzdENvbW1vbkRpdmlzb3IoYSwgYikge1xuICAgICAgICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZ3JlYXRlc3RDb21tb25EaXZpc29yKGIsIGEgJSBiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suYXVkaW9zYW1wbGVyYXRlIC8gZ3JlYXRlc3RDb21tb25EaXZpc29yKGF1ZGlvVHJhY2suYXVkaW9zYW1wbGVyYXRlLCBhdWRpb1RyYWNrLmlzQUFDID8gMTAyNCA6IDExNTIpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdhdWRpbyBtcDQgdGltZXNjYWxlIDonICsgYXVkaW9UcmFjay50aW1lc2NhbGUpO1xuICAgICAgICBpZiAoIWF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5tcGVnKSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wZWcnO1xuICAgICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZVN1cHBvcnRlZC5tcDMpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnbXAzJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgIGNvZGVjOiBhdWRpb1RyYWNrLmNvZGVjLFxuICAgICAgICAgIGluaXRTZWdtZW50OiAhYXVkaW9UcmFjay5pc0FBQyAmJiB0eXBlU3VwcG9ydGVkLm1wZWcgPyBuZXcgVWludDhBcnJheSgpIDogX21wNEdlbmVyYXRvcjIuZGVmYXVsdC5pbml0U2VnbWVudChbYXVkaW9UcmFja10pLFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICBjaGFubmVsQ291bnQ6IGF1ZGlvVHJhY2suY2hhbm5lbENvdW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiB0aGlzIGRlbXV4aW5nIGNvbnRleHQuIGZvciBhdWRpbywgUFRTID0gRFRTXG4gICAgICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBhdWRpb1NhbXBsZXNbMF0ucHRzIC0gcGVzVGltZVNjYWxlICogdGltZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmlkZW9UcmFjay5zcHMgJiYgdmlkZW9UcmFjay5wcHMgJiYgdmlkZW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IHRoaXMuTVA0X1RJTUVTQ0FMRTtcbiAgICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgICAgY29kZWM6IHZpZGVvVHJhY2suY29kZWMsXG4gICAgICAgICAgaW5pdFNlZ21lbnQ6IF9tcDRHZW5lcmF0b3IyLmRlZmF1bHQuaW5pdFNlZ21lbnQoW3ZpZGVvVHJhY2tdKSxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgd2lkdGg6IHZpZGVvVHJhY2sud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHZpZGVvVHJhY2suaGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICAgIGluaXRQVFMgPSBNYXRoLm1pbihpbml0UFRTLCB2aWRlb1NhbXBsZXNbMF0ucHRzIC0gcGVzVGltZVNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgICAgaW5pdERUUyA9IE1hdGgubWluKGluaXREVFMsIHZpZGVvU2FtcGxlc1swXS5kdHMgLSBwZXNUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5JTklUX1BUU19GT1VORCwgeyBpbml0UFRTOiBpbml0UFRTIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyh0cmFja3MpLmxlbmd0aCkge1xuICAgICAgICBvYnNlcnZlci50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwgZGF0YSk7XG4gICAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICAgIHRoaXMuX2luaXRQVFMgPSBpbml0UFRTO1xuICAgICAgICAgIHRoaXMuX2luaXREVFMgPSBpbml0RFRTO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYnNlcnZlci50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBfZXJyb3JzLkVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgcmVhc29uOiAnbm8gYXVkaW8vdmlkZW8gc2FtcGxlcyBmb3VuZCcgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVtdXhWaWRlbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbXV4VmlkZW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgpIHtcbiAgICAgIHZhciBvZmZzZXQgPSA4LFxuICAgICAgICAgIHBlc1RpbWVTY2FsZSA9IHRoaXMuUEVTX1RJTUVTQ0FMRSxcbiAgICAgICAgICBwZXMybXA0U2NhbGVGYWN0b3IgPSB0aGlzLlBFUzJNUDRTQ0FMRUZBQ1RPUixcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbixcbiAgICAgICAgICBtZGF0LFxuICAgICAgICAgIG1vb2YsXG4gICAgICAgICAgZmlyc3RQVFMsXG4gICAgICAgICAgZmlyc3REVFMsXG4gICAgICAgICAgbmV4dERUUyxcbiAgICAgICAgICBsYXN0UFRTLFxuICAgICAgICAgIGxhc3REVFMsXG4gICAgICAgICAgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcyxcbiAgICAgICAgICBvdXRwdXRTYW1wbGVzID0gW10sXG4gICAgICAgICAgbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aCxcbiAgICAgICAgICBwdHNOb3JtYWxpemUgPSB0aGlzLl9QVFNOb3JtYWxpemUsXG4gICAgICAgICAgaW5pdERUUyA9IHRoaXMuX2luaXREVFM7XG5cbiAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2suc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gICBsZXQgYXZjU2FtcGxlID0gdHJhY2suc2FtcGxlc1tpXTtcbiAgICAgIC8vICAgbGV0IHVuaXRzID0gYXZjU2FtcGxlLnVuaXRzLnVuaXRzO1xuICAgICAgLy8gICBsZXQgdW5pdHNTdHJpbmcgPSAnJztcbiAgICAgIC8vICAgZm9yIChsZXQgaiA9IDA7IGogPCB1bml0cy5sZW5ndGggOyBqKyspIHtcbiAgICAgIC8vICAgICB1bml0c1N0cmluZyArPSB1bml0c1tqXS50eXBlICsgJywnO1xuICAgICAgLy8gICAgIGlmICh1bml0c1tqXS5kYXRhLmxlbmd0aCA8IDUwMCkge1xuICAgICAgLy8gICAgICAgdW5pdHNTdHJpbmcgKz0gSGV4LmhleER1bXAodW5pdHNbal0uZGF0YSk7XG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gICB9XG4gICAgICAvLyAgIGxvZ2dlci5sb2coYXZjU2FtcGxlLnB0cyArICcvJyArIGF2Y1NhbXBsZS5kdHMgKyAnLCcgKyB1bml0c1N0cmluZyArIGF2Y1NhbXBsZS51bml0cy5sZW5ndGgpO1xuICAgICAgLy8gfVxuXG4gICAgICAvLyBzb3J0IHZpZGVvIHNhbXBsZXMgYnkgRFRTIHRoZW4gUFRTIG9yZGVyXG4gICAgICBpbnB1dFNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgZGVsdGFkdHMgPSBhLmR0cyAtIGIuZHRzO1xuICAgICAgICByZXR1cm4gZGVsdGFkdHMgPyBkZWx0YWR0cyA6IGEucHRzIC0gYi5wdHM7XG4gICAgICB9KTtcblxuICAgICAgLy8gaGFuZGxlIGJyb2tlbiBzdHJlYW1zIHdpdGggUFRTIDwgRFRTLCB0b2xlcmFuY2UgdXAgMjAwbXMgKDE4MDAwIGluIDkwa0h6IHRpbWVzY2FsZSlcbiAgICAgIHZhciBQVFNEVFNzaGlmdCA9IGlucHV0U2FtcGxlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHByZXYsIGN1cnIucHRzIC0gY3Vyci5kdHMpLCAtMTgwMDApO1xuICAgICAgfSwgMCk7XG4gICAgICBpZiAoUFRTRFRTc2hpZnQgPCAwKSB7XG4gICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ1BUUyA8IERUUyBkZXRlY3RlZCBpbiB2aWRlbyBzYW1wbGVzLCBzaGlmdGluZyBEVFMgYnkgJyArIE1hdGgucm91bmQoUFRTRFRTc2hpZnQgLyA5MCkgKyAnIG1zIHRvIG92ZXJjb21lIHRoaXMgaXNzdWUnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpbnB1dFNhbXBsZXNbaV0uZHRzICs9IFBUU0RUU3NoaWZ0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFBUUyBpcyBjb2RlZCBvbiAzM2JpdHMsIGFuZCBjYW4gbG9vcCBmcm9tIC0yXjMyIHRvIDJeMzJcbiAgICAgIC8vIHB0c05vcm1hbGl6ZSB3aWxsIG1ha2UgUFRTL0RUUyB2YWx1ZSBtb25vdG9uaWMsIHdlIHVzZSBsYXN0IGtub3duIERUUyB2YWx1ZSBhcyByZWZlcmVuY2UgdmFsdWVcbiAgICAgIHZhciBuZXh0QXZjRHRzID0gdm9pZCAwO1xuICAgICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICAgIGlmIChjb250aWd1b3VzKSB7XG4gICAgICAgIC8vIGlmIHBhcnNlZCBmcmFnbWVudCBpcyBjb250aWd1b3VzIHdpdGggbGFzdCBvbmUsIGxldCdzIHVzZSBsYXN0IERUUyB2YWx1ZSBhcyByZWZlcmVuY2VcbiAgICAgICAgbmV4dEF2Y0R0cyA9IHRoaXMubmV4dEF2Y0R0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGFyZ2V0IHRpbWVPZmZzZXRcbiAgICAgICAgbmV4dEF2Y0R0cyA9IHRpbWVPZmZzZXQgKiBwZXNUaW1lU2NhbGU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbXB1dGUgZmlyc3QgRFRTIGFuZCBsYXN0IERUUywgbm9ybWFsaXplIHRoZW0gYWdhaW5zdCByZWZlcmVuY2UgdmFsdWVcbiAgICAgIHZhciBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbMF07XG4gICAgICBmaXJzdERUUyA9IE1hdGgubWF4KHB0c05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gaW5pdERUUywgbmV4dEF2Y0R0cyksIDApO1xuICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heChwdHNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXREVFMsIG5leHRBdmNEdHMpLCAwKTtcblxuICAgICAgLy8gY2hlY2sgdGltZXN0YW1wIGNvbnRpbnVpdHkgYWNjcm9zcyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgKHRoaXMgaXMgdG8gcmVtb3ZlIGludGVyLWZyYWdtZW50IGdhcC9ob2xlKVxuICAgICAgdmFyIGRlbHRhID0gTWF0aC5yb3VuZCgoZmlyc3REVFMgLSBuZXh0QXZjRHRzKSAvIDkwKTtcbiAgICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xuICAgICAgaWYgKGNvbnRpZ3VvdXMpIHtcbiAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgaWYgKGRlbHRhID4gMSkge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdBVkM6JyArIGRlbHRhICsgJyBtcyBob2xlIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkLGZpbGxpbmcgaXQnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRlbHRhIDwgLTEpIHtcbiAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnQVZDOicgKyAtZGVsdGEgKyAnIG1zIG92ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHJlbW92ZSBob2xlL2dhcCA6IHNldCBEVFMgdG8gbmV4dCBleHBlY3RlZCBEVFNcbiAgICAgICAgICBmaXJzdERUUyA9IG5leHRBdmNEdHM7XG4gICAgICAgICAgaW5wdXRTYW1wbGVzWzBdLmR0cyA9IGZpcnN0RFRTICsgaW5pdERUUztcbiAgICAgICAgICAvLyBvZmZzZXQgUFRTIGFzIHdlbGwsIGVuc3VyZSB0aGF0IFBUUyBpcyBzbWFsbGVyIG9yIGVxdWFsIHRoYW4gbmV3IERUU1xuICAgICAgICAgIGZpcnN0UFRTID0gTWF0aC5tYXgoZmlyc3RQVFMgLSBkZWx0YSwgbmV4dEF2Y0R0cyk7XG4gICAgICAgICAgaW5wdXRTYW1wbGVzWzBdLnB0cyA9IGZpcnN0UFRTICsgaW5pdERUUztcbiAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5sb2coJ1ZpZGVvL1BUUy9EVFMgYWRqdXN0ZWQ6ICcgKyBNYXRoLnJvdW5kKGZpcnN0UFRTIC8gOTApICsgJy8nICsgTWF0aC5yb3VuZChmaXJzdERUUyAvIDkwKSArICcsZGVsdGE6JyArIGRlbHRhICsgJyBtcycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0RFRTID0gZmlyc3REVFM7XG5cbiAgICAgIC8vIGNvbXB1dGUgbGFzdFBUUy9sYXN0RFRTXG4gICAgICBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaW5wdXRTYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgICAgbGFzdERUUyA9IE1hdGgubWF4KHB0c05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gaW5pdERUUywgbmV4dEF2Y0R0cyksIDApO1xuICAgICAgbGFzdFBUUyA9IE1hdGgubWF4KHB0c05vcm1hbGl6ZShzYW1wbGUucHRzIC0gaW5pdERUUywgbmV4dEF2Y0R0cyksIDApO1xuICAgICAgbGFzdFBUUyA9IE1hdGgubWF4KGxhc3RQVFMsIGxhc3REVFMpO1xuXG4gICAgICB2YXIgdmVuZG9yID0gbmF2aWdhdG9yLnZlbmRvcixcbiAgICAgICAgICB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICAgIGlzU2FmYXJpID0gdmVuZG9yICYmIHZlbmRvci5pbmRleE9mKCdBcHBsZScpID4gLTEgJiYgdXNlckFnZW50ICYmICF1c2VyQWdlbnQubWF0Y2goJ0NyaU9TJyk7XG5cbiAgICAgIC8vIG9uIFNhZmFyaSBsZXQncyBzaWduYWwgdGhlIHNhbWUgc2FtcGxlIGR1cmF0aW9uIGZvciBhbGwgc2FtcGxlc1xuICAgICAgLy8gc2FtcGxlIGR1cmF0aW9uIChhcyBleHBlY3RlZCBieSB0cnVuIE1QNCBib3hlcyksIHNob3VsZCBiZSB0aGUgZGVsdGEgYmV0d2VlbiBzYW1wbGUgRFRTXG4gICAgICAvLyBzZXQgdGhpcyBjb25zdGFudCBkdXJhdGlvbiBhcyBiZWluZyB0aGUgYXZnIGRlbHRhIGJldHdlZW4gY29uc2VjdXRpdmUgRFRTLlxuICAgICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gTWF0aC5yb3VuZCgobGFzdERUUyAtIGZpcnN0RFRTKSAvIChwZXMybXA0U2NhbGVGYWN0b3IgKiAoaW5wdXRTYW1wbGVzLmxlbmd0aCAtIDEpKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYk5hbHUgPSAwLFxuICAgICAgICAgIG5hbHVMZW4gPSAwO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5iU2FtcGxlczsgX2krKykge1xuICAgICAgICAvLyBjb21wdXRlIHRvdGFsL2F2YyBzYW1wbGUgbGVuZ3RoIGFuZCBuYiBvZiBOQUwgdW5pdHNcbiAgICAgICAgdmFyIF9zYW1wbGUgPSBpbnB1dFNhbXBsZXNbX2ldLFxuICAgICAgICAgICAgdW5pdHMgPSBfc2FtcGxlLnVuaXRzLnVuaXRzLFxuICAgICAgICAgICAgbmJVbml0cyA9IHVuaXRzLmxlbmd0aCxcbiAgICAgICAgICAgIHNhbXBsZUxlbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgICAgc2FtcGxlTGVuICs9IHVuaXRzW2pdLmRhdGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIG5hbHVMZW4gKz0gc2FtcGxlTGVuO1xuICAgICAgICBuYk5hbHUgKz0gbmJVbml0cztcbiAgICAgICAgX3NhbXBsZS5sZW5ndGggPSBzYW1wbGVMZW47XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIFBUUy9EVFNcbiAgICAgICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICAgICAgLy8gc2FtcGxlIERUUyBpcyBjb21wdXRlZCB1c2luZyBhIGNvbnN0YW50IGRlY29kaW5nIG9mZnNldCAobXA0U2FtcGxlRHVyYXRpb24pIGJldHdlZW4gc2FtcGxlc1xuICAgICAgICAgIF9zYW1wbGUuZHRzID0gZmlyc3REVFMgKyBfaSAqIHBlczJtcDRTY2FsZUZhY3RvciAqIG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVuc3VyZSBzYW1wbGUgbW9ub3RvbmljIERUU1xuICAgICAgICAgIF9zYW1wbGUuZHRzID0gTWF0aC5tYXgocHRzTm9ybWFsaXplKF9zYW1wbGUuZHRzIC0gaW5pdERUUywgbmV4dEF2Y0R0cyksIGZpcnN0RFRTKTtcbiAgICAgICAgICAvLyBlbnN1cmUgZHRzIGlzIGEgbXVsdGlwbGUgb2Ygc2NhbGUgZmFjdG9yIHRvIGF2b2lkIHJvdW5kaW5nIGlzc3Vlc1xuICAgICAgICAgIF9zYW1wbGUuZHRzID0gTWF0aC5yb3VuZChfc2FtcGxlLmR0cyAvIHBlczJtcDRTY2FsZUZhY3RvcikgKiBwZXMybXA0U2NhbGVGYWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2Ugbm9ybWFsaXplIFBUUyBhZ2FpbnN0IG5leHRBdmNEdHMsIHdlIGFsc28gc3Vic3RyYWN0IGluaXREVFMgKHNvbWUgc3RyZWFtcyBkb24ndCBzdGFydCBAIFBUUyBPKVxuICAgICAgICAvLyBhbmQgd2UgZW5zdXJlIHRoYXQgY29tcHV0ZWQgdmFsdWUgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHNhbXBsZSBEVFNcbiAgICAgICAgX3NhbXBsZS5wdHMgPSBNYXRoLm1heChwdHNOb3JtYWxpemUoX3NhbXBsZS5wdHMgLSBpbml0RFRTLCBuZXh0QXZjRHRzKSwgX3NhbXBsZS5kdHMpO1xuICAgICAgICAvLyBlbnN1cmUgcHRzIGlzIGEgbXVsdGlwbGUgb2Ygc2NhbGUgZmFjdG9yIHRvIGF2b2lkIHJvdW5kaW5nIGlzc3Vlc1xuICAgICAgICBfc2FtcGxlLnB0cyA9IE1hdGgucm91bmQoX3NhbXBsZS5wdHMgLyBwZXMybXA0U2NhbGVGYWN0b3IpICogcGVzMm1wNFNjYWxlRmFjdG9yO1xuICAgICAgfVxuXG4gICAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbXBkYXQgdHlwZSkgKi9cbiAgICAgIHZhciBtZGF0U2l6ZSA9IG5hbHVMZW4gKyA0ICogbmJOYWx1ICsgODtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk1VWF9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnl0ZXM6IG1kYXRTaXplLCByZWFzb246ICdmYWlsIGFsbG9jYXRpbmcgdmlkZW8gbWRhdCAnICsgbWRhdFNpemUgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcbiAgICAgIG1kYXQuc2V0KF9tcDRHZW5lcmF0b3IyLmRlZmF1bHQudHlwZXMubWRhdCwgNCk7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5iU2FtcGxlczsgX2kyKyspIHtcbiAgICAgICAgdmFyIGF2Y1NhbXBsZSA9IGlucHV0U2FtcGxlc1tfaTJdLFxuICAgICAgICAgICAgYXZjU2FtcGxlVW5pdHMgPSBhdmNTYW1wbGUudW5pdHMudW5pdHMsXG4gICAgICAgICAgICBtcDRTYW1wbGVMZW5ndGggPSAwLFxuICAgICAgICAgICAgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gdm9pZCAwO1xuICAgICAgICAvLyBjb252ZXJ0IE5BTFUgYml0c3RyZWFtIHRvIE1QNCBmb3JtYXQgKHByZXBlbmQgTkFMVSB3aXRoIHNpemUgZmllbGQpXG4gICAgICAgIGZvciAodmFyIF9qID0gMCwgX25iVW5pdHMgPSBhdmNTYW1wbGVVbml0cy5sZW5ndGg7IF9qIDwgX25iVW5pdHM7IF9qKyspIHtcbiAgICAgICAgICB2YXIgdW5pdCA9IGF2Y1NhbXBsZVVuaXRzW19qXSxcbiAgICAgICAgICAgICAgdW5pdERhdGEgPSB1bml0LmRhdGEsXG4gICAgICAgICAgICAgIHVuaXREYXRhTGVuID0gdW5pdC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCB1bml0RGF0YUxlbik7XG4gICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgbWRhdC5zZXQodW5pdERhdGEsIG9mZnNldCk7XG4gICAgICAgICAgb2Zmc2V0ICs9IHVuaXREYXRhTGVuO1xuICAgICAgICAgIG1wNFNhbXBsZUxlbmd0aCArPSA0ICsgdW5pdERhdGFMZW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzU2FmYXJpKSB7XG4gICAgICAgICAgLy8gZXhwZWN0ZWQgc2FtcGxlIGR1cmF0aW9uIGlzIHRoZSBEZWNvZGluZyBUaW1lc3RhbXAgZGlmZiBvZiBjb25zZWN1dGl2ZSBzYW1wbGVzXG4gICAgICAgICAgaWYgKF9pMiA8IG5iU2FtcGxlcyAtIDEpIHtcbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gaW5wdXRTYW1wbGVzW19pMiArIDFdLmR0cyAtIGF2Y1NhbXBsZS5kdHM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgICAgICBsYXN0RnJhbWVEdXJhdGlvbiA9IGF2Y1NhbXBsZS5kdHMgLSBpbnB1dFNhbXBsZXNbX2kyID4gMCA/IF9pMiAtIDEgOiBfaTJdLmR0cztcbiAgICAgICAgICAgIGlmIChjb25maWcuc3RyZXRjaFNob3J0VmlkZW9UcmFjaykge1xuICAgICAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cbiAgICAgICAgICAgICAgLy8gU2luY2Ugd2UndmUgYWxyZWFkeSByZW11eGVkIGF1ZGlvLCBhbmQgd2Uga25vdyBob3cgbG9uZyB0aGUgYXVkaW8gdHJhY2sgaXMsIHdlIGxvb2sgdG9cbiAgICAgICAgICAgICAgLy8gc2VlIGlmIHRoZSBkZWx0YSB0byB0aGUgbmV4dCBzZWdtZW50IGlzIGxvbmdlciB0aGFuIHRoZSBtaW5pbXVtIG9mIG1heEJ1ZmZlckhvbGUgYW5kXG4gICAgICAgICAgICAgIC8vIG1heFNlZWtIb2xlLiBJZiBzbywgcGxheWJhY2sgd291bGQgcG90ZW50aWFsbHkgZ2V0IHN0dWNrLCBzbyB3ZSBhcnRpZmljaWFsbHkgaW5mbGF0ZVxuICAgICAgICAgICAgICAvLyB0aGUgZHVyYXRpb24gb2YgdGhlIGxhc3QgZnJhbWUgdG8gbWluaW1pemUgYW55IHBvdGVudGlhbCBnYXAgYmV0d2VlbiBzZWdtZW50cy5cbiAgICAgICAgICAgICAgdmFyIG1heEJ1ZmZlckhvbGUgPSBjb25maWcubWF4QnVmZmVySG9sZSxcbiAgICAgICAgICAgICAgICAgIG1heFNlZWtIb2xlID0gY29uZmlnLm1heFNlZWtIb2xlLFxuICAgICAgICAgICAgICAgICAgZ2FwVG9sZXJhbmNlID0gTWF0aC5mbG9vcihNYXRoLm1pbihtYXhCdWZmZXJIb2xlLCBtYXhTZWVrSG9sZSkgKiBwZXNUaW1lU2NhbGUpLFxuICAgICAgICAgICAgICAgICAgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBmaXJzdFBUUyArIGF1ZGlvVHJhY2tMZW5ndGggKiBwZXNUaW1lU2NhbGUgOiB0aGlzLm5leHRBdWRpb1B0cykgLSBhdmNTYW1wbGUucHRzO1xuICAgICAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc3VidHJhY3QgbGFzdEZyYW1lRHVyYXRpb24gZnJvbSBkZWx0YVRvRnJhbWVFbmQgdG8gdHJ5IHRvIHByZXZlbnQgYW55IHZpZGVvXG4gICAgICAgICAgICAgICAgLy8gZnJhbWUgb3ZlcmxhcC4gbWF4QnVmZmVySG9sZS9tYXhTZWVrSG9sZSBzaG91bGQgYmUgPj4gbGFzdEZyYW1lRHVyYXRpb24gYW55d2F5LlxuICAgICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKG1wNFNhbXBsZUR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdJdCBpcyBhcHByb3hpbWF0ZWx5ICcgKyBkZWx0YVRvRnJhbWVFbmQgLyA5MCArICcgbXMgdG8gdGhlIG5leHQgc2VnbWVudDsgdXNpbmcgZHVyYXRpb24gJyArIG1wNFNhbXBsZUR1cmF0aW9uIC8gOTAgKyAnIG1zIGZvciB0aGUgbGFzdCB2aWRlbyBmcmFtZS4nKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiAvPSBwZXMybXA0U2NhbGVGYWN0b3I7XG4gICAgICAgICAgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5yb3VuZCgoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpIC8gcGVzMm1wNFNjYWxlRmFjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSBNYXRoLm1heCgwLCBtcDRTYW1wbGVEdXJhdGlvbiAqIE1hdGgucm91bmQoKGF2Y1NhbXBsZS5wdHMgLSBhdmNTYW1wbGUuZHRzKSAvIChwZXMybXA0U2NhbGVGYWN0b3IgKiBtcDRTYW1wbGVEdXJhdGlvbikpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ1BUUy9EVFMvaW5pdERUUy9ub3JtUFRTL25vcm1EVFMvcmVsYXRpdmUgUFRTIDogJHthdmNTYW1wbGUucHRzfS8ke2F2Y1NhbXBsZS5kdHN9LyR7aW5pdERUU30vJHtwdHNub3JtfS8ke2R0c25vcm19LyR7KGF2Y1NhbXBsZS5wdHMvNDI5NDk2NzI5NikudG9GaXhlZCgzKX0nKTtcbiAgICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICBzaXplOiBtcDRTYW1wbGVMZW5ndGgsXG4gICAgICAgICAgLy8gY29uc3RhbnQgZHVyYXRpb25cbiAgICAgICAgICBkdXJhdGlvbjogbXA0U2FtcGxlRHVyYXRpb24sXG4gICAgICAgICAgY3RzOiBjb21wb3NpdGlvblRpbWVPZmZzZXQsXG4gICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgICAgICAgZGVwZW5kc09uOiBhdmNTYW1wbGUua2V5ID8gMiA6IDEsXG4gICAgICAgICAgICBpc05vblN5bmM6IGF2Y1NhbXBsZS5rZXkgPyAwIDogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBuZXh0IEFWQyBzYW1wbGUgRFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBEVFMgKyBsYXN0IHNhbXBsZSBkdXJhdGlvbiAoaW4gUEVTIHRpbWVzY2FsZSlcbiAgICAgIHRoaXMubmV4dEF2Y0R0cyA9IGxhc3REVFMgKyBtcDRTYW1wbGVEdXJhdGlvbiAqIHBlczJtcDRTY2FsZUZhY3RvcjtcbiAgICAgIHZhciBkcm9wcGVkID0gdHJhY2suZHJvcHBlZDtcbiAgICAgIHRyYWNrLmxlbiA9IDA7XG4gICAgICB0cmFjay5uYk5hbHUgPSAwO1xuICAgICAgdHJhY2suZHJvcHBlZCA9IDA7XG4gICAgICBpZiAob3V0cHV0U2FtcGxlcy5sZW5ndGggJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2Nocm9tZScpID4gLTEpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gb3V0cHV0U2FtcGxlc1swXS5mbGFncztcbiAgICAgICAgLy8gY2hyb21lIHdvcmthcm91bmQsIG1hcmsgZmlyc3Qgc2FtcGxlIGFzIGJlaW5nIGEgUmFuZG9tIEFjY2VzcyBQb2ludCB0byBhdm9pZCBzb3VyY2VidWZmZXIgYXBwZW5kIGlzc3VlXG4gICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjk0MTJcbiAgICAgICAgZmxhZ3MuZGVwZW5kc09uID0gMjtcbiAgICAgICAgZmxhZ3MuaXNOb25TeW5jID0gMDtcbiAgICAgIH1cbiAgICAgIHRyYWNrLnNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzO1xuICAgICAgbW9vZiA9IF9tcDRHZW5lcmF0b3IyLmRlZmF1bHQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdERUUyAvIHBlczJtcDRTY2FsZUZhY3RvciwgdHJhY2spO1xuICAgICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuXG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgICBzdGFydFBUUzogZmlyc3RQVFMgLyBwZXNUaW1lU2NhbGUsXG4gICAgICAgIGVuZFBUUzogKGxhc3RQVFMgKyBwZXMybXA0U2NhbGVGYWN0b3IgKiBtcDRTYW1wbGVEdXJhdGlvbikgLyBwZXNUaW1lU2NhbGUsXG4gICAgICAgIHN0YXJ0RFRTOiBmaXJzdERUUyAvIHBlc1RpbWVTY2FsZSxcbiAgICAgICAgZW5kRFRTOiB0aGlzLm5leHRBdmNEdHMgLyBwZXNUaW1lU2NhbGUsXG4gICAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICAgIG5iOiBvdXRwdXRTYW1wbGVzLmxlbmd0aCxcbiAgICAgICAgZHJvcHBlZDogZHJvcHBlZFxuICAgICAgfTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19EQVRBLCBkYXRhKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbXV4QXVkaW8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICAgIHZhciBwZXNUaW1lU2NhbGUgPSB0aGlzLlBFU19USU1FU0NBTEUsXG4gICAgICAgICAgbXA0dGltZVNjYWxlID0gdHJhY2sudGltZXNjYWxlLFxuICAgICAgICAgIHBlczJtcDRTY2FsZUZhY3RvciA9IHBlc1RpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZSxcbiAgICAgICAgICBleHBlY3RlZFNhbXBsZUR1cmF0aW9uID0gdHJhY2sudGltZXNjYWxlICogKHRyYWNrLmlzQUFDID8gMTAyNCA6IDExNTIpIC8gdHJhY2suYXVkaW9zYW1wbGVyYXRlLFxuICAgICAgICAgIHBlc0ZyYW1lRHVyYXRpb24gPSBleHBlY3RlZFNhbXBsZUR1cmF0aW9uICogcGVzMm1wNFNjYWxlRmFjdG9yLFxuICAgICAgICAgIHB0c05vcm1hbGl6ZSA9IHRoaXMuX1BUU05vcm1hbGl6ZSxcbiAgICAgICAgICBpbml0RFRTID0gdGhpcy5faW5pdERUUyxcbiAgICAgICAgICByYXdNUEVHID0gIXRyYWNrLmlzQUFDICYmIHRoaXMudHlwZVN1cHBvcnRlZC5tcGVnO1xuXG4gICAgICB2YXIgdmlldyxcbiAgICAgICAgICBvZmZzZXQgPSByYXdNUEVHID8gMCA6IDgsXG4gICAgICAgICAgYXVkaW9TYW1wbGUsXG4gICAgICAgICAgbXA0U2FtcGxlLFxuICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgbWRhdCxcbiAgICAgICAgICBtb29mLFxuICAgICAgICAgIGZpcnN0UFRTLFxuICAgICAgICAgIGZpcnN0RFRTLFxuICAgICAgICAgIGxhc3REVFMsXG4gICAgICAgICAgcHRzLFxuICAgICAgICAgIGR0cyxcbiAgICAgICAgICBwdHNub3JtLFxuICAgICAgICAgIGR0c25vcm0sXG4gICAgICAgICAgb3V0cHV0U2FtcGxlcyA9IFtdLFxuICAgICAgICAgIGlucHV0U2FtcGxlcyA9IFtdLFxuICAgICAgICAgIGZpbGxGcmFtZSxcbiAgICAgICAgICBuZXdTdGFtcCxcbiAgICAgICAgICBuZXh0QXVkaW9QdHM7XG5cbiAgICAgIHRyYWNrLnNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5wdHMgLSBiLnB0cztcbiAgICAgIH0pO1xuICAgICAgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcztcblxuICAgICAgLy8gZm9yIGF1ZGlvIHNhbXBsZXMsIGFsc28gY29uc2lkZXIgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFzIGJlaW5nIGNvbnRpZ3VvdXMgKGV2ZW4gaWYgYSBsZXZlbCBzd2l0Y2ggb2NjdXJzKSxcbiAgICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XG4gICAgICAvLyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXJlIGZyYWdzIHdpdGhcbiAgICAgIC8vICAtIGxlc3MgdGhhbiAxMDBtcyBnYXBzIGJldHdlZW4gbmV3IHRpbWUgb2Zmc2V0IGFuZCBuZXh0IGV4cGVjdGVkIFBUUyBPUlxuICAgICAgLy8gIC0gbGVzcyB0aGFuIDIwIGF1ZGlvIGZyYW1lcyBkaXN0YW5jZVxuICAgICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICAgIC8vIHRoaXMgaGVscHMgZW5zdXJpbmcgYXVkaW8gY29udGludWl0eVxuICAgICAgLy8gYW5kIHRoaXMgYWxzbyBhdm9pZHMgYXVkaW8gZ2xpdGNoZXMvY3V0IHdoZW4gc3dpdGNoaW5nIHF1YWxpdHksIG9yIHJlcG9ydGluZyB3cm9uZyBkdXJhdGlvbiBvbiBmaXJzdCBhdWRpbyBmcmFtZVxuXG4gICAgICBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cztcbiAgICAgIGNvbnRpZ3VvdXMgfD0gaW5wdXRTYW1wbGVzLmxlbmd0aCAmJiBuZXh0QXVkaW9QdHMgJiYgKE1hdGguYWJzKHRpbWVPZmZzZXQgLSBuZXh0QXVkaW9QdHMgLyBwZXNUaW1lU2NhbGUpIDwgMC4xIHx8IE1hdGguYWJzKGlucHV0U2FtcGxlc1swXS5wdHMgLSBuZXh0QXVkaW9QdHMgLSB0aGlzLl9pbml0RFRTKSA8IDIwICogcGVzRnJhbWVEdXJhdGlvbik7XG5cbiAgICAgIGlmICghY29udGlndW91cykge1xuICAgICAgICAvLyBpZiBmcmFnbWVudHMgYXJlIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGltZU9mZnNldCB0byBjb21wdXRlIG5leHQgQXVkaW8gUFRTXG4gICAgICAgIG5leHRBdWRpb1B0cyA9IHRpbWVPZmZzZXQgKiBwZXNUaW1lU2NhbGU7XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgYXVkaW8gdHJhY2sgaXMgbWlzc2luZyBzYW1wbGVzLCB0aGUgZnJhbWVzIHNlZW0gdG8gZ2V0IFwibGVmdC1zaGlmdGVkXCIgd2l0aGluIHRoZVxuICAgICAgLy8gcmVzdWx0aW5nIG1wNCBzZWdtZW50LCBjYXVzaW5nIHN5bmMgaXNzdWVzIGFuZCBsZWF2aW5nIGdhcHMgYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gc2VnbWVudC5cbiAgICAgIC8vIEluIGFuIGVmZm9ydCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcsIHdlIGluamVjdCBmcmFtZXMgaGVyZSB3aGVyZSB0aGVyZSBhcmUgZ2Fwcy5cbiAgICAgIC8vIFdoZW4gcG9zc2libGUsIHdlIGluamVjdCBhIHNpbGVudCBmcmFtZTsgd2hlbiB0aGF0J3Mgbm90IHBvc3NpYmxlLCB3ZSBkdXBsaWNhdGUgdGhlIGxhc3RcbiAgICAgIC8vIGZyYW1lLlxuXG4gICAgICAvLyBvbmx5IGluamVjdC9kcm9wIGF1ZGlvIGZyYW1lcyBpbiBjYXNlIHRpbWUgb2Zmc2V0IGlzIGFjY3VyYXRlXG4gICAgICBpZiAoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmIHRyYWNrLmlzQUFDKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuZXh0UHRzTm9ybSA9IG5leHRBdWRpb1B0czsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7KSB7XG4gICAgICAgICAgLy8gRmlyc3QsIGxldCdzIHNlZSBob3cgZmFyIG9mZiB0aGlzIGZyYW1lIGlzIGZyb20gd2hlcmUgd2UgZXhwZWN0IGl0IHRvIGJlXG4gICAgICAgICAgdmFyIHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXSxcbiAgICAgICAgICAgICAgcHRzTm9ybSA9IHB0c05vcm1hbGl6ZShzYW1wbGUucHRzIC0gaW5pdERUUywgbmV4dEF1ZGlvUHRzKSxcbiAgICAgICAgICAgICAgZGVsdGEgPSBwdHNOb3JtIC0gbmV4dFB0c05vcm07XG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBvdmVybGFwcGluZyBieSBtb3JlIHRoYW4gYSBkdXJhdGlvbiwgZHJvcCB0aGlzIHNhbXBsZVxuICAgICAgICAgIGlmIChkZWx0YSA8PSAtcGVzRnJhbWVEdXJhdGlvbikge1xuICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIud2FybignRHJvcHBpbmcgMSBhdWRpbyBmcmFtZSBAICcgKyBNYXRoLnJvdW5kKG5leHRQdHNOb3JtIC8gOTApIC8gMTAwMCArICdzIGR1ZSB0byAnICsgTWF0aC5yb3VuZChNYXRoLmFicyhkZWx0YSAvIDkwKSkgKyAnIG1zIG92ZXJsYXAuJyk7XG4gICAgICAgICAgICBpbnB1dFNhbXBsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdHJhY2subGVuIC09IHNhbXBsZS51bml0Lmxlbmd0aDtcbiAgICAgICAgICAgIC8vIERvbid0IHRvdWNoIG5leHRQdHNOb3JtIG9yIGlcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB3ZSdyZSBtb3JlIHRoYW4gYSBmcmFtZSBhd2F5IGZyb20gd2hlcmUgd2Ugc2hvdWxkIGJlLCBpbnNlcnQgbWlzc2luZyBmcmFtZXNcbiAgICAgICAgICAvLyBhbHNvIG9ubHkgaW5qZWN0IHNpbGVudCBhdWRpbyBmcmFtZXMgaWYgY3VycmVudFRpbWUgIT09IDAgKG5leHRQdHNOb3JtICE9PSAwKVxuICAgICAgICAgIGVsc2UgaWYgKGRlbHRhID49IHBlc0ZyYW1lRHVyYXRpb24gJiYgbmV4dFB0c05vcm0pIHtcbiAgICAgICAgICAgICAgdmFyIG1pc3NpbmcgPSBNYXRoLnJvdW5kKGRlbHRhIC8gcGVzRnJhbWVEdXJhdGlvbik7XG4gICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ0luamVjdGluZyAnICsgbWlzc2luZyArICcgYXVkaW8gZnJhbWUgQCAnICsgTWF0aC5yb3VuZChuZXh0UHRzTm9ybSAvIDkwKSAvIDEwMDAgKyAncyBkdWUgdG8gJyArIE1hdGgucm91bmQoZGVsdGEgLyA5MCkgKyAnIG1zIGdhcC4nKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICAgICAgICBuZXdTdGFtcCA9IG5leHRQdHNOb3JtICsgaW5pdERUUztcbiAgICAgICAgICAgICAgICBuZXdTdGFtcCA9IE1hdGgubWF4KG5ld1N0YW1wLCBpbml0RFRTKTtcbiAgICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBfYWFjMi5kZWZhdWx0LmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygnVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyBsYXN0IGZyYW1lIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBzYW1wbGUudW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnB1dFNhbXBsZXMuc3BsaWNlKGksIDAsIHsgdW5pdDogZmlsbEZyYW1lLCBwdHM6IG5ld1N0YW1wLCBkdHM6IG5ld1N0YW1wIH0pO1xuICAgICAgICAgICAgICAgIHRyYWNrLmxlbiArPSBmaWxsRnJhbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5leHRQdHNOb3JtICs9IHBlc0ZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQWRqdXN0IHNhbXBsZSB0byBuZXh0IGV4cGVjdGVkIHB0c1xuICAgICAgICAgICAgICBzYW1wbGUucHRzID0gc2FtcGxlLmR0cyA9IG5leHRQdHNOb3JtICsgaW5pdERUUztcbiAgICAgICAgICAgICAgbmV4dFB0c05vcm0gKz0gcGVzRnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdyZSB3aXRoaW4gaGFsZiBhIGZyYW1lIGR1cmF0aW9uLCBzbyBqdXN0IGFkanVzdCBwdHNcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPiAwLjEgKiBwZXNGcmFtZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coYEludmFsaWQgZnJhbWUgZGVsdGEgJHtNYXRoLnJvdW5kKHB0c05vcm0gLSBuZXh0UHRzTm9ybSArIHBlc0ZyYW1lRHVyYXRpb24pfSBhdCBQVFMgJHtNYXRoLnJvdW5kKHB0c05vcm0gLyA5MCl9IChzaG91bGQgYmUgJHtNYXRoLnJvdW5kKHBlc0ZyYW1lRHVyYXRpb24pfSkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRQdHNOb3JtICs9IHBlc0ZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gaW5pdERUUyArIG5leHRBdWRpb1B0cztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBpbnB1dFNhbXBsZXNbaSAtIDFdLnB0cyArIHBlc0ZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9qMiA9IDAsIF9uYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoOyBfajIgPCBfbmJTYW1wbGVzOyBfajIrKykge1xuICAgICAgICBhdWRpb1NhbXBsZSA9IGlucHV0U2FtcGxlc1tfajJdO1xuICAgICAgICB1bml0ID0gYXVkaW9TYW1wbGUudW5pdDtcbiAgICAgICAgcHRzID0gYXVkaW9TYW1wbGUucHRzIC0gaW5pdERUUztcbiAgICAgICAgZHRzID0gYXVkaW9TYW1wbGUuZHRzIC0gaW5pdERUUztcbiAgICAgICAgLy9sb2dnZXIubG9nKGBBdWRpby9QVFM6JHtNYXRoLnJvdW5kKHB0cy85MCl9YCk7XG4gICAgICAgIC8vIGlmIG5vdCBmaXJzdCBzYW1wbGVcbiAgICAgICAgaWYgKGxhc3REVFMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHB0c25vcm0gPSBwdHNOb3JtYWxpemUocHRzLCBsYXN0RFRTKTtcbiAgICAgICAgICBkdHNub3JtID0gcHRzTm9ybWFsaXplKGR0cywgbGFzdERUUyk7XG4gICAgICAgICAgbXA0U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgoZHRzbm9ybSAtIGxhc3REVFMpIC8gcGVzMm1wNFNjYWxlRmFjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdHNub3JtID0gcHRzTm9ybWFsaXplKHB0cywgbmV4dEF1ZGlvUHRzKTtcbiAgICAgICAgICBkdHNub3JtID0gcHRzTm9ybWFsaXplKGR0cywgbmV4dEF1ZGlvUHRzKTtcbiAgICAgICAgICB2YXIgX2RlbHRhID0gTWF0aC5yb3VuZCgxMDAwICogKHB0c25vcm0gLSBuZXh0QXVkaW9QdHMpIC8gcGVzVGltZVNjYWxlKSxcbiAgICAgICAgICAgICAgbnVtTWlzc2luZ0ZyYW1lcyA9IDA7XG4gICAgICAgICAgLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXG4gICAgICAgICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICAgICAgICBpZiAoY29udGlndW91cyAmJiB0cmFjay5pc0FBQykge1xuICAgICAgICAgICAgLy8gbG9nIGRlbHRhXG4gICAgICAgICAgICBpZiAoX2RlbHRhKSB7XG4gICAgICAgICAgICAgIGlmIChfZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgbnVtTWlzc2luZ0ZyYW1lcyA9IE1hdGgucm91bmQoKHB0c25vcm0gLSBuZXh0QXVkaW9QdHMpIC8gcGVzRnJhbWVEdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKF9kZWx0YSArICcgbXMgaG9sZSBiZXR3ZWVuIEFBQyBzYW1wbGVzIGRldGVjdGVkLGZpbGxpbmcgaXQnKTtcbiAgICAgICAgICAgICAgICBpZiAobnVtTWlzc2luZ0ZyYW1lcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IF9hYWMyLmRlZmF1bHQuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IHVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRyYWNrLmxlbiArPSBudW1NaXNzaW5nRnJhbWVzICogZmlsbEZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBmcmFtZSBvdmVybGFwLCBvdmVybGFwcGluZyBmb3IgbW9yZSB0aGFuIGhhbGYgYSBmcmFtZSBkdXJhaW9uXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoX2RlbHRhIDwgLTEyKSB7XG4gICAgICAgICAgICAgICAgLy8gZHJvcCBvdmVybGFwcGluZyBhdWRpbyBmcmFtZXMuLi4gYnJvd3NlciB3aWxsIGRlYWwgd2l0aCBpdFxuICAgICAgICAgICAgICAgIF9sb2dnZXIubG9nZ2VyLmxvZygtX2RlbHRhICsgJyBtcyBvdmVybGFwcGluZyBiZXR3ZWVuIEFBQyBzYW1wbGVzIGRldGVjdGVkLCBkcm9wIGZyYW1lJyk7XG4gICAgICAgICAgICAgICAgdHJhY2subGVuIC09IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBzZXQgUFRTL0RUUyB0byBleHBlY3RlZCBQVFMvRFRTXG4gICAgICAgICAgICAgIHB0c25vcm0gPSBkdHNub3JtID0gbmV4dEF1ZGlvUHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2Ygb3VyIGF1ZGlvU2FtcGxlcywgZW5zdXJlIHZhbHVlIGlzIHBvc2l0aXZlXG4gICAgICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heCgwLCBwdHNub3JtKTtcbiAgICAgICAgICBmaXJzdERUUyA9IE1hdGgubWF4KDAsIGR0c25vcm0pO1xuICAgICAgICAgIGlmICh0cmFjay5sZW4gPiAwKSB7XG4gICAgICAgICAgICAvKiBjb25jYXRlbmF0ZSB0aGUgYXVkaW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAgICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbWRhdCB0eXBlKSAqL1xuXG4gICAgICAgICAgICB2YXIgbWRhdFNpemUgPSByYXdNUEVHID8gdHJhY2subGVuIDogdHJhY2subGVuICsgODtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogX2Vycm9ycy5FcnJvclR5cGVzLk1VWF9FUlJPUiwgZGV0YWlsczogX2Vycm9ycy5FcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnl0ZXM6IG1kYXRTaXplLCByZWFzb246ICdmYWlsIGFsbG9jYXRpbmcgYXVkaW8gbWRhdCAnICsgbWRhdFNpemUgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmF3TVBFRykge1xuICAgICAgICAgICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgICAgICAgICAgICBtZGF0LnNldChfbXA0R2VuZXJhdG9yMi5kZWZhdWx0LnR5cGVzLm1kYXQsIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBhdWRpbyBzYW1wbGVzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG51bU1pc3NpbmdGcmFtZXM7IF9pMysrKSB7XG4gICAgICAgICAgICBuZXdTdGFtcCA9IHB0c25vcm0gLSAobnVtTWlzc2luZ0ZyYW1lcyAtIF9pMykgKiBwZXNGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgZmlsbEZyYW1lID0gX2FhYzIuZGVmYXVsdC5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcbiAgICAgICAgICAgICAgX2xvZ2dlci5sb2dnZXIubG9nKCdVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIHRoaXMgZnJhbWUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgZmlsbEZyYW1lID0gdW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWRhdC5zZXQoZmlsbEZyYW1lLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGZpbGxGcmFtZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgbXA0U2FtcGxlID0ge1xuICAgICAgICAgICAgICBzaXplOiBmaWxsRnJhbWUuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgY3RzOiAwLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMTAyNCxcbiAgICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICAgICAgICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgICAgICAgICAgICBkZXBlbmRzT246IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG91dHB1dFNhbXBsZXMucHVzaChtcDRTYW1wbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZGF0LnNldCh1bml0LCBvZmZzZXQpO1xuICAgICAgICB2YXIgdW5pdExlbiA9IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgICAgb2Zmc2V0ICs9IHVuaXRMZW47XG4gICAgICAgIC8vY29uc29sZS5sb2coJ1BUUy9EVFMvaW5pdERUUy9ub3JtUFRTL25vcm1EVFMvcmVsYXRpdmUgUFRTIDogJHthdWRpb1NhbXBsZS5wdHN9LyR7YXVkaW9TYW1wbGUuZHRzfS8ke2luaXREVFN9LyR7cHRzbm9ybX0vJHtkdHNub3JtfS8keyhhdWRpb1NhbXBsZS5wdHMvNDI5NDk2NzI5NikudG9GaXhlZCgzKX0nKTtcbiAgICAgICAgbXA0U2FtcGxlID0ge1xuICAgICAgICAgIHNpemU6IHVuaXRMZW4sXG4gICAgICAgICAgY3RzOiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgICBpc0RlcGVuZGVkT246IDAsXG4gICAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgICAgICAgIGRlcGVuZHNPbjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XG4gICAgICAgIGxhc3REVFMgPSBkdHNub3JtO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RTYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgICB2YXIgbmJTYW1wbGVzID0gb3V0cHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgICAvL3NldCBsYXN0IHNhbXBsZSBkdXJhdGlvbiBhcyBiZWluZyBpZGVudGljYWwgdG8gcHJldmlvdXMgc2FtcGxlXG4gICAgICBpZiAobmJTYW1wbGVzID49IDIpIHtcbiAgICAgICAgbGFzdFNhbXBsZUR1cmF0aW9uID0gb3V0cHV0U2FtcGxlc1tuYlNhbXBsZXMgLSAyXS5kdXJhdGlvbjtcbiAgICAgICAgbXA0U2FtcGxlLmR1cmF0aW9uID0gbGFzdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKG5iU2FtcGxlcykge1xuICAgICAgICAvLyBuZXh0IGF1ZGlvIHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGR1cmF0aW9uXG4gICAgICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gcHRzbm9ybSArIHBlczJtcDRTY2FsZUZhY3RvciAqIGxhc3RTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgLy9sb2dnZXIubG9nKCdBdWRpby9QVFMvUFRTZW5kOicgKyBhdWRpb1NhbXBsZS5wdHMudG9GaXhlZCgwKSArICcvJyArIHRoaXMubmV4dEFhY0R0cy50b0ZpeGVkKDApKTtcbiAgICAgICAgdHJhY2subGVuID0gMDtcbiAgICAgICAgdHJhY2suc2FtcGxlcyA9IG91dHB1dFNhbXBsZXM7XG4gICAgICAgIGlmIChyYXdNUEVHKSB7XG4gICAgICAgICAgbW9vZiA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9vZiA9IF9tcDRHZW5lcmF0b3IyLmRlZmF1bHQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdERUUyAvIHBlczJtcDRTY2FsZUZhY3RvciwgdHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICAgICAgdmFyIGF1ZGlvRGF0YSA9IHtcbiAgICAgICAgICBkYXRhMTogbW9vZixcbiAgICAgICAgICBkYXRhMjogbWRhdCxcbiAgICAgICAgICBzdGFydFBUUzogZmlyc3RQVFMgLyBwZXNUaW1lU2NhbGUsXG4gICAgICAgICAgZW5kUFRTOiB0aGlzLm5leHRBdWRpb1B0cyAvIHBlc1RpbWVTY2FsZSxcbiAgICAgICAgICBzdGFydERUUzogZmlyc3REVFMgLyBwZXNUaW1lU2NhbGUsXG4gICAgICAgICAgZW5kRFRTOiAoZHRzbm9ybSArIHBlczJtcDRTY2FsZUZhY3RvciAqIGxhc3RTYW1wbGVEdXJhdGlvbikgLyBwZXNUaW1lU2NhbGUsXG4gICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICBuYjogbmJTYW1wbGVzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihfZXZlbnRzMi5kZWZhdWx0LkZSQUdfUEFSU0lOR19EQVRBLCBhdWRpb0RhdGEpO1xuICAgICAgICByZXR1cm4gYXVkaW9EYXRhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVtdXhFbXB0eUF1ZGlvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtdXhFbXB0eUF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCB2aWRlb0RhdGEpIHtcbiAgICAgIHZhciBwZXNUaW1lU2NhbGUgPSB0aGlzLlBFU19USU1FU0NBTEUsXG4gICAgICAgICAgbXA0dGltZVNjYWxlID0gdHJhY2sudGltZXNjYWxlID8gdHJhY2sudGltZXNjYWxlIDogdHJhY2suYXVkaW9zYW1wbGVyYXRlLFxuICAgICAgICAgIHBlczJtcDRTY2FsZUZhY3RvciA9IHBlc1RpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZSxcbiAgICAgICAgICBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cyxcblxuXG4gICAgICAvLyBzeW5jIHdpdGggdmlkZW8ncyB0aW1lc3RhbXBcbiAgICAgIHN0YXJ0RFRTID0gKG5leHRBdWRpb1B0cyAhPT0gdW5kZWZpbmVkID8gbmV4dEF1ZGlvUHRzIDogdmlkZW9EYXRhLnN0YXJ0RFRTICogcGVzVGltZVNjYWxlKSArIHRoaXMuX2luaXREVFMsXG4gICAgICAgICAgZW5kRFRTID0gdmlkZW9EYXRhLmVuZERUUyAqIHBlc1RpbWVTY2FsZSArIHRoaXMuX2luaXREVFMsXG5cbiAgICAgIC8vIG9uZSBzYW1wbGUncyBkdXJhdGlvbiB2YWx1ZVxuICAgICAgc2FtcGxlRHVyYXRpb24gPSAxMDI0LFxuICAgICAgICAgIGZyYW1lRHVyYXRpb24gPSBwZXMybXA0U2NhbGVGYWN0b3IgKiBzYW1wbGVEdXJhdGlvbixcblxuXG4gICAgICAvLyBzYW1wbGVzIGNvdW50IG9mIHRoaXMgc2VnbWVudCdzIGR1cmF0aW9uXG4gICAgICBuYlNhbXBsZXMgPSBNYXRoLmNlaWwoKGVuZERUUyAtIHN0YXJ0RFRTKSAvIGZyYW1lRHVyYXRpb24pLFxuXG5cbiAgICAgIC8vIHNpbGVudCBmcmFtZVxuICAgICAgc2lsZW50RnJhbWUgPSBfYWFjMi5kZWZhdWx0LmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG5cbiAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ3JlbXV4IGVtcHR5IEF1ZGlvJyk7XG4gICAgICAvLyBDYW4ndCByZW11eCBpZiB3ZSBjYW4ndCBnZW5lcmF0ZSBhIHNpbGVudCBmcmFtZS4uLlxuICAgICAgaWYgKCFzaWxlbnRGcmFtZSkge1xuICAgICAgICBfbG9nZ2VyLmxvZ2dlci50cmFjZSgnVW5hYmxlIHRvIHJlbXV4RW1wdHlBdWRpbyBzaW5jZSB3ZSB3ZXJlIHVuYWJsZSB0byBnZXQgYSBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjIScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzYW1wbGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IHN0YXJ0RFRTICsgaSAqIGZyYW1lRHVyYXRpb247XG4gICAgICAgIHNhbXBsZXMucHVzaCh7IHVuaXQ6IHNpbGVudEZyYW1lLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wIH0pO1xuICAgICAgICB0cmFjay5sZW4gKz0gc2lsZW50RnJhbWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XG5cbiAgICAgIHRoaXMucmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVtdXhJRDMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW11eElEMyh0cmFjaywgdGltZU9mZnNldCkge1xuICAgICAgdmFyIGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoLFxuICAgICAgICAgIHNhbXBsZTtcbiAgICAgIC8vIGNvbnN1bWUgc2FtcGxlc1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgICAgICAgLy8gc2V0dGluZyBpZDMgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgICAgICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgICBzYW1wbGUucHRzID0gKHNhbXBsZS5wdHMgLSB0aGlzLl9pbml0UFRTKSAvIHRoaXMuUEVTX1RJTUVTQ0FMRTtcbiAgICAgICAgICBzYW1wbGUuZHRzID0gKHNhbXBsZS5kdHMgLSB0aGlzLl9pbml0RFRTKSAvIHRoaXMuUEVTX1RJTUVTQ0FMRTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHtcbiAgICAgICAgICBzYW1wbGVzOiB0cmFjay5zYW1wbGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgICB0aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW11eFRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW11eFRleHQodHJhY2ssIHRpbWVPZmZzZXQpIHtcbiAgICAgIHRyYWNrLnNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5wdHMgLSBiLnB0cztcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGgsXG4gICAgICAgICAgc2FtcGxlO1xuICAgICAgLy8gY29uc3VtZSBzYW1wbGVzXG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAgICAgICAvLyBzZXR0aW5nIHRleHQgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgICAgICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgICBzYW1wbGUucHRzID0gKHNhbXBsZS5wdHMgLSB0aGlzLl9pbml0UFRTKSAvIHRoaXMuUEVTX1RJTUVTQ0FMRTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHtcbiAgICAgICAgICBzYW1wbGVzOiB0cmFjay5zYW1wbGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgICB0aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfUFRTTm9ybWFsaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX1BUU05vcm1hbGl6ZSh2YWx1ZSwgcmVmZXJlbmNlKSB7XG4gICAgICB2YXIgb2Zmc2V0O1xuICAgICAgaWYgKHJlZmVyZW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWZlcmVuY2UgPCB2YWx1ZSkge1xuICAgICAgICAvLyAtIDJeMzNcbiAgICAgICAgb2Zmc2V0ID0gLTg1ODk5MzQ1OTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyArIDJeMzNcbiAgICAgICAgb2Zmc2V0ID0gODU4OTkzNDU5MjtcbiAgICAgIH1cbiAgICAgIC8qIFBUUyBpcyAzM2JpdCAoZnJvbSAwIHRvIDJeMzMgLTEpXG4gICAgICAgIGlmIGRpZmYgYmV0d2VlbiB2YWx1ZSBhbmQgcmVmZXJlbmNlIGlzIGJpZ2dlciB0aGFuIGhhbGYgb2YgdGhlIGFtcGxpdHVkZSAoMl4zMikgdGhlbiBpdCBtZWFucyB0aGF0XG4gICAgICAgIFBUUyBsb29waW5nIG9jY3VyZWQuIGZpbGwgdGhlIGdhcCAqL1xuICAgICAgd2hpbGUgKE1hdGguYWJzKHZhbHVlIC0gcmVmZXJlbmNlKSA+IDQyOTQ5NjcyOTYpIHtcbiAgICAgICAgdmFsdWUgKz0gb2Zmc2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNUDRSZW11eGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNUDRSZW11eGVyO1xuXG59LHtcIjMxXCI6MzEsXCIzM1wiOjMzLFwiMzRcIjozNCxcIjQyXCI6NDIsXCI1MFwiOjUwfV0sNDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpOyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBwYXNzdGhyb3VnaCByZW11eGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuXG52YXIgX2V2ZW50cyA9IF9kZXJlcV8oMzMpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUGFzc1Rocm91Z2hSZW11eGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXNzVGhyb3VnaFJlbXV4ZXIob2JzZXJ2ZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFzc1Rocm91Z2hSZW11eGVyKTtcblxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQYXNzVGhyb3VnaFJlbXV4ZXIsIFt7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fVxuICB9LCB7XG4gICAga2V5OiAncmVzZXRUaW1lU3RhbXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFRpbWVTdGFtcCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldEluaXRTZWdtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW11eCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgcmF3RGF0YSkge1xuICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcbiAgICAgIHZhciBzdHJlYW1UeXBlID0gJyc7XG4gICAgICBpZiAoYXVkaW9UcmFjaykge1xuICAgICAgICBzdHJlYW1UeXBlICs9ICdhdWRpbyc7XG4gICAgICB9XG4gICAgICBpZiAodmlkZW9UcmFjaykge1xuICAgICAgICBzdHJlYW1UeXBlICs9ICd2aWRlbyc7XG4gICAgICB9XG4gICAgICBvYnNlcnZlci50cmlnZ2VyKF9ldmVudHMyLmRlZmF1bHQuRlJBR19QQVJTSU5HX0RBVEEsIHtcbiAgICAgICAgZGF0YTE6IHJhd0RhdGEsXG4gICAgICAgIHN0YXJ0UFRTOiB0aW1lT2Zmc2V0LFxuICAgICAgICBzdGFydERUUzogdGltZU9mZnNldCxcbiAgICAgICAgdHlwZTogc3RyZWFtVHlwZSxcbiAgICAgICAgbmI6IDEsXG4gICAgICAgIGRyb3BwZWQ6IDBcbiAgICAgIH0pO1xuICAgICAgLy9ub3RpZnkgZW5kIG9mIHBhcnNpbmdcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoX2V2ZW50czIuZGVmYXVsdC5GUkFHX1BBUlNFRCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhc3NUaHJvdWdoUmVtdXhlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUGFzc1Rocm91Z2hSZW11eGVyO1xuXG59LHtcIjMzXCI6MzN9XSw0NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLztcbnZhciBBVFRSX0xJU1RfUkVHRVggPSAvXFxzKiguKz8pXFxzKj0oKD86XFxcIi4qP1xcXCIpfC4qPykoPzosfCQpL2c7XG5cbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20va2Fub25naWwvbm9kZS1tM3U4cGFyc2UvYmxvYi9tYXN0ZXIvYXR0cmxpc3QuanNcblxudmFyIEF0dHJMaXN0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBdHRyTGlzdChhdHRycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdHRyTGlzdCk7XG5cbiAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgYXR0cnMgPSBBdHRyTGlzdC5wYXJzZUF0dHJMaXN0KGF0dHJzKTtcbiAgICB9XG4gICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xuICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgIHRoaXNbYXR0cl0gPSBhdHRyc1thdHRyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQXR0ckxpc3QsIFt7XG4gICAga2V5OiAnZGVjaW1hbEludGVnZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNpbWFsSW50ZWdlcihhdHRyTmFtZSkge1xuICAgICAgdmFyIGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDEwKTtcbiAgICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoZXhhZGVjaW1hbEludGVnZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZXhhZGVjaW1hbEludGVnZXIoYXR0ck5hbWUpIHtcbiAgICAgIGlmICh0aGlzW2F0dHJOYW1lXSkge1xuICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSAodGhpc1thdHRyTmFtZV0gfHwgJzB4Jykuc2xpY2UoMik7XG4gICAgICAgIHN0cmluZ1ZhbHVlID0gKHN0cmluZ1ZhbHVlLmxlbmd0aCAmIDEgPyAnMCcgOiAnJykgKyBzdHJpbmdWYWx1ZTtcblxuICAgICAgICB2YXIgdmFsdWUgPSBuZXcgVWludDhBcnJheShzdHJpbmdWYWx1ZS5sZW5ndGggLyAyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZVtpXSA9IHBhcnNlSW50KHN0cmluZ1ZhbHVlLnNsaWNlKGkgKiAyLCBpICogMiArIDIpLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZXhhZGVjaW1hbEludGVnZXJBc051bWJlcihhdHRyTmFtZSkge1xuICAgICAgdmFyIGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcbiAgICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWNpbWFsRmxvYXRpbmdQb2ludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY2ltYWxGbG9hdGluZ1BvaW50KGF0dHJOYW1lKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzW2F0dHJOYW1lXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW51bWVyYXRlZFN0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudW1lcmF0ZWRTdHJpbmcoYXR0ck5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWNpbWFsUmVzb2x1dGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY2ltYWxSZXNvbHV0aW9uKGF0dHJOYW1lKSB7XG4gICAgICB2YXIgcmVzID0gREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYLmV4ZWModGhpc1thdHRyTmFtZV0pO1xuICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHBhcnNlSW50KHJlc1sxXSwgMTApLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KHJlc1syXSwgMTApXG4gICAgICB9O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAncGFyc2VBdHRyTGlzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlQXR0ckxpc3QoaW5wdXQpIHtcbiAgICAgIHZhciBtYXRjaCxcbiAgICAgICAgICBhdHRycyA9IHt9O1xuICAgICAgQVRUUl9MSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgICB3aGlsZSAoKG1hdGNoID0gQVRUUl9MSVNUX1JFR0VYLmV4ZWMoaW5wdXQpKSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBtYXRjaFsyXSxcbiAgICAgICAgICAgIHF1b3RlID0gJ1wiJztcblxuICAgICAgICBpZiAodmFsdWUuaW5kZXhPZihxdW90ZSkgPT09IDAgJiYgdmFsdWUubGFzdEluZGV4T2YocXVvdGUpID09PSB2YWx1ZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnNbbWF0Y2hbMV1dID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cnM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEF0dHJMaXN0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBBdHRyTGlzdDtcblxufSx7fV0sNDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBCaW5hcnlTZWFyY2ggPSB7XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgZm9yIGFuIGl0ZW0gaW4gYW4gYXJyYXkgd2hpY2ggbWF0Y2hlcyBhIGNlcnRhaW4gY29uZGl0aW9uLlxuICAgICAqIFRoaXMgcmVxdWlyZXMgdGhlIGNvbmRpdGlvbiB0byBvbmx5IG1hdGNoIG9uZSBpdGVtIGluIHRoZSBhcnJheSxcbiAgICAgKiBhbmQgZm9yIHRoZSBhcnJheSB0byBiZSBvcmRlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmlzb25GdW5jdGlvblxuICAgICAqICAgICAgQ2FsbGVkIGFuZCBwcm92aWRlZCBhIGNhbmRpZGF0ZSBpdGVtIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAgKiAgICAgIFNob3VsZCByZXR1cm46XG4gICAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICogICAgICAgICAgPiAxIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgaGlnaGVyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICogICAgICAgICAgPiAwIGlmIHRoZSBpdGVtIGlzIHRoZSBpdGVtIHlvdSdyZSBsb29raW5nIGZvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBvYmplY3QgaWYgaXQgaXMgZm91bmQgb3IgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VhcmNoOiBmdW5jdGlvbiBzZWFyY2gobGlzdCwgY29tcGFyaXNvbkZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBtaW5JbmRleCA9IDA7XG4gICAgICAgIHZhciBtYXhJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IG51bGw7XG4gICAgICAgIHZhciBjdXJyZW50RWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgICBjdXJyZW50SW5kZXggPSAobWluSW5kZXggKyBtYXhJbmRleCkgLyAyIHwgMDtcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gbGlzdFtjdXJyZW50SW5kZXhdO1xuXG4gICAgICAgICAgICB2YXIgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GdW5jdGlvbihjdXJyZW50RWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoY29tcGFyaXNvblJlc3VsdCA+IDApIHtcbiAgICAgICAgICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgbWF4SW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJpbmFyeVNlYXJjaDtcblxufSx7fV0sNDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICpcbiAqIFRoaXMgY29kZSB3YXMgcG9ydGVkIGZyb20gdGhlIGRhc2guanMgcHJvamVjdCBhdDpcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9ibG9iL2RldmVsb3BtZW50L2V4dGVybmFscy9jZWE2MDgtcGFyc2VyLmpzXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvY29tbWl0LzgyNjliMjZhNzYxZTA4NTNiYjIxZDc4NzgwZWQ5NDUxNDRlY2RkNGQjZGlmZi03MWJjMjk1YTJkNmI2YjcwOTNhMWQzMjkwZDUzYTRiMlxuICpcbiAqIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgYXBwZWFycyBiZWxvdzpcbiAqXG4gKiBUaGUgY29weXJpZ2h0IGluIHRoaXMgc29mdHdhcmUgaXMgYmVpbmcgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLFxuICogaW5jbHVkZWQgYmVsb3cuIFRoaXMgc29mdHdhcmUgbWF5IGJlIHN1YmplY3QgdG8gb3RoZXIgdGhpcmQgcGFydHkgYW5kIGNvbnRyaWJ1dG9yXG4gKiByaWdodHMsIGluY2x1ZGluZyBwYXRlbnQgcmlnaHRzLCBhbmQgbm8gc3VjaCByaWdodHMgYXJlIGdyYW50ZWQgdW5kZXIgdGhpcyBsaWNlbnNlLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE2LCBEQVNIIEluZHVzdHJ5IEZvcnVtLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yXG4gKiAgb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAyLiBOZWl0aGVyIHRoZSBuYW1lIG9mIERhc2ggSW5kdXN0cnkgRm9ydW0gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgQVMgSVMgQU5EIEFOWVxuICogIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuXG4gKiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcbiAqICBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUXG4gKiAgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLFxuICogIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqICBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG4vKipcbiAqICBFeGNlcHRpb25zIGZyb20gcmVndWxhciBBU0NJSS4gQ29kZVBvaW50cyBhcmUgbWFwcGVkIHRvIFVURi0xNiBjb2Rlc1xuICovXG5cbnZhciBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2RlcyA9IHtcbiAgICAweDJhOiAweGUxLCAvLyBsb3dlcmNhc2UgYSwgYWN1dGUgYWNjZW50XG4gICAgMHg1YzogMHhlOSwgLy8gbG93ZXJjYXNlIGUsIGFjdXRlIGFjY2VudFxuICAgIDB4NWU6IDB4ZWQsIC8vIGxvd2VyY2FzZSBpLCBhY3V0ZSBhY2NlbnRcbiAgICAweDVmOiAweGYzLCAvLyBsb3dlcmNhc2UgbywgYWN1dGUgYWNjZW50XG4gICAgMHg2MDogMHhmYSwgLy8gbG93ZXJjYXNlIHUsIGFjdXRlIGFjY2VudFxuICAgIDB4N2I6IDB4ZTcsIC8vIGxvd2VyY2FzZSBjIHdpdGggY2VkaWxsYVxuICAgIDB4N2M6IDB4ZjcsIC8vIGRpdmlzaW9uIHN5bWJvbFxuICAgIDB4N2Q6IDB4ZDEsIC8vIHVwcGVyY2FzZSBOIHRpbGRlXG4gICAgMHg3ZTogMHhmMSwgLy8gbG93ZXJjYXNlIG4gdGlsZGVcbiAgICAweDdmOiAweDI1ODgsIC8vIEZ1bGwgYmxvY2tcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAxNiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMSBBTkQgTE9XIEJFVFdFRU4gMHgzMCBBTkQgMHgzRlxuICAgIC8vIFRISVMgTUVBTlMgVEhBVCBcXHg1MCBNVVNUIEJFIEFEREVEIFRPIFRIRSBWQUxVRVNcbiAgICAweDgwOiAweGFlLCAvLyBSZWdpc3RlcmVkIHN5bWJvbCAoUilcbiAgICAweDgxOiAweGIwLCAvLyBkZWdyZWUgc2lnblxuICAgIDB4ODI6IDB4YmQsIC8vIDEvMiBzeW1ib2xcbiAgICAweDgzOiAweGJmLCAvLyBJbnZlcnRlZCAob3BlbikgcXVlc3Rpb24gbWFya1xuICAgIDB4ODQ6IDB4MjEyMiwgLy8gVHJhZGVtYXJrIHN5bWJvbCAoVE0pXG4gICAgMHg4NTogMHhhMiwgLy8gQ2VudHMgc3ltYm9sXG4gICAgMHg4NjogMHhhMywgLy8gUG91bmRzIHN0ZXJsaW5nXG4gICAgMHg4NzogMHgyNjZhLCAvLyBNdXNpYyA4J3RoIG5vdGVcbiAgICAweDg4OiAweGUwLCAvLyBsb3dlcmNhc2UgYSwgZ3JhdmUgYWNjZW50XG4gICAgMHg4OTogMHgyMCwgLy8gdHJhbnNwYXJlbnQgc3BhY2UgKHJlZ3VsYXIpXG4gICAgMHg4YTogMHhlOCwgLy8gbG93ZXJjYXNlIGUsIGdyYXZlIGFjY2VudFxuICAgIDB4OGI6IDB4ZTIsIC8vIGxvd2VyY2FzZSBhLCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIDB4OGM6IDB4ZWEsIC8vIGxvd2VyY2FzZSBlLCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIDB4OGQ6IDB4ZWUsIC8vIGxvd2VyY2FzZSBpLCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIDB4OGU6IDB4ZjQsIC8vIGxvd2VyY2FzZSBvLCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIDB4OGY6IDB4ZmIsIC8vIGxvd2VyY2FzZSB1LCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gICAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEyIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gICAgMHg5MDogMHhjMSwgLy8gY2FwaXRhbCBsZXR0ZXIgQSB3aXRoIGFjdXRlXG4gICAgMHg5MTogMHhjOSwgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGFjdXRlXG4gICAgMHg5MjogMHhkMywgLy8gY2FwaXRhbCBsZXR0ZXIgTyB3aXRoIGFjdXRlXG4gICAgMHg5MzogMHhkYSwgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGFjdXRlXG4gICAgMHg5NDogMHhkYywgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGRpYXJlc2lzXG4gICAgMHg5NTogMHhmYywgLy8gbG93ZXJjYXNlIGxldHRlciBVIHdpdGggZGlhZXJlc2lzXG4gICAgMHg5NjogMHgyMDE4LCAvLyBvcGVuaW5nIHNpbmdsZSBxdW90ZVxuICAgIDB4OTc6IDB4YTEsIC8vIGludmVydGVkIGV4Y2xhbWF0aW9uIG1hcmtcbiAgICAweDk4OiAweDJhLCAvLyBhc3Rlcmlza1xuICAgIDB4OTk6IDB4MjAxOSwgLy8gY2xvc2luZyBzaW5nbGUgcXVvdGVcbiAgICAweDlhOiAweDI1MDEsIC8vIGJveCBkcmF3aW5ncyBoZWF2eSBob3Jpem9udGFsXG4gICAgMHg5YjogMHhhOSwgLy8gY29weXJpZ2h0IHNpZ25cbiAgICAweDljOiAweDIxMjAsIC8vIFNlcnZpY2UgbWFya1xuICAgIDB4OWQ6IDB4MjAyMiwgLy8gKHJvdW5kKSBidWxsZXRcbiAgICAweDllOiAweDIwMWMsIC8vIExlZnQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gICAgMHg5ZjogMHgyMDFkLCAvLyBSaWdodCBkb3VibGUgcXVvdGF0aW9uIG1hcmtcbiAgICAweGEwOiAweGMwLCAvLyB1cHBlcmNhc2UgQSwgZ3JhdmUgYWNjZW50XG4gICAgMHhhMTogMHhjMiwgLy8gdXBwZXJjYXNlIEEsIGNpcmN1bWZsZXhcbiAgICAweGEyOiAweGM3LCAvLyB1cHBlcmNhc2UgQyB3aXRoIGNlZGlsbGFcbiAgICAweGEzOiAweGM4LCAvLyB1cHBlcmNhc2UgRSwgZ3JhdmUgYWNjZW50XG4gICAgMHhhNDogMHhjYSwgLy8gdXBwZXJjYXNlIEUsIGNpcmN1bWZsZXhcbiAgICAweGE1OiAweGNiLCAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggZGlhcmVzaXNcbiAgICAweGE2OiAweGViLCAvLyBsb3dlcmNhc2UgbGV0dGVyIGUgd2l0aCBkaWFyZXNpc1xuICAgIDB4YTc6IDB4Y2UsIC8vIHVwcGVyY2FzZSBJLCBjaXJjdW1mbGV4XG4gICAgMHhhODogMHhjZiwgLy8gdXBwZXJjYXNlIEksIHdpdGggZGlhcmVzaXNcbiAgICAweGE5OiAweGVmLCAvLyBsb3dlcmNhc2UgaSwgd2l0aCBkaWFyZXNpc1xuICAgIDB4YWE6IDB4ZDQsIC8vIHVwcGVyY2FzZSBPLCBjaXJjdW1mbGV4XG4gICAgMHhhYjogMHhkOSwgLy8gdXBwZXJjYXNlIFUsIGdyYXZlIGFjY2VudFxuICAgIDB4YWM6IDB4ZjksIC8vIGxvd2VyY2FzZSB1LCBncmF2ZSBhY2NlbnRcbiAgICAweGFkOiAweGRiLCAvLyB1cHBlcmNhc2UgVSwgY2lyY3VtZmxleFxuICAgIDB4YWU6IDB4YWIsIC8vIGxlZnQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gICAgMHhhZjogMHhiYiwgLy8gcmlnaHQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gICAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTMgQU5EIExPVyBCRVRXRUVOIDB4MjAgQU5EIDB4M0ZcbiAgICAweGIwOiAweGMzLCAvLyBVcHBlcmNhc2UgQSwgdGlsZGVcbiAgICAweGIxOiAweGUzLCAvLyBMb3dlcmNhc2UgYSwgdGlsZGVcbiAgICAweGIyOiAweGNkLCAvLyBVcHBlcmNhc2UgSSwgYWN1dGUgYWNjZW50XG4gICAgMHhiMzogMHhjYywgLy8gVXBwZXJjYXNlIEksIGdyYXZlIGFjY2VudFxuICAgIDB4YjQ6IDB4ZWMsIC8vIExvd2VyY2FzZSBpLCBncmF2ZSBhY2NlbnRcbiAgICAweGI1OiAweGQyLCAvLyBVcHBlcmNhc2UgTywgZ3JhdmUgYWNjZW50XG4gICAgMHhiNjogMHhmMiwgLy8gTG93ZXJjYXNlIG8sIGdyYXZlIGFjY2VudFxuICAgIDB4Yjc6IDB4ZDUsIC8vIFVwcGVyY2FzZSBPLCB0aWxkZVxuICAgIDB4Yjg6IDB4ZjUsIC8vIExvd2VyY2FzZSBvLCB0aWxkZVxuICAgIDB4Yjk6IDB4N2IsIC8vIE9wZW4gY3VybHkgYnJhY2VcbiAgICAweGJhOiAweDdkLCAvLyBDbG9zaW5nIGN1cmx5IGJyYWNlXG4gICAgMHhiYjogMHg1YywgLy8gQmFja3NsYXNoXG4gICAgMHhiYzogMHg1ZSwgLy8gQ2FyZXRcbiAgICAweGJkOiAweDVmLCAvLyBVbmRlcnNjb3JlXG4gICAgMHhiZTogMHg3YywgLy8gUGlwZSAodmVydGljYWwgbGluZSlcbiAgICAweGJmOiAweDIyM2MsIC8vIFRpbGRlIG9wZXJhdG9yXG4gICAgMHhjMDogMHhjNCwgLy8gVXBwZXJjYXNlIEEsIHVtbGF1dFxuICAgIDB4YzE6IDB4ZTQsIC8vIExvd2VyY2FzZSBBLCB1bWxhdXRcbiAgICAweGMyOiAweGQ2LCAvLyBVcHBlcmNhc2UgTywgdW1sYXV0XG4gICAgMHhjMzogMHhmNiwgLy8gTG93ZXJjYXNlIG8sIHVtbGF1dFxuICAgIDB4YzQ6IDB4ZGYsIC8vIEVzc3pldHQgKHNoYXJwIFMpXG4gICAgMHhjNTogMHhhNSwgLy8gWWVuIHN5bWJvbFxuICAgIDB4YzY6IDB4YTQsIC8vIEdlbmVyaWMgY3VycmVuY3kgc2lnblxuICAgIDB4Yzc6IDB4MjUwMywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHZlcnRpY2FsXG4gICAgMHhjODogMHhjNSwgLy8gVXBwZXJjYXNlIEEsIHJpbmdcbiAgICAweGM5OiAweGU1LCAvLyBMb3dlcmNhc2UgQSwgcmluZ1xuICAgIDB4Y2E6IDB4ZDgsIC8vIFVwcGVyY2FzZSBPLCBzdHJva2VcbiAgICAweGNiOiAweGY4LCAvLyBMb3dlcmNhc2Ugbywgc3Ryb2tcbiAgICAweGNjOiAweDI1MGYsIC8vIEJveCBkcmF3aW5ncyBoZWF2eSBkb3duIGFuZCByaWdodFxuICAgIDB4Y2Q6IDB4MjUxMywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIGxlZnRcbiAgICAweGNlOiAweDI1MTcsIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgcmlnaHRcbiAgICAweGNmOiAweDI1MWIgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCBsZWZ0XG59O1xuXG4vKipcbiAqIFV0aWxzXG4gKi9cbnZhciBnZXRDaGFyRm9yQnl0ZSA9IGZ1bmN0aW9uIGdldENoYXJGb3JCeXRlKGJ5dGUpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBieXRlO1xuICAgIGlmIChzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlcy5oYXNPd25Qcm9wZXJ0eShieXRlKSkge1xuICAgICAgICBjaGFyQ29kZSA9IHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzW2J5dGVdO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59O1xuXG52YXIgTlJfUk9XUyA9IDE1LFxuICAgIE5SX0NPTFMgPSAxMDA7XG4vLyBUYWJsZXMgdG8gbG9vayB1cCByb3cgZnJvbSBQQUMgZGF0YVxudmFyIHJvd3NMb3dDaDEgPSB7IDB4MTE6IDEsIDB4MTI6IDMsIDB4MTU6IDUsIDB4MTY6IDcsIDB4MTc6IDksIDB4MTA6IDExLCAweDEzOiAxMiwgMHgxNDogMTQgfTtcbnZhciByb3dzSGlnaENoMSA9IHsgMHgxMTogMiwgMHgxMjogNCwgMHgxNTogNiwgMHgxNjogOCwgMHgxNzogMTAsIDB4MTM6IDEzLCAweDE0OiAxNSB9O1xudmFyIHJvd3NMb3dDaDIgPSB7IDB4MTk6IDEsIDB4MUE6IDMsIDB4MUQ6IDUsIDB4MUU6IDcsIDB4MUY6IDksIDB4MTg6IDExLCAweDFCOiAxMiwgMHgxQzogMTQgfTtcbnZhciByb3dzSGlnaENoMiA9IHsgMHgxOTogMiwgMHgxQTogNCwgMHgxRDogNiwgMHgxRTogOCwgMHgxRjogMTAsIDB4MUI6IDEzLCAweDFDOiAxNSB9O1xuXG52YXIgYmFja2dyb3VuZENvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICdibGFjaycsICd0cmFuc3BhcmVudCddO1xuXG4vKipcbiAqIFNpbXBsZSBsb2dnZXIgY2xhc3MgdG8gYmUgYWJsZSB0byB3cml0ZSB3aXRoIHRpbWUtc3RhbXBzIGFuZCBmaWx0ZXIgb24gbGV2ZWwuXG4gKi9cbnZhciBsb2dnZXIgPSB7XG4gICAgdmVyYm9zZUZpbHRlcjogeyAnREFUQSc6IDMsICdERUJVRyc6IDMsICdJTkZPJzogMiwgJ1dBUk5JTkcnOiAyLCAnVEVYVCc6IDEsICdFUlJPUic6IDAgfSxcbiAgICB0aW1lOiBudWxsLFxuICAgIHZlcmJvc2VMZXZlbDogMCwgLy8gT25seSB3cml0ZSBlcnJvcnNcbiAgICBzZXRUaW1lOiBmdW5jdGlvbiBzZXRUaW1lKG5ld1RpbWUpIHtcbiAgICAgICAgdGhpcy50aW1lID0gbmV3VGltZTtcbiAgICB9LFxuICAgIGxvZzogZnVuY3Rpb24gbG9nKHNldmVyaXR5LCBtc2cpIHtcbiAgICAgICAgdmFyIG1pbkxldmVsID0gdGhpcy52ZXJib3NlRmlsdGVyW3NldmVyaXR5XTtcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZUxldmVsID49IG1pbkxldmVsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnRpbWUgKyAnIFsnICsgc2V2ZXJpdHkgKyAnXSAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBudW1BcnJheVRvSGV4QXJyYXkgPSBmdW5jdGlvbiBudW1BcnJheVRvSGV4QXJyYXkobnVtQXJyYXkpIHtcbiAgICB2YXIgaGV4QXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGhleEFycmF5LnB1c2gobnVtQXJyYXlbal0udG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleEFycmF5O1xufTtcblxudmFyIFBlblN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBlblN0YXRlKGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBlblN0YXRlKTtcblxuICAgICAgICB0aGlzLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kIHx8ICd3aGl0ZSc7XG4gICAgICAgIHRoaXMudW5kZXJsaW5lID0gdW5kZXJsaW5lIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLml0YWxpY3MgPSBpdGFsaWNzIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kIHx8ICdibGFjayc7XG4gICAgICAgIHRoaXMuZmxhc2ggPSBmbGFzaCB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUGVuU3RhdGUsIFt7XG4gICAgICAgIGtleTogJ3Jlc2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICAgICAgICAgIHRoaXMudW5kZXJsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLml0YWxpY3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZCA9ICdibGFjayc7XG4gICAgICAgICAgICB0aGlzLmZsYXNoID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldFN0eWxlcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlicyA9IFsnZm9yZWdyb3VuZCcsICd1bmRlcmxpbmUnLCAnaXRhbGljcycsICdiYWNrZ3JvdW5kJywgJ2ZsYXNoJ107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhdHRyaWJzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzRGVmYXVsdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0RlZmF1bHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JlZ3JvdW5kID09PSAnd2hpdGUnICYmICF0aGlzLnVuZGVybGluZSAmJiAhdGhpcy5pdGFsaWNzICYmIHRoaXMuYmFja2dyb3VuZCA9PT0gJ2JsYWNrJyAmJiAhdGhpcy5mbGFzaDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXF1YWxzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yZWdyb3VuZCA9PT0gb3RoZXIuZm9yZWdyb3VuZCAmJiB0aGlzLnVuZGVybGluZSA9PT0gb3RoZXIudW5kZXJsaW5lICYmIHRoaXMuaXRhbGljcyA9PT0gb3RoZXIuaXRhbGljcyAmJiB0aGlzLmJhY2tncm91bmQgPT09IG90aGVyLmJhY2tncm91bmQgJiYgdGhpcy5mbGFzaCA9PT0gb3RoZXIuZmxhc2g7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvcHknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29weShuZXdQZW5TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gbmV3UGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICAgICAgICAgIHRoaXMudW5kZXJsaW5lID0gbmV3UGVuU3RhdGUudW5kZXJsaW5lO1xuICAgICAgICAgICAgdGhpcy5pdGFsaWNzID0gbmV3UGVuU3RhdGUuaXRhbGljcztcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ld1BlblN0YXRlLmJhY2tncm91bmQ7XG4gICAgICAgICAgICB0aGlzLmZsYXNoID0gbmV3UGVuU3RhdGUuZmxhc2g7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICdjb2xvcj0nICsgdGhpcy5mb3JlZ3JvdW5kICsgJywgdW5kZXJsaW5lPScgKyB0aGlzLnVuZGVybGluZSArICcsIGl0YWxpY3M9JyArIHRoaXMuaXRhbGljcyArICcsIGJhY2tncm91bmQ9JyArIHRoaXMuYmFja2dyb3VuZCArICcsIGZsYXNoPScgKyB0aGlzLmZsYXNoO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFBlblN0YXRlO1xufSgpO1xuXG4vKipcbiAqIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggc3R5bGluZyBhbmQgYmFja2dyb3VuZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFN0eWxlZFVuaWNvZGVDaGFyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxlZFVuaWNvZGVDaGFyKHVjaGFyLCBmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHlsZWRVbmljb2RlQ2hhcik7XG5cbiAgICAgICAgdGhpcy51Y2hhciA9IHVjaGFyIHx8ICcgJzsgLy8gdW5pY29kZSBjaGFyYWN0ZXJcbiAgICAgICAgdGhpcy5wZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZShmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU3R5bGVkVW5pY29kZUNoYXIsIFt7XG4gICAgICAgIGtleTogJ3Jlc2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgdGhpcy51Y2hhciA9ICcgJztcbiAgICAgICAgICAgIHRoaXMucGVuU3RhdGUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0Q2hhcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDaGFyKHVjaGFyLCBuZXdQZW5TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy51Y2hhciA9IHVjaGFyO1xuICAgICAgICAgICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0UGVuU3RhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGVuU3RhdGUobmV3UGVuU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2VxdWFscycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVjaGFyID09PSBvdGhlci51Y2hhciAmJiB0aGlzLnBlblN0YXRlLmVxdWFscyhvdGhlci5wZW5TdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvcHknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29weShuZXdDaGFyKSB7XG4gICAgICAgICAgICB0aGlzLnVjaGFyID0gbmV3Q2hhci51Y2hhcjtcbiAgICAgICAgICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdDaGFyLnBlblN0YXRlKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNFbXB0eScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudWNoYXIgPT09ICcgJyAmJiB0aGlzLnBlblN0YXRlLmlzRGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFN0eWxlZFVuaWNvZGVDaGFyO1xufSgpO1xuXG4vKipcbiAqIENFQS02MDggcm93IGNvbnNpc3Rpbmcgb2YgTlJfQ09MUyBpbnN0YW5jZXMgb2YgU3R5bGVkVW5pY29kZUNoYXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUm93KCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm93KTtcblxuICAgICAgICB0aGlzLmNoYXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNoYXJzLnB1c2gobmV3IFN0eWxlZFVuaWNvZGVDaGFyKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5jdXJyUGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUm93LCBbe1xuICAgICAgICBrZXk6ICdlcXVhbHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICB2YXIgZXF1YWwgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uZXF1YWxzKG90aGVyLmNoYXJzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXF1YWw7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvcHknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29weShvdGhlcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJzW2ldLmNvcHkob3RoZXIuY2hhcnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc0VtcHR5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbXB0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgU2V0IHRoZSBjdXJzb3IgdG8gYSB2YWxpZCBjb2x1bW4uXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRDdXJzb3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zICE9PSBhYnNQb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGFic1BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA8IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdOZWdhdGl2ZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucG9zID4gTlJfQ09MUykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ1RvbyBsYXJnZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IE5SX0NPTFM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZSB0aGUgY3Vyc29yIHJlbGF0aXZlIHRvIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtb3ZlQ3Vyc29yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVDdXJzb3IocmVsUG9zKSB7XG4gICAgICAgICAgICB2YXIgbmV3UG9zID0gdGhpcy5wb3MgKyByZWxQb3M7XG4gICAgICAgICAgICBpZiAocmVsUG9zID4gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBvcyArIDE7IGkgPCBuZXdQb3MgKyAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyc1tpXS5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IobmV3UG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYWNrc3BhY2UsIG1vdmUgb25lIHN0ZXAgYmFjayBhbmQgY2xlYXIgY2hhcmFjdGVyLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYmFja1NwYWNlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJhY2tTcGFjZSgpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvcigtMSk7XG4gICAgICAgICAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKCcgJywgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpbnNlcnRDaGFyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydENoYXIoYnl0ZSkge1xuICAgICAgICAgICAgaWYgKGJ5dGUgPj0gMHg5MCkge1xuICAgICAgICAgICAgICAgIC8vRXh0ZW5kZWQgY2hhclxuICAgICAgICAgICAgICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hhciA9IGdldENoYXJGb3JCeXRlKGJ5dGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdDYW5ub3QgaW5zZXJ0ICcgKyBieXRlLnRvU3RyaW5nKDE2KSArICcgKCcgKyBjaGFyICsgJykgYXQgcG9zaXRpb24gJyArIHRoaXMucG9zICsgJy4gU2tpcHBpbmcgaXQhJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcihjaGFyLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3IoMSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NsZWFyRnJvbVBvcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckZyb21Qb3Moc3RhcnRQb3MpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gc3RhcnRQb3M7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJzW2ldLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NsZWFyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhckZyb21Qb3MoMCk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB0aGlzLmN1cnJQZW5TdGF0ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjbGVhclRvRW5kT2ZSb3cnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJUb0VuZE9mUm93KCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhckZyb21Qb3ModGhpcy5wb3MpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRUZXh0U3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHRTdHJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgY2hhcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGFyID0gdGhpcy5jaGFyc1tpXS51Y2hhcjtcbiAgICAgICAgICAgICAgICBpZiAoY2hhciAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYXJzLnB1c2goY2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0UGVuU3R5bGVzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBlblN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyclBlblN0YXRlLnNldFN0eWxlcyhzdHlsZXMpO1xuICAgICAgICAgICAgdmFyIGN1cnJDaGFyID0gdGhpcy5jaGFyc1t0aGlzLnBvc107XG4gICAgICAgICAgICBjdXJyQ2hhci5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUm93O1xufSgpO1xuXG4vKipcbiAqIEtlZXAgYSBDRUEtNjA4IHNjcmVlbiBvZiAzMngxNSBzdHlsZWQgY2hhcmFjdGVyc1xuICogQGNvbnN0cnVjdG9yXG4qL1xuXG5cbnZhciBDYXB0aW9uU2NyZWVuID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhcHRpb25TY3JlZW4oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYXB0aW9uU2NyZWVuKTtcblxuICAgICAgICB0aGlzLnJvd3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucm93cy5wdXNoKG5ldyBSb3coKSk7IC8vIE5vdGUgdGhhdCB3ZSB1c2UgemVyby1iYXNlZCBudW1iZXJpbmcgKDAtMTQpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gICAgICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDYXB0aW9uU2NyZWVuLCBbe1xuICAgICAgICBrZXk6ICdyZXNldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXF1YWxzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgdmFyIGVxdWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uZXF1YWxzKG90aGVyLnJvd3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlcXVhbDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29weScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KG90aGVyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucm93c1tpXS5jb3B5KG90aGVyLnJvd3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc0VtcHR5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucm93c1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdiYWNrU3BhY2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmFja1NwYWNlKCkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICAgICAgcm93LmJhY2tTcGFjZSgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjbGVhclRvRW5kT2ZSb3cnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJUb0VuZE9mUm93KCkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICAgICAgcm93LmNsZWFyVG9FbmRPZlJvdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydCBhIGNoYXJhY3RlciAod2l0aG91dCBzdHlsaW5nKSBpbiB0aGUgY3VycmVudCByb3cuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpbnNlcnRDaGFyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydENoYXIoY2hhcikge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICAgICAgcm93Lmluc2VydENoYXIoY2hhcik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldFBlbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQZW4oc3R5bGVzKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgICAgICByb3cuc2V0UGVuU3R5bGVzKHN0eWxlcyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21vdmVDdXJzb3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZUN1cnNvcihyZWxQb3MpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgICAgIHJvdy5tb3ZlQ3Vyc29yKHJlbFBvcyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldEN1cnNvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXJzb3IoYWJzUG9zKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ3NldEN1cnNvcjogJyArIGFic1Bvcyk7XG4gICAgICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgICAgICByb3cuc2V0Q3Vyc29yKGFic1Bvcyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldFBBQycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQQUMocGFjRGF0YSkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdwYWNEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KHBhY0RhdGEpKTtcbiAgICAgICAgICAgIHZhciBuZXdSb3cgPSBwYWNEYXRhLnJvdyAtIDE7XG4gICAgICAgICAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgJiYgbmV3Um93IDwgdGhpcy5uclJvbGxVcFJvd3MgLSAxKSB7XG4gICAgICAgICAgICAgICAgbmV3Um93ID0gdGhpcy5uclJvbGxVcFJvd3MgLSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL01ha2Ugc3VyZSB0aGlzIG9ubHkgYWZmZWN0cyBSb2xsLXVwIENhcHRpb25zIGJ5IGNoZWNraW5nIHRoaXMubnJSb2xsVXBSb3dzXG4gICAgICAgICAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgJiYgdGhpcy5jdXJyUm93ICE9PSBuZXdSb3cpIHtcbiAgICAgICAgICAgICAgICAvL2NsZWFyIGFsbCByb3dzIGZpcnN0XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9Db3B5IHRoaXMubnJSb2xsVXBSb3dzIHJvd3MgZnJvbSBsYXN0T3V0cHV0U2NyZWVuIGFuZCBwbGFjZSBpdCBpbiB0aGUgbmV3Um93IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgLy90b3BSb3dJbmRleCAtIHRoZSBzdGFydCBvZiByb3dzIHRvIGNvcHkgKGluY2x1c2l2ZSBpbmRleClcbiAgICAgICAgICAgICAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7XG4gICAgICAgICAgICAgICAgLy9XZSBvbmx5IGNvcHkgaWYgdGhlIGxhc3QgcG9zaXRpb24gd2FzIGFscmVhZHkgc2hvd24uXG4gICAgICAgICAgICAgICAgLy9XZSB1c2UgdGhlIGN1ZVN0YXJ0VGltZSB2YWx1ZSB0byBjaGVjayB0aGlzLlxuICAgICAgICAgICAgICAgIHZhciBsYXN0T3V0cHV0U2NyZWVuID0gdGhpcy5sYXN0T3V0cHV0U2NyZWVuO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0T3V0cHV0U2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2TGluZVRpbWUgPSBsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXhdLmN1ZVN0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZMaW5lVGltZSAmJiBwcmV2TGluZVRpbWUgPCBsb2dnZXIudGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMubnJSb2xsVXBSb3dzOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dzW25ld1JvdyAtIHRoaXMubnJSb2xsVXBSb3dzICsgX2kgKyAxXS5jb3B5KGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleCArIF9pXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3VyclJvdyA9IG5ld1JvdztcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgICAgIGlmIChwYWNEYXRhLmluZGVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRlbnQgPSBwYWNEYXRhLmluZGVudDtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlBvcyA9IE1hdGgubWF4KGluZGVudCAtIDEsIDApO1xuICAgICAgICAgICAgICAgIHJvdy5zZXRDdXJzb3IocGFjRGF0YS5pbmRlbnQpO1xuICAgICAgICAgICAgICAgIHBhY0RhdGEuY29sb3IgPSByb3cuY2hhcnNbcHJldlBvc10ucGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSB7IGZvcmVncm91bmQ6IHBhY0RhdGEuY29sb3IsIHVuZGVybGluZTogcGFjRGF0YS51bmRlcmxpbmUsIGl0YWxpY3M6IHBhY0RhdGEuaXRhbGljcywgYmFja2dyb3VuZDogJ2JsYWNrJywgZmxhc2g6IGZhbHNlIH07XG4gICAgICAgICAgICB0aGlzLnNldFBlbihzdHlsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBiYWNrZ3JvdW5kL2V4dHJhIGZvcmVncm91bmQsIGJ1dCBmaXJzdCBkbyBiYWNrX3NwYWNlLCBhbmQgdGhlbiBpbnNlcnQgc3BhY2UgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldEJrZ0RhdGEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QmtnRGF0YShia2dEYXRhKSB7XG5cbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnYmtnRGF0YSA9ICcgKyBKU09OLnN0cmluZ2lmeShia2dEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRQZW4oYmtnRGF0YSk7XG4gICAgICAgICAgICB0aGlzLmluc2VydENoYXIoMHgyMCk7IC8vU3BhY2VcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0Um9sbFVwUm93cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSb2xsVXBSb3dzKG5yUm93cykge1xuICAgICAgICAgICAgdGhpcy5uclJvbGxVcFJvd3MgPSBuclJvd3M7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JvbGxVcCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByb2xsVXAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdyb2xsX3VwIGJ1dCBuclJvbGxVcFJvd3Mgbm90IHNldCB5ZXQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vTm90IHByb3Blcmx5IHNldHVwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdURVhUJywgdGhpcy5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICAgICAgICAgIHZhciB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSB0aGlzLm5yUm9sbFVwUm93cztcbiAgICAgICAgICAgIHZhciB0b3BSb3cgPSB0aGlzLnJvd3Muc3BsaWNlKHRvcFJvd0luZGV4LCAxKVswXTtcbiAgICAgICAgICAgIHRvcFJvdy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5yb3dzLnNwbGljZSh0aGlzLmN1cnJSb3csIDAsIHRvcFJvdyk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JvbGxpbmcgdXAnKTtcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnVEVYVCcsIHRoaXMuZ2V0X2Rpc3BsYXlfdGV4dCgpKVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbGwgbm9uLWVtcHR5IHJvd3Mgd2l0aCBhcyB1bmljb2RlIHRleHQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXREaXNwbGF5VGV4dCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaXNwbGF5VGV4dChhc09uZVJvdykge1xuICAgICAgICAgICAgYXNPbmVSb3cgPSBhc09uZVJvdyB8fCBmYWxzZTtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5VGV4dCA9IFtdO1xuICAgICAgICAgICAgdmFyIHRleHQgPSAnJztcbiAgICAgICAgICAgIHZhciByb3dOciA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93VGV4dCA9IHRoaXMucm93c1tpXS5nZXRUZXh0U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvd1RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93TnIgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKCdSb3cgJyArIHJvd05yICsgJzogXFwnJyArIHJvd1RleHQgKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKHJvd1RleHQudHJpbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXNwbGF5VGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSAnWycgKyBkaXNwbGF5VGV4dC5qb2luKCcgfCAnKSArICddJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZGlzcGxheVRleHQuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFRleHRBbmRGb3JtYXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dEFuZEZvcm1hdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd3M7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2FwdGlvblNjcmVlbjtcbn0oKTtcblxuLy92YXIgbW9kZXMgPSBbJ01PREVfUk9MTC1VUCcsICdNT0RFX1BPUC1PTicsICdNT0RFX1BBSU5ULU9OJywgJ01PREVfVEVYVCddO1xuXG52YXIgQ2VhNjA4Q2hhbm5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDZWE2MDhDaGFubmVsKGNoYW5uZWxOdW1iZXIsIG91dHB1dEZpbHRlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2VhNjA4Q2hhbm5lbCk7XG5cbiAgICAgICAgdGhpcy5jaE5yID0gY2hhbm5lbE51bWJlcjtcbiAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBvdXRwdXRGaWx0ZXI7XG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IDA7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4oKTtcbiAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgICAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MgLSAxXTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXJlIGEgY3VlIHN0YXJ0ZWQuXG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENlYTYwOENoYW5uZWwsIFt7XG4gICAgICAgIGtleTogJ3Jlc2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MgLSAxXTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3RDdWVFbmRUaW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0SGFuZGxlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIYW5kbGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0RmlsdGVyO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRIYW5kbGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhhbmRsZXIobmV3SGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBuZXdIYW5kbGVyO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRQQUMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UEFDKHBhY0RhdGEpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UEFDKHBhY0RhdGEpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRCa2dEYXRhJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEJrZ0RhdGEoYmtnRGF0YSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRNb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1vZGUobmV3TW9kZSkge1xuICAgICAgICAgICAgaWYgKG5ld01vZGUgPT09IHRoaXMubW9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ01PREU9JyArIG5ld01vZGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4ucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGUgIT09ICdNT0RFX1JPTEwtVVAnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaW5zZXJ0Q2hhcnMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Q2hhcnMoY2hhcnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuLmluc2VydENoYXIoY2hhcnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjcmVlbiA9IHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5ID8gJ0RJU1AnIDogJ05PTl9ESVNQJztcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCBzY3JlZW4gKyAnOiAnICsgdGhpcy53cml0ZVNjcmVlbi5nZXREaXNwbGF5VGV4dCh0cnVlKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QQUlOVC1PTicgfHwgdGhpcy5tb2RlID09PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCAnRElTUExBWUVEOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjY1JDTCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjY1JDTCgpIHtcbiAgICAgICAgICAgIC8vIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcgKHN3aXRjaCBtb2RlIHRvIFBvcCBPbilcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUkNMIC0gUmVzdW1lIENhcHRpb24gTG9hZGluZycpO1xuICAgICAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BPUC1PTicpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjY0JTJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNjQlMoKSB7XG4gICAgICAgICAgICAvLyBCYWNrU3BhY2VcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnQlMgLSBCYWNrU3BhY2UnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1RFWFQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5iYWNrU3BhY2UoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjY0FPRicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjY0FPRigpIHtcbiAgICAgICAgICAgIC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPZmYpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NjQU9OJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNjQU9OKCkge1xuICAgICAgICAgICAgLy8gUmVzZXJ2ZWQgKGZvcm1lcmx5IEFsYXJtIE9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjY0RFUicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjY0RFUigpIHtcbiAgICAgICAgICAgIC8vIERlbGV0ZSB0byBFbmQgb2YgUm93XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0RFUi0gRGVsZXRlIHRvIEVuZCBvZiBSb3cnKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4uY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2NSVScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjY1JVKG5yUm93cykge1xuICAgICAgICAgICAgLy9Sb2xsLVVwIENhcHRpb25zLTIsMyxvciA0IFJvd3NcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUlUoJyArIG5yUm93cyArICcpIC0gUm9sbCBVcCcpO1xuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1JPTEwtVVAnKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0Um9sbFVwUm93cyhuclJvd3MpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjY0ZPTicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjY0ZPTigpIHtcbiAgICAgICAgICAgIC8vRmxhc2ggT25cbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRk9OIC0gRmxhc2ggT24nKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHsgZmxhc2g6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NjUkRDJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNjUkRDKCkge1xuICAgICAgICAgICAgLy8gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nIChzd2l0Y2ggbW9kZSB0byBQYWludE9uKVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSREMgLSBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QQUlOVC1PTicpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjY1RSJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNjVFIoKSB7XG4gICAgICAgICAgICAvLyBUZXh0IFJlc3RhcnQgaW4gdGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdUUicpO1xuICAgICAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2NSVEQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2NSVEQoKSB7XG4gICAgICAgICAgICAvLyBSZXN1bWUgVGV4dCBEaXNwbGF5IGluIFRleHQgbW9kZSAobm90IHN1cHBvcnRlZCwgaG93ZXZlcilcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUlREJyk7XG4gICAgICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjY0VETScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjY0VETSgpIHtcbiAgICAgICAgICAgIC8vIEVyYXNlIERpc3BsYXllZCBNZW1vcnlcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjY0NSJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNjQ1IoKSB7XG4gICAgICAgICAgICAvLyBDYXJyaWFnZSBSZXR1cm5cbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0NSIC0gQ2FycmlhZ2UgUmV0dXJuJyk7XG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnJvbGxVcCgpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NjRU5NJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNjRU5NKCkge1xuICAgICAgICAgICAgLy9FcmFzZSBOb24tRGlzcGxheWVkIE1lbW9yeVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2NFT0MnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2NFT0MoKSB7XG4gICAgICAgICAgICAvL0VuZCBvZiBDYXB0aW9uIChGbGlwIE1lbW9yaWVzKVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdFT0MgLSBFbmQgT2YgQ2FwdGlvbicpO1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgICAgICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gdG1wO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdURVhUJywgJ0RJU1A6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjY1RPJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNjVE8obnJDb2xzKSB7XG4gICAgICAgICAgICAvLyBUYWIgT2Zmc2V0IDEsMiwgb3IgMyBjb2x1bW5zXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1RPKCcgKyBuckNvbHMgKyAnKSAtIFRhYiBPZmZzZXQnKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4ubW92ZUN1cnNvcihuckNvbHMpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjY01JRFJPVycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjY01JRFJPVyhzZWNvbmRCeXRlKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBNSURST1cgY29tbWFuZFxuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHsgZmxhc2g6IGZhbHNlIH07XG4gICAgICAgICAgICBzdHlsZXMudW5kZXJsaW5lID0gc2Vjb25kQnl0ZSAlIDIgPT09IDE7XG4gICAgICAgICAgICBzdHlsZXMuaXRhbGljcyA9IHNlY29uZEJ5dGUgPj0gMHgyZTtcbiAgICAgICAgICAgIGlmICghc3R5bGVzLml0YWxpY3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IE1hdGguZmxvb3Ioc2Vjb25kQnl0ZSAvIDIpIC0gMHgxMDtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJ107XG4gICAgICAgICAgICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSBjb2xvcnNbY29sb3JJbmRleF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnTUlEUk9XOiAnICsgSlNPTi5zdHJpbmdpZnkoc3R5bGVzKSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbihzdHlsZXMpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvdXRwdXREYXRhVXBkYXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERhdGFVcGRhdGUoKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGxvZ2dlci50aW1lO1xuICAgICAgICAgICAgaWYgKHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIudXBkYXRlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci51cGRhdGVEYXRhKHQsIHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VlU3RhcnRUaW1lID09PSBudWxsICYmICF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgb2YgYSBuZXcgY3VlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmVxdWFscyh0aGlzLmxhc3RPdXRwdXRTY3JlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmxhc3RPdXRwdXRTY3JlZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4uY29weSh0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2N1ZVNwbGl0QXRUaW1lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGN1ZVNwbGl0QXRUaW1lKHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdCwgdGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2VhNjA4Q2hhbm5lbDtcbn0oKTtcblxudmFyIENlYTYwOFBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDZWE2MDhQYXJzZXIoZmllbGQsIG91dDEsIG91dDIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENlYTYwOFBhcnNlcik7XG5cbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkIHx8IDE7XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IFtvdXQxLCBvdXQyXTtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IFtuZXcgQ2VhNjA4Q2hhbm5lbCgxLCBvdXQxKSwgbmV3IENlYTYwOENoYW5uZWwoMiwgb3V0MildO1xuICAgICAgICB0aGlzLmN1cnJDaE5yID0gLTE7IC8vIFdpbGwgYmUgMSBvciAyXG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsOyAvLyBGaXJzdCBieXRlIG9mIGxhc3QgY29tbWFuZFxuICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDsgLy8gU2Vjb25kIGJ5dGUgb2YgbGFzdCBjb21tYW5kXG4gICAgICAgIHRoaXMuYnVmZmVyZWREYXRhID0gW107XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzID0geyAncGFkZGluZyc6IDAsICdjaGFyJzogMCwgJ2NtZCc6IDAsICdvdGhlcic6IDAgfTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2VhNjA4UGFyc2VyLCBbe1xuICAgICAgICBrZXk6ICdnZXRIYW5kbGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhhbmRsZXIoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW2luZGV4XS5nZXRIYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldEhhbmRsZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SGFuZGxlcihpbmRleCwgbmV3SGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tpbmRleF0uc2V0SGFuZGxlcihuZXdIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgZGF0YSBmb3IgdGltZSB0IGluIGZvcm1zIG9mIGxpc3Qgb2YgYnl0ZXMgKHVuc2lnbmVkIGludHMpLiBUaGUgYnl0ZXMgYXJlIHRyZWF0ZWQgYXMgcGFpcnMuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhZGREYXRhJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZERhdGEodCwgYnl0ZUxpc3QpIHtcbiAgICAgICAgICAgIHZhciBjbWRGb3VuZCxcbiAgICAgICAgICAgICAgICBhLFxuICAgICAgICAgICAgICAgIGIsXG4gICAgICAgICAgICAgICAgY2hhcnNGb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLmxhc3RUaW1lID0gdDtcbiAgICAgICAgICAgIGxvZ2dlci5zZXRUaW1lKHQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVMaXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgYSA9IGJ5dGVMaXN0W2ldICYgMHg3ZjtcbiAgICAgICAgICAgICAgICBiID0gYnl0ZUxpc3RbaSArIDFdICYgMHg3ZjtcbiAgICAgICAgICAgICAgICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLnBhZGRpbmcgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnREFUQScsICdbJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pICsgJ10gLT4gKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZUNtZChhLCBiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZU1pZHJvdyhhLCBiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VQQUMoYSwgYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNGb3VuZCA9IHRoaXMucGFyc2VDaGFycyhhLCBiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJDaE5yICYmIHRoaXMuY3VyckNoTnIgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1t0aGlzLmN1cnJDaE5yIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5pbnNlcnRDaGFycyhjaGFyc0ZvdW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdObyBjaGFubmVsIGZvdW5kIHlldC4gVEVYVC1NT0RFPycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbWRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5jbWQgKz0gMjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMuY2hhciArPSAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLm90aGVyICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1dBUk5JTkcnLCAnQ291bGRuXFwndCBwYXJzZSBjbGVhbmVkIGRhdGEgJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyBvcmlnOiAnICsgbnVtQXJyYXlUb0hleEFycmF5KFtieXRlTGlzdFtpXSwgYnl0ZUxpc3RbaSArIDFdXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZSBDb21tYW5kLlxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGVsbHMgaWYgYSBjb21tYW5kIHdhcyBmb3VuZFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGFyc2VDbWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VDbWQoYSwgYikge1xuICAgICAgICAgICAgdmFyIGNoTnIgPSBudWxsO1xuXG4gICAgICAgICAgICB2YXIgY29uZDEgPSAoYSA9PT0gMHgxNCB8fCBhID09PSAweDFDKSAmJiAweDIwIDw9IGIgJiYgYiA8PSAweDJGO1xuICAgICAgICAgICAgdmFyIGNvbmQyID0gKGEgPT09IDB4MTcgfHwgYSA9PT0gMHgxRikgJiYgMHgyMSA8PSBiICYmIGIgPD0gMHgyMztcbiAgICAgICAgICAgIGlmICghKGNvbmQxIHx8IGNvbmQyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdSZXBlYXRlZCBjb21tYW5kICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSBpcyBkcm9wcGVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MTcpIHtcbiAgICAgICAgICAgICAgICBjaE5yID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hOciA9IDI7IC8vIChhID09PSAweDFDIHx8IGE9PT0gMHgxZilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnIgLSAxXTtcblxuICAgICAgICAgICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykge1xuICAgICAgICAgICAgICAgIGlmIChiID09PSAweDIwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSQ0woKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jY0JTKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDIyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NBT0YoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jY0FPTigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNjREVSKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI1KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSgyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JVKDMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNykge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNjUlUoNCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NGT04oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JEQygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyQSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNjVFIoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JURCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyQykge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNjRURNKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJEKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NDUigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyRSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNjRU5NKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJGKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NFT0MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NUTyhiIC0gMHgyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gYTtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBiO1xuICAgICAgICAgICAgdGhpcy5jdXJyQ2hOciA9IGNoTnI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZSBtaWRyb3cgc3R5bGluZyBjb21tYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGFyc2VNaWRyb3cnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VNaWRyb3coYSwgYikge1xuICAgICAgICAgICAgdmFyIGNoTnIgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoKGEgPT09IDB4MTEgfHwgYSA9PT0gMHgxOSkgJiYgMHgyMCA8PSBiICYmIGIgPD0gMHgyZikge1xuICAgICAgICAgICAgICAgIGlmIChhID09PSAweDExKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoTnIgPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoTnIgPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hOciAhPT0gdGhpcy5jdXJyQ2hOcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdNaXNtYXRjaCBjaGFubmVsIGluIG1pZHJvdyBwYXJzaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnIgLSAxXTtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjTUlEUk9XKGIpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ01JRFJPVyAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2UgUHJlYWJsZSBBY2Nlc3MgQ29kZXMgKFRhYmxlIDUzKS5cbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIFBBQyBmb3VuZFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGFyc2VQQUMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VQQUMoYSwgYikge1xuXG4gICAgICAgICAgICB2YXIgY2hOciA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcm93ID0gbnVsbDtcblxuICAgICAgICAgICAgdmFyIGNhc2UxID0gKDB4MTEgPD0gYSAmJiBhIDw9IDB4MTcgfHwgMHgxOSA8PSBhICYmIGEgPD0gMHgxRikgJiYgMHg0MCA8PSBiICYmIGIgPD0gMHg3RjtcbiAgICAgICAgICAgIHZhciBjYXNlMiA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIDB4NDAgPD0gYiAmJiBiIDw9IDB4NUY7XG4gICAgICAgICAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhID09PSB0aGlzLmxhc3RDbWRBICYmIGIgPT09IHRoaXMubGFzdENtZEIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gUmVwZWF0ZWQgY29tbWFuZHMgYXJlIGRyb3BwZWQgKG9uY2UpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoTnIgPSBhIDw9IDB4MTcgPyAxIDogMjtcblxuICAgICAgICAgICAgaWYgKDB4NDAgPD0gYiAmJiBiIDw9IDB4NUYpIHtcbiAgICAgICAgICAgICAgICByb3cgPSBjaE5yID09PSAxID8gcm93c0xvd0NoMVthXSA6IHJvd3NMb3dDaDJbYV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDB4NjAgPD0gYiA8PSAweDdGXG4gICAgICAgICAgICAgICAgcm93ID0gY2hOciA9PT0gMSA/IHJvd3NIaWdoQ2gxW2FdIDogcm93c0hpZ2hDaDJbYV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFjRGF0YSA9IHRoaXMuaW50ZXJwcmV0UEFDKHJvdywgYik7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOciAtIDFdO1xuICAgICAgICAgICAgY2hhbm5lbC5zZXRQQUMocGFjRGF0YSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gYTtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBiO1xuICAgICAgICAgICAgdGhpcy5jdXJyQ2hOciA9IGNoTnI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcnByZXQgdGhlIHNlY29uZCBieXRlIG9mIHRoZSBwYWMsIGFuZCByZXR1cm4gdGhlIGluZm9ybWF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBwYWNEYXRhIHdpdGggc3R5bGUgcGFyYW1ldGVycy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2ludGVycHJldFBBQycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnByZXRQQUMocm93LCBieXRlKSB7XG4gICAgICAgICAgICB2YXIgcGFjSW5kZXggPSBieXRlO1xuICAgICAgICAgICAgdmFyIHBhY0RhdGEgPSB7IGNvbG9yOiBudWxsLCBpdGFsaWNzOiBmYWxzZSwgaW5kZW50OiBudWxsLCB1bmRlcmxpbmU6IGZhbHNlLCByb3c6IHJvdyB9O1xuXG4gICAgICAgICAgICBpZiAoYnl0ZSA+IDB4NUYpIHtcbiAgICAgICAgICAgICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDYwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFjRGF0YS51bmRlcmxpbmUgPSAocGFjSW5kZXggJiAxKSA9PT0gMTtcbiAgICAgICAgICAgIGlmIChwYWNJbmRleCA8PSAweGQpIHtcbiAgICAgICAgICAgICAgICBwYWNEYXRhLmNvbG9yID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ3doaXRlJ11bTWF0aC5mbG9vcihwYWNJbmRleCAvIDIpXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFjSW5kZXggPD0gMHhmKSB7XG4gICAgICAgICAgICAgICAgcGFjRGF0YS5pdGFsaWNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYWNEYXRhLmNvbG9yID0gJ3doaXRlJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFjRGF0YS5pbmRlbnQgPSBNYXRoLmZsb29yKChwYWNJbmRleCAtIDB4MTApIC8gMikgKiA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhY0RhdGE7IC8vIE5vdGUgdGhhdCByb3cgaGFzIHplcm8gb2Zmc2V0LiBUaGUgc3BlYyB1c2VzIDEuXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2UgY2hhcmFjdGVycy5cbiAgICAgICAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCAxIHRvIDIgY29kZXMgY29ycmVzcG9uZGluZyB0byBjaGFycywgaWYgZm91bmQuIG51bGwgb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGFyc2VDaGFycycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUNoYXJzKGEsIGIpIHtcblxuICAgICAgICAgICAgdmFyIGNoYW5uZWxOciA9IG51bGwsXG4gICAgICAgICAgICAgICAgY2hhckNvZGVzID0gbnVsbCxcbiAgICAgICAgICAgICAgICBjaGFyQ29kZTEgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoYSA+PSAweDE5KSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbE5yID0gMjtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZTEgPSBhIC0gODtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbE5yID0gMTtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZTEgPSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDB4MTEgPD0gY2hhckNvZGUxICYmIGNoYXJDb2RlMSA8PSAweDEzKSB7XG4gICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICB2YXIgb25lQ29kZSA9IGI7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMSkge1xuICAgICAgICAgICAgICAgICAgICBvbmVDb2RlID0gYiArIDB4NTA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZTEgPT09IDB4MTIpIHtcbiAgICAgICAgICAgICAgICAgICAgb25lQ29kZSA9IGIgKyAweDcwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9uZUNvZGUgPSBiICsgMHg5MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdTcGVjaWFsIGNoYXIgXFwnJyArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgJ1xcJyBpbiBjaGFubmVsICcgKyBjaGFubmVsTnIpO1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlcyA9IFtvbmVDb2RlXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoMHgyMCA8PSBhICYmIGEgPD0gMHg3Zikge1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlcyA9IGIgPT09IDAgPyBbYV0gOiBbYSwgYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhckNvZGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhleENvZGVzID0gbnVtQXJyYXlUb0hleEFycmF5KGNoYXJDb2Rlcyk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnQ2hhciBjb2RlcyA9ICAnICsgaGV4Q29kZXMuam9pbignLCcpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGFyQ29kZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgKiBQYXJzZSBleHRlbmRlZCBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBuZXcgZm9yZWdyb3VuZCBjb2xvciBibGFjay5cbiAgICAgICAgKiBAcmV0dXJuc3tCb29sZWFufSBUZWxscyBpZiBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXJlIGZvdW5kXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3BhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyhhLCBiKSB7XG4gICAgICAgICAgICB2YXIgYmtnRGF0YSwgaW5kZXgsIGNoTnIsIGNoYW5uZWw7XG5cbiAgICAgICAgICAgIHZhciBjYXNlMSA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIDB4MjAgPD0gYiAmJiBiIDw9IDB4MmY7XG4gICAgICAgICAgICB2YXIgY2FzZTIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiAweDJkIDw9IGIgJiYgYiA8PSAweDJmO1xuICAgICAgICAgICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmtnRGF0YSA9IHt9O1xuICAgICAgICAgICAgaWYgKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoYiAtIDB4MjApIC8gMik7XG4gICAgICAgICAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGIgJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJrZ0RhdGEuYmFja2dyb3VuZCArICdfc2VtaSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJkKSB7XG4gICAgICAgICAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmtnRGF0YS5mb3JlZ3JvdW5kID0gJ2JsYWNrJztcbiAgICAgICAgICAgICAgICBpZiAoYiA9PT0gMHgyZikge1xuICAgICAgICAgICAgICAgICAgICBia2dEYXRhLnVuZGVybGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hOciA9IGEgPCAweDE4ID8gMSA6IDI7XG4gICAgICAgICAgICBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG4gICAgICAgICAgICBjaGFubmVsLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXQgc3RhdGUgb2YgcGFyc2VyIGFuZCBpdHMgY2hhbm5lbHMuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXNldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbaV0ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXIgdGhlIGdlbmVyYXRpb24gb2YgYSBjdWUsIGFuZCB0aGUgc3RhcnQgb2YgYSBuZXcgb25lIGlmIGRpc3BsYXlTY3JlZW5zIGFyZSBub3QgZW1wdHkuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjdWVTcGxpdEF0VGltZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxzW2ldLmN1ZVNwbGl0QXRUaW1lKHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDZWE2MDhQYXJzZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENlYTYwOFBhcnNlcjtcblxufSx7fV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Z0dHBhcnNlciA9IF9kZXJlcV8oNTMpO1xuXG52YXIgQ3VlcyA9IHtcblxuICBuZXdDdWU6IGZ1bmN0aW9uIG5ld0N1ZSh0cmFjaywgc3RhcnRUaW1lLCBlbmRUaW1lLCBjYXB0aW9uU2NyZWVuKSB7XG4gICAgdmFyIHJvdztcbiAgICB2YXIgY3VlO1xuICAgIHZhciBpbmRlbnRpbmc7XG4gICAgdmFyIGluZGVudDtcbiAgICB2YXIgdGV4dDtcbiAgICB2YXIgVlRUQ3VlID0gd2luZG93LlZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xuXG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBjYXB0aW9uU2NyZWVuLnJvd3MubGVuZ3RoOyByKyspIHtcbiAgICAgIHJvdyA9IGNhcHRpb25TY3JlZW4ucm93c1tyXTtcbiAgICAgIGluZGVudGluZyA9IHRydWU7XG4gICAgICBpbmRlbnQgPSAwO1xuICAgICAgdGV4dCA9ICcnO1xuXG4gICAgICBpZiAoIXJvdy5pc0VtcHR5KCkpIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCByb3cuY2hhcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICBpZiAocm93LmNoYXJzW2NdLnVjaGFyLm1hdGNoKC9cXHMvKSAmJiBpbmRlbnRpbmcpIHtcbiAgICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ICs9IHJvdy5jaGFyc1tjXS51Y2hhcjtcbiAgICAgICAgICAgIGluZGVudGluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL1RvIGJlIHVzZWQgZm9yIGNsZWFuaW5nLXVwIG9ycGhhbmVkIHJvbGwtdXAgY2FwdGlvbnNcbiAgICAgICAgcm93LmN1ZVN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgY3VlID0gbmV3IFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsICgwLCBfdnR0cGFyc2VyLmZpeExpbmVCcmVha3MpKHRleHQudHJpbSgpKSk7XG5cbiAgICAgICAgaWYgKGluZGVudCA+PSAxNikge1xuICAgICAgICAgIGluZGVudC0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVlRUQ3VlLmxpbmUgZ2V0J3MgZmxha2V5IHdoZW4gdXNpbmcgY29udHJvbHMsIHNvIGxldCdzIG5vdyBpbmNsdWRlIGxpbmUgMTMmMTRcbiAgICAgICAgLy8gYWxzbywgZHJvcCBsaW5lIDEgc2luY2UgaXQncyB0byBjbG9zZSB0byB0aGUgdG9wXG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvLykpIHtcbiAgICAgICAgICBjdWUubGluZSA9IHIgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1ZS5saW5lID0gciA+IDcgPyByIC0gMiA6IHIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGN1ZS5hbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgLy8gQ2xhbXAgdGhlIHBvc2l0aW9uIGJldHdlZW4gMCBhbmQgMTAwIC0gaWYgb3V0IG9mIHRoZXNlIGJvdW5kcywgRmlyZWZveCB0aHJvd3MgYW4gZXhjZXB0aW9uIGFuZCBjYXB0aW9ucyBicmVha1xuICAgICAgICBjdWUucG9zaXRpb24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIDEwMCAqIChpbmRlbnQgLyAzMikgKyAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLy8pID8gNTAgOiAwKSkpO1xuICAgICAgICB0cmFjay5hZGRDdWUoY3VlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDdWVzO1xuXG59LHtcIjUzXCI6NTN9XSw0OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLypcbiAqIGNvbXB1dGUgYW4gRXhwb25lbnRpYWwgV2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VcbiAqIC0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW92aW5nX2F2ZXJhZ2UjRXhwb25lbnRpYWxfbW92aW5nX2F2ZXJhZ2VcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqL1xuXG52YXIgRVdNQSA9IGZ1bmN0aW9uICgpIHtcblxuICAvLyAgQWJvdXQgaGFsZiBvZiB0aGUgZXN0aW1hdGVkIHZhbHVlIHdpbGwgYmUgZnJvbSB0aGUgbGFzdCB8aGFsZkxpZmV8IHNhbXBsZXMgYnkgd2VpZ2h0LlxuICBmdW5jdGlvbiBFV01BKGhhbGZMaWZlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVXTUEpO1xuXG4gICAgLy8gTGFyZ2VyIHZhbHVlcyBvZiBhbHBoYSBleHBpcmUgaGlzdG9yaWNhbCBkYXRhIG1vcmUgc2xvd2x5LlxuICAgIHRoaXMuYWxwaGFfID0gaGFsZkxpZmUgPyBNYXRoLmV4cChNYXRoLmxvZygwLjUpIC8gaGFsZkxpZmUpIDogMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IDA7XG4gICAgdGhpcy50b3RhbFdlaWdodF8gPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVXTUEsIFt7XG4gICAga2V5OiBcInNhbXBsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYW1wbGUod2VpZ2h0LCB2YWx1ZSkge1xuICAgICAgdmFyIGFkakFscGhhID0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHdlaWdodCk7XG4gICAgICB0aGlzLmVzdGltYXRlXyA9IHZhbHVlICogKDEgLSBhZGpBbHBoYSkgKyBhZGpBbHBoYSAqIHRoaXMuZXN0aW1hdGVfO1xuICAgICAgdGhpcy50b3RhbFdlaWdodF8gKz0gd2VpZ2h0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb3RhbFdlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb3RhbFdlaWdodCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvdGFsV2VpZ2h0XztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RXN0aW1hdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RXN0aW1hdGUoKSB7XG4gICAgICBpZiAodGhpcy5hbHBoYV8pIHtcbiAgICAgICAgdmFyIHplcm9GYWN0b3IgPSAxIC0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHRoaXMudG90YWxXZWlnaHRfKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfIC8gemVyb0ZhY3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXztcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRVdNQTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRVdNQTtcblxufSx7fV0sNTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgZmFrZUxvZ2dlciA9IHtcbiAgdHJhY2U6IG5vb3AsXG4gIGRlYnVnOiBub29wLFxuICBsb2c6IG5vb3AsXG4gIHdhcm46IG5vb3AsXG4gIGluZm86IG5vb3AsXG4gIGVycm9yOiBub29wXG59O1xuXG52YXIgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuXG4vKmdsb2JhbHMgc2VsZjogZmFsc2UgKi9cblxuLy9sZXQgbGFzdENhbGxUaW1lO1xuLy8gZnVuY3Rpb24gZm9ybWF0TXNnV2l0aFRpbWVJbmZvKHR5cGUsIG1zZykge1xuLy8gICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuLy8gICBjb25zdCBkaWZmID0gbGFzdENhbGxUaW1lID8gJysnICsgKG5vdyAtIGxhc3RDYWxsVGltZSkgOiAnMCc7XG4vLyAgIGxhc3RDYWxsVGltZSA9IG5vdztcbi8vICAgbXNnID0gKG5ldyBEYXRlKG5vdykpLnRvSVNPU3RyaW5nKCkgKyAnIHwgWycgKyAgdHlwZSArICddID4gJyArIG1zZyArICcgKCAnICsgZGlmZiArICcgbXMgKSc7XG4vLyAgIHJldHVybiBtc2c7XG4vLyB9XG5cbmZ1bmN0aW9uIGZvcm1hdE1zZyh0eXBlLCBtc2cpIHtcbiAgbXNnID0gJ1snICsgdHlwZSArICddID4gJyArIG1zZztcbiAgcmV0dXJuIG1zZztcbn1cblxuZnVuY3Rpb24gY29uc29sZVByaW50Rm4odHlwZSkge1xuICB2YXIgZnVuYyA9IHNlbGYuY29uc29sZVt0eXBlXTtcbiAgaWYgKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3NbMF0pIHtcbiAgICAgICAgYXJnc1swXSA9IGZvcm1hdE1zZyh0eXBlLCBhcmdzWzBdKTtcbiAgICAgIH1cbiAgICAgIGZ1bmMuYXBwbHkoc2VsZi5jb25zb2xlLCBhcmdzKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBub29wO1xufVxuXG5mdW5jdGlvbiBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jdGlvbnMgPSBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgZnVuY3Rpb25zW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgZnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBleHBvcnRlZExvZ2dlclt0eXBlXSA9IGRlYnVnQ29uZmlnW3R5cGVdID8gZGVidWdDb25maWdbdHlwZV0uYmluZChkZWJ1Z0NvbmZpZykgOiBjb25zb2xlUHJpbnRGbih0eXBlKTtcbiAgfSk7XG59XG5cbnZhciBlbmFibGVMb2dzID0gZXhwb3J0cy5lbmFibGVMb2dzID0gZnVuY3Rpb24gZW5hYmxlTG9ncyhkZWJ1Z0NvbmZpZykge1xuICBpZiAoZGVidWdDb25maWcgPT09IHRydWUgfHwgKHR5cGVvZiBkZWJ1Z0NvbmZpZyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGVidWdDb25maWcpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcsXG4gICAgLy8gUmVtb3ZlIG91dCBmcm9tIGxpc3QgaGVyZSB0byBoYXJkLWRpc2FibGUgYSBsb2ctbGV2ZWxcbiAgICAvLyd0cmFjZScsXG4gICAgJ2RlYnVnJywgJ2xvZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InKTtcbiAgICAvLyBTb21lIGJyb3dzZXJzIGRvbid0IGFsbG93IHRvIHVzZSBiaW5kIG9uIGNvbnNvbGUgb2JqZWN0IGFueXdheVxuICAgIC8vIGZhbGxiYWNrIHRvIGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgdHJ5IHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyLmxvZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICB9XG59O1xuXG52YXIgbG9nZ2VyID0gZXhwb3J0cy5sb2dnZXIgPSBleHBvcnRlZExvZ2dlcjtcblxufSx7fV0sNTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqICBUaW1lUmFuZ2VzIHRvIHN0cmluZyBoZWxwZXJcbiAqL1xuXG52YXIgVGltZVJhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGltZVJhbmdlcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZVJhbmdlcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGltZVJhbmdlcywgbnVsbCwgW3tcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKHIpIHtcbiAgICAgIHZhciBsb2cgPSAnJyxcbiAgICAgICAgICBsZW4gPSByLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbG9nICs9ICdbJyArIHIuc3RhcnQoaSkudG9GaXhlZCgzKSArICcsJyArIHIuZW5kKGkpLnRvRml4ZWQoMykgKyAnXSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9nO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUaW1lUmFuZ2VzO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUaW1lUmFuZ2VzO1xuXG59LHt9XSw1MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZUVEN1ZSkge1xuICAgIHJldHVybiB3aW5kb3cuVlRUQ3VlO1xuICB9XG5cbiAgdmFyIGF1dG9LZXl3b3JkID0gJ2F1dG8nO1xuICB2YXIgZGlyZWN0aW9uU2V0dGluZyA9IHtcbiAgICAnJzogdHJ1ZSxcbiAgICBscjogdHJ1ZSxcbiAgICBybDogdHJ1ZVxuICB9O1xuICB2YXIgYWxpZ25TZXR0aW5nID0ge1xuICAgIHN0YXJ0OiB0cnVlLFxuICAgIG1pZGRsZTogdHJ1ZSxcbiAgICBlbmQ6IHRydWUsXG4gICAgbGVmdDogdHJ1ZSxcbiAgICByaWdodDogdHJ1ZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGRpciA9IGRpcmVjdGlvblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gICAgcmV0dXJuIGRpciA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRBbGlnblNldHRpbmcodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgYWxpZ24gPSBhbGlnblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gICAgcmV0dXJuIGFsaWduID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuICAgIHZhciBpID0gMTtcbiAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwIGluIGNvYmopIHtcbiAgICAgICAgb2JqW3BdID0gY29ialtwXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gVlRUQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xuICAgIHZhciBjdWUgPSB0aGlzO1xuICAgIHZhciBpc0lFOCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gKC9NU0lFXFxzOFxcLjAvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICAgICk7XG4gICAgfSgpO1xuICAgIHZhciBiYXNlT2JqID0ge307XG5cbiAgICBpZiAoaXNJRTgpIHtcbiAgICAgIGN1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlT2JqLmVudW1lcmFibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNoaW0gaW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGluXG4gICAgICogdGhlIHNwZWMuXG4gICAgICovXG5cbiAgICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxuICAgIC8vIHRvIHJlY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZS4gVGhpcyBsZXRzIHVzIGNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGVcbiAgICAvLyBsYXppbHkuXG4gICAgY3VlLmhhc0JlZW5SZXNldCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVlRUQ3VlIGFuZCBUZXh0VHJhY2tDdWUgcHJvcGVydGllc1xuICAgICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxuICAgICAqL1xuXG4gICAgdmFyIF9pZCA9ICcnO1xuICAgIHZhciBfcGF1c2VPbkV4aXQgPSBmYWxzZTtcbiAgICB2YXIgX3N0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICB2YXIgX2VuZFRpbWUgPSBlbmRUaW1lO1xuICAgIHZhciBfdGV4dCA9IHRleHQ7XG4gICAgdmFyIF9yZWdpb24gPSBudWxsO1xuICAgIHZhciBfdmVydGljYWwgPSAnJztcbiAgICB2YXIgX3NuYXBUb0xpbmVzID0gdHJ1ZTtcbiAgICB2YXIgX2xpbmUgPSAnYXV0byc7XG4gICAgdmFyIF9saW5lQWxpZ24gPSAnc3RhcnQnO1xuICAgIHZhciBfcG9zaXRpb24gPSA1MDtcbiAgICB2YXIgX3Bvc2l0aW9uQWxpZ24gPSAnbWlkZGxlJztcbiAgICB2YXIgX3NpemUgPSA1MDtcbiAgICB2YXIgX2FsaWduID0gJ21pZGRsZSc7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnaWQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2lkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9pZCA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3BhdXNlT25FeGl0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9wYXVzZU9uRXhpdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfcGF1c2VPbkV4aXQgPSAhIXZhbHVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzdGFydFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3N0YXJ0VGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0YXJ0IHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3N0YXJ0VGltZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2VuZFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2VuZFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBfZW5kVGltZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3RleHQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3RleHQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX3RleHQgPSAnJyArIHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3JlZ2lvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9yZWdpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd2ZXJ0aWNhbCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfdmVydGljYWw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfdmVydGljYWwgPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NuYXBUb0xpbmVzJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfc25hcFRvTGluZXMgPSAhIXZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2xpbmU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgJiYgdmFsdWUgIT09IGF1dG9LZXl3b3JkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG51bWJlciBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9saW5lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZUFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lQWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncG9zaXRpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3Bvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncG9zaXRpb25BbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfcG9zaXRpb25BbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfcG9zaXRpb25BbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc2l6ZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaXplIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3NpemUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdhbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfYWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2FsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIE90aGVyIDx0cmFjaz4gc3BlYyBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICAgKi9cblxuICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS12aWRlby1lbGVtZW50Lmh0bWwjdGV4dC10cmFjay1jdWUtZGlzcGxheS1zdGF0ZVxuICAgIGN1ZS5kaXNwbGF5U3RhdGUgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNJRTgpIHtcbiAgICAgIHJldHVybiBjdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZUVEN1ZSBtZXRob2RzXG4gICAqL1xuXG4gIFZUVEN1ZS5wcm90b3R5cGUuZ2V0Q3VlQXNIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEFzc3VtZSBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSBpcyBvbiB0aGUgZ2xvYmFsLlxuICAgIHZhciBXZWJWVFQgPSB3aW5kb3cuV2ViVlRUO1xuICAgIHJldHVybiBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSh3aW5kb3csIHRoaXMudGV4dCk7XG4gIH07XG5cbiAgcmV0dXJuIFZUVEN1ZTtcbn0oKTtcblxufSx7fV0sNTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5maXhMaW5lQnJlYWtzID0gdW5kZWZpbmVkO1xuXG52YXIgX3Z0dGN1ZSA9IF9kZXJlcV8oNTIpO1xuXG52YXIgX3Z0dGN1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92dHRjdWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoKSB7XG4gIHJldHVybiB7XG4gICAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGUoZGF0YSkge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xuICAgIH1cbiAgfTtcbn07IC8qXG4gICAgKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcy9ibG9iL21hc3Rlci9kaXN0L3Z0dC5qcyNMMTcxNlxuICAgICovXG5cbmZ1bmN0aW9uIFZUVFBhcnNlcigpIHtcbiAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gIHRoaXMuc3RhdGUgPSAnSU5JVElBTCc7XG4gIHRoaXMuYnVmZmVyID0gJyc7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCk7XG4gIHRoaXMucmVnaW9uTGlzdCA9IFtdO1xufVxuXG4vLyBUcnkgdG8gcGFyc2UgaW5wdXQgYXMgYSB0aW1lIHN0YW1wLlxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAoaW5wdXQpIHtcblxuICBmdW5jdGlvbiBjb21wdXRlU2Vjb25kcyhoLCBtLCBzLCBmKSB7XG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIChmIHwgMCkgLyAxMDAwO1xuICB9XG5cbiAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihcXGQrKTooXFxkezJ9KSg6XFxkezJ9KT9cXC4oXFxkezN9KS8pO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChtWzNdKSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCBtWzNdLnJlcGxhY2UoJzonLCAnJyksIG1bNF0pO1xuICB9IGVsc2UgaWYgKG1bMV0gPiA1OSkge1xuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXS5bbWlsbGlzZWNvbmRzXVxuICAgIC8vIEZpcnN0IHBvc2l0aW9uIGlzIGhvdXJzIGFzIGl0J3Mgb3ZlciA1OS5cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgMCwgbVs0XSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMoMCwgbVsxXSwgbVsyXSwgbVs0XSk7XG4gIH1cbn1cblxuLy8gQSBzZXR0aW5ncyBvYmplY3QgaG9sZHMga2V5L3ZhbHVlIHBhaXJzIGFuZCB3aWxsIGlnbm9yZSBhbnl0aGluZyBidXQgdGhlIGZpcnN0XG4vLyBhc3NpZ25tZW50IHRvIGEgc3BlY2lmaWMga2V5LlxuZnVuY3Rpb24gU2V0dGluZ3MoKSB7XG4gIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuU2V0dGluZ3MucHJvdG90eXBlID0ge1xuICAvLyBPbmx5IGFjY2VwdCB0aGUgZmlyc3QgYXNzaWdubWVudCB0byBhbnkga2V5LlxuICBzZXQ6IGZ1bmN0aW9uIHNldChrLCB2KSB7XG4gICAgaWYgKCF0aGlzLmdldChrKSAmJiB2ICE9PSAnJykge1xuICAgICAgdGhpcy52YWx1ZXNba10gPSB2O1xuICAgIH1cbiAgfSxcbiAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgYSBrZXksIG9yIGEgZGVmYXVsdCB2YWx1ZS5cbiAgLy8gSWYgJ2RlZmF1bHRLZXknIGlzIHBhc3NlZCB0aGVuICdkZmx0JyBpcyBhc3N1bWVkIHRvIGJlIGFuIG9iamVjdCB3aXRoXG4gIC8vIGEgbnVtYmVyIG9mIHBvc3NpYmxlIGRlZmF1bHQgdmFsdWVzIGFzIHByb3BlcnRpZXMgd2hlcmUgJ2RlZmF1bHRLZXknIGlzXG4gIC8vIHRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBjaG9zZW47IG90aGVyd2lzZSBpdCdzIGFzc3VtZWQgdG8gYmVcbiAgLy8gYSBzaW5nbGUgdmFsdWUuXG4gIGdldDogZnVuY3Rpb24gZ2V0KGssIGRmbHQsIGRlZmF1bHRLZXkpIHtcbiAgICBpZiAoZGVmYXVsdEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0W2RlZmF1bHRLZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHQ7XG4gIH0sXG4gIC8vIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBhIHZhbHVlIGZvciBhIGtleS5cbiAgaGFzOiBmdW5jdGlvbiBoYXMoaykge1xuICAgIHJldHVybiBrIGluIHRoaXMudmFsdWVzO1xuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgYWx0OiBmdW5jdGlvbiBhbHQoaywgdiwgYSkge1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYS5sZW5ndGg7ICsrbikge1xuICAgICAgaWYgKHYgPT09IGFbbl0pIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICBpbnRlZ2VyOiBmdW5jdGlvbiBpbnRlZ2VyKGssIHYpIHtcbiAgICBpZiAoL14tP1xcZCskLy50ZXN0KHYpKSB7XG4gICAgICAvLyBpbnRlZ2VyXG4gICAgICB0aGlzLnNldChrLCBwYXJzZUludCh2LCAxMCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCBwZXJjZW50YWdlLlxuICBwZXJjZW50OiBmdW5jdGlvbiBwZXJjZW50KGssIHYpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAobSA9IHYubWF0Y2goL14oW1xcZF17MSwzfSkoXFwuW1xcZF0qKT8lJC8pKSB7XG4gICAgICB2ID0gcGFyc2VGbG9hdCh2KTtcbiAgICAgIGlmICh2ID49IDAgJiYgdiA8PSAxMDApIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBpbnB1dCBpbnRvIGdyb3VwcyBzZXBhcmF0ZWQgYnkgJ2dyb3VwRGVsaW0nLCBhbmRcbi8vIGludGVycHJldGUgZWFjaCBncm91cCBhcyBhIGtleS92YWx1ZSBwYWlyIHNlcGFyYXRlZCBieSAna2V5VmFsdWVEZWxpbScuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMoaW5wdXQsIGNhbGxiYWNrLCBrZXlWYWx1ZURlbGltLCBncm91cERlbGltKSB7XG4gIHZhciBncm91cHMgPSBncm91cERlbGltID8gaW5wdXQuc3BsaXQoZ3JvdXBEZWxpbSkgOiBbaW5wdXRdO1xuICBmb3IgKHZhciBpIGluIGdyb3Vwcykge1xuICAgIGlmICh0eXBlb2YgZ3JvdXBzW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBrdiA9IGdyb3Vwc1tpXS5zcGxpdChrZXlWYWx1ZURlbGltKTtcbiAgICBpZiAoa3YubGVuZ3RoICE9PSAyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGsgPSBrdlswXTtcbiAgICB2YXIgdiA9IGt2WzFdO1xuICAgIGNhbGxiYWNrKGssIHYpO1xuICB9XG59XG5cbnZhciBkZWZhdWx0cyA9IG5ldyBfdnR0Y3VlMi5kZWZhdWx0KDAsIDAsIDApO1xuLy8gJ21pZGRsZScgd2FzIGNoYW5nZWQgdG8gJ2NlbnRlcicgaW4gdGhlIHNwZWM6IGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2VidnR0L3B1bGwvMjQ0XG4vLyBDaHJvbWUgYW5kIFNhZmFyaSBkb24ndCB5ZXQgc3VwcG9ydCB0aGlzIGNoYW5nZSwgYnV0IEZGIGRvZXNcbnZhciBjZW50ZXIgPSBkZWZhdWx0cy5hbGlnbiA9PT0gJ21pZGRsZScgPyAnbWlkZGxlJyA6ICdjZW50ZXInO1xuXG5mdW5jdGlvbiBwYXJzZUN1ZShpbnB1dCwgY3VlLCByZWdpb25MaXN0KSB7XG4gIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCBpbnB1dCBpZiB3ZSBuZWVkIHRvIHRocm93IGFuIGVycm9yLlxuICB2YXIgb0lucHV0ID0gaW5wdXQ7XG4gIC8vIDQuMSBXZWJWVFQgdGltZXN0YW1wXG4gIGZ1bmN0aW9uIGNvbnN1bWVUaW1lU3RhbXAoKSB7XG4gICAgdmFyIHRzID0gcGFyc2VUaW1lU3RhbXAoaW5wdXQpO1xuICAgIGlmICh0cyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgdGltZXN0YW1wOiAnICsgb0lucHV0KTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRpbWUgc3RhbXAgZnJvbSBpbnB1dC5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15bXlxcc2EtekEtWi1dKy8sICcnKTtcbiAgICByZXR1cm4gdHM7XG4gIH1cblxuICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXG4gIGZ1bmN0aW9uIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKSB7XG4gICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG5cbiAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgY2FzZSAncmVnaW9uJzpcbiAgICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHJlZ2lvbiB3ZSBwYXJzZWQgd2l0aCB0aGUgc2FtZSByZWdpb24gaWQuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IHJlZ2lvbkxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLnNldChrLCByZWdpb25MaXN0W2ldLnJlZ2lvbik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3JsJywgJ2xyJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgICB2YXIgdmFscyA9IHYuc3BsaXQoJywnKSxcbiAgICAgICAgICAgICAgdmFsczAgPSB2YWxzWzBdO1xuICAgICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdmFsczApO1xuICAgICAgICAgIGlmIChzZXR0aW5ncy5wZXJjZW50KGssIHZhbHMwKSkge1xuICAgICAgICAgICAgc2V0dGluZ3Muc2V0KCdzbmFwVG9MaW5lcycsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHZhbHMwLCBbJ2F1dG8nXSk7XG4gICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hbHQoJ2xpbmVBbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pO1xuICAgICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdwb3NpdGlvbkFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsaW5lLWxlZnQnLCAnbGluZS1yaWdodCcsICdhdXRvJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYWxpZ24nOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xlZnQnLCAncmlnaHQnXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSwgLzovLCAvXFxzLyk7XG5cbiAgICAvLyBBcHBseSBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IG1pc3NpbmcgZmllbGRzLlxuICAgIGN1ZS5yZWdpb24gPSBzZXR0aW5ncy5nZXQoJ3JlZ2lvbicsIG51bGwpO1xuICAgIGN1ZS52ZXJ0aWNhbCA9IHNldHRpbmdzLmdldCgndmVydGljYWwnLCAnJyk7XG4gICAgdmFyIGxpbmUgPSBzZXR0aW5ncy5nZXQoJ2xpbmUnLCAnYXV0bycpO1xuICAgIGlmIChsaW5lID09PSAnYXV0bycgJiYgZGVmYXVsdHMubGluZSA9PT0gLTEpIHtcbiAgICAgIC8vIHNldCBudW1lcmljIGxpbmUgbnVtYmVyIGZvciBTYWZhcmlcbiAgICAgIGxpbmUgPSAtMTtcbiAgICB9XG4gICAgY3VlLmxpbmUgPSBsaW5lO1xuICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2xpbmVBbGlnbicsICdzdGFydCcpO1xuICAgIGN1ZS5zbmFwVG9MaW5lcyA9IHNldHRpbmdzLmdldCgnc25hcFRvTGluZXMnLCB0cnVlKTtcbiAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldCgnc2l6ZScsIDEwMCk7XG4gICAgY3VlLmFsaWduID0gc2V0dGluZ3MuZ2V0KCdhbGlnbicsIGNlbnRlcik7XG4gICAgdmFyIHBvc2l0aW9uID0gc2V0dGluZ3MuZ2V0KCdwb3NpdGlvbicsICdhdXRvJyk7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgZGVmYXVsdHMucG9zaXRpb24gPT09IDUwKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBwb3NpdGlvbiBmb3IgU2FmYXJpXG4gICAgICBwb3NpdGlvbiA9IGN1ZS5hbGlnbiA9PT0gJ3N0YXJ0JyB8fCBjdWUuYWxpZ24gPT09ICdsZWZ0JyA/IDAgOiBjdWUuYWxpZ24gPT09ICdlbmQnIHx8IGN1ZS5hbGlnbiA9PT0gJ3JpZ2h0JyA/IDEwMCA6IDUwO1xuICAgIH1cbiAgICBjdWUucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlxccysvLCAnJyk7XG4gIH1cblxuICAvLyA0LjEgV2ViVlRUIGN1ZSB0aW1pbmdzLlxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuc3RhcnRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAvLyAoMSkgY29sbGVjdCBjdWUgc3RhcnQgdGltZVxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBpZiAoaW5wdXQuc3Vic3RyKDAsIDMpICE9PSAnLS0+Jykge1xuICAgIC8vICgzKSBuZXh0IGNoYXJhY3RlcnMgbXVzdCBtYXRjaCAnLS0+J1xuICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIHRpbWUgc3RhbXAgKHRpbWUgc3RhbXBzIG11c3QgYmUgc2VwYXJhdGVkIGJ5IFxcJy0tPlxcJyk6ICcgKyBvSW5wdXQpO1xuICB9XG4gIGlucHV0ID0gaW5wdXQuc3Vic3RyKDMpO1xuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDUpIGNvbGxlY3QgY3VlIGVuZCB0aW1lXG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgc2V0dGluZ3MgbGlzdC5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpO1xufVxuXG5mdW5jdGlvbiBmaXhMaW5lQnJlYWtzKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5yZXBsYWNlKC88YnIoPzogXFwvKT8+L2dpLCAnXFxuJyk7XG59XG5cblZUVFBhcnNlci5wcm90b3R5cGUgPSB7XG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gZGF0YSB0aGVuIHdlIHdvbid0IGRlY29kZSBpdCwgYnV0IHdpbGwganVzdCB0cnkgdG8gcGFyc2VcbiAgICAvLyB3aGF0ZXZlciBpcyBpbiBidWZmZXIgYWxyZWFkeS4gVGhpcyBtYXkgb2NjdXIgaW4gY2lyY3Vtc3RhbmNlcywgZm9yXG4gICAgLy8gZXhhbXBsZSB3aGVuIGZsdXNoKCkgaXMgY2FsbGVkLlxuICAgIGlmIChkYXRhKSB7XG4gICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBkYXRhIHRoYXQgd2UgcmVjZWl2ZWQuXG4gICAgICBzZWxmLmJ1ZmZlciArPSBzZWxmLmRlY29kZXIuZGVjb2RlKGRhdGEsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3ROZXh0TGluZSgpIHtcbiAgICAgIHZhciBidWZmZXIgPSBzZWxmLmJ1ZmZlcjtcbiAgICAgIHZhciBwb3MgPSAwO1xuXG4gICAgICBidWZmZXIgPSBmaXhMaW5lQnJlYWtzKGJ1ZmZlcik7XG5cbiAgICAgIHdoaWxlIChwb3MgPCBidWZmZXIubGVuZ3RoICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxyJyAmJiBidWZmZXJbcG9zXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICB2YXIgbGluZSA9IGJ1ZmZlci5zdWJzdHIoMCwgcG9zKTtcbiAgICAgIC8vIEFkdmFuY2UgdGhlIGJ1ZmZlciBlYXJseSBpbiBjYXNlIHdlIGZhaWwgYmVsb3cuXG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXHInKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIHNlbGYuYnVmZmVyID0gYnVmZmVyLnN1YnN0cihwb3MpO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG4gICAgLy8gMy4yIFdlYlZUVCBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIoaW5wdXQpIHtcbiAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgICAgY2FzZSAnUmVnaW9uJzpcbiAgICAgICAgICAgIC8vIDMuMyBXZWJWVFQgcmVnaW9uIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwYXJzZSByZWdpb24nLCB2KTtcbiAgICAgICAgICAgIC8vcGFyc2VSZWdpb24odik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSwgLzovKTtcbiAgICB9XG5cbiAgICAvLyA1LjEgV2ViVlRUIGZpbGUgcGFyc2luZy5cbiAgICB0cnkge1xuICAgICAgdmFyIGxpbmU7XG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gJ0lOSVRJQUwnKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHN0YXJ0IHBhcnNpbmcgdW50aWwgd2UgaGF2ZSB0aGUgZmlyc3QgbGluZS5cbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChzZWxmLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcblxuICAgICAgICB2YXIgbSA9IGxpbmUubWF0Y2goL15XRUJWVFQoWyBcXHRdLiopPyQvKTtcbiAgICAgICAgaWYgKCFtIHx8ICFtWzBdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc3RhdGUgPSAnSEVBREVSJztcbiAgICAgIH1cblxuICAgICAgdmFyIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICB3aGlsZSAoc2VsZi5idWZmZXIpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgcGFyc2UgYSBsaW5lIHVudGlsIHdlIGhhdmUgdGhlIGZ1bGwgbGluZS5cbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChzZWxmLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWxyZWFkeUNvbGxlY3RlZExpbmUpIHtcbiAgICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoc2VsZi5zdGF0ZSkge1xuICAgICAgICAgIGNhc2UgJ0hFQURFUic6XG4gICAgICAgICAgICAvLyAxMy0xOCAtIEFsbG93IGEgaGVhZGVyIChtZXRhZGF0YSkgdW5kZXIgdGhlIFdFQlZUVCBsaW5lLlxuICAgICAgICAgICAgaWYgKC86Ly50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgIHBhcnNlSGVhZGVyKGxpbmUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbGluZSkge1xuICAgICAgICAgICAgICAvLyBBbiBlbXB0eSBsaW5lIHRlcm1pbmF0ZXMgdGhlIGhlYWRlciBhbmQgc3RhcnRzIHRoZSBib2R5IChjdWVzKS5cbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdOT1RFJzpcbiAgICAgICAgICAgIC8vIElnbm9yZSBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ0lEJzpcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgTk9URSBibG9ja3MuXG4gICAgICAgICAgICBpZiAoL15OT1RFKCR8WyBcXHRdKS8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ05PVEUnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDE5LTI5IC0gQWxsb3cgYW55IG51bWJlciBvZiBsaW5lIHRlcm1pbmF0b3JzLCB0aGVuIGluaXRpYWxpemUgbmV3IGN1ZSB2YWx1ZXMuXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmN1ZSA9IG5ldyBfdnR0Y3VlMi5kZWZhdWx0KDAsIDAsICcnKTtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQ1VFJztcbiAgICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCctLT4nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgc2VsZi5jdWUuaWQgPSBsaW5lO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQcm9jZXNzIGxpbmUgYXMgc3RhcnQgb2YgYSBjdWUuXG4gICAgICAgICAgLypmYWxscyB0aHJvdWdoKi9cbiAgICAgICAgICBjYXNlICdDVUUnOlxuICAgICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBhcnNlQ3VlKGxpbmUsIHNlbGYuY3VlLCBzZWxmLnJlZ2lvbkxpc3QpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdCQURDVUUnO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQ1VFVEVYVCc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdDVUVURVhUJzpcbiAgICAgICAgICAgIHZhciBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoJy0tPicpICE9PSAtMTtcbiAgICAgICAgICAgIC8vIDM0IC0gSWYgd2UgaGF2ZSBhbiBlbXB0eSBsaW5lIHRoZW4gcmVwb3J0IHRoZSBjdWUuXG4gICAgICAgICAgICAvLyAzNSAtIElmIHdlIGhhdmUgdGhlIHNwZWNpYWwgc3Vic3RyaW5nICctLT4nIHRoZW4gcmVwb3J0IHRoZSBjdWUsXG4gICAgICAgICAgICAvLyBidXQgZG8gbm90IGNvbGxlY3QgdGhlIGxpbmUgYXMgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAvLyBvbmUgYXMgYSBuZXcgY3VlLlxuICAgICAgICAgICAgaWYgKCFsaW5lIHx8IGhhc1N1YnN0cmluZyAmJiAoYWxyZWFkeUNvbGxlY3RlZExpbmUgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBwYXJzaW5nIHNlbGYgY3VlLlxuICAgICAgICAgICAgICBpZiAoc2VsZi5vbmN1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYub25jdWUoc2VsZi5jdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY3VlLnRleHQpIHtcbiAgICAgICAgICAgICAgc2VsZi5jdWUudGV4dCArPSAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuY3VlLnRleHQgKz0gbGluZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ0JBRENVRSc6XG4gICAgICAgICAgICAvLyBCQURDVUVcbiAgICAgICAgICAgIC8vIDU0LTYyIC0gQ29sbGVjdCBhbmQgZGlzY2FyZCB0aGUgcmVtYWluaW5nIGN1ZS5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IHBhcnNpbmcgYSBjdWUsIHJlcG9ydCB3aGF0IHdlIGhhdmUuXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gJ0NVRVRFWFQnICYmIHNlbGYuY3VlICYmIHNlbGYub25jdWUpIHtcbiAgICAgICAgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XG4gICAgICB9XG4gICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAvLyBFbnRlciBCQURXRUJWVFQgc3RhdGUgaWYgaGVhZGVyIHdhcyBub3QgcGFyc2VkIGNvcnJlY3RseSBvdGhlcndpc2VcbiAgICAgIC8vIGFub3RoZXIgZXhjZXB0aW9uIG9jY3VycmVkIHNvIGVudGVyIEJBRENVRSBzdGF0ZS5cbiAgICAgIHNlbGYuc3RhdGUgPSBzZWxmLnN0YXRlID09PSAnSU5JVElBTCcgPyAnQkFEV0VCVlRUJyA6ICdCQURDVUUnO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZmx1c2g6IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgLy8gRmluaXNoIGRlY29kaW5nIHRoZSBzdHJlYW0uXG4gICAgICBzZWxmLmJ1ZmZlciArPSBzZWxmLmRlY29kZXIuZGVjb2RlKCk7XG4gICAgICAvLyBTeW50aGVzaXplIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgY3VlIG9yIHJlZ2lvbi5cbiAgICAgIGlmIChzZWxmLmN1ZSB8fCBzZWxmLnN0YXRlID09PSAnSEVBREVSJykge1xuICAgICAgICBzZWxmLmJ1ZmZlciArPSAnXFxuXFxuJztcbiAgICAgICAgc2VsZi5wYXJzZSgpO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UndmUgZmx1c2hlZCwgcGFyc2VkLCBhbmQgd2UncmUgc3RpbGwgb24gdGhlIElOSVRJQUwgc3RhdGUgdGhlblxuICAgICAgLy8gdGhhdCBtZWFucyB3ZSBkb24ndCBoYXZlIGVub3VnaCBvZiB0aGUgc3RyZWFtIHRvIHBhcnNlIHRoZSBmaXJzdFxuICAgICAgLy8gbGluZS5cbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnSU5JVElBTCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBpZiAoc2VsZi5vbmZsdXNoKSB7XG4gICAgICBzZWxmLm9uZmx1c2goKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbmV4cG9ydHMuZml4TGluZUJyZWFrcyA9IGZpeExpbmVCcmVha3M7XG5leHBvcnRzLmRlZmF1bHQgPSBWVFRQYXJzZXI7XG5cbn0se1wiNTJcIjo1Mn1dLDU0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF92dHRwYXJzZXIgPSBfZGVyZXFfKDUzKTtcblxudmFyIF92dHRwYXJzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdnR0cGFyc2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGN1ZVN0cmluZzJtaWxsaXMgPSBmdW5jdGlvbiBjdWVTdHJpbmcybWlsbGlzKHRpbWVTdHJpbmcpIHtcbiAgICB2YXIgdHMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigtMykpO1xuICAgIHZhciBzZWNzID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTYsIDIpKTtcbiAgICB2YXIgbWlucyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC05LCAyKSk7XG4gICAgdmFyIGhvdXJzID0gdGltZVN0cmluZy5sZW5ndGggPiA5ID8gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoMCwgdGltZVN0cmluZy5pbmRleE9mKCc6JykpKSA6IDA7XG5cbiAgICBpZiAoaXNOYU4odHMpIHx8IGlzTmFOKHNlY3MpIHx8IGlzTmFOKG1pbnMpIHx8IGlzTmFOKGhvdXJzKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgdHMgKz0gMTAwMCAqIHNlY3M7XG4gICAgdHMgKz0gNjAgKiAxMDAwICogbWlucztcbiAgICB0cyArPSA2MCAqIDYwICogMTAwMCAqIGhvdXJzO1xuXG4gICAgcmV0dXJuIHRzO1xufTtcblxudmFyIGNhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKSB7XG4gICAgdmFyIGN1cnJDQyA9IHZ0dENDc1tjY107XG4gICAgdmFyIHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcblxuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRpc2NvbnRpbnVpdHkgb3IgY3VlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHNpbmNlIHRoZSBsYXN0IGRpc2NvbnRpbnVpdHlcbiAgICAvLyBPZmZzZXQgPSBjdXJyZW50IGRpc2NvbnRpbnVpdHkgdGltZVxuICAgIGlmICghcHJldkNDIHx8ICFwcmV2Q0MubmV3ICYmIGN1cnJDQy5uZXcpIHtcbiAgICAgICAgdnR0Q0NzLmNjT2Zmc2V0ID0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICAgICAgY3VyckNDLm5ldyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhlcmUgaGF2ZSBiZWVuIGRpc2NvbnRpbnVpdGllcyBzaW5jZSBjdWVzIHdlcmUgbGFzdCBwYXJzZWQuXG4gICAgLy8gT2Zmc2V0ID0gdGltZSBlbGFwc2VkXG4gICAgd2hpbGUgKHByZXZDQyAmJiBwcmV2Q0MubmV3KSB7XG4gICAgICAgIHZ0dENDcy5jY09mZnNldCArPSBjdXJyQ0Muc3RhcnQgLSBwcmV2Q0Muc3RhcnQ7XG4gICAgICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcbiAgICAgICAgY3VyckNDID0gcHJldkNDO1xuICAgICAgICBwcmV2Q0MgPSB2dHRDQ3NbY3VyckNDLnByZXZDQ107XG4gICAgfVxuXG4gICAgdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IHByZXNlbnRhdGlvblRpbWU7XG59O1xuXG52YXIgV2ViVlRUUGFyc2VyID0ge1xuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh2dHRCeXRlQXJyYXksIHN5bmNQVFMsIHZ0dENDcywgY2MsIGNhbGxCYWNrLCBlcnJvckNhbGxCYWNrKSB7XG4gICAgICAgIC8vIENvbnZlcnQgYnl0ZUFycmF5IGludG8gc3RyaW5nLCByZXBsYWNpbmcgYW55IHNvbWV3aGF0IGV4b3RpYyBsaW5lZmVlZHMgd2l0aCBcIlxcblwiLCB0aGVuIHNwbGl0IG9uIHRoYXQgY2hhcmFjdGVyLlxuICAgICAgICB2YXIgcmUgPSAvXFxyXFxufFxcblxccnxcXG58XFxyL2c7XG4gICAgICAgIHZhciB2dHRMaW5lcyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkodnR0Qnl0ZUFycmF5KSkudHJpbSgpLnJlcGxhY2UocmUsICdcXG4nKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIHZhciBjdWVUaW1lID0gJzAwOjAwLjAwMCc7XG4gICAgICAgIHZhciBtcGVnVHMgPSAwO1xuICAgICAgICB2YXIgbG9jYWxUaW1lID0gMDtcbiAgICAgICAgdmFyIHByZXNlbnRhdGlvblRpbWUgPSAwO1xuICAgICAgICB2YXIgY3VlcyA9IFtdO1xuICAgICAgICB2YXIgcGFyc2luZ0Vycm9yID0gdm9pZCAwO1xuICAgICAgICB2YXIgaW5IZWFkZXIgPSB0cnVlO1xuICAgICAgICAvLyBsZXQgVlRUQ3VlID0gVlRUQ3VlIHx8IHdpbmRvdy5UZXh0VHJhY2tDdWU7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHBhcnNlciBvYmplY3QgdXNpbmcgVlRUQ3VlIHdpdGggVGV4dFRyYWNrQ3VlIGZhbGxiYWNrIG9uIGNlcnRhaW4gYnJvd3NlcnMuXG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgX3Z0dHBhcnNlcjIuZGVmYXVsdCgpO1xuXG4gICAgICAgIHBhcnNlci5vbmN1ZSA9IGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgICAgICAgIC8vIEFkanVzdCBjdWUgdGltaW5nOyBjbGFtcCBjdWVzIHRvIHN0YXJ0IG5vIGVhcmxpZXIgdGhhbiAtIGFuZCBkcm9wIGN1ZXMgdGhhdCBkb24ndCBlbmQgYWZ0ZXIgLSAwIG9uIHRpbWVsaW5lLlxuICAgICAgICAgICAgdmFyIGN1cnJDQyA9IHZ0dENDc1tjY107XG4gICAgICAgICAgICB2YXIgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0O1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgb2Zmc2V0cyBmb3IgbmV3IGRpc2NvbnRpbnVpdGllc1xuICAgICAgICAgICAgaWYgKGN1cnJDQyAmJiBjdXJyQ0MubmV3KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGxvY2FsIHRpbWUgaXMgcHJvdmlkZWQsIG9mZnNldCA9IGRpc2NvbnRpbnVpdHkgc3RhcnQgdGltZSAtIGxvY2FsIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0ID0gY3VyckNDLnN0YXJ0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmVzZW50YXRpb25UaW1lICYmICFsb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIE1QRUdUUyBidXQgbm8gTE9DQUwgdGltZSwgb2Zmc2V0ID0gcHJlc2VudGF0aW9uIHRpbWUgKyBkaXNjb250aW51aXR5IG9mZnNldFxuICAgICAgICAgICAgICAgIGN1ZU9mZnNldCA9IHByZXNlbnRhdGlvblRpbWUgKyB2dHRDQ3MuY2NPZmZzZXQgLSB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdWUuc3RhcnRUaW1lICs9IGN1ZU9mZnNldCAtIGxvY2FsVGltZTtcbiAgICAgICAgICAgIGN1ZS5lbmRUaW1lICs9IGN1ZU9mZnNldCAtIGxvY2FsVGltZTtcblxuICAgICAgICAgICAgLy8gRml4IGVuY29kaW5nIG9mIHNwZWNpYWwgY2hhcmFjdGVycy4gVE9ETzogVGVzdCB3aXRoIGFsbCBzb3J0cyBvZiB3ZWlyZCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgY3VlLnRleHQgPSBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGN1ZS50ZXh0KSk7XG4gICAgICAgICAgICBpZiAoY3VlLmVuZFRpbWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgY3Vlcy5wdXNoKGN1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHBhcnNpbmdFcnJvciA9IGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgcGFyc2VyLm9uZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocGFyc2luZ0Vycm9yICYmIGVycm9yQ2FsbEJhY2spIHtcbiAgICAgICAgICAgICAgICBlcnJvckNhbGxCYWNrKHBhcnNpbmdFcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbEJhY2soY3Vlcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR28gdGhyb3VnaCBjb250ZW50cyBsaW5lIGJ5IGxpbmUuXG4gICAgICAgIHZ0dExpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgIGlmIChpbkhlYWRlcikge1xuICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIFgtVElNRVNUQU1QLU1BUCBpbiBoZWFkZXIuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnWC1USU1FU1RBTVAtTUFQPScpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9uY2UgZm91bmQsIG5vIG1vcmUgYXJlIGFsbG93ZWQgYW55d2F5LCBzbyBzdG9wIHNlYXJjaGluZy5cbiAgICAgICAgICAgICAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBMT0NBTCBhbmQgTVBFR1RTLlxuICAgICAgICAgICAgICAgICAgICBsaW5lLnN1YnN0cigxNikuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAuc3RhcnRzV2l0aCgnTE9DQUw6JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdWVUaW1lID0gdGltZXN0YW1wLnN1YnN0cig2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZXN0YW1wLnN0YXJ0c1dpdGgoJ01QRUdUUzonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wZWdUcyA9IHBhcnNlSW50KHRpbWVzdGFtcC5zdWJzdHIoNykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzdWJ0aXRsZSBvZmZzZXQgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgc3luYyBQVFMgaXMgbGVzcyB0aGFuIHplcm8sIHdlIGhhdmUgYSAzMy1iaXQgd3JhcGFyb3VuZCwgd2hpY2ggaXMgZml4ZWQgYnkgYWRkaW5nIDJeMzMgPSA4NTg5OTM0NTkyLlxuICAgICAgICAgICAgICAgICAgICAgICAgc3luY1BUUyA9IHN5bmNQVFMgPCAwID8gc3luY1BUUyArIDg1ODk5MzQ1OTIgOiBzeW5jUFRTO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRqdXN0IE1QRUdUUyBieSBzeW5jIFBUUy5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1wZWdUcyAtPSBzeW5jUFRTO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBjdWUgdGltZSB0byBzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFRpbWUgPSBjdWVTdHJpbmcybWlsbGlzKGN1ZVRpbWUpIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgTVBFR1RTIHRvIHNlY29uZHMgZnJvbSA5MGtIei5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnRhdGlvblRpbWUgPSBtcGVnVHMgLyA5MDAwMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsVGltZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoJ01hbGZvcm1lZCBYLVRJTUVTVEFNUC1NQVA6ICcgKyBsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiAnICsgbGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHdpdGhvdXQgcGFyc2luZyBYLVRJTUVTVEFNUC1NQVAgbGluZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBsaW5lIGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICBwYXJzZXIucGFyc2UobGluZSArICdcXG4nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGFyc2VyLmZsdXNoKCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJWVFRQYXJzZXI7XG5cbn0se1wiNTNcIjo1M31dLDU1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogWEhSIGJhc2VkIGxvZ2dlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBfbG9nZ2VyID0gX2RlcmVxXyg1MCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBYaHJMb2FkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhockxvYWRlcihjb25maWcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWGhyTG9hZGVyKTtcblxuICAgIGlmIChjb25maWcgJiYgY29uZmlnLnhoclNldHVwKSB7XG4gICAgICB0aGlzLnhoclNldHVwID0gY29uZmlnLnhoclNldHVwO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhYaHJMb2FkZXIsIFt7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmFib3J0KCk7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWJvcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcjtcbiAgICAgIGlmIChsb2FkZXIgJiYgbG9hZGVyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgdGhpcy5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gbnVsbDtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgICAgdGhpcy5yZXRyeVRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICAgIHRoaXMuc3RhdHMgPSB7IHRyZXF1ZXN0OiBwZXJmb3JtYW5jZS5ub3coKSwgcmV0cnk6IDAgfTtcbiAgICAgIHRoaXMucmV0cnlEZWxheSA9IGNvbmZpZy5yZXRyeURlbGF5O1xuICAgICAgdGhpcy5sb2FkSW50ZXJuYWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkSW50ZXJuYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkSW50ZXJuYWwoKSB7XG4gICAgICB2YXIgeGhyLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgWERvbWFpblJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHhociA9IHRoaXMubG9hZGVyID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4aHIgPSB0aGlzLmxvYWRlciA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgfVxuXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5yZWFkeXN0YXRlY2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdSYW5nZScsICdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgKGNvbnRleHQucmFuZ2VFbmQgLSAxKSk7XG4gICAgICB9XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gY29udGV4dC5yZXNwb25zZVR5cGU7XG4gICAgICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgICAgc3RhdHMudGZpcnN0ID0gMDtcbiAgICAgIHN0YXRzLmxvYWRlZCA9IDA7XG4gICAgICBpZiAodGhpcy54aHJTZXR1cCkge1xuICAgICAgICB0aGlzLnhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgfVxuICAgICAgLy8gc2V0dXAgdGltZW91dCBiZWZvcmUgd2UgcGVyZm9ybSByZXF1ZXN0XG4gICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZy50aW1lb3V0KTtcbiAgICAgIHhoci5zZW5kKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVhZHlzdGF0ZWNoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2UoZXZlbnQpIHtcbiAgICAgIHZhciB4aHIgPSBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgIHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZSxcbiAgICAgICAgICBzdGF0cyA9IHRoaXMuc3RhdHMsXG4gICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgICAgLy8gZG9uJ3QgcHJvY2VlZCBpZiB4aHIgaGFzIGJlZW4gYWJvcnRlZFxuICAgICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyA+PSBIRUFERVJTX1JFQ0VJVkVEXG4gICAgICBpZiAocmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICAgIC8vIGNsZWFyIHhociB0aW1lb3V0IGFuZCByZWFybSBpdCBpZiByZWFkeVN0YXRlIGxlc3MgdGhhbiA0XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIGlmIChzdGF0cy50Zmlyc3QgPT09IDApIHtcbiAgICAgICAgICBzdGF0cy50Zmlyc3QgPSBNYXRoLm1heChwZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMudHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgdmFyIHN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgICAgICAgLy8gaHR0cCBzdGF0dXMgYmV0d2VlbiAyMDAgdG8gMjk5IGFyZSBhbGwgc3VjY2Vzc2Z1bFxuICAgICAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgc3RhdHMudGxvYWQgPSBNYXRoLm1heChzdGF0cy50Zmlyc3QsIHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGxlbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IGxlbjtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHsgdXJsOiB4aHIucmVzcG9uc2VVUkwsIGRhdGE6IGRhdGEgfTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgICAgaWYgKHN0YXRzLnJldHJ5ID49IGNvbmZpZy5tYXhSZXRyeSB8fCBzdGF0dXMgPj0gNDAwICYmIHN0YXR1cyA8IDQ5OSkge1xuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci5lcnJvcihzdGF0dXMgKyAnIHdoaWxlIGxvYWRpbmcgJyArIGNvbnRleHQudXJsKTtcbiAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcih7IGNvZGU6IHN0YXR1cywgdGV4dDogeGhyLnN0YXR1c1RleHQgfSwgY29udGV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZXRyeVxuICAgICAgICAgICAgICBfbG9nZ2VyLmxvZ2dlci53YXJuKHN0YXR1cyArICcgd2hpbGUgbG9hZGluZyAnICsgY29udGV4dC51cmwgKyAnLCByZXRyeWluZyBpbiAnICsgdGhpcy5yZXRyeURlbGF5ICsgJy4uLicpO1xuICAgICAgICAgICAgICAvLyBhYm9ydHMgYW5kIHJlc2V0cyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgLy8gc2NoZWR1bGUgcmV0cnlcbiAgICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgICAvLyBzZXQgZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICAgICAgICB0aGlzLnJldHJ5RGVsYXkgPSBNYXRoLm1pbigyICogdGhpcy5yZXRyeURlbGF5LCBjb25maWcubWF4UmV0cnlEZWxheSk7XG4gICAgICAgICAgICAgIHN0YXRzLnJldHJ5Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJlYWR5U3RhdGUgPj0gMiBBTkQgcmVhZHlTdGF0ZSAhPT00IChyZWFkeVN0YXRlID0gSEVBREVSU19SRUNFSVZFRCB8fCBMT0FESU5HKSByZWFybSB0aW1lb3V0IGFzIHhociBub3QgZmluaXNoZWQgeWV0XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgY29uZmlnLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZHRpbWVvdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkdGltZW91dCgpIHtcbiAgICAgIF9sb2dnZXIubG9nZ2VyLndhcm4oJ3RpbWVvdXQgd2hpbGUgbG9hZGluZyAnICsgdGhpcy5jb250ZXh0LnVybCk7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vblRpbWVvdXQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkcHJvZ3Jlc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkcHJvZ3Jlc3MoZXZlbnQpIHtcbiAgICAgIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICBzdGF0cy50b3RhbCA9IGV2ZW50LnRvdGFsO1xuICAgICAgfVxuICAgICAgdmFyIG9uUHJvZ3Jlc3MgPSB0aGlzLmNhbGxiYWNrcy5vblByb2dyZXNzO1xuICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gbGFzdCBhcmdzIGlzIHRvIHByb3ZpZGUgb24gcHJvZ3Jlc3MgZGF0YVxuICAgICAgICBvblByb2dyZXNzKHN0YXRzLCB0aGlzLmNvbnRleHQsIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBYaHJMb2FkZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFhockxvYWRlcjtcblxufSx7XCI1MFwiOjUwfV19LHt9LFszOF0pKDM4KVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obHMuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGxzLmpzL2Rpc3QvaGxzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjRcbi8vIG1vZHVsZSBjaHVua3MgPSA2IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vY29udGFpbmVyJ1xyXG5pbXBvcnQgTWVudUl0ZW0gZnJvbSAnLi9tZW51SXRlbSc7XHJcbmltcG9ydCBMaW5rIGZyb20gJ25leHQvbGluaydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGVhZGVyXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29udGFpbmVyIGZsZXg9e3RydWV9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaW5rIGhyZWY9XCIvXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiL3N0YXRpYy9sb2dvLnN2Z1wiLz4gXHJcbiAgICAgICAgICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1lbnVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cIi9yZWdpc3RlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1lbnVJdGVtPuazqOWGjDwvTWVudUl0ZW0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIvbG9naW5cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxNZW51SXRlbT7nmbvlvZU8L01lbnVJdGVtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TWVudUl0ZW0+5YWz5LqOPC9NZW51SXRlbT5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvQ29udGFpbmVyPlxyXG5cclxuICAgICAgICAgICAgICAgIDxzdHlsZSBqc3g+e2BcclxuICAgICAgICAgICAgICAgICAgICAuaGVhZGVyIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDQwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICMwMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6LWluZGV4OiA5OTk5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAuaGVhZGVyIGltZyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXgtaGVpZ2h0OiAxMDAlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDBweDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbnRhaW5lciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDUwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC5tZW51IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBgfTwvc3R5bGU+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvaGVhZGVyLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vY29udGFpbmVyJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm1lbnUtaXRlbVwiPlxyXG4gICAgICAgICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XHJcblxyXG4gICAgICAgICAgICAgICAgPHN0eWxlIGpzeD57YFxyXG4gICAgICAgICAgICAgICAgICAgIC5tZW51LWl0ZW0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogI2ZmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogNXB4IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgLjFzIGxpbmVhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAuMXMgbGluZWFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDIwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLm1lbnUtaXRlbTphZnRlciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAjNmZiOTAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAubWVudS1pdGVtOmhvdmVyIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogLjc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYH08L3N0eWxlPlxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvbWVudUl0ZW0uanMiLCIoZnVuY3Rpb24oc2VsZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gc2VsZixcbiAgICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gc2VsZiAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXVxuXG4gICAgdmFyIGlzRGF0YVZpZXcgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICAgIH1cblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG5cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXVxuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSsnLCcrdmFsdWUgOiB2YWx1ZVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChuYW1lKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7IGl0ZW1zLnB1c2godmFsdWUpIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzXG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpXG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpXG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG5cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KVxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7IGJvZHk6IHRoaXMuX2JvZHlJbml0IH0pXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gICAgcmF3SGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gICAgdGhpcy5zdGF0dXMgPSAnc3RhdHVzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiAyMDBcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snXG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfVxuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfVxuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnNcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdFxuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2VcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgfSlcbiAgfVxuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3doYXR3Zy1mZXRjaC9mZXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAyIDMgNCA1IDYiLCJpbXBvcnQgJ2lzb21vcnBoaWMtZmV0Y2gnXHJcblxyXG5mdW5jdGlvbiByYW5kb21Vc2VyaWQoKSB7XHJcbiAgICBsZXQgc3RyID0gXCJcIjtcclxuICAgIGxldCBzdHIyID0gXCJcIjtcclxuICAgIGxldCBwb3MgPSAnJztcclxuICAgIGxldCBhcnIgPSBbJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJ107XHJcbiAgICBcclxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKXtcclxuICAgICAgICBwb3MgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAoYXJyLmxlbmd0aC0xKSk7XHJcbiAgICAgICAgc3RyICs9IGFycltwb3NdO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBzdHIyID0gc3RyLnN1YnN0cmluZygwLCA4KSArICctJyArIHN0ci5zdWJzdHJpbmcoOCwgMTIpICsgJy0nICsgc3RyLnN1YnN0cmluZygxMiwgMTYpICsgJy0nICsgc3RyLnN1YnN0cmluZygxNiwyMCkgKyAnLScgKyBzdHIuc3Vic3RyaW5nKDIwLDMyKTtcclxuICAgIHJldHVybiBzdHIyO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnkoKSB7XHJcbiAgICBsZXQgdXNlcmlkID0gcmFuZG9tVXNlcmlkKCk7XHJcblxyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2VyaWRcIiwgdXNlcmlkKTtcclxuXHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9sb2xpYXBpLmNvbS9sb2dpbi8ke3VzZXJpZH1gKTtcclxuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xyXG4gICAgbGV0IHRva2VuID0ganNvbi5NZXNzYWdlLlRva2VuO1xyXG5cclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidG9rZW5cIiwgdG9rZW4pO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB2ZXJpZnk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL3Rvb2wuanMiXSwic291cmNlUm9vdCI6IiJ9"}